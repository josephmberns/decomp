`#include <stdio.h>

int main()
{
    double inf = 1/0.0;
    double minus_inf = -1/0.0;
    double minus_zero = -1/ inf ;
    double nan = 0.0/0.0;

    printf("positive infinity: %f\n",inf);
    printf("negative infinity: %f\n",minus_inf);
    printf("negative zero: %f\n",minus_zero);
    printf("not a number: %f\n",nan);

    /* some arithmetic */

    printf("+inf + 2.0 = %f\n",inf + 2.0);
    printf("+inf - 10.1 = %f\n",inf - 10.1);
    printf("+inf + -inf = %f\n",inf + minus_inf);
    printf("0.0 * +inf = %f\n",0.0 * inf);
    printf("1.0/-0.0 = %f\n",1.0/minus_zero);
    printf("NaN + 1.0 = %f\n",nan + 1.0);
    printf("NaN + NaN = %f\n",nan + nan);

    /* some comparisons */

    printf("NaN == NaN = %s\n",nan == nan ? "true" : "false");
    printf("0.0 == -0.0 = %s\n",0.0 == minus_zero ? "true" : "false");

    return 0;
}
`,`#include "extreme-floating-point-values-1.h"



// WARNING: Removing unreachable block (ram,0x000100003e5c)

undefined4 entry(void)

{
  _printf("positive infinity: %f\n");
  _printf("negative infinity: %f\n");
  _printf("negative zero: %f\n");
  _printf("not a number: %f\n");
  _printf("+inf + 2.0 = %f\n");
  _printf("+inf - 10.1 = %f\n");
  _printf("+inf + -inf = %f\n");
  _printf("0.0 * +inf = %f\n");
  _printf("1.0/-0.0 = %f\n");
  _printf("NaN + 1.0 = %f\n");
  _printf("NaN + NaN = %f\n");
  _printf("NaN == NaN = %s\n");
  _printf("0.0 == -0.0 = %s\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void padovanN(int n, size_t t, int *p) {
    int i, j;
    if (n < 2 || t < 3) {
        for (i = 0; i < t; ++i) p[i] = 1;
        return;
    }
    padovanN(n-1, t, p);
    for (i = n + 1; i < t; ++i) {
        p[i] = 0;
        for (j = i - 2; j >= i - n - 1; --j) p[i] += p[j];
    }
}

int main() {
    int n, i;
    const size_t t = 15;
    int p[t];
    printf("First %ld terms of the Padovan n-step number sequences:\n", t);
    for (n = 2; n <= 8; ++n) {
        for (i = 0; i < t; ++i) p[i] = 0;
        padovanN(n, t, p);
        printf("%d: ", n);
        for (i = 0; i < t; ++i) printf("%3d ", p[i]);
        printf("\n");
    }
    return 0;
}
`,`#include "padovan-n-step-number-sequences.h"



void _padovanN(int param_1,ulong param_2,long param_3)

{
  int *piVar1;
  int local_30;
  int local_2c;
  
  if ((param_1 < 2) || (param_2 < 3)) {
    for (local_2c = 0; (ulong)(long)local_2c < param_2; local_2c = local_2c + 1) {
      *(undefined4 *)(param_3 + (long)local_2c * 4) = 1;
    }
  }
  else {
    _padovanN(param_1 + -1,param_2,param_3);
    for (local_2c = param_1 + 1; (ulong)(long)local_2c < param_2; local_2c = local_2c + 1) {
      *(undefined4 *)(param_3 + (long)local_2c * 4) = 0;
      for (local_30 = local_2c + -2; (local_2c - param_1) + -1 <= local_30; local_30 = local_30 + -1
          ) {
        piVar1 = (int *)(param_3 + (long)local_2c * 4);
        *piVar1 = *piVar1 + *(int *)(param_3 + (long)local_30 * 4);
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  uint local_60;
  int local_5c;
  undefined4 auStack_54 [15];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  iVar1 = _printf("First %ld terms of the Padovan n-step number sequences:\n");
  for (local_5c = 2; local_5c < 9; local_5c = local_5c + 1) {
    for (local_60 = 0; local_60 < 0xf; local_60 = local_60 + 1) {
      auStack_54[(int)local_60] = 0;
    }
    _padovanN(local_5c,0xf,auStack_54);
    _printf("%d: ");
    for (local_60 = 0; local_60 < 0xf; local_60 = local_60 + 1) {
      _printf("%3d ");
    }
    iVar1 = _printf("\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

int main()
{
	setlocale(LC_CTYPE, "");
	char moose[] = "møøse";
	printf("bytes: %d\n", sizeof(moose) - 1);
	printf("chars: %d\n", (int)mbstowcs(0, moose, 0));

	return 0;
}
`,`#include "string-length-5.h"



undefined8 entry(void)

{
  int iVar1;
  char local_20 [8];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _setlocale(2,"");
  builtin_strncpy(local_20,"møøse",8);
  _printf("bytes: %d\n");
  _mbstowcs((wchar_t *)0x0,local_20,0);
  iVar1 = _printf("chars: %d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _mbstowcs(wchar_t *param_1,char *param_2,size_t param_3)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__mbstowcs_100004010)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004020)();
  return;
}


`
`#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

#define MAX(x,y) ((x) > (y) ? (x) : (y))
#define MIN(x,y) ((x) < (y) ? (x) : (y))

/* Find base-20 digits. */
size_t base20(unsigned int n, uint8_t *out) {
    /* generate digits */
    uint8_t *start = out;
    do {*out++ = n % 20;} while (n /= 20);
    size_t length = out - start;

    /* put digits in high-endian order */
    while (out > start) {
        uint8_t x = *--out;
        *out = *start;
        *start++ = x;
    }
    return length;
}

/* Write a Mayan digit */
void make_digit(int n, char *place, size_t line_length) {
    static const char *parts[] = {"    "," .  "," .. ","... ","....","----"};
    int i;

    /* write 4-part digit */
    for (i=4; i>0; i--, n -= 5)
        memcpy(place + i*line_length, parts[MAX(0, MIN(5, n))], 4);

    /* if digit was 0 we should put '@' in 2nd position of last line */
    if (n == -20) place[4 * line_length + 1] = '@';
}

/* Make a Mayan numeral */
char *mayan(unsigned int n) {
    if (n == 0) return NULL;

    uint8_t digits[15]; /* 2**64 is 15 Mayan digits long */
    size_t n_digits = base20(n, digits);

    /* a digit is 4 chars wide, plus N+1 divider lines, plus a newline
       makes for a length of 5*n+2 */
    size_t line_length = n_digits*5 + 2;

    /* we need 6 lines - four for the digits, plus top and bottom row */
    char *str = malloc(line_length * 6 + 1);
    if (str == NULL) return NULL;
    str[line_length * 6] = 0;

    /* make the cartouche divider lines */
    char *ptr;
    unsigned int i;
    /* top and bottom row */
    for (ptr=str, i=0; i<line_length; i+=5, ptr+=5)
        memcpy(ptr, "+----", 5);
    memcpy(ptr-5, "+\n", 2);
    memcpy(str+5*line_length, str, line_length);
    /* middle rows */
    for (ptr=str+line_length, i=0; i<line_length; i+=5, ptr+=5)
        memcpy(ptr, "|    ", 5);
    memcpy(ptr-5, "|\n", 2);
    memcpy(str+2*line_length, str+line_length, line_length);
    memcpy(str+3*line_length, str+line_length, 2*line_length);

    /* copy in the digits */
    for (i=0; i<n_digits; i++)
        make_digit(digits[i], str+1+5*i, line_length);

    return str;
}

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, "usage: mayan <number>\n");
        return 1;
    }
    int i = atoi(argv[1]);
    if (i <= 0) {
        fprintf(stderr, "number must be positive\n");
        return 1;
    }
    char *m = mayan(i);
    printf("%s",m);
    free(m);
    return 0;
}
`,`#include "mayan-numerals.h"



long _base20(uint param_1,char *param_2)

{
  char *pcVar1;
  char cVar2;
  char *local_18;
  char *local_10;
  uint local_4;
  
  local_10 = param_2;
  local_4 = param_1;
  do {
    pcVar1 = local_10 + 1;
    *local_10 = (char)local_4 + (char)(local_4 / 0x14) * -0x14;
    local_4 = local_4 / 0x14;
    local_10 = pcVar1;
  } while (local_4 != 0);
  local_18 = param_2;
  while (local_18 < local_10) {
    local_10 = local_10 + -1;
    cVar2 = *local_10;
    *local_10 = *local_18;
    *local_18 = cVar2;
    local_18 = local_18 + 1;
  }
  return (long)pcVar1 - (long)param_2;
}



void _make_digit(int param_1,long param_2,long param_3)

{
  int local_44;
  int local_40;
  int local_3c;
  int local_2c;
  int local_14;
  
  local_14 = param_1;
  for (local_2c = 4; 0 < local_2c; local_2c = local_2c + -1) {
    if (local_14 < 6) {
      local_3c = local_14;
    }
    else {
      local_3c = 5;
    }
    if (local_3c < 0) {
      local_40 = 0;
    }
    else {
      if (local_14 < 6) {
        local_44 = local_14;
      }
      else {
        local_44 = 5;
      }
      local_40 = local_44;
    }
    ___memcpy_chk(param_2 + local_2c * param_3,(&PTR_s__100008000)[local_40],4,0xffffffffffffffff);
    local_14 = local_14 + -5;
  }
  if (local_14 == -0x14) {
    *(undefined *)(param_2 + param_3 * 4 + 1) = 0x40;
  }
  return;
}



void * _mayan(int param_1)

{
  ulong uVar1;
  ulong uVar2;
  uint local_5c;
  void *local_58;
  void *local_30;
  undefined auStack_27 [15];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  if (param_1 == 0) {
    local_30 = (void *)0x0;
  }
  else {
    uVar2 = _base20(param_1,auStack_27);
    uVar1 = uVar2 * 5 + 2;
    local_30 = _malloc(uVar1 * 6 + 1);
    if (local_30 == (void *)0x0) {
      local_30 = (void *)0x0;
    }
    else {
      *(undefined *)((long)local_30 + uVar1 * 6) = 0;
      local_58 = local_30;
      for (local_5c = 0; local_5c < uVar1; local_5c = local_5c + 5) {
        ___memcpy_chk(local_58,"+----",5,0xffffffffffffffff);
        local_58 = (void *)((long)local_58 + 5);
      }
      ___memcpy_chk((long)local_58 + -5,"+\n",2);
      ___memcpy_chk((void *)((long)local_30 + uVar1 * 5),local_30,uVar1,0xffffffffffffffff);
      local_58 = (void *)((long)local_30 + uVar1);
      for (local_5c = 0; local_5c < uVar1; local_5c = local_5c + 5) {
        ___memcpy_chk(local_58,"|    ",5,0xffffffffffffffff);
        local_58 = (void *)((long)local_58 + 5);
      }
      ___memcpy_chk((long)local_58 + -5,"|\n");
      ___memcpy_chk((void *)((long)local_30 + uVar1 * 2),(long)local_30 + uVar1,uVar1,
                    0xffffffffffffffff);
      ___memcpy_chk((void *)((long)local_30 + uVar1 * 3),(long)local_30 + uVar1,uVar1 * 2,
                    0xffffffffffffffff);
      for (local_5c = 0; local_5c < uVar2; local_5c = local_5c + 1) {
        _make_digit(auStack_27[local_5c],(long)local_30 + (ulong)(local_5c * 5) + 1,uVar1);
      }
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return local_30;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  void *pvVar2;
  undefined4 local_14;
  
  if (param_1 == 2) {
    iVar1 = _atoi(*(char **)(param_2 + 8));
    if (iVar1 < 1) {
      _fprintf(*(FILE **)PTR____stderrp_100004018,"number must be positive\n");
      local_14 = 1;
    }
    else {
      pvVar2 = (void *)_mayan(iVar1);
      _printf("%s");
      _free(pvVar2);
      local_14 = 0;
    }
  }
  else {
    _fprintf(*(FILE **)PTR____stderrp_100004018,"usage: mayan <number>\n");
    local_14 = 1;
  }
  return local_14;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define sqr(x) ((x) * (x))
#define greet printf("Hello There!\n")

int twice(int x)
{
	return 2 * x;
}

int main(void)
{
	int x;

	printf("This will demonstrate function and label scopes.\n");
	printf("All output is happening through printf(), a function declared in the header stdio.h, which is external to this program.\n");
	printf("Enter a number: ");
	if (scanf("%d", &x) != 1)
		return 0;
	
	switch (x % 2) {
	default:
		printf("Case labels in switch statements have scope local to the switch block.\n");
	case 0:
		printf("You entered an even number.\n");
		printf("Its square is %d, which was computed by a macro. It has global scope within the translation unit.\n", sqr(x));
		break;
	case 1:
		printf("You entered an odd number.\n");
		goto sayhello;
	jumpin:
		printf("2 times %d is %d, which was computed by a function defined in this file. It has global scope within the translation unit.\n", x, twice(x));
		printf("Since you jumped in, you will now be greeted, again!\n");
	sayhello:
		greet;
		if (x == -1)
			goto scram;
		break;
	}

	printf("We now come to goto, it's extremely powerful but it's also prone to misuse. Its use is discouraged and it wasn't even adopted by Java and later languages.\n");

	if (x != -1) {
		x = -1;   /* To break goto infinite loop. */
	 	goto jumpin;
	}

scram:
	printf("If you are trying to figure out what happened, you now understand goto.\n");
	return 0;
}
`,`#include "scope-function-names-and-labels.h"



int _twice(int param_1)

{
  return param_1 * 2;
}



undefined4 entry(void)

{
  int iVar1;
  int local_18;
  
  _printf("This will demonstrate function and label scopes.\n");
  _printf(
         "All output is happening through printf(), a function declared in the header stdio.h, which is external to this program.\n"
         );
  _printf("Enter a number: ");
  iVar1 = _scanf("%d");
  if (iVar1 == 1) {
    if (local_18 % 2 != 0) {
      if (local_18 % 2 == 1) {
        _printf("You entered an odd number.\n");
        goto LAB_100003bc4;
      }
      _printf("Case labels in switch statements have scope local to the switch block.\n");
    }
    _printf("You entered an even number.\n");
    _printf(
           "Its square is %d, which was computed by a macro. It has global scope within the translation unit.\n"
           );
    do {
      _printf(
             "We now come to goto, it\'s extremely powerful but it\'s also prone to misuse. Its use is discouraged and it wasn\'t even adopted by Java and later languages.\n"
             );
      if (local_18 == -1) break;
      local_18 = -1;
      _twice(0xffffffff);
      _printf(
             "2 times %d is %d, which was computed by a function defined in this file. It has global scope within the translation unit.\n"
             );
      _printf("Since you jumped in, you will now be greeted, again!\n");
LAB_100003bc4:
      _printf("Hello There!\n");
    } while (local_18 != -1);
    _printf("If you are trying to figure out what happened, you now understand goto.\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int ackermann(int m, int n)
{
        if (!m) return n + 1;
        if (!n) return ackermann(m - 1, 1);
        return ackermann(m - 1, ackermann(m, n - 1));
}

int main()
{
        int m, n;
        for (m = 0; m <= 4; m++)
                for (n = 0; n < 6 - m; n++)
                        printf("A(%d, %d) = %d\n", m, n, ackermann(m, n));

        return 0;
}
`,`#include "ackermann-function-1.h"



int _ackermann(int param_1,int param_2)

{
  undefined8 uVar1;
  undefined4 local_14;
  
  if (param_1 == 0) {
    local_14 = param_2 + 1;
  }
  else if (param_2 == 0) {
    local_14 = _ackermann(param_1 + -1,1);
  }
  else {
    uVar1 = _ackermann(param_1,param_2 + -1);
    local_14 = _ackermann(param_1 + -1,uVar1);
  }
  return local_14;
}



undefined8 entry(void)

{
  int local_1c;
  int local_18;
  
  for (local_18 = 0; local_18 < 5; local_18 = local_18 + 1) {
    for (local_1c = 0; local_1c < 6 - local_18; local_1c = local_1c + 1) {
      _ackermann(local_18,local_1c);
      _printf("A(%d, %d) = %d\n");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PRIME 1000000
char *primes;
int n_primes;

/*  Sieve. If we were to handle 10^9 range, use bit field. Regardless,
 *  if a large amount of prime numbers need to be tested, sieve is fast.
 */
void init_primes()
{
	int j;
	primes = malloc(sizeof(char) * MAX_PRIME);
	memset(primes, 1, MAX_PRIME);
	primes[0] = primes[1] = 0;
	int i = 2;
	while (i * i < MAX_PRIME) {
		for (j = i * 2; j < MAX_PRIME; j += i)
			primes[j] = 0;
		while (++i < MAX_PRIME && !primes[i]);
	}
}

int left_trunc(int n)
{
	int tens = 1;
	while (tens < n) tens *= 10;

	while (n) {
		if (!primes[n]) return 0;
		tens /= 10;
		if (n < tens) return 0;
		n %= tens;
	}
	return 1;
}

int right_trunc(int n)
{
	while (n) {
		if (!primes[n]) return 0;
		n /= 10;
	}
	return 1;
}

int main()
{
	int n;
	int max_left = 0, max_right = 0;
	init_primes();

	for (n = MAX_PRIME - 1; !max_left;  n -= 2)
		if (left_trunc(n)) max_left = n;

	for (n = MAX_PRIME - 1; !max_right; n -= 2)
		if (right_trunc(n)) max_right = n;

	printf("Left: %d; right: %d\n", max_left, max_right);
	return 0;
}
`,`#include "truncatable-primes-1.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

void _init_primes(void)

{
  bool bVar1;
  int local_18;
  int local_14;
  
  __primes = (undefined *)_malloc(1000000);
  ___memset_chk(__primes,1,1000000,0xffffffffffffffff);
  __primes[1] = 0;
  *__primes = 0;
  local_18 = 2;
  while (local_18 * local_18 < 1000000) {
    for (local_14 = local_18 << 1; local_14 < 1000000; local_14 = local_14 + local_18) {
      __primes[local_14] = 0;
    }
    do {
      local_18 = local_18 + 1;
      bVar1 = false;
      if (local_18 < 1000000) {
        bVar1 = __primes[local_18] == '\0';
      }
    } while (bVar1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 _left_trunc(int param_1)

{
  int iVar1;
  int local_c;
  int local_8;
  
  for (local_c = 1; local_8 = param_1, local_c < param_1; local_c = local_c * 10) {
  }
  while( true ) {
    if (local_8 == 0) {
      return 1;
    }
    if (*(char *)(__primes + local_8) == '\0') break;
    local_c = local_c / 10;
    if (local_8 < local_c) {
      return 0;
    }
    iVar1 = 0;
    if (local_c != 0) {
      iVar1 = local_8 / local_c;
    }
    local_8 = local_8 - iVar1 * local_c;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 _right_trunc(int param_1)

{
  int local_8;
  
  local_8 = param_1;
  while( true ) {
    if (local_8 == 0) {
      return 1;
    }
    if (*(char *)(__primes + local_8) == '\0') break;
    local_8 = local_8 / 10;
  }
  return 0;
}



undefined8 entry(void)

{
  int iVar1;
  int local_20;
  int local_1c;
  int local_18;
  
  local_1c = 0;
  local_20 = 0;
  _init_primes();
  local_18 = 999999;
  while (local_1c == 0) {
    iVar1 = _left_trunc(local_18);
    if (iVar1 != 0) {
      local_1c = local_18;
    }
    local_18 = local_18 + -2;
  }
  local_18 = 999999;
  while (local_20 == 0) {
    iVar1 = _right_trunc(local_18);
    if (iVar1 != 0) {
      local_20 = local_18;
    }
    local_18 = local_18 + -2;
  }
  _printf("Left: %d; right: %d\n");
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
` #include <stdio.h>

/**
 * description : Counts the number of bits set to 1
 *        input: the number to have its bit counted
 *       output: the number of bits set to 1
 */
unsigned count_bits(unsigned v) {
    unsigned c = 0;
    while (v) {
        c += v & 1;
        v >>= 1;
    }

    return c;
}

int main(void) {
    /*          i: loop iterator
     *     length: the length of the sequence to be printed
     * ascii_base: the lower char for use when printing
     */
    unsigned i, length = 0;
    int ascii_base;


    /* scan in sequence length */
    printf("Sequence length: ");
    do {
        scanf("%u", &length);
    } while (length == 0);


    /* scan in sequence mode */
    printf("(a)lpha or (b)inary: ");
    do {
        ascii_base = getchar();
    } while ((ascii_base != 'a') && (ascii_base != 'b'));
    ascii_base = ascii_base == 'b' ? '0' : 'A';


    /* print the Thue-Morse sequence */
    for (i = 0; i < length; ++i) {
        putchar(ascii_base + count_bits(i) % 2);
    }
    putchar('\n');

    return 0;
}
`,`#include "thue-morse-3.h"



int _count_bits(uint param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0;
  for (local_4 = param_1; local_4 != 0; local_4 = local_4 >> 1) {
    local_8 = local_8 + (local_4 & 1);
  }
  return local_8;
}



// WARNING: Removing unreachable block (ram,0x000100003e4c)
// WARNING: Removing unreachable block (ram,0x000100003e60)
// WARNING: Removing unreachable block (ram,0x000100003e84)
// WARNING: Removing unreachable block (ram,0x000100003e9c)
// WARNING: Removing unreachable block (ram,0x000100003ea4)
// WARNING: Removing unreachable block (ram,0x000100003ec4)
// WARNING: Removing unreachable block (ram,0x000100003ee8)
// WARNING: Removing unreachable block (ram,0x000100003ed4)
// WARNING: Removing unreachable block (ram,0x000100003f2c)

void entry(void)

{
  _printf("Sequence length: ");
  do {
    _scanf("%u");
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004000)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main() {
  int c;
  while ((c = getchar()) != EOF) {
    putchar(c);
  }
  return 0;
}
`,`#include "copy-stdin-to-stdout.h"



undefined8 entry(void)

{
  int iVar1;
  
  while( true ) {
    iVar1 = _getchar();
    if (iVar1 == -1) break;
    _putchar(iVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004000)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

void clear() {
	for(int n = 0;n < 10; n++) {
		printf("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\r\n\r\n\r\n");
	}
}

#define UP    "00^00\r\n00|00\r\n00000\r\n"
#define DOWN  "00000\r\n00|00\r\n00v00\r\n"
#define LEFT  "00000\r\n<--00\r\n00000\r\n"
#define RIGHT "00000\r\n00-->\r\n00000\r\n"
#define HOME  "00000\r\n00+00\r\n00000\r\n"

int main() {
	clear();
	system("stty raw");

	printf(HOME);
	printf("space to exit; wasd to move\r\n");
	char c = 1;

	while(c) {
		c = getc(stdin);
		clear();

		switch (c)
		{
			case 'a':
				printf(LEFT);
				break;
			case 'd':
				printf(RIGHT);
				break;
			case 'w':
				printf(UP);
				break;
			case 's':
				printf(DOWN);
				break;
			case ' ':
				c = 0;
				break;
			default:
				printf(HOME);
		};

		printf("space to exit; wasd key to move\r\n");
	}

	system("stty cooked");
	system("clear");
	return 1;
}
`,`#include "joystick-position.h"



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _clear(void)

{
  int in_w0;
  int local_14;
  
  for (local_14 = 0; local_14 < 10; local_14 = local_14 + 1) {
    in_w0 = _printf("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\r\n\r\n\r\n");
  }
  return in_w0;
}



undefined8 entry(void)

{
  uint uVar1;
  char local_15;
  
  _clear();
  _system("stty raw");
  _printf("00000\r\n00+00\r\n00000\r\n");
  _printf("space to exit; wasd to move\r\n");
  local_15 = '\x01';
  while (local_15 != '\0') {
    uVar1 = _getc(*(FILE **)PTR____stdinp_100004000);
    local_15 = (char)uVar1;
    _clear();
    uVar1 = uVar1 & 0xff;
    if (uVar1 == 0x20) {
      local_15 = '\0';
    }
    else if (uVar1 == 0x61) {
      _printf("00000\r\n<--00\r\n00000\r\n");
    }
    else if (uVar1 == 100) {
      _printf("00000\r\n00-->\r\n00000\r\n");
    }
    else if (uVar1 == 0x73) {
      _printf("00000\r\n00|00\r\n00v00\r\n");
    }
    else if (uVar1 == 0x77) {
      _printf("00^00\r\n00|00\r\n00000\r\n");
    }
    else {
      _printf("00000\r\n00+00\r\n00000\r\n");
    }
    _printf("space to exit; wasd key to move\r\n");
  }
  _system("stty cooked");
  _system("clear");
  return 1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getc_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _system(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__system_100004018)((int)param_1);
  return iVar1;
}


`
`#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

typedef uint32_t integer;

integer next_prime_digit_number(integer n) {
    if (n == 0)
        return 2;
    switch (n % 10) {
    case 2:
        return n + 1;
    case 3:
    case 5:
        return n + 2;
    default:
        return 2 + next_prime_digit_number(n/10) * 10;
    }
}

bool is_prime(integer n) {
    if (n < 2)
        return false;
    if (n % 2 == 0)
        return n == 2;
    if (n % 3 == 0)
        return n == 3;
    if (n % 5 == 0)
        return n == 5;
    static const integer wheel[] = { 4,2,4,2,4,6,2,6 };
    integer p = 7;
    for (;;) {
        for (int i = 0; i < 8; ++i) {
            if (p * p > n)
                return true;
            if (n % p == 0)
                return false;
            p += wheel[i];
        }
    }
}

int main() {
    setlocale(LC_ALL, "");
    const integer limit = 1000000000;
    integer n = 0, max = 0;
    printf("First 25 SPDS primes:\n");
    for (int i = 0; n < limit; ) {
        n = next_prime_digit_number(n);
        if (!is_prime(n))
            continue;
        if (i < 25) {
            if (i > 0)
                printf(" ");
            printf("%'u", n);
        }
        else if (i == 25)
            printf("\n");
        ++i;
        if (i == 100)
            printf("Hundredth SPDS prime: %'u\n", n);
        else if (i == 1000)
            printf("Thousandth SPDS prime: %'u\n", n);
        else if (i == 10000)
            printf("Ten thousandth SPDS prime: %'u\n", n);
        max = n;
    }
    printf("Largest SPDS prime less than %'u: %'u\n", limit, max);
    return 0;
}
`,`#include "smarandache-prime-digital-sequence.h"



int _next_prime_digit_number(uint param_1)

{
  uint uVar1;
  int iVar2;
  undefined4 local_14;
  
  if (param_1 == 0) {
    local_14 = 2;
  }
  else {
    uVar1 = param_1 % 10;
    if (uVar1 == 2) {
      local_14 = param_1 + 1;
    }
    else if ((uVar1 == 3) || (uVar1 == 5)) {
      local_14 = param_1 + 2;
    }
    else {
      iVar2 = _next_prime_digit_number(param_1 / 10);
      local_14 = iVar2 * 10 + 2;
    }
  }
  return local_14;
}



bool _is_prime(uint param_1)

{
  uint uVar1;
  int local_10;
  uint local_c;
  bool local_1;
  
  if (param_1 < 2) {
    local_1 = false;
  }
  else if (param_1 % 2 == 0) {
    local_1 = param_1 == 2;
  }
  else if (param_1 % 3 == 0) {
    local_1 = param_1 == 3;
  }
  else {
    if (param_1 % 5 != 0) {
      local_c = 7;
      do {
        for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {
          if (param_1 < local_c * local_c) {
            return true;
          }
          uVar1 = 0;
          if (local_c != 0) {
            uVar1 = param_1 / local_c;
          }
          if (param_1 == uVar1 * local_c) {
            return false;
          }
          local_c = local_c + *(int *)(&DAT_100003ee0 + (long)local_10 * 4);
        }
      } while( true );
    }
    local_1 = param_1 == 5;
  }
  return local_1;
}



undefined8 entry(void)

{
  ulong uVar1;
  int local_24;
  uint local_1c;
  
  _setlocale(0,"");
  local_1c = 0;
  _printf("First 25 SPDS primes:\n");
  local_24 = 0;
  while (local_1c < 1000000000) {
    local_1c = _next_prime_digit_number(local_1c);
    uVar1 = _is_prime(local_1c);
    if ((uVar1 & 1) != 0) {
      if (local_24 < 0x19) {
        if (0 < local_24) {
          _printf(" ");
        }
        _printf("%\'u");
      }
      else if (local_24 == 0x19) {
        _printf("\n");
      }
      local_24 = local_24 + 1;
      if (local_24 == 100) {
        _printf("Hundredth SPDS prime: %\'u\n");
      }
      else if (local_24 == 1000) {
        _printf("Thousandth SPDS prime: %\'u\n");
      }
      else if (local_24 == 10000) {
        _printf("Ten thousandth SPDS prime: %\'u\n");
      }
    }
  }
  _printf("Largest SPDS prime less than %\'u: %\'u\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004008)();
  return;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct { int *x, n; } tower;
tower *new_tower(int cap)
{
	tower *t = calloc(1, sizeof(tower) + sizeof(int) * cap);
	t->x = (int*)(t + 1);
	return t;
}

tower *t[3];
int height;

void text(int y, int i, int d, const char *s)
{
	printf("\033[%d;%dH", height - y + 1, (height + 1) * (2 * i + 1) - d);
	while (d--) printf("%s", s);
}

void add_disk(int i, int d)
{
	t[i]->x[t[i]->n++] = d;
	text(t[i]->n, i, d, "==");

	usleep(100000);
	fflush(stdout);
}

int remove_disk(int i)
{
	int d = t[i]->x[--t[i]->n];
	text(t[i]->n + 1, i, d, "  ");
	return d;
}

void move(int n, int from, int to, int via)
{
	if (!n) return;

	move(n - 1, from, via, to);
	add_disk(to, remove_disk(from));
	move(n - 1, via, to, from);
}

int main(int c, char *v[])
{
	puts("\033[H\033[J");

	if (c <= 1 || (height = atoi(v[1])) <= 0)
		height = 8;
	for (c = 0; c < 3; c++)	 t[c] = new_tower(height);
	for (c = height; c; c--) add_disk(0, c);

	move(height, 0, 2, 1);

	text(1, 0, 1, "\n");
	return 0;
}
`,`#include "towers-of-hanoi-2.h"



long * _new_tower(int param_1)

{
  long *plVar1;
  
  plVar1 = (long *)_calloc(1,(long)param_1 * 4 + 0x10);
  *plVar1 = (long)(plVar1 + 2);
  return plVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _text(undefined8 param_1,undefined8 param_2,int param_3)

{
  int iVar1;
  int local_1c;
  
  iVar1 = _printf("\x1b[%d;%dH");
  local_1c = param_3;
  while( true ) {
    if (local_1c == 0) break;
    iVar1 = _printf("%s");
    local_1c = local_1c + -1;
  }
  return iVar1;
}



int _add_disk(int param_1,undefined4 param_2)

{
  int iVar1;
  long lVar2;
  
  lVar2 = **(long **)(&_t + (long)param_1 * 8);
  iVar1 = *(int *)(*(long *)(&_t + (long)param_1 * 8) + 8);
  *(int *)(*(long *)(&_t + (long)param_1 * 8) + 8) = iVar1 + 1;
  *(undefined4 *)(lVar2 + (long)iVar1 * 4) = param_2;
  _text(*(undefined4 *)(*(long *)(&_t + (long)param_1 * 8) + 8),param_1,param_2,"==");
  _usleep(100000);
  iVar1 = _fflush(*(FILE **)PTR____stdoutp_100004000);
  return iVar1;
}



undefined4 _remove_disk(int param_1)

{
  undefined4 uVar1;
  int iVar2;
  long lVar3;
  
  lVar3 = **(long **)(&_t + (long)param_1 * 8);
  iVar2 = *(int *)(*(long *)(&_t + (long)param_1 * 8) + 8) + -1;
  *(int *)(*(long *)(&_t + (long)param_1 * 8) + 8) = iVar2;
  uVar1 = *(undefined4 *)(lVar3 + (long)iVar2 * 4);
  _text(*(int *)(*(long *)(&_t + (long)param_1 * 8) + 8) + 1,param_1,uVar1,"  ");
  return uVar1;
}



int _move(int param_1,int param_2)

{
  int iVar1;
  undefined8 uVar2;
  undefined4 in_w2;
  int in_w3;
  
  if (param_1 == 0) {
    iVar1 = 0;
  }
  else {
    _move(param_1 + -1,param_2);
    uVar2 = _remove_disk(param_2);
    _add_disk(in_w2,uVar2);
    iVar1 = _move(param_1 + -1,in_w3);
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 entry(int param_1,long param_2)

{
  undefined8 uVar1;
  int local_18;
  
  _puts("\x1b[H\x1b[J");
  if ((param_1 < 2) || (__height = _atoi(*(char **)(param_2 + 8)), __height < 1)) {
    __height = 8;
  }
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    uVar1 = _new_tower(__height);
    *(undefined8 *)(&_t + (long)local_18 * 8) = uVar1;
  }
  for (local_18 = __height; local_18 != 0; local_18 = local_18 + -1) {
    _add_disk(0,local_18);
  }
  _move(__height,0);
  _text(1,0,1,"\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004030)(param_1);
  return iVar1;
}


`
`#include <time.h>
#include <stdio.h>

int main() {
    time_t t = 0;
    printf("%s", asctime(gmtime(&t)));
    return 0;
}
`,`#include "show-the-epoch-1.h"



undefined4 entry(void)

{
  tm *ptVar1;
  time_t local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = 0;
  ptVar1 = _gmtime(&local_20);
  _asctime(ptVar1);
  _printf("%s");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _asctime(tm *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__asctime_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * _gmtime(time_t *param_1)

{
  tm *ptVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  ptVar1 = (tm *)(*(code *)PTR__gmtime_100004008)();
  return ptVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int f(int n, int x, int y)
{
	return (x + y*2 + 1)%n;
}

int main(int argc, char **argv)
{
	int i, j, n;

	//Edit: Add argument checking
	if(argc!=2) return 1;

	//Edit: Input must be odd and not less than 3.
	n = atoi(argv[1]);
	if (n < 3 || (n%2) == 0) return 2;

	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++)
			printf("% 4d", f(n, n - j - 1, i)*n + f(n, j, i) + 1);
		putchar('\n');
	}
	printf("\n Magic Constant: %d.\n", (n*n+1)/2*n);

	return 0;
}
`,`#include "magic-squares-of-odd-order.h"



int _f(int param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;
  
  iVar1 = param_2 + param_3 * 2 + 1;
  iVar2 = 0;
  if (param_1 != 0) {
    iVar2 = iVar1 / param_1;
  }
  return iVar1 - iVar2 * param_1;
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  int local_28;
  int local_24;
  undefined4 local_14;
  
  if (param_1 == 2) {
    iVar1 = _atoi(*(char **)(param_2 + 8));
    if ((iVar1 < 3) || (iVar1 % 2 == 0)) {
      local_14 = 2;
    }
    else {
      for (local_24 = 0; local_24 < iVar1; local_24 = local_24 + 1) {
        for (local_28 = 0; local_28 < iVar1; local_28 = local_28 + 1) {
          _f(iVar1,(iVar1 - local_28) + -1,local_24);
          _f(iVar1,local_28,local_24);
          _printf("% 4d");
        }
        _putchar(10);
      }
      _printf("\n Magic Constant: %d.\n");
      local_14 = 0;
    }
  }
  else {
    local_14 = 1;
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char *name;
    int weight;
    int value;
} item_t;

item_t items[] = {
    {"map",                      9,   150},
    {"compass",                 13,    35},
    {"water",                  153,   200},
    {"sandwich",                50,   160},
    {"glucose",                 15,    60},
    {"tin",                     68,    45},
    {"banana",                  27,    60},
    {"apple",                   39,    40},
    {"cheese",                  23,    30},
    {"beer",                    52,    10},
    {"suntan cream",            11,    70},
    {"camera",                  32,    30},
    {"T-shirt",                 24,    15},
    {"trousers",                48,    10},
    {"umbrella",                73,    40},
    {"waterproof trousers",     42,    70},
    {"waterproof overclothes",  43,    75},
    {"note-case",               22,    80},
    {"sunglasses",               7,    20},
    {"towel",                   18,    12},
    {"socks",                    4,    50},
    {"book",                    30,    10},
};

int *knapsack (item_t *items, int n, int w) {
    int i, j, a, b, *mm, **m, *s;
    mm = calloc((n + 1) * (w + 1), sizeof (int));
    m = malloc((n + 1) * sizeof (int *));
    m[0] = mm;
    for (i = 1; i <= n; i++) {
        m[i] = &mm[i * (w + 1)];
        for (j = 0; j <= w; j++) {
            if (items[i - 1].weight > j) {
                m[i][j] = m[i - 1][j];
            }
            else {
                a = m[i - 1][j];
                b = m[i - 1][j - items[i - 1].weight] + items[i - 1].value;
                m[i][j] = a > b ? a : b;
            }
        }
    }
    s = calloc(n, sizeof (int));
    for (i = n, j = w; i > 0; i--) {
        if (m[i][j] > m[i - 1][j]) {
            s[i - 1] = 1;
            j -= items[i - 1].weight;
        }
    }
    free(mm);
    free(m);
    return s;
}

int main () {
    int i, n, tw = 0, tv = 0, *s;
    n = sizeof (items) / sizeof (item_t);
    s = knapsack(items, n, 400);
    for (i = 0; i < n; i++) {
        if (s[i]) {
            printf("%-22s %5d %5d\n", items[i].name, items[i].weight, items[i].value);
            tw += items[i].weight;
            tv += items[i].value;
        }
    }
    printf("%-22s %5d %5d\n", "totals:", tw, tv);
    return 0;
}
`,`#include "knapsack-problem-0-1.h"



void * _knapsack(long param_1,int param_2,int param_3)

{
  int iVar1;
  void *pvVar2;
  undefined8 *puVar3;
  void *pvVar4;
  int local_50;
  int local_28;
  int local_24;
  
  pvVar2 = _calloc((long)((param_2 + 1) * (param_3 + 1)),4);
  puVar3 = (undefined8 *)_malloc((long)(param_2 + 1) << 3);
  *puVar3 = pvVar2;
  for (local_24 = 1; local_24 <= param_2; local_24 = local_24 + 1) {
    puVar3[local_24] = (void *)((long)pvVar2 + (long)(local_24 * (param_3 + 1)) * 4);
    for (local_28 = 0; local_28 <= param_3; local_28 = local_28 + 1) {
      if (local_28 < *(int *)(param_1 + (long)(local_24 + -1) * 0x10 + 8)) {
        *(undefined4 *)(puVar3[local_24] + (long)local_28 * 4) =
             *(undefined4 *)(puVar3[local_24 + -1] + (long)local_28 * 4);
      }
      else {
        iVar1 = *(int *)(puVar3[local_24 + -1] + (long)local_28 * 4);
        local_50 = *(int *)(puVar3[local_24 + -1] +
                           (long)(local_28 - *(int *)(param_1 + (long)(local_24 + -1) * 0x10 + 8)) *
                           4) + *(int *)(param_1 + (long)(local_24 + -1) * 0x10 + 0xc);
        if (local_50 < iVar1) {
          local_50 = iVar1;
        }
        *(int *)(puVar3[local_24] + (long)local_28 * 4) = local_50;
      }
    }
  }
  pvVar4 = _calloc((long)param_2,4);
  local_28 = param_3;
  for (local_24 = param_2; 0 < local_24; local_24 = local_24 + -1) {
    if (*(int *)(puVar3[local_24 + -1] + (long)local_28 * 4) <
        *(int *)(puVar3[local_24] + (long)local_28 * 4)) {
      *(undefined4 *)((long)pvVar4 + (long)(local_24 + -1) * 4) = 1;
      local_28 = local_28 - *(int *)(param_1 + (long)(local_24 + -1) * 0x10 + 8);
    }
  }
  _free(pvVar2);
  _free(puVar3);
  return pvVar4;
}



undefined8 entry(void)

{
  long lVar1;
  int local_18;
  
  lVar1 = _knapsack(&_items,0x16,400);
  for (local_18 = 0; local_18 < 0x16; local_18 = local_18 + 1) {
    if (*(int *)(lVar1 + (long)local_18 * 4) != 0) {
      _printf("%-22s %5d %5d\n");
    }
  }
  _printf("%-22s %5d %5d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

static int digsum(int n)
{
    int sum = 0;
    do { sum += n % 10; } while (n /= 10);
    return sum;
}

int main(void)
{
    int n, done, found;

    for (n = 1, done = found = 0; !done; ++n) {
        if (n % digsum(n) == 0) {
            if (found++ < 20) printf("%d ", n);
            if (n > 1000) done = printf("\n%d\n", n);
        }
    }

    return 0;
}
`,`#include "harshad-or-niven-series.h"



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  int local_20;
  int local_1c;
  int local_18;
  
  local_18 = 1;
  local_20 = 0;
  local_1c = 0;
  while (local_1c == 0) {
    iVar2 = FUN_100003f28(local_18);
    iVar1 = 0;
    if (iVar2 != 0) {
      iVar1 = local_18 / iVar2;
    }
    if (local_18 == iVar1 * iVar2) {
      iVar1 = local_20 + 1;
      if (local_20 < 0x14) {
        _printf("%d ");
      }
      local_20 = iVar1;
      if (1000 < local_18) {
        local_1c = _printf("\n%d\n");
      }
    }
    local_18 = local_18 + 1;
  }
  return 0;
}



int FUN_100003f28(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0;
  local_4 = param_1;
  do {
    local_8 = local_8 + local_4 % 10;
    local_4 = local_4 / 10;
  } while (local_4 != 0);
  return local_8;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

unsigned long long raiseTo(unsigned long long base, unsigned long long power){
    unsigned long long result = 1,i;
    for (i=0; i<power;i++) {
        result*=base;
    }
    return result;
}

unsigned long long properDivisorSum(unsigned long long n){
	unsigned long long prod = 1;
	unsigned long long temp = n,i,count = 0;

	while(n%2 == 0){
		count++;
		n /= 2;
	}
	
	if(count!=0)
		prod *= (raiseTo(2,count + 1) - 1);

	for(i=3;i*i<=n;i+=2){
		count = 0;
		
		while(n%i == 0){
			count++;
			n /= i;
		}
		
		if(count==1)
			prod *= (i+1);
		else if(count > 1)
			prod *= ((raiseTo(i,count + 1) - 1)/(i-1));
	}
	
	if(n>2)
		prod *= (n+1);

	return prod - temp;
}

void printSeries(unsigned long long* arr,int size,char* type){
	int i;
	
	printf("\nInteger : %llu, Type : %s, Series : ",arr[0],type);
	
	for(i=0;i<size-1;i++)
		printf("%llu, ",arr[i]);
	printf("%llu",arr[i]);
}

void aliquotClassifier(unsigned long long n){
	unsigned long long arr[16];
	int i,j;
	
	arr[0] = n;
	
	for(i=1;i<16;i++){
		arr[i] = properDivisorSum(arr[i-1]);
		
		if(arr[i]==0||arr[i]==n||(arr[i]==arr[i-1] && arr[i]!=n)){
			printSeries(arr,i+1,(arr[i]==0)?"Terminating":(arr[i]==n && i==1)?"Perfect":(arr[i]==n && i==2)?"Amicable":(arr[i]==arr[i-1] && arr[i]!=n)?"Aspiring":"Sociable");
			return;
		}
		
		for(j=1;j<i;j++){
			if(arr[j]==arr[i]){
				printSeries(arr,i+1,"Cyclic");
				return;
			}
		}
	}
	
	printSeries(arr,i+1,"Non-Terminating");
}

void processFile(char* fileName){
	FILE* fp = fopen(fileName,"r");
	char str[21];
	
	while(fgets(str,21,fp)!=NULL)
		aliquotClassifier(strtoull(str,(char**)NULL,10));
	
	fclose(fp);
}

int main(int argC,char* argV[])
{
    if(argC!=2)
		printf("Usage : %s <positive integer>",argV[0]);
	else{
		if(strchr(argV[1],'.')!=NULL)
			processFile(argV[1]);
		else
			aliquotClassifier(strtoull(argV[1],(char**)NULL,10));
	}
	return 0;
}
`,`#include "aliquot-sequence-classifications-2.h"



long _raiseTo(long param_1,ulong param_2)

{
  undefined8 local_20;
  undefined8 local_18;
  
  local_18 = 1;
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    local_18 = local_18 * param_1;
  }
  return local_18;
}



long _properDivisorSum(ulong param_1)

{
  ulong uVar1;
  long lVar2;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_20;
  undefined8 local_18;
  
  local_20 = 1;
  local_38 = 0;
  for (local_18 = param_1; local_18 % 2 == 0; local_18 = local_18 / 2) {
    local_38 = local_38 + 1;
  }
  if (local_38 != 0) {
    local_20 = _raiseTo(2,local_38 + 1);
    local_20 = local_20 + -1;
  }
  for (local_30 = 3; local_30 * local_30 < local_18 || local_30 * local_30 - local_18 == 0;
      local_30 = local_30 + 2) {
    local_38 = 0;
    uVar1 = local_18;
    while( true ) {
      local_18 = uVar1;
      uVar1 = 0;
      if (local_30 != 0) {
        uVar1 = local_18 / local_30;
      }
      if (local_18 != uVar1 * local_30) break;
      local_38 = local_38 + 1;
      uVar1 = 0;
      if (local_30 != 0) {
        uVar1 = local_18 / local_30;
      }
    }
    if (local_38 == 1) {
      local_20 = local_20 * (local_30 + 1);
    }
    else if (1 < local_38) {
      lVar2 = _raiseTo(local_30,local_38 + 1);
      uVar1 = 0;
      if (local_30 - 1 != 0) {
        uVar1 = (lVar2 - 1U) / (local_30 - 1);
      }
      local_20 = local_20 * uVar1;
    }
  }
  if (2 < local_18) {
    local_20 = local_20 * (local_18 + 1);
  }
  return local_20 - param_1;
}



int _printSeries(undefined8 param_1,int param_2)

{
  int iVar1;
  int local_2c;
  
  _printf("\nInteger : %llu, Type : %s, Series : ");
  for (local_2c = 0; local_2c < param_2 + -1; local_2c = local_2c + 1) {
    _printf("%llu, ");
  }
  iVar1 = _printf("%llu");
  return iVar1;
}



void _aliquotClassifier(long param_1)

{
  bool bVar1;
  long lVar2;
  char *local_d0;
  char *local_c8;
  char *local_c0;
  int local_a8;
  int local_a4;
  long local_98 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_98[0] = param_1;
  local_a4 = 1;
  do {
    if (0xf < local_a4) {
      _printSeries(local_98,local_a4 + 1,"Non-Terminating");
LAB_100003d30:
      if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
        return;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    lVar2 = _properDivisorSum(local_98[local_a4 + -1]);
    local_98[local_a4] = lVar2;
    if (((local_98[local_a4] == 0) || (local_98[local_a4] == param_1)) ||
       ((local_98[local_a4] == local_98[local_a4 + -1] && (local_98[local_a4] != param_1)))) {
      if (local_98[local_a4] == 0) {
        local_c0 = "Terminating";
      }
      else {
        if ((local_98[local_a4] == param_1) && (local_a4 == 1)) {
          local_c8 = "Perfect";
        }
        else {
          if ((local_98[local_a4] == param_1) && (local_a4 == 2)) {
            local_d0 = "Amicable";
          }
          else {
            bVar1 = false;
            if (local_98[local_a4] == local_98[local_a4 + -1]) {
              bVar1 = local_98[local_a4] != param_1;
            }
            local_d0 = "Aspiring";
            if (!bVar1) {
              local_d0 = "Sociable";
            }
          }
          local_c8 = local_d0;
        }
        local_c0 = local_c8;
      }
      _printSeries(local_98,local_a4 + 1,local_c0);
      goto LAB_100003d30;
    }
    for (local_a8 = 1; local_a8 < local_a4; local_a8 = local_a8 + 1) {
      if (local_98[local_a8] == local_98[local_a4]) {
        _printSeries(local_98,local_a4 + 1,"Cyclic");
        goto LAB_100003d30;
      }
    }
    local_a4 = local_a4 + 1;
  } while( true );
}



void _processFile(char *param_1)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  char acStack_2d [21];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pFVar2 = _fopen(param_1,"r");
  while (pcVar3 = _fgets(acStack_2d,0x15,pFVar2), pcVar3 != (char *)0x0) {
    _strtoull(acStack_2d,(char **)0x0,10);
    _aliquotClassifier();
  }
  iVar1 = _fclose(pFVar2);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  char *pcVar1;
  
  if (param_1 == 2) {
    pcVar1 = _strchr(*(char **)(param_2 + 8),0x2e);
    if (pcVar1 == (char *)0x0) {
      _strtoull(*(char **)(param_2 + 8),(char **)0x0,10);
      _aliquotClassifier();
    }
    else {
      _processFile(*(undefined8 *)(param_2 + 8));
    }
  }
  else {
    _printf("Usage : %s <positive integer>");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004030)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulonglong _strtoull(char *param_1,char **param_2,int param_3)

{
  ulonglong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoull_100004038)(param_1,param_2,param_3);
  return uVar1;
}


`
`// http://stackoverflow.com/questions/3385515/static-assert-in-c
#define STATIC_ASSERT(COND,MSG) typedef char static_assertion_##MSG[(!!(COND))*2-1]
// token pasting madness:
#define COMPILE_TIME_ASSERT3(X,L) STATIC_ASSERT(X,static_assertion_at_line_##L)
#define COMPILE_TIME_ASSERT2(X,L) COMPILE_TIME_ASSERT3(X,L)
#define COMPILE_TIME_ASSERT(X)    COMPILE_TIME_ASSERT2(X,__LINE__)

COMPILE_TIME_ASSERT(sizeof(long)==8);
int main()
{
    COMPILE_TIME_ASSERT(sizeof(int)==4);
}
`,`#include "metaprogramming-1.h"



undefined8 entry(void)

{
  return 0;
}


`
`#include <stdio.h>

int digits[26] = { 0, 0, 100, 500, 0, 0, 0, 0, 1, 1, 0, 50, 1000, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 10, 0, 0 };

/* assuming ASCII, do upper case and get index in alphabet. could also be
        inline int VALUE(char x) { return digits [ (~0x20 & x) - 'A' ]; }
   if you think macros are evil */
#define VALUE(x) digits[(~0x20 & (x)) - 'A']

int decode(const char * roman)
{
        const char *bigger;
        int current;
        int arabic = 0;
        while (*roman != '\0') {
                current = VALUE(*roman);
                /*      if (!current) return -1;
                        note: -1 can be used as error code; Romans didn't even have zero
                */
                bigger = roman;

                /* look for a larger digit, like IV or XM */
                while (VALUE(*bigger) <= current && *++bigger != '\0');

                if (*bigger == '\0')
                        arabic += current;
                else {
                        arabic += VALUE(*bigger);
                        while (roman < bigger)
                                arabic -= VALUE(* (roman++) );
                }

                roman ++;
        }
        return arabic;
}

int main()
{
        const char * romans[] = { "MCmxC", "MMVIII", "MDClXVI", "MCXLUJ" };
        int i;

        for (i = 0; i < 4; i++)
                printf("%s\t%d\n", romans[i], decode(romans[i]));

        return 0;
}
`,`#include "roman-numerals-decode.h"



int _decode(char *param_1)

{
  bool bVar1;
  int local_18;
  char *local_10;
  char *local_8;
  
  local_18 = 0;
  for (local_8 = param_1; *local_8 != '\0'; local_8 = local_8 + 1) {
    local_10 = local_8;
    do {
      bVar1 = false;
      if (*(int *)(&_digits + (long)(int)(((int)*local_10 & 0xffffffdfU) - 0x41) * 4) <=
          *(int *)(&_digits + (long)(int)(((int)*local_8 & 0xffffffdfU) - 0x41) * 4)) {
        bVar1 = local_10[1] != '\0';
        local_10 = local_10 + 1;
      }
    } while (bVar1);
    if (*local_10 == '\0') {
      local_18 = local_18 +
                 *(int *)(&_digits + (long)(int)(((int)*local_8 & 0xffffffdfU) - 0x41) * 4);
    }
    else {
      local_18 = local_18 +
                 *(int *)(&_digits + (long)(int)(((int)*local_10 & 0xffffffdfU) - 0x41) * 4);
      for (; local_8 < local_10; local_8 = local_8 + 1) {
        local_18 = local_18 -
                   *(int *)(&_digits + (long)(int)(((int)*local_8 & 0xffffffdfU) - 0x41) * 4);
      }
    }
  }
  return local_18;
}



undefined8 entry(ulong param_1)

{
  uint uVar1;
  int local_48;
  char *local_40 [5];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_40[1] = "MMVIII";
  local_40[0] = "MCmxC";
  local_40[3] = "MCXLUJ";
  local_40[2] = "MDClXVI";
  for (local_48 = 0; local_48 < 4; local_48 = local_48 + 1) {
    _decode(local_40[local_48]);
    uVar1 = _printf("%s\t%d\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    // Get a chance to make stdin input buffer dirty.
    //
    char text[256];
    getchar();

    // This DOES NOT WORK properly on all modern systems including Linux & W10.
    // Obsolete, don't use this. BTW, there is no fpurge in MSVC libs in 2020.
    //
    // fflush(stdin);

    // Always works. Readed characters may remain somethere in RAM.
    //
    fseek(stdin, 0, SEEK_END);

    // A very dirty solution - an unbuffered stream does not need any flushing.
    //
    // setvbuf(stdin, NULL, _IONBF, 0);

    // Now we are able to check if the buffer is really empty.
    //
    fgets(text, sizeof(text), stdin);
    puts(text);

    return EXIT_SUCCESS;
}
`,`#include "keyboard-input-flush-the-keyboard-buffer-1.h"



undefined8 entry(void)

{
  undefined *puVar1;
  int iVar2;
  char acStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _getchar();
  puVar1 = PTR____stdinp_100004010;
  _fseek(*(FILE **)PTR____stdinp_100004010,0,2);
  _fgets(acStack_128,0x100,*(FILE **)puVar1);
  iVar2 = _puts(acStack_128);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fseek(FILE *param_1,long param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fseek_100004020)((int)param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

// Euclid's algorithm
int GCD(int x, int y)
{
    if (y == 0)
        return x;
    return GCD(y, x % y);
}

int main()
{
    int a, b;
    printf("Input two numbers:\n");
    scanf("%d %d", &a, &b);
    printf("Greatest common divisor: %d\n", GCD(a, b));
}
`,`#include "gcd.h"



int _GCD(int param_1,int param_2)

{
  int iVar1;
  undefined4 local_14;
  
  local_14 = param_1;
  if (param_2 != 0) {
    iVar1 = 0;
    if (param_2 != 0) {
      iVar1 = param_1 / param_2;
    }
    local_14 = _GCD(param_2,param_1 - iVar1 * param_2);
  }
  return local_14;
}



undefined8 entry(void)

{
  undefined4 local_18;
  undefined4 local_14;
  
  _printf("Input two numbers:\n");
  _scanf("%d %d");
  _GCD(local_14,local_18);
  _printf("Greatest common divisor: %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>

#define N 5
const char *names[N] = { "Aristotle", "Kant", "Spinoza", "Marx", "Russell" };
pthread_mutex_t forks[N];

#define M 5 /* think bubbles */
const char *topic[M] = { "Spaghetti!", "Life", "Universe", "Everything", "Bathroom" };

#define lock pthread_mutex_lock
#define unlock pthread_mutex_unlock
#define xy(x, y) printf("\033[%d;%dH", x, y)
#define clear_eol(x) print(x, 12, "\033[K")
void print(int y, int x, const char *fmt, ...)
{
	static pthread_mutex_t screen = PTHREAD_MUTEX_INITIALIZER;
	va_list ap;
	va_start(ap, fmt);

	lock(&screen);
	xy(y + 1, x), vprintf(fmt, ap);
	xy(N + 1, 1), fflush(stdout);
	unlock(&screen);
}

void eat(int id)
{
	int f[2], ration, i; /* forks */
	f[0] = f[1] = id;

	/* make some (but not all) philosophers leftie.
	   could have been f[!id] = (id + 1) %N; for example */
	f[id & 1] = (id + 1) % N;

	clear_eol(id);
	print(id, 12, "..oO (forks, need forks)");

	for (i = 0; i < 2; i++) {
		lock(forks + f[i]);
		if (!i) clear_eol(id);

		print(id, 12 + (f[i] != id) * 6, "fork%d", f[i]);
		/* delay 1 sec to clearly show the order of fork acquisition */
		sleep(1);
	}

	for (i = 0, ration = 3 + rand() % 8; i < ration; i++)
		print(id, 24 + i * 4, "nom"), sleep(1);

	/* done nomming, give up forks (order doesn't matter) */
	for (i = 0; i < 2; i++) unlock(forks + f[i]);
}

void think(int id)
{
	int i, t;
	char buf[64] = {0};

	do {
		clear_eol(id);
		sprintf(buf, "..oO (%s)", topic[t = rand() % M]);

		for (i = 0; buf[i]; i++) {
			print(id, i+12, "%c", buf[i]);
			if (i < 5) usleep(200000);
		}
		usleep(500000 + rand() % 1000000);
	} while (t);
}

void* philosophize(void *a)
{
	int id = *(int*)a;
	print(id, 1, "%10s", names[id]);
	while(1) think(id), eat(id);
}

int main()
{
	int i, id[N];
	pthread_t tid[N];

	for (i = 0; i < N; i++)
		pthread_mutex_init(forks + (id[i] = i), 0);

	for (i = 0; i < N; i++)
		pthread_create(tid + i, 0, philosophize, id + i);

	/* wait forever: the threads don't actually stop */
	return pthread_join(tid[0], 0);
}
`,`#include "dining-philosophers-1.h"



int _print(undefined8 param_1,undefined8 param_2,char *param_3)

{
  int iVar1;
  
  _pthread_mutex_lock((pthread_mutex_t *)&DAT_100008050);
  _printf("\x1b[%d;%dH");
  _vprintf(param_3,&stack0x00000000);
  _printf("\x1b[%d;%dH");
  _fflush(*(FILE **)PTR____stdoutp_100004018);
  iVar1 = _pthread_mutex_unlock((pthread_mutex_t *)&DAT_100008050);
  return iVar1;
}



void _eat(uint param_1)

{
  int iVar1;
  uint uVar2;
  int local_2c;
  uint local_20 [2];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_20[0] = param_1;
  local_20[1] = param_1;
  local_20[(int)(param_1 & 1)] = (int)(param_1 + 1) % 5;
  _print(param_1,0xc,"\x1b[K");
  _print(param_1,0xc,"..oO (forks, need forks)");
  for (local_2c = 0; local_2c < 2; local_2c = local_2c + 1) {
    _pthread_mutex_lock((pthread_mutex_t *)(&_forks + (long)(int)local_20[local_2c] * 0x40));
    if (local_2c == 0) {
      _print(param_1,0xc,"\x1b[K");
    }
    _print(param_1,(local_20[local_2c] != param_1) * '\x06' + '\f',"fork%d");
    _sleep(1);
  }
  local_2c = 0;
  uVar2 = _rand();
  iVar1 = (int)uVar2 % 8;
  for (; local_2c < iVar1 + 3; local_2c = local_2c + 1) {
    _print(param_1,local_2c * 4 + 0x18,"nom");
    uVar2 = _sleep(1);
  }
  for (local_2c = 0; local_2c < 2; local_2c = local_2c + 1) {
    uVar2 = _pthread_mutex_unlock
                      ((pthread_mutex_t *)(&_forks + (long)(int)local_20[local_2c] * 0x40));
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar2);
}



void _think(undefined4 param_1)

{
  int iVar1;
  int iVar2;
  int local_60;
  char acStack_58 [64];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  _memset(acStack_58,0,0x40);
  do {
    _print(param_1,0xc,"\x1b[K");
    iVar1 = _rand();
    ___sprintf_chk(acStack_58,0,0x40,"..oO (%s)");
    for (local_60 = 0; acStack_58[local_60] != '\0'; local_60 = local_60 + 1) {
      _print(param_1,local_60 + 0xc,"%c");
      if (local_60 < 5) {
        _usleep(200000);
      }
    }
    iVar2 = _rand();
    iVar2 = _usleep(iVar2 % 1000000 + 500000);
  } while (iVar1 % 5 != 0);
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar2);
}



void _philosophize(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *param_1;
  _print(uVar1,1,"%10s");
  do {
    _think(uVar1);
    _eat(uVar1);
  } while( true );
}



int entry(void)

{
  int iVar1;
  int local_60;
  pthread_t local_58 [5];
  int aiStack_2c [5];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  for (local_60 = 0; local_60 < 5; local_60 = local_60 + 1) {
    aiStack_2c[local_60] = local_60;
    _pthread_mutex_init((pthread_mutex_t *)(&_forks + (long)local_60 * 0x40),
                        (pthread_mutexattr_t *)0x0);
  }
  for (local_60 = 0; local_60 < 5; local_60 = local_60 + 1) {
    _pthread_create(local_58 + local_60,(pthread_attr_t *)0x0,(void **)_philosophize,
                    aiStack_2c + local_60);
  }
  iVar1 = _pthread_join(local_58[0],(void **)0x0);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return iVar1;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004028)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_create(pthread_t *param_1,pthread_attr_t *param_2,void **param_3,void *param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_create_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_join(pthread_t param_1,void **param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_join_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_init(pthread_mutex_t *param_1,pthread_mutexattr_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_init_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_lock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_lock_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_unlock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_unlock_100004058)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004060)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint _sleep(uint param_1)

{
  uint uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__sleep_100004068)(param_1);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004070)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _vprintf(char *param_1,va_list param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__vprintf_100004078)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void quicksort(int *A, int len);

int main (void) {
  int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
  int n = sizeof a / sizeof a[0];

  int i;
  for (i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("\n");

  quicksort(a, n);

  for (i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("\n");

  return 0;
}

void quicksort(int *A, int len) {
  if (len < 2) return;

  int pivot = A[len / 2];

  int i, j;
  for (i = 0, j = len - 1; ; i++, j--) {
    while (A[i] < pivot) i++;
    while (A[j] > pivot) j--;

    if (i >= j) break;

    int temp = A[i];
    A[i]     = A[j];
    A[j]     = temp;
  }

  quicksort(A, i);
  quicksort(A + i, len - i);
}
`,`#include "sorting-algorithms-quicksort-1.h"



undefined8 entry(void)

{
  int iVar1;
  int local_4c;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f78,0x28);
  for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
    _printf("%d ");
  }
  _printf("\n");
  _quicksort(auStack_40,10);
  for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
    _printf("%d ");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void _quicksort(long param_1,int param_2)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 local_28;
  undefined4 local_24;
  
  if (1 < param_2) {
    iVar1 = *(int *)(param_1 + (long)(param_2 / 2) * 4);
    local_24 = 0;
    local_28 = param_2 + -1;
    while( true ) {
      while (*(int *)(param_1 + (long)local_24 * 4) < iVar1) {
        local_24 = local_24 + 1;
      }
      while (iVar1 < *(int *)(param_1 + (long)local_28 * 4)) {
        local_28 = local_28 + -1;
      }
      if (local_28 <= local_24) break;
      uVar2 = *(undefined4 *)(param_1 + (long)local_24 * 4);
      *(undefined4 *)(param_1 + (long)local_24 * 4) = *(undefined4 *)(param_1 + (long)local_28 * 4);
      *(undefined4 *)(param_1 + (long)local_28 * 4) = uVar2;
      local_24 = local_24 + 1;
      local_28 = local_28 + -1;
    }
    _quicksort(param_1,local_24);
    _quicksort(param_1 + (long)local_24 * 4,param_2 - local_24);
  }
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h> // atoi()
#include <math.h> // pow()

int main(int argc, char* argv[])
{
  int i, count=0;
  double f, sum=0.0, prod=1.0, resum=0.0;

  for (i=1; i<argc; ++i) {
    f = atof(argv[i]);
    count++;
    sum += f;
    prod *= f;
    resum += (1.0/f);
  }
  //printf(" c:%d\n s:%f\n p:%f\n r:%f\n",count,sum,prod,resum);
  printf("Arithmetic mean = %f\n",sum/count);
  printf("Geometric mean = %f\n",pow(prod,(1.0/count)));
  printf("Harmonic mean = %f\n",count/resum);

  return 0;
}
`,`#include "averages-pythagorean-means.h"



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  double dVar2;
  double local_40;
  int local_28;
  int local_24;
  
  local_28 = 0;
  local_40 = 1.0;
  for (local_24 = 1; local_24 < param_1; local_24 = local_24 + 1) {
    dVar2 = _atof(*(char **)(param_2 + (long)local_24 * 8));
    local_28 = local_28 + 1;
    local_40 = local_40 * dVar2;
  }
  iVar1 = _printf("Arithmetic mean = %f\n");
  _pow(local_40,1.0 / (double)(long)local_28,iVar1);
  _printf("Geometric mean = %f\n");
  _printf("Harmonic mean = %f\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _atof(char *param_1)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__atof_100004000)();
  return dVar1;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned long long ham;

size_t alloc = 0, n = 1;
ham *q = 0;

void qpush(ham h)
{
	int i, j;
	if (alloc <= n) {
		alloc = alloc ? alloc * 2 : 16;
		q = realloc(q, sizeof(ham) * alloc);
	}

	for (i = n++; (j = i/2) && q[j] > h; q[i] = q[j], i = j);
	q[i] = h;
}

ham qpop()
{
	int i, j;
	ham r, t;
	/* outer loop for skipping duplicates */
	for (r = q[1]; n > 1 && r == q[1]; q[i] = t) {
		/* inner loop is the normal down heap routine */
		for (i = 1, t = q[--n]; (j = i * 2) < n;) {
			if (j + 1 < n && q[j] > q[j+1]) j++;
			if (t <= q[j]) break;
			q[i] = q[j], i = j;
		}
	}

	return r;
}

int main()
{
	int i;
	ham h;

	for (qpush(i = 1); i <= 1691; i++) {
		/* takes smallest value, and queue its multiples */
		h = qpop();
		qpush(h * 2);
		qpush(h * 3);
		qpush(h * 5);

		if (i <= 20 || i == 1691)
			printf("%6d: %llu\n", i, h);
	}

	/* free(q); */
	return 0;
}
`,`#include "hamming-numbers-1.h"



void _qpush(ulong param_1)

{
  bool bVar1;
  int iVar2;
  undefined8 local_28;
  undefined4 local_1c;
  
  if (_alloc <= _n) {
    if (_alloc == 0) {
      local_28 = 0x10;
    }
    else {
      local_28 = _alloc << 1;
    }
    _alloc = local_28;
    _q = _realloc(_q,local_28 * 8);
  }
  local_1c = (int)_n;
  _n = _n + 1;
  while( true ) {
    iVar2 = local_1c / 2;
    bVar1 = false;
    if (iVar2 != 0) {
      bVar1 = param_1 < *(ulong *)((long)_q + (long)iVar2 * 8);
    }
    if (!bVar1) break;
    *(undefined8 *)((long)_q + (long)local_1c * 8) = *(undefined8 *)((long)_q + (long)iVar2 * 8);
    local_1c = iVar2;
  }
  *(ulong *)((long)_q + (long)local_1c * 8) = param_1;
  return;
}



long _qpop(void)

{
  bool bVar1;
  long lVar2;
  ulong uVar3;
  int local_8;
  int local_4;
  
  lVar2 = *(long *)(_q + 8);
  do {
    bVar1 = false;
    if (1 < _n) {
      bVar1 = lVar2 == *(long *)(_q + 8);
    }
    if (!bVar1) {
      return lVar2;
    }
    local_4 = 1;
    _n = _n - 1;
    uVar3 = *(ulong *)(_q + _n * 8);
    while (local_8 = local_4 * 2, (ulong)(long)local_8 < _n) {
      if (((ulong)(long)(local_8 + 1) < _n) &&
         (*(ulong *)(_q + (long)(local_8 + 1) * 8) < *(ulong *)(_q + (long)local_8 * 8))) {
        local_8 = local_8 + 1;
      }
      if (uVar3 <= *(ulong *)(_q + (long)local_8 * 8)) break;
      *(undefined8 *)(_q + (long)local_4 * 8) = *(undefined8 *)(_q + (long)local_8 * 8);
      local_4 = local_8;
    }
    *(ulong *)(_q + (long)local_4 * 8) = uVar3;
  } while( true );
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  long lVar3;
  int local_18;
  
  local_18 = 1;
  uVar2 = _qpush(1);
  for (; local_18 < 0x69c; local_18 = local_18 + 1) {
    lVar3 = _qpop(uVar2);
    _qpush(lVar3 << 1);
    _qpush(lVar3 * 3);
    uVar2 = _qpush(lVar3 * 5);
    if ((local_18 < 0x15) || (local_18 == 0x69b)) {
      uVar1 = _printf("%6d: %llu\n");
      uVar2 = (ulong)uVar1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004008)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int b[3][3]; /* board. 0: blank; -1: computer; 1: human */

int check_winner()
{
	int i;
	for (i = 0; i < 3; i++) {
		if (b[i][0] && b[i][1] == b[i][0] && b[i][2] == b[i][0])
			return b[i][0];
		if (b[0][i] && b[1][i] == b[0][i] && b[2][i] == b[0][i])
			return b[0][i];
	}
	if (!b[1][1]) return 0;

	if (b[1][1] == b[0][0] && b[2][2] == b[0][0]) return b[0][0];
	if (b[1][1] == b[2][0] && b[0][2] == b[1][1]) return b[1][1];

	return 0;
}

void showboard()
{
	const char *t = "X O";
	int i, j;
	for (i = 0; i < 3; i++, putchar('\n'))
		for (j = 0; j < 3; j++)
			printf("%c ", t[ b[i][j] + 1 ]);
	printf("-----\n");
}

#define for_ij for (i = 0; i < 3; i++) for (j = 0; j < 3; j++)
int best_i, best_j;
int test_move(int val, int depth)
{
	int i, j, score;
	int best = -1, changed = 0;

	if ((score = check_winner())) return (score == val) ? 1 : -1;

	for_ij {
		if (b[i][j]) continue;

		changed = b[i][j] = val;
		score = -test_move(-val, depth + 1);
		b[i][j] = 0;

		if (score <= best) continue;
		if (!depth) {
			best_i = i;
			best_j = j;
		}
		best = score;
	}

	return changed ? best : 0;
}

const char* game(int user)
{
	int i, j, k, move, win = 0;
	for_ij b[i][j] = 0;

	printf("Board postions are numbered so:\n1 2 3\n4 5 6\n7 8 9\n");
	printf("You have O, I have X.\n\n");
	for (k = 0; k < 9; k++, user = !user) {
		while(user) {
			printf("your move: ");
			if (!scanf("%d", &move)) {
				scanf("%*s");
				continue;
			}
			if (--move < 0 || move >= 9) continue;
			if (b[i = move / 3][j = move % 3]) continue;

			b[i][j] = 1;
			break;
		}
		if (!user) {
			if (!k) { /* randomize if computer opens, less boring */
				best_i = rand() % 3;
				best_j = rand() % 3;
			} else
				test_move(-1, 0);

			b[best_i][best_j] = -1;
			printf("My move: %d\n", best_i * 3 + best_j + 1);
		}

		showboard();
		if ((win = check_winner()))
			return win == 1 ? "You win.\n\n": "I win.\n\n";
	}
	return "A draw.\n\n";
}

int main()
{
	int first = 0;
	while (1) printf("%s", game(first = !first));
	return 0;
}
`,`#include "tic-tac-toe.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _check_winner(void)

{
  int local_8;
  int local_4;
  
  local_8 = 0;
  while( true ) {
    if (2 < local_8) {
      if (_DAT_100008010 == 0) {
        local_4 = 0;
      }
      else if ((_DAT_100008010 == __b) && (_DAT_100008020 == __b)) {
        local_4 = __b;
      }
      else if ((_DAT_100008010 == _DAT_100008018) && (_DAT_100008008 == _DAT_100008010)) {
        local_4 = _DAT_100008010;
      }
      else {
        local_4 = 0;
      }
      return local_4;
    }
    if (((*(int *)(&_b + (long)local_8 * 0xc) != 0) &&
        (*(int *)((long)local_8 * 0xc + 0x100008004) == *(int *)(&_b + (long)local_8 * 0xc))) &&
       (*(int *)(&DAT_100008008 + (long)local_8 * 0xc) == *(int *)(&_b + (long)local_8 * 0xc)))
    break;
    if (((*(int *)(&_b + (long)local_8 * 4) != 0) &&
        (*(int *)((long)local_8 * 4 + 0x10000800c) == *(int *)(&_b + (long)local_8 * 4))) &&
       (*(int *)(&DAT_100008018 + (long)local_8 * 4) == *(int *)(&_b + (long)local_8 * 4))) {
      return *(int *)(&_b + (long)local_8 * 4);
    }
    local_8 = local_8 + 1;
  }
  return *(int *)(&_b + (long)local_8 * 0xc);
}



int _showboard(void)

{
  int iVar1;
  int local_20;
  int local_1c;
  
  local_1c = 0;
  while (local_1c < 3) {
    for (local_20 = 0; local_20 < 3; local_20 = local_20 + 1) {
      _printf("%c ");
    }
    local_1c = local_1c + 1;
    _putchar(10);
  }
  iVar1 = _printf("-----\n");
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _test_move(int param_1,int param_2)

{
  int iVar1;
  int local_4c;
  int local_30;
  int local_2c;
  int local_24;
  int local_20;
  int local_14;
  
  local_2c = -1;
  local_30 = 0;
  iVar1 = _check_winner();
  if (iVar1 == 0) {
    for (local_20 = 0; local_20 < 3; local_20 = local_20 + 1) {
      for (local_24 = 0; local_24 < 3; local_24 = local_24 + 1) {
        if (*(int *)(&_b + (long)local_24 * 4 + (long)local_20 * 0xc) == 0) {
          *(int *)(&_b + (long)local_24 * 4 + (long)local_20 * 0xc) = param_1;
          iVar1 = _test_move(-param_1,param_2 + 1);
          iVar1 = -iVar1;
          *(undefined4 *)(&_b + (long)local_24 * 4 + (long)local_20 * 0xc) = 0;
          local_30 = param_1;
          if ((local_2c < iVar1) && (local_2c = iVar1, param_2 == 0)) {
            __best_i = local_20;
            __best_j = local_24;
          }
        }
      }
    }
    if (local_30 == 0) {
      local_4c = 0;
    }
    else {
      local_4c = local_2c;
    }
    local_14 = local_4c;
  }
  else {
    local_14 = -1;
    if (iVar1 == param_1) {
      local_14 = 1;
    }
  }
  return local_14;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

char * _game(uint param_1)

{
  uint uVar1;
  ulong uVar2;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  uint local_1c;
  char *local_18;
  
  for (local_20 = 0; local_20 < 3; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < 3; local_24 = local_24 + 1) {
      *(undefined4 *)(&_b + (long)local_24 * 4 + (long)local_20 * 0xc) = 0;
    }
  }
  _printf("Board postions are numbered so:\n1 2 3\n4 5 6\n7 8 9\n");
  uVar1 = _printf("You have O, I have X.\n\n");
  uVar2 = (ulong)uVar1;
  local_28 = 0;
  local_1c = param_1;
  do {
    if (8 < local_28) {
      local_18 = "A draw.\n\n";
      return local_18;
    }
    do {
      do {
        while( true ) {
          if (local_1c == 0) goto LAB_100003d10;
          _printf("your move: ");
          uVar1 = _scanf("%d");
          uVar2 = (ulong)uVar1;
          if (uVar1 != 0) break;
          uVar1 = _scanf("%*s");
          uVar2 = (ulong)uVar1;
        }
        local_2c = local_2c + -1;
      } while ((local_2c < 0) || (8 < local_2c));
    } while (*(int *)(&_b + (long)(local_2c % 3) * 4 + (long)(local_2c / 3) * 0xc) != 0);
    *(undefined4 *)(&_b + (long)(local_2c % 3) * 4 + (long)(local_2c / 3) * 0xc) = 1;
LAB_100003d10:
    if (local_1c == 0) {
      if (local_28 == 0) {
        __best_i = _rand();
        __best_i = __best_i % 3;
        __best_j = _rand();
        __best_j = __best_j % 3;
      }
      else {
        _test_move(0xffffffff,0);
      }
      *(undefined4 *)(&_b + (long)__best_j * 4 + (long)__best_i * 0xc) = 0xffffffff;
      uVar1 = _printf("My move: %d\n");
      uVar2 = (ulong)uVar1;
    }
    _showboard(uVar2);
    uVar2 = _check_winner();
    if ((int)uVar2 != 0) {
      if ((int)uVar2 == 1) {
        return "You win.\n\n";
      }
      return "I win.\n\n";
    }
    local_28 = local_28 + 1;
    local_1c = (uint)(local_1c == 0);
  } while( true );
}



void entry(void)

{
  do {
    _game();
    _printf("%s");
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004010)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>

/*The stdlib header file is required for the malloc and free functions*/

int main()
{
	/*Declaring a four fold integer pointer, also called
	a pointer to a pointer to a pointer to an integer pointer*/
	
	int**** hyperCube, i,j,k;

	/*We will need i,j,k for the memory allocation*/
	
	/*First the five lines*/
	
	hyperCube = (int****)malloc(5*sizeof(int***));
	
	/*Now the four planes*/
	
	for(i=0;i<5;i++){
		hyperCube[i] = (int***)malloc(4*sizeof(int**));
		
		/*Now the 3 cubes*/
		
		for(j=0;j<4;j++){
			hyperCube[i][j] = (int**)malloc(3*sizeof(int*));
			
			/*Now the 2 hypercubes (?)*/
			
			for(k=0;k<3;k++){
				hyperCube[i][j][k] = (int*)malloc(2*sizeof(int));
			}
		}
	}
	
	/*All that looping and function calls may seem futile now,
	but imagine real applications when the dimensions of the dataset are
	not known beforehand*/
	
	/*Yes, I just copied the rest from the first program*/
	
	hyperCube[4][3][2][1] = 1;
	
	/*IMPORTANT : C ( and hence C++ and Java and everyone of the family ) arrays are zero based.
	The above element is thus actually the last element of the hypercube.*/
	
	/*Now we print out that element*/
	
	printf("\n%d",hyperCube[4][3][2][1]);
	
	/*But that's not the only way to get at that element*/
	printf("\n%d",*(*(*(*(hyperCube + 4) + 3) + 2) + 1));

	/*Yes, I know, it's beautiful*/
	*(*(*(*(hyperCube+3)+2)+1)) = 3;
	
	printf("\n%d",hyperCube[3][2][1][0]);
	
	/*Always nice to clean up after you, yes memory is cheap, but C is 45+ years old,
	and anyways, imagine you are dealing with terabytes of data, or more...*/
	
	free(hyperCube);
	
	return 0;
}
`,`#include "multi-dimensional-array-3.h"



undefined8 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  int local_2c;
  int local_28;
  int local_24;
  
  pvVar1 = _malloc(0x28);
  for (local_24 = 0; local_24 < 5; local_24 = local_24 + 1) {
    pvVar2 = _malloc(0x20);
    *(void **)((long)pvVar1 + (long)local_24 * 8) = pvVar2;
    for (local_28 = 0; local_28 < 4; local_28 = local_28 + 1) {
      pvVar2 = _malloc(0x18);
      *(void **)(*(long *)((long)pvVar1 + (long)local_24 * 8) + (long)local_28 * 8) = pvVar2;
      for (local_2c = 0; local_2c < 3; local_2c = local_2c + 1) {
        pvVar2 = _malloc(8);
        *(void **)(*(long *)(*(long *)((long)pvVar1 + (long)local_24 * 8) + (long)local_28 * 8) +
                  (long)local_2c * 8) = pvVar2;
      }
    }
  }
  *(undefined4 *)(*(long *)(*(long *)(*(long *)((long)pvVar1 + 0x20) + 0x18) + 0x10) + 4) = 1;
  _printf("\n%d");
  _printf("\n%d");
  **(undefined4 **)(*(long *)(*(long *)((long)pvVar1 + 0x18) + 0x10) + 8) = 3;
  _printf("\n%d");
  _free(pvVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>
#include <math.h>
#include <stdio.h>

typedef struct point_tag {
    double x;
    double y;
} point_t;

// Returns the distance from point p to the line between p1 and p2
double perpendicular_distance(point_t p, point_t p1, point_t p2) {
    double dx = p2.x - p1.x;
    double dy = p2.y - p1.y;
    double d = sqrt(dx * dx + dy * dy);
    return fabs(p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)/d;
}

// Simplify an array of points using the Ramer–Douglas–Peucker algorithm.
// Returns the number of output points.
size_t douglas_peucker(const point_t* points, size_t n, double epsilon,
                       point_t* dest, size_t destlen) {
    assert(n >= 2);
    assert(epsilon >= 0);
    double max_dist = 0;
    size_t index = 0;
    for (size_t i = 1; i + 1 < n; ++i) {
        double dist = perpendicular_distance(points[i], points[0], points[n - 1]);
        if (dist > max_dist) {
            max_dist = dist;
            index = i;
        }
    }
    if (max_dist > epsilon) {
        size_t n1 = douglas_peucker(points, index + 1, epsilon, dest, destlen);
        if (destlen >= n1 - 1) {
            destlen -= n1 - 1;
            dest += n1 - 1;
        } else {
            destlen = 0;
        }
        size_t n2 = douglas_peucker(points + index, n - index, epsilon, dest, destlen);
        return n1 + n2 - 1;
    }
    if (destlen >= 2) {
        dest[0] = points[0];
        dest[1] = points[n - 1];
    }
    return 2;
}

void print_points(const point_t* points, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        if (i > 0)
            printf(" ");
        printf("(%g, %g)", points[i].x, points[i].y);
    }
    printf("\n");
}

int main() {
    point_t points[] = {
        {0,0}, {1,0.1}, {2,-0.1}, {3,5}, {4,6},
        {5,7}, {6,8.1}, {7,9}, {8,9}, {9,9}
    };
    const size_t len = sizeof(points)/sizeof(points[0]);
    point_t out[len];
    size_t n = douglas_peucker(points, len, 1.0, out, len);
    print_points(out, n);
    return 0;
}
`,`#include "ramer-douglas-peucker-line-simplification.h"



undefined  [16]
_perpendicular_distance
          (undefined8 param_1,double param_2,double param_3,double param_4,double param_5,
          double param_6)

{
  double dVar1;
  double dVar2;
  double dVar3;
  undefined auVar4 [16];
  undefined8 uVar5;
  
  dVar1 = param_5 - param_3;
  dVar2 = param_6 - param_4;
  dVar3 = (double)NEON_fmadd(dVar1,dVar1,dVar2 * dVar2);
  uVar5 = NEON_fnmsub(param_1,dVar2,param_2 * dVar1);
  uVar5 = NEON_fmadd(param_5,param_4,uVar5);
  dVar1 = (double)NEON_fmsub(param_6,param_3,uVar5);
  auVar4._0_8_ = ABS(dVar1) / SQRT(dVar3);
  auVar4._8_8_ = 0;
  return auVar4;
}



long _douglas_peucker(double param_1,undefined8 *param_2,ulong param_3,undefined8 *param_4,
                     ulong param_5)

{
  long lVar1;
  long lVar2;
  double dVar3;
  undefined8 uVar4;
  long local_58;
  long local_50;
  double local_48;
  long local_40;
  undefined8 *local_38;
  long local_18;
  
  if (param_3 < 2) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("douglas_peucker","ramer-douglas-peucker-line-simplification.c",0x16,"n >= 2");
  }
  if (param_1 < 0.0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("douglas_peucker","ramer-douglas-peucker-line-simplification.c",0x17,
                  "epsilon >= 0");
  }
  local_48 = 0.0;
  local_50 = 0;
  for (local_58 = 1; local_58 + 1U < param_3; local_58 = local_58 + 1) {
    dVar3 = (double)_perpendicular_distance
                              (param_2[local_58 * 2],(param_2 + local_58 * 2)[1],*param_2,param_2[1]
                               ,param_2[(param_3 - 1) * 2],(param_2 + (param_3 - 1) * 2)[1]);
    if (local_48 < dVar3) {
      local_50 = local_58;
      local_48 = dVar3;
    }
  }
  if (local_48 <= param_1) {
    if (1 < param_5) {
      uVar4 = *param_2;
      param_4[1] = param_2[1];
      *param_4 = uVar4;
      uVar4 = param_2[(param_3 - 1) * 2];
      param_4[3] = (param_2 + (param_3 - 1) * 2)[1];
      param_4[2] = uVar4;
    }
    local_18 = 2;
  }
  else {
    lVar1 = _douglas_peucker(param_1,param_2,local_50 + 1,param_4,param_5);
    if (param_5 < lVar1 - 1U) {
      local_40 = 0;
      local_38 = param_4;
    }
    else {
      local_40 = param_5 - (lVar1 + -1);
      local_38 = param_4 + (lVar1 + -1) * 2;
    }
    lVar2 = _douglas_peucker(param_1,param_2 + local_50 * 2,param_3 - local_50,local_38,local_40);
    local_18 = lVar1 + lVar2 + -1;
  }
  return local_18;
}



int _print_points(undefined8 param_1,ulong param_2)

{
  int iVar1;
  ulong local_28;
  
  for (local_28 = 0; local_28 < param_2; local_28 = local_28 + 1) {
    if (local_28 != 0) {
      _printf(" ");
    }
    _printf("(%g, %g)");
  }
  iVar1 = _printf("\n");
  return iVar1;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  undefined auStack_168 [160];
  undefined auStack_c8 [160];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _memcpy(auStack_c8,&DAT_100003ef8,0xa0);
  uVar1 = _douglas_peucker(0x3ff0000000000000,auStack_c8,10);
  _print_points(auStack_168,uVar1);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint;
typedef unsigned long long tree;
#define B(x) (1ULL<<(x))

tree *list = 0;
uint cap = 0, len = 0;
uint offset[32] = {0, 1, 0};

void append(tree t)
{
	if (len == cap) {
		cap = cap ? cap*2 : 2;
		list = realloc(list, cap*sizeof(tree));
	}
	list[len++] = 1 | t<<1;
}

void show(tree t, uint len)
{
	for (; len--; t >>= 1)
		putchar(t&1 ? '(' : ')');
}

void listtrees(uint n)
{
	uint i;
	for (i = offset[n]; i < offset[n+1]; i++) {
		show(list[i], n*2);
		putchar('\n');
	}
}

/* assemble tree from subtrees
	n:   length of tree we want to make
	t:   assembled parts so far
	sl:  length of subtree we are looking at
	pos: offset of subtree we are looking at
	rem: remaining length to be put together
*/
void assemble(uint n, tree t, uint sl, uint pos, uint rem)
{
	if (!rem) {
		append(t);
		return;
	}

	if (sl > rem) // need smaller subtrees
		pos = offset[sl = rem];
	else if (pos >= offset[sl + 1]) {
		// used up sl-trees, try smaller ones
		if (!--sl) return;
		pos = offset[sl];
	}

	assemble(n, t<<(2*sl) | list[pos], sl, pos, rem - sl);
	assemble(n, t, sl, pos + 1, rem);
}

void mktrees(uint n)
{
	if (offset[n + 1]) return;
	if (n) mktrees(n - 1);

	assemble(n, 0, n-1, offset[n-1], n-1);
	offset[n+1] = len;
}

int main(int c, char**v)
{
	int n;
	if (c < 2 || (n = atoi(v[1])) <= 0 || n > 25) n = 5;

	// init 1-tree
	append(0);

	mktrees((uint)n);
	fprintf(stderr, "Number of %d-trees: %u\n", n, offset[n+1] - offset[n]);
	listtrees((uint)n);

	return 0;
}
`,`#include "list-rooted-trees.h"



void _append(long param_1)

{
  ulong uVar1;
  undefined4 local_1c;
  
  if (_len == _cap) {
    if (_cap == 0) {
      local_1c = 2;
    }
    else {
      local_1c = _cap << 1;
    }
    _cap = local_1c;
    _list = _realloc(_list,(ulong)local_1c << 3);
  }
  uVar1 = (ulong)_len;
  _len = _len + 1;
  *(ulong *)((long)_list + uVar1 * 8) = param_1 << 1 | 1;
  return;
}



ulong _show(ulong param_1,int param_2)

{
  uint uVar1;
  int iVar2;
  undefined4 local_1c;
  undefined8 local_18;
  
  local_1c = param_2;
  local_18 = param_1;
  while (local_1c != 0) {
    iVar2 = 0x28;
    if ((local_18 & 1) == 0) {
      iVar2 = 0x29;
    }
    uVar1 = _putchar(iVar2);
    param_1 = (ulong)uVar1;
    local_18 = local_18 >> 1;
    local_1c = local_1c + -1;
  }
  return param_1;
}



ulong _listtrees(ulong param_1)

{
  int iVar1;
  uint uVar2;
  uint local_18;
  
  iVar1 = (int)param_1;
  for (local_18 = *(uint *)((long)&_offset + (param_1 & 0xffffffff) * 4);
      local_18 < *(uint *)((long)&_offset + (ulong)(iVar1 + 1) * 4); local_18 = local_18 + 1) {
    _show(*(undefined8 *)(_list + (ulong)local_18 * 8),iVar1 << 1);
    uVar2 = _putchar(10);
    param_1 = (ulong)uVar2;
  }
  return param_1;
}



void _assemble(undefined4 param_1,long param_2,uint param_3,uint param_4,uint param_5)

{
  uint local_28;
  uint local_24;
  
  if (param_5 == 0) {
    _append(param_2);
  }
  else {
    if (param_5 < param_3) {
      local_28 = *(uint *)((long)&_offset + (ulong)param_5 * 4);
      local_24 = param_5;
    }
    else {
      local_28 = param_4;
      local_24 = param_3;
      if (*(uint *)((long)&_offset + (ulong)(param_3 + 1) * 4) <= param_4) {
        local_24 = param_3 - 1;
        if (local_24 == 0) {
          return;
        }
        local_28 = *(uint *)((long)&_offset + (ulong)local_24 * 4);
      }
    }
    _assemble(param_1,param_2 << ((ulong)(local_24 * 2) & 0x3f) |
                      *(ulong *)(_list + (ulong)local_28 * 8),local_24,local_28,param_5 - local_24);
    _assemble(param_1,param_2,local_24,local_28 + 1,param_5);
  }
  return;
}



void _mktrees(int param_1)

{
  if (*(int *)((long)&_offset + (ulong)(param_1 + 1) * 4) == 0) {
    if (param_1 != 0) {
      _mktrees(param_1 + -1);
    }
    _assemble(param_1,0,param_1 + -1,*(undefined4 *)((long)&_offset + (ulong)(param_1 - 1) * 4),
              param_1 + -1);
    *(undefined4 *)((long)&_offset + (ulong)(param_1 + 1) * 4) = _len;
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  int local_24;
  
  if (((param_1 < 2) || (local_24 = _atoi(*(char **)(param_2 + 8)), local_24 < 1)) ||
     (0x19 < local_24)) {
    local_24 = 5;
  }
  _append(0);
  _mktrees(local_24);
  _fprintf(*(FILE **)PTR____stderrp_100004000,"Number of %d-trees: %u\n");
  _listtrees(local_24);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004020)();
  return pvVar1;
}


`
`#include <stdio.h>

typedef unsigned char sint;
enum states { s_blnk = 0, s_tran, s_cont, s_disj };

/* Recursively look at each item in list, taking both choices of
   picking the item or not.  The state at each step depends on prvious
   pickings, with the state transition table:
	blank + no pick -> blank
	blank + pick -> contiguous
	transitional + no pick -> transitional
	transitional + pick -> disjoint
	contiguous + no pick -> transitional
	contiguous + pick -> contiguous
	disjoint + pick -> disjoint
	disjoint + no pick -> disjoint
   At first step, before looking at any item, state is blank.
   Because state is known at each step and needs not be calculated,
   it can be quite fast.
*/
unsigned char tbl[][2] = {
	{ s_blnk, s_cont },
	{ s_tran, s_disj },
	{ s_tran, s_cont },
	{ s_disj, s_disj },
};

void pick(sint n, sint step, sint state, char **v, unsigned long bits)
{
	int i, b;
	if (step == n) {
		if (state != s_disj) return;
		for (i = 0, b = 1; i < n; i++, b <<= 1)
			if ((b & bits)) printf("%s ", v[i]);
		putchar('\n');
		return;
	}

	bits <<= 1;
	pick(n, step + 1, tbl[state][0], v, bits); /* no pick */
	pick(n, step + 1, tbl[state][1], v, bits | 1); /* pick */
}

int main(int c, char **v)
{
	if (c - 1 >= sizeof(unsigned long) * 4)
		printf("Too many items");
	else
		pick(c - 1, 0, s_blnk, v + 1, 0);
	return 0;
}
`,`#include "non-continuous-subsequences-3.h"



ulong _pick(ulong param_1,byte param_2,byte param_3,undefined8 param_4,ulong param_5)

{
  uint uVar1;
  int local_30;
  int local_2c;
  
  if (param_2 == (byte)param_1) {
    if (param_3 == 3) {
      local_30 = 1;
      for (local_2c = 0; local_2c < (int)(uint)(byte)param_1; local_2c = local_2c + 1) {
        if (((long)local_30 & param_5) != 0) {
          _printf("%s ");
        }
        local_30 = local_30 << 1;
      }
      uVar1 = _putchar(10);
      param_1 = (ulong)uVar1;
    }
  }
  else {
    _pick(param_1 & 0xff,param_2 + 1,(&_tbl)[(ulong)param_3 * 2],param_4,param_5 << 1);
    param_1 = _pick(param_1 & 0xff,param_2 + 1,(&DAT_100008001)[(ulong)param_3 * 2],param_4,
                    param_5 << 1 | 1);
  }
  return param_1;
}



undefined8 entry(int param_1,long param_2)

{
  if (param_1 - 1U < 0x20) {
    _pick(param_1 - 1U & 0xff,0,0,param_2 + 8,0);
  }
  else {
    _printf("Too many items");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
        int i, j;
        double degrees[] = { 0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5,
                84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88,
                168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12,
                253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5,
                354.37, 354.38 };
        const char * names =  "North                 "
                              "North by east         "
                              "North-northeast       "
                              "Northeast by north    "
                              "Northeast             "
                              "Northeast by east     "
                              "East-northeast        "
                              "East by north         "
                              "East                  "
                              "East by south         "
                              "East-southeast        "
                              "Southeast by east     "
                              "Southeast             "
                              "Southeast by south    "
                              "South-southeast       "
                              "South by east         "
                              "South                 "
                              "South by west         "
                              "South-southwest       "
                              "Southwest by south    "
                              "Southwest             "
                              "Southwest by west     "
                              "West-southwest        "
                              "West by south         "
                              "West                  "
                              "West by north         "
                              "West-northwest        "
                              "Northwest by west     "
                              "Northwest             "
                              "Northwest by north    "
                              "North-northwest       "
                              "North by west         "
                              "North                 ";

        for (i = 0; i < 33; i++) {
                j = .5 + degrees[i] * 32 / 360;

                printf("%2d  %.22s  %6.2f\n", (j % 32) + 1, names + (j % 32) * 22,
                        degrees[i]);
        }

        return 0;
}
`,`#include "box-the-compass.h"



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  int local_138;
  undefined auStack_130 [264];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memcpy(auStack_130,&DAT_100003bb0,0x108);
  for (local_138 = 0; local_138 < 0x21; local_138 = local_138 + 1) {
    uVar1 = _printf("%2d  %.22s  %6.2f\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003b84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b90. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <string.h>

int ordered(char *s, char **end)
{
	int r = 1;
	while (*++s != '\n' && *s != '\r' && *s != '\0')
		if (s[0] < s[-1]) r = 0;

	*end = s;
	return r;
}

int main()
{
	char *buf, *word, *end, *tail;
	struct stat st;
	int longest = 0, len, fd;

	if ((fd = open("unixdict.txt", O_RDONLY)) == -1) err(1, "read error");

	fstat(fd, &st);
	if (!(buf = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)))
		err(1, "mmap");

	for (word = end = buf; end < buf + st.st_size; word = end) {
		while (*word == '\r' || *word == '\n') word++;
		if (!ordered(word, &end)) continue;
		if ((len = end - word + 1) < longest) continue;
		if (len > longest) {
			tail = buf;  /* longer words found; reset out buffer */
			longest = len;
		}
		/* use the same mmap'd region to store output.  because of MAP_PRIVATE,
		 * change will not go back to file.  mmap is copy on write, and we are using
		 * only the head space to store output, so kernel doesn't need to copy more
		 * than the words we saved--in this case, one page tops.
		 */
		memcpy(tail, word, len);
		tail += len;
		*tail = '\0';
	}
	printf(buf);

	munmap(buf, st.st_size);
	close(fd);
	return 0;
}
`,`#include "ordered-words-3.h"



undefined4 _ordered(byte *param_1,long *param_2)

{
  byte *pbVar1;
  byte bVar2;
  bool bVar3;
  undefined4 local_14;
  byte *local_8;
  
  local_14 = 1;
  local_8 = param_1;
  while( true ) {
    pbVar1 = local_8 + 1;
    bVar3 = false;
    if ((local_8[1] != 10) && (bVar3 = false, *pbVar1 != 0xd)) {
      bVar3 = *pbVar1 != 0;
    }
    if (!bVar3) break;
    bVar2 = *local_8;
    local_8 = pbVar1;
    if ((int)(char)*pbVar1 < (int)(uint)bVar2) {
      local_14 = 0;
    }
  }
  *param_2 = (long)pbVar1;
  return local_14;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  int local_cc;
  stat sStack_c8;
  char *local_38;
  char *local_30;
  char *local_28;
  char *local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_cc = 0;
  iVar2 = _open("unixdict.txt",0);
  if (iVar2 == -1) {
    _err(1,"read error");
  }
  _fstat(iVar2,&sStack_c8);
  local_20 = (char *)_mmap(0,sStack_c8.st_size,3,2,iVar2,0);
  if (local_20 == (char *)0x0) {
    _err(1,"mmap");
  }
  local_28 = local_20;
  while (local_30 = local_28, local_28 < local_20 + sStack_c8.st_size) {
    while( true ) {
      bVar1 = true;
      if (*local_28 != '\r') {
        bVar1 = *local_28 == '\n';
      }
      if (!bVar1) break;
      local_28 = local_28 + 1;
    }
    iVar3 = _ordered(local_28,&local_30);
    if ((iVar3 != 0) && (iVar3 = ((int)local_30 - (int)local_28) + 1, local_cc <= iVar3)) {
      if (local_cc < iVar3) {
        local_38 = local_20;
        local_cc = iVar3;
      }
      ___memcpy_chk(local_38,local_28,(long)iVar3,0xffffffffffffffff);
      local_38 = local_38 + iVar3;
      *local_38 = '\0';
    }
    local_28 = local_30;
  }
  _printf(local_20);
  _munmap(local_20,sStack_c8.st_size);
  _close(iVar2);
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004008)(param_1);
  return iVar1;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004018)(param_1);
  return iVar1;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004020)();
  return;
}



void _munmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__munmap_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004030)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

typedef struct node_t {
	struct node_t *left, *right;
	int freq;
	char c;
} *node;

struct node_t pool[256] = {{0}};
node qqq[255], *q = qqq - 1;
int n_nodes = 0, qend = 1;
char *code[128] = {0}, buf[1024];

node new_node(int freq, char c, node a, node b)
{
	node n = pool + n_nodes++;
	if (freq) n->c = c, n->freq = freq;
	else {
		n->left = a, n->right = b;
		n->freq = a->freq + b->freq;
	}
	return n;
}

/* priority queue */
void qinsert(node n)
{
	int j, i = qend++;
	while ((j = i / 2)) {
		if (q[j]->freq <= n->freq) break;
		q[i] = q[j], i = j;
	}
	q[i] = n;
}

node qremove()
{
	int i, l;
	node n = q[i = 1];

	if (qend < 2) return 0;
	qend--;
	while ((l = i * 2) < qend) {
		if (l + 1 < qend && q[l + 1]->freq < q[l]->freq) l++;
		q[i] = q[l], i = l;
	}
	q[i] = q[qend];
	return n;
}

/* walk the tree and put 0s and 1s */
void build_code(node n, char *s, int len)
{
	static char *out = buf;
	if (n->c) {
		s[len] = 0;
		strcpy(out, s);
		code[n->c] = out;
		out += len + 1;
		return;
	}

	s[len] = '0'; build_code(n->left,  s, len + 1);
	s[len] = '1'; build_code(n->right, s, len + 1);
}

void init(const char *s)
{
	int i, freq[128] = {0};
	char c[16];

	while (*s) freq[(int)*s++]++;

	for (i = 0; i < 128; i++)
		if (freq[i]) qinsert(new_node(freq[i], i, 0, 0));

	while (qend > 2)
		qinsert(new_node(0, 0, qremove(), qremove()));

	build_code(q[1], c, 0);
}

void encode(const char *s, char *out)
{
	while (*s) {
		strcpy(out, code[*s]);
		out += strlen(code[*s++]);
	}
}

void decode(const char *s, node t)
{
	node n = t;
	while (*s) {
		if (*s++ == '0') n = n->left;
		else n = n->right;

		if (n->c) putchar(n->c), n = t;
	}

	putchar('\n');
	if (t != n) printf("garbage input\n");
}

int main(void)
{
	int i;
	const char *str = "this is an example for huffman encoding";
        char buf[1024];

	init(str);
	for (i = 0; i < 128; i++)
		if (code[i]) printf("'%c': %s\n", i, code[i]);

	encode(str, buf);
	printf("encoded: %s\n", buf);

	printf("decoded: ");
	decode(buf, q[1]);

	return 0;
}
`,`#include "huffman-coding-2.h"



long * _new_node(int param_1,undefined param_2,long param_3,long param_4)

{
  long lVar1;
  
  lVar1 = (long)_n_nodes;
  _n_nodes = _n_nodes + 1;
  lVar1 = lVar1 * 0x18;
  if (param_1 == 0) {
    *(long *)(&_pool + lVar1) = param_3;
    *(long *)(&DAT_100008020 + lVar1) = param_4;
    *(int *)(&DAT_100008028 + lVar1) = *(int *)(param_3 + 0x10) + *(int *)(param_4 + 0x10);
  }
  else {
    (&DAT_10000802c)[lVar1] = param_2;
    *(int *)(&DAT_100008028 + lVar1) = param_1;
  }
  return (long *)(&_pool + lVar1);
}



void _qinsert(long param_1)

{
  int iVar1;
  int local_10;
  
  local_10 = _qend;
  _qend = _qend + 1;
  while ((iVar1 = local_10 / 2, iVar1 != 0 &&
         (*(int *)(param_1 + 0x10) < *(int *)(*(long *)(_q + (long)iVar1 * 8) + 0x10)))) {
    *(undefined8 *)(_q + (long)local_10 * 8) = *(undefined8 *)(_q + (long)iVar1 * 8);
    local_10 = iVar1;
  }
  *(long *)(_q + (long)local_10 * 8) = param_1;
  return;
}



undefined8 _qremove(void)

{
  int local_10;
  int local_c;
  undefined8 local_8;
  
  local_c = 1;
  local_8 = *(undefined8 *)(_q + 8);
  if (_qend < 2) {
    local_8 = 0;
  }
  else {
    _qend = _qend + -1;
    while (local_10 = local_c * 2, local_10 < _qend) {
      if ((local_10 + 1 < _qend) &&
         (*(int *)(*(long *)(_q + (long)(local_10 + 1) * 8) + 0x10) <
          *(int *)(*(long *)(_q + (long)local_10 * 8) + 0x10))) {
        local_10 = local_10 + 1;
      }
      *(undefined8 *)(_q + (long)local_c * 8) = *(undefined8 *)(_q + (long)local_10 * 8);
      local_c = local_10;
    }
    *(undefined8 *)(_q + (long)local_c * 8) = *(undefined8 *)(_q + (long)_qend * 8);
  }
  return local_8;
}



void _build_code(undefined8 *param_1,long param_2,int param_3)

{
  if (*(char *)((long)param_1 + 0x14) == '\0') {
    *(undefined *)(param_2 + param_3) = 0x30;
    _build_code(*param_1,param_2,param_3 + 1);
    *(undefined *)(param_2 + param_3) = 0x31;
    _build_code(param_1[1],param_2,param_3 + 1);
  }
  else {
    *(undefined *)(param_2 + param_3) = 0;
    ___strcpy_chk(PTR__buf_100008010,param_2,0xffffffffffffffff);
    *(undefined **)(&_code + (long)*(char *)((long)param_1 + 0x14) * 8) = PTR__buf_100008010;
    PTR__buf_100008010 = PTR__buf_100008010 + (param_3 + 1);
  }
  return;
}



void _init(char *param_1)

{
  undefined8 uVar1;
  undefined8 uVar2;
  int local_244;
  char *local_240;
  undefined auStack_238 [16];
  int aiStack_228 [128];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _bzero(aiStack_228,0x200);
  local_240 = param_1;
  while (*local_240 != '\0') {
    aiStack_228[*local_240] = aiStack_228[*local_240] + 1;
    local_240 = local_240 + 1;
  }
  for (local_244 = 0; local_244 < 0x80; local_244 = local_244 + 1) {
    if (aiStack_228[local_244] != 0) {
      _new_node(aiStack_228[local_244],(int)(char)local_244,0);
      _qinsert();
    }
  }
  while (2 < _qend) {
    uVar1 = _qremove();
    uVar2 = _qremove();
    _new_node(0,0,uVar1,uVar2);
    _qinsert();
  }
  _build_code(*(undefined8 *)(_q + 8),auStack_238,0);
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void _encode(char *param_1,long param_2)

{
  size_t sVar1;
  long local_20;
  char *local_18;
  
  local_20 = param_2;
  local_18 = param_1;
  while (*local_18 != '\0') {
    ___strcpy_chk(local_20,*(undefined8 *)(&_code + (long)*local_18 * 8),0xffffffffffffffff);
    sVar1 = _strlen(*(char **)(&_code + (long)*local_18 * 8));
    local_20 = local_20 + sVar1;
    local_18 = local_18 + 1;
  }
  return;
}



int _decode(char *param_1,undefined8 *param_2)

{
  char *pcVar1;
  int iVar2;
  undefined8 *local_28;
  char *local_18;
  
  local_28 = param_2;
  local_18 = param_1;
  while (*local_18 != '\0') {
    pcVar1 = local_18 + 1;
    if (*local_18 == '0') {
      local_28 = (undefined8 *)*local_28;
    }
    else {
      local_28 = (undefined8 *)local_28[1];
    }
    local_18 = pcVar1;
    if (*(char *)((long)local_28 + 0x14) != '\0') {
      _putchar((int)*(char *)((long)local_28 + 0x14));
      local_28 = param_2;
    }
  }
  iVar2 = _putchar(10);
  if (param_2 != local_28) {
    iVar2 = _printf("garbage input\n");
  }
  return iVar2;
}



undefined8 entry(void)

{
  int local_430;
  undefined auStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _init("this is an example for huffman encoding");
  for (local_430 = 0; local_430 < 0x80; local_430 = local_430 + 1) {
    if (*(long *)(&_code + (long)local_430 * 8) != 0) {
      _printf("\'%c\': %s\n");
    }
  }
  _encode("this is an example for huffman encoding");
  _printf("encoded: %s\n");
  _printf("decoded: ");
  _decode(auStack_428,*(undefined8 *)(_q + 8));
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004028)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <stdio.h>

void t(int n)
{
	int i, j, c, len;

	i = n * (n - 1) / 2;
	for (len = c = 1; c < i; c *= 10, len++);
	c -= i; // c is the col where width changes

#define SPEED_MATTERS 0
#if SPEED_MATTERS	// in case we really, really wanted to print huge triangles often
	char tmp[32], s[4096], *p;

	sprintf(tmp, "%*d", len, 0);

	inline void inc_numstr(void) {
		int k = len;

	redo:	if (!k--) return;

		if (tmp[k] == '9') {
			tmp[k] = '0';
			goto redo;
		}

		if (++tmp[k] == '!')
			tmp[k] = '1';
	}

	for (p = s, i = 1; i <= n; i++) {
		for (j = 1; j <= i; j++) {
			inc_numstr();
			__builtin_memcpy(p, tmp + 1 - (j >= c), len - (j < c));
			p += len - (j < c);

			*(p++) = (i - j)? ' ' : '\n';

			if (p - s + len >= 4096) {
				fwrite(s, 1, p - s, stdout);
				p = s;
			}
		}
	}

	fwrite(s, 1, p - s, stdout);
#else // NO_IT_DOESN'T
	int num;
	for (num = i = 1; i <= n; i++)
		for (j = 1; j <= i; j++)
			printf("%*d%c",	len - (j < c), num++, i - j ? ' ':'\n');
#endif
}

int main(void)
{
	t(5), t(14);

	// maybe not
	// t(10000);
	return 0;
}
`,`#include "floyds-triangle.h"



ulong _t(ulong param_1)

{
  int iVar1;
  uint uVar2;
  int local_20;
  int local_1c;
  int local_18;
  
  iVar1 = (int)param_1;
  for (local_20 = 1; local_20 < (iVar1 * (iVar1 + -1)) / 2; local_20 = local_20 * 10) {
  }
  for (local_18 = 1; local_18 <= iVar1; local_18 = local_18 + 1) {
    for (local_1c = 1; local_1c <= local_18; local_1c = local_1c + 1) {
      uVar2 = _printf("%*d%c");
      param_1 = (ulong)uVar2;
    }
  }
  return param_1;
}



undefined4 entry(void)

{
  _t(5);
  _t(0xe);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
int main(){char*c="#include <stdio.h>%cint main(){char*c=%c%s%c;printf(c,10,34,c,34,10);return 0;}%c";printf(c,10,34,c,34,10);return 0;}
`,`#include "quine-2.h"



undefined4 entry(void)

{
  _printf("#include <stdio.h>%cint main(){char*c=%c%s%c;printf(c,10,34,c,34,10);return 0;}%c");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

int main() {
  puts(getenv("HOME"));
  puts(getenv("PATH"));
  puts(getenv("USER"));
  return 0;
}
`,`#include "environment-variables.h"



undefined4 entry(void)

{
  char *pcVar1;
  
  pcVar1 = _getenv("HOME");
  _puts(pcVar1);
  pcVar1 = _getenv("PATH");
  _puts(pcVar1);
  pcVar1 = _getenv("USER");
  _puts(pcVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _getenv(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__getenv_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <arpa/inet.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef struct ip_address_tag {
    union {
        uint8_t address_v6[16];
        uint32_t address_v4;
    } address;
    uint16_t family;
    uint16_t port;
} ip_address_t;

bool parse_ipv4_address(const char* input, ip_address_t* result) {
    struct in_addr addr;
    if (inet_pton(AF_INET, input, &addr) == 1) {
        result->family = AF_INET;
        result->address.address_v4 = ntohl(addr.s_addr);
        result->port = 0;
        return true;
    }
    return false;
}

bool parse_ipv6_address(const char* input, ip_address_t* result) {
    struct in6_addr addr;
    if (inet_pton(AF_INET6, input, &addr) == 1) {
        result->family = AF_INET6;
        memcpy(result->address.address_v6, addr.s6_addr, 16);
        result->port = 0;
        return true;
    }
    return false;
}

uint16_t parse_port_number(const char* str) {
    char* eptr;
    unsigned long port = strtoul(str, &eptr, 10);
    if (port > 0 && *eptr == '\0' && port <= UINT16_MAX)
        return (uint16_t)port;
    return 0;
}

//
// Parse an IP address and port from the given input string.
// Returns false if the input is not valid.
//
// Valid formats are:
// [ipv6_address]:port
// ipv4_address:port
// ipv4_address
// ipv6_address
//
bool parse_address(const char* input, ip_address_t* result) {
    char* ptr = strrchr(input, ':');
    if (ptr != NULL && ptr > input) {
        uint16_t port = parse_port_number(ptr + 1);
        if (port > 0) {
            bool success = false;
            char* copy = strdup(input);
            if (copy == NULL)
                return false;
            int index = ptr - input;
            copy[index] = '\0';
            if (copy[index - 1] == ']' && copy[0] == '[') {
                copy[index - 1] = '\0';
                if (parse_ipv6_address(copy + 1, result))
                    success = true;
            } else if (parse_ipv4_address(copy, result)) {
                success = true;
            }
            free(copy);
            if (success) {
                result->port = port;
                return true;
            }
        }
    }
    return parse_ipv6_address(input, result)
        || parse_ipv4_address(input, result);
}

void test_parse_address(const char* input) {
    printf("input: %s\n", input);
    ip_address_t result;
    if (parse_address(input, &result)) {
        printf("address family: %s\n",
               result.family == AF_INET ? "IPv4" : "IPv6");
        if (result.family == AF_INET)
            printf("address: %X", result.address.address_v4);
        else if (result.family == AF_INET6) {
            printf("address: ");
            for (int i = 0; i < 16; ++i)
                printf("%02X", (unsigned int)result.address.address_v6[i]);
        }
        printf("\n");
        if (result.port > 0)
            printf("port: %hu\n", result.port);
        else
            printf("port not specified\n");
    } else {
        printf("Parsing failed.\n");
    }
    printf("\n");
}

int main() {
    test_parse_address("127.0.0.1");
    test_parse_address("127.0.0.1:80");
    test_parse_address("::ffff:127.0.0.1");
    test_parse_address("::1");
    test_parse_address("[::1]:80");
    test_parse_address("1::80");
    test_parse_address("2605:2700:0:3::4713:93e3");
    test_parse_address("[2605:2700:0:3::4713:93e3]:80");
    return 0;
}
`,`#include "parse-an-ip-address-3.h"



bool _parse_ipv4_address(char *param_1,undefined4 *param_2)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 local_2c;
  undefined4 *local_28;
  char *local_20;
  
  local_28 = param_2;
  local_20 = param_1;
  iVar1 = _inet_pton(2,param_1,&local_2c);
  if (iVar1 == 1) {
    *(undefined2 *)(local_28 + 4) = 2;
    uVar2 = FUN_1000038c0(local_2c);
    *local_28 = uVar2;
    *(undefined2 *)((long)local_28 + 0x12) = 0;
  }
  return iVar1 == 1;
}



uint FUN_1000038c0(uint param_1)

{
  uint uVar1;
  
  uVar1 = (param_1 & 0xff00ff00) >> 8 | (param_1 & 0xff00ff) << 8;
  return uVar1 >> 0x10 | uVar1 << 0x10;
}



bool _parse_ipv6_address(char *param_1,long param_2)

{
  int iVar1;
  undefined auStack_38 [16];
  long local_28;
  char *local_20;
  
  local_28 = param_2;
  local_20 = param_1;
  iVar1 = _inet_pton(0x1e,param_1,auStack_38);
  if (iVar1 == 1) {
    *(undefined2 *)(local_28 + 0x10) = 0x1e;
    ___memcpy_chk(local_28,auStack_38,0x10,0xffffffffffffffff);
    *(undefined2 *)(local_28 + 0x12) = 0;
  }
  return iVar1 == 1;
}



undefined2 _parse_port_number(char *param_1)

{
  ulong uVar1;
  char *local_28;
  char *local_20;
  undefined2 local_12;
  
  local_20 = param_1;
  uVar1 = _strtoul(param_1,&local_28,10);
  if (((uVar1 == 0) || (*local_28 != '\0')) || (0xffff < uVar1)) {
    local_12 = 0;
  }
  else {
    local_12 = (undefined2)uVar1;
  }
  return local_12;
}



byte _parse_address(char *param_1,long param_2)

{
  short sVar1;
  char *pcVar2;
  char *pcVar3;
  ulong uVar4;
  int iVar5;
  byte local_48;
  
  pcVar2 = _strrchr(param_1,0x3a);
  if (((pcVar2 != (char *)0x0) && (param_1 < pcVar2)) &&
     (sVar1 = _parse_port_number(pcVar2 + 1), sVar1 != 0)) {
    pcVar3 = _strdup(param_1);
    if (pcVar3 == (char *)0x0) {
      return 0;
    }
    iVar5 = (int)pcVar2 - (int)param_1;
    pcVar3[iVar5] = '\0';
    if ((pcVar3[iVar5 + -1] == ']') && (*pcVar3 == '[')) {
      pcVar3[iVar5 + -1] = '\0';
      uVar4 = _parse_ipv6_address(pcVar3 + 1,param_2);
    }
    else {
      uVar4 = _parse_ipv4_address(pcVar3,param_2);
    }
    _free(pcVar3);
    if ((uVar4 & 1) != 0) {
      *(short *)(param_2 + 0x12) = sVar1;
      return 1;
    }
  }
  uVar4 = _parse_ipv6_address(param_1,param_2);
  local_48 = 1;
  if ((uVar4 & 1) == 0) {
    local_48 = _parse_ipv4_address(param_1,param_2);
  }
  return local_48 & 1;
}



void _test_parse_address(undefined8 param_1)

{
  int iVar1;
  ulong uVar2;
  int local_3c;
  undefined local_2c [16];
  short local_1c;
  short local_1a;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  _printf("input: %s\n");
  uVar2 = _parse_address(param_1,local_2c);
  if ((uVar2 & 1) == 0) {
    _printf("Parsing failed.\n");
  }
  else {
    _printf("address family: %s\n");
    if (local_1c == 2) {
      _printf("address: %X");
    }
    else if (local_1c == 0x1e) {
      _printf("address: ");
      for (local_3c = 0; local_3c < 0x10; local_3c = local_3c + 1) {
        _printf("%02X");
      }
    }
    _printf("\n");
    if (local_1a == 0) {
      _printf("port not specified\n");
    }
    else {
      _printf("port: %hu\n");
    }
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined4 entry(void)

{
  _test_parse_address("127.0.0.1");
  _test_parse_address("127.0.0.1:80");
  _test_parse_address("::ffff:127.0.0.1");
  _test_parse_address("::1");
  _test_parse_address("[::1]:80");
  _test_parse_address("1::80");
  _test_parse_address("2605:2700:0:3::4713:93e3");
  _test_parse_address("[2605:2700:0:3::4713:93e3]:80");
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _inet_pton(int param_1,char *param_2,void *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__inet_pton_100004020)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004030)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strrchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strrchr_100004038)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulong _strtoul(char *param_1,char **param_2,int param_3)

{
  ulong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoul_100004040)(param_1,param_2,param_3);
  return uVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char *menu_select(const char *const *items, const char *prompt);

int
main(void)
{
	const char *items[] = {"fee fie", "huff and puff", "mirror mirror", "tick tock", NULL};
	const char *prompt = "Which is from the three pigs?";

	printf("You chose %s.\n", menu_select(items, prompt));

	return EXIT_SUCCESS;
}

const char *
menu_select(const char *const *items, const char *prompt)
{
	char buf[BUFSIZ];
	int i;
	int choice;
	int choice_max;

	if (items == NULL)
		return NULL;

	do {
		for (i = 0; items[i] != NULL; i++) {
			printf("%d) %s\n", i + 1, items[i]);
		}
		choice_max = i;
		if (prompt != NULL)
			printf("%s ", prompt);
		else
			printf("Choice? ");
		if (fgets(buf, sizeof(buf), stdin) != NULL) {
			choice = atoi(buf);
		}
	} while (1 > choice || choice > choice_max);

	return items[choice - 1];
}
`,`#include "menu.h"



undefined8 entry(void)

{
  int iVar1;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&PTR_s_fee_fie_100004038,0x28);
  _menu_select(auStack_40,"Which is from the three pigs?");
  iVar1 = _printf("You chose %s.\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



undefined8 _menu_select(long param_1,long param_2)

{
  char *pcVar1;
  int local_448;
  int local_444;
  undefined8 local_430;
  char acStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  if (param_1 == 0) {
    local_430 = 0;
  }
  else {
    do {
      local_444 = 0;
      while (*(long *)(param_1 + (long)local_444 * 8) != 0) {
        _printf("%d) %s\n");
        local_444 = local_444 + 1;
      }
      if (param_2 == 0) {
        _printf("Choice? ");
      }
      else {
        _printf("%s ");
      }
      pcVar1 = _fgets(acStack_428,0x400,*(FILE **)PTR____stdinp_100004010);
      if (pcVar1 != (char *)0x0) {
        local_448 = _atoi(acStack_428);
      }
    } while (local_448 < 1 || local_444 < local_448);
    local_430 = *(undefined8 *)(param_1 + (long)(local_448 + -1) * 8);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_430;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004020)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h> /* for atoi() and malloc() */
#include <string.h> /* for memmove() */

/* Conveniently print to standard error and exit nonzero. */
#define ERROR(fmt, arg) return fprintf(stderr, fmt "\n", arg)

int main(int argc, char **argv)
{
    FILE *fp;
    char *buf;
    size_t sz;
    int start, count, lines = 1;
    int dest = 0, src = 0, pos = -1;

    /* Initialization and sanity checks */
    if (argc != 4)
        ERROR("Usage: %s <file> <start> <count>", argv[0]);

    if ((count = atoi(argv[3])) < 1) /* We're a no-op. */
        return 0;

    if ((start = atoi(argv[2])) < 1)
        ERROR("Error: <start> (%d) must be positive", start);

    if ((fp = fopen(argv[1], "r")) == NULL)
        ERROR("No such file: %s", argv[1]);

    /* Determine filesize and allocate a buffer accordingly. */
    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    buf = malloc(sz + 1);
    rewind(fp);

    /* Fill the buffer, count lines, and remember a few important offsets. */
    while ((buf[++pos] = fgetc(fp)) != EOF) {
        if (buf[pos] == '\n') {
            ++lines;
            if (lines == start) dest = pos + 1;
            if (lines == start + count) src = pos + 1;
        }
    }

    /* We've been asked to do something weird; clean up and bail. */
    if (start + count > lines) {
        free(buf);
        fclose(fp);
        ERROR("Error: invalid parameters for file with %d lines", --lines);
    }

    /* Overwrite the lines to be deleted with the survivors. */
    memmove(buf + dest, buf + src, pos - src);

    /* Reopen the file and write back just enough of the buffer. */
    freopen(argv[1], "w", fp);
    fwrite(buf, pos - src + dest, 1, fp);

    free(buf);
    fclose(fp);
    return 0;
}
`,`#include "remove-lines-from-a-file.h"



int entry(int param_1,long param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  FILE *pFVar5;
  long lVar6;
  void *pvVar7;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_14;
  
  local_44 = 1;
  local_48 = 0;
  local_4c = 0;
  local_50 = -1;
  if (param_1 == 4) {
    iVar2 = _atoi(*(char **)(param_2 + 0x18));
    if (iVar2 < 1) {
      local_14 = 0;
    }
    else {
      iVar3 = _atoi(*(char **)(param_2 + 0x10));
      if (iVar3 < 1) {
        local_14 = _fprintf(*(FILE **)PTR____stderrp_100004008,
                            "Error: <start> (%d) must be positive\n");
      }
      else {
        pFVar5 = _fopen(*(char **)(param_2 + 8),"r");
        if (pFVar5 == (FILE *)0x0) {
          local_14 = _fprintf(*(FILE **)PTR____stderrp_100004008,"No such file: %s\n");
        }
        else {
          _fseek(pFVar5,0,2);
          lVar6 = _ftell(pFVar5);
          pvVar7 = _malloc(lVar6 + 1);
          _rewind(pFVar5);
          iVar1 = local_50;
          while( true ) {
            local_50 = iVar1;
            iVar4 = _fgetc(pFVar5);
            iVar1 = local_50 + 1;
            *(char *)((long)pvVar7 + (long)iVar1) = (char)iVar4;
            if ((char)iVar4 == -1) break;
            if (*(char *)((long)pvVar7 + (long)iVar1) == '\n') {
              local_44 = local_44 + 1;
              if (local_44 == iVar3) {
                local_48 = local_50 + 2;
              }
              if (local_44 == iVar3 + iVar2) {
                local_4c = local_50 + 2;
              }
            }
          }
          if (local_44 < iVar3 + iVar2) {
            _free(pvVar7);
            _fclose(pFVar5);
            local_14 = _fprintf(*(FILE **)PTR____stderrp_100004008,
                                "Error: invalid parameters for file with %d lines\n");
          }
          else {
            ___memmove_chk((long)pvVar7 + (long)local_48,(long)pvVar7 + (long)local_4c,
                           (long)(iVar1 - local_4c),0xffffffffffffffff);
            _freopen(*(char **)(param_2 + 8),"w",pFVar5);
            _fwrite(pvVar7,(long)((iVar1 - local_4c) + local_48),1,pFVar5);
            _free(pvVar7);
            _fclose(pFVar5);
            local_14 = 0;
          }
        }
      }
    }
  }
  else {
    local_14 = _fprintf(*(FILE **)PTR____stderrp_100004008,"Usage: %s <file> <start> <count>\n");
  }
  return local_14;
}



void ___memmove_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memmove_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004028)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _freopen(char *param_1,char *param_2,FILE *param_3)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__freopen_100004040)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fseek(FILE *param_1,long param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fseek_100004048)((int)param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _ftell(FILE *param_1)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__ftell_100004050)();
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004058)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004060)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _rewind(FILE *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__rewind_100004068)();
  return;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

const char *shades = ".:!*oe&#%@";

void vsub(double *v1, double *v2, double *s) {
	s[0] = v1[0] - v2[0];
	s[1] = v1[1] - v2[1];
	s[2] = v1[2] - v2[2];
}

double normalize(double * v) {
        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        v[0] /= len; v[1] /= len; v[2] /= len;
	return len;
}

double dot(double *x, double *y) {
        return x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
}

double * cross(double x[3], double y[3], double s[3]) {
	s[0] = x[1] * y[2] - x[2] * y[1];
	s[1] = x[2] * y[0] - x[0] * y[2];
	s[2] = x[0] * y[1] - x[1] * y[0];
	return s;
}

double* madd(double *x, double *y, double d, double *r) {
	r[0] = x[0] + y[0] * d;
	r[1] = x[1] + y[1] * d;
	r[2] = x[2] + y[2] * d;
	return r;
}

double v000[] = { -4, -3, -2 };
double v100[] = {  4, -3, -2 };
double v010[] = { -4,  3, -2 };
double v110[] = {  4,  3, -2 };
double v001[] = { -4, -3,  2 };
double v101[] = {  4, -3,  2 };
double v011[] = { -4,  3,  2 };
double v111[] = {  4,  3,  2 };

typedef struct {
	double * v[4];
	double norm[3];
} face_t;

face_t f[] = {
	{ { v000, v010, v110, v100 }, {  0,  0, -1 } },
	{ { v001, v011, v111, v101 }, {  0,  0,  1 } },
	{ { v000, v010, v011, v001 }, { -1,  0,  0 } },
	{ { v100, v110, v111, v101 }, {  1,  0,  0 } },
	{ { v000, v100, v101, v001 }, {  0, -1,  0 } },
	{ { v010, v110, v111, v011 }, {  0,  1,  0 } },
};

int in_range(double x, double x0, double x1) {
	return (x - x0) * (x - x1) <= 0;
}

int face_hit(face_t *face, double src[3], double dir[3], double hit[3], double *d)
{
	int i;
	double dist;
	for (i = 0; i < 3; i++)
		if (face->norm[i])
			dist = (face->v[0][i] - src[i]) / dir[i];

	madd(src, dir, dist, hit);
	*d = fabs(dot(dir, face->norm) * dist);

	if (face->norm[0]) {
		return  in_range(hit[1], face->v[0][1], face->v[2][1]) &&
			in_range(hit[2], face->v[0][2], face->v[2][2]);
	}
	else if (face->norm[1]) {
		return  in_range(hit[0], face->v[0][0], face->v[2][0]) &&
			in_range(hit[2], face->v[0][2], face->v[2][2]);
	}
	else if (face->norm[2]) {
		return  in_range(hit[0], face->v[0][0], face->v[2][0]) &&
			in_range(hit[1], face->v[0][1], face->v[2][1]);
	}
	return 0;
}

int main()
{
	int i, j, k;
	double eye[3] = { 7, 7, 6 };
	double dir[3] = { -1, -1, -1 }, orig[3] = {0, 0, 0};
	double hit[3], dx[3], dy[3] = {0, 0, 1}, proj[3];
	double d, *norm, dbest, b;
	double light[3] = { 6, 8, 6 }, ldist[3], decay, strength = 10;

 	normalize(cross(eye, dy, dx));
	normalize(cross(eye, dx, dy));

	for (i = -10; i <= 17; i++) {
		for (j = -35; j < 35; j++) {
			vsub(orig, orig, proj);
			madd(madd(proj, dx, j / 6., proj), dy, i/3., proj);
			vsub(proj, eye, dir);
			dbest = 1e100;
			norm = 0;
		 	for (k = 0; k < 6; k++) {
				if (!face_hit(f + k, eye, dir, hit, &d)) continue;
				if (dbest > d) {
					dbest = d;
					norm = f[k].norm;
				}
			}

			if (!norm) {
				putchar(' ');
				continue;
			}

			vsub(light, hit, ldist);
			decay = normalize(ldist);
			b = dot(norm, ldist) / decay * strength;
			if (b < 0) b = 0;
			else if (b > 1) b = 1;
			b += .2;
			if (b > 1) b = 0;
			else b = 1 - b;
			putchar(shades[(int)(b * (sizeof(shades) - 2))]);
		}
		putchar('\n');
	}

        return 0;
}
`,`#include "draw-a-cuboid.h"



void _vsub(double *param_1,double *param_2,double *param_3)

{
  *param_3 = *param_1 - *param_2;
  param_3[1] = param_1[1] - param_2[1];
  param_3[2] = param_1[2] - param_2[2];
  return;
}



undefined  [16] _normalize(double *param_1)

{
  double dVar1;
  undefined auVar2 [16];
  undefined8 uVar3;
  
  uVar3 = NEON_fmadd(*param_1,*param_1,param_1[1] * param_1[1]);
  dVar1 = (double)NEON_fmadd(param_1[2],param_1[2],uVar3);
  auVar2._0_8_ = SQRT(dVar1);
  *param_1 = *param_1 / auVar2._0_8_;
  param_1[1] = param_1[1] / auVar2._0_8_;
  param_1[2] = param_1[2] / auVar2._0_8_;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined  [16] _dot(undefined8 *param_1,undefined8 *param_2)

{
  undefined auVar1 [16];
  undefined8 uVar2;
  
  uVar2 = NEON_fmadd(*param_1,*param_2,(double)param_1[1] * (double)param_2[1]);
  auVar1._0_8_ = NEON_fmadd(param_1[2],param_2[2],uVar2);
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined8 * _cross(double *param_1,double *param_2,undefined8 *param_3)

{
  undefined8 uVar1;
  
  uVar1 = NEON_fnmsub(param_1[1],param_2[2],param_1[2] * param_2[1]);
  *param_3 = uVar1;
  uVar1 = NEON_fnmsub(param_1[2],*param_2,*param_1 * param_2[2]);
  param_3[1] = uVar1;
  uVar1 = NEON_fnmsub(*param_1,param_2[1],param_1[1] * *param_2);
  param_3[2] = uVar1;
  return param_3;
}



undefined8 * _madd(undefined8 param_1,undefined8 *param_2,undefined8 *param_3,undefined8 *param_4)

{
  undefined8 uVar1;
  
  uVar1 = NEON_fmadd(*param_3,param_1,*param_2);
  *param_4 = uVar1;
  uVar1 = NEON_fmadd(param_3[1],param_1,param_2[1]);
  param_4[1] = uVar1;
  uVar1 = NEON_fmadd(param_3[2],param_1,param_2[2]);
  param_4[2] = uVar1;
  return param_4;
}



bool _in_range(double param_1,double param_2,double param_3)

{
  return (param_1 - param_2) * (param_1 - param_3) <= 0.0;
}



bool _face_hit(long *param_1,long param_2,long param_3,undefined8 *param_4,double *param_5)

{
  bool bVar1;
  int iVar2;
  double dVar3;
  double local_50;
  int local_44;
  
  for (local_44 = 0; local_44 < 3; local_44 = local_44 + 1) {
    if ((double)param_1[(long)local_44 + 4] != 0.0) {
      local_50 = (*(double *)(*param_1 + (long)local_44 * 8) -
                 *(double *)(param_2 + (long)local_44 * 8)) /
                 *(double *)(param_3 + (long)local_44 * 8);
    }
  }
  _madd(local_50,param_2,param_3,param_4);
  dVar3 = (double)_dot(param_3,param_1 + 4);
  *param_5 = ABS(dVar3 * local_50);
  if ((double)param_1[4] == 0.0) {
    if ((double)param_1[5] == 0.0) {
      if ((double)param_1[6] == 0.0) {
        bVar1 = false;
      }
      else {
        iVar2 = _in_range(*param_4,*(undefined8 *)*param_1,*(undefined8 *)param_1[2]);
        bVar1 = false;
        if (iVar2 != 0) {
          iVar2 = _in_range(param_4[1],*(undefined8 *)(*param_1 + 8),*(undefined8 *)(param_1[2] + 8)
                           );
          bVar1 = iVar2 != 0;
        }
      }
    }
    else {
      iVar2 = _in_range(*param_4,*(undefined8 *)*param_1,*(undefined8 *)param_1[2]);
      bVar1 = false;
      if (iVar2 != 0) {
        iVar2 = _in_range(param_4[2],*(undefined8 *)(*param_1 + 0x10),
                          *(undefined8 *)(param_1[2] + 0x10));
        bVar1 = iVar2 != 0;
      }
    }
  }
  else {
    iVar2 = _in_range(param_4[1],*(undefined8 *)(*param_1 + 8),*(undefined8 *)(param_1[2] + 8));
    bVar1 = false;
    if (iVar2 != 0) {
      iVar2 = _in_range(param_4[2],*(undefined8 *)(*param_1 + 0x10),
                        *(undefined8 *)(param_1[2] + 0x10));
      bVar1 = iVar2 != 0;
    }
  }
  return bVar1;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  undefined8 uVar4;
  double dVar5;
  double dVar6;
  double local_138;
  double local_130;
  long local_128;
  double local_120;
  int local_118;
  int local_114;
  int local_110;
  undefined4 local_10c;
  undefined auStack_108 [24];
  undefined8 local_f0;
  undefined8 uStack_e8;
  undefined8 local_e0;
  undefined auStack_d8 [24];
  undefined8 local_c0;
  undefined8 uStack_b8;
  undefined8 local_b0;
  undefined auStack_a8 [24];
  undefined auStack_90 [24];
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 uStack_58;
  undefined8 local_50;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_10c = 0;
  uStack_38 = 0x401c000000000000;
  local_40 = 0x401c000000000000;
  local_30 = 0x4018000000000000;
  uStack_58 = 0xbff0000000000000;
  local_60 = 0xbff0000000000000;
  local_50 = 0xbff0000000000000;
  local_78 = 0;
  local_70 = 0;
  local_68 = 0;
  uStack_b8 = 0;
  local_c0 = 0;
  local_b0 = 0x3ff0000000000000;
  uStack_e8 = 0x4020000000000000;
  local_f0 = 0x4018000000000000;
  local_e0 = 0x4018000000000000;
  _cross();
  _normalize();
  _cross(&local_40,auStack_a8,&local_c0);
  uVar3 = _normalize();
  for (local_110 = -10; local_110 < 0x12; local_110 = local_110 + 1) {
    for (local_114 = -0x23; local_114 < 0x23; local_114 = local_114 + 1) {
      _vsub(&local_78);
      uVar4 = _madd((double)(long)local_114 / 6.0,auStack_d8,auStack_a8);
      _madd((double)(long)local_110 / 3.0,uVar4,&local_c0,auStack_d8);
      _vsub(auStack_d8,&local_40,&local_60);
      local_130 = 1e+100;
      local_128 = 0;
      for (local_118 = 0; local_118 < 6; local_118 = local_118 + 1) {
        iVar1 = _face_hit(&_f + (long)local_118 * 7,&local_40,&local_60,auStack_90,&local_120);
        if ((iVar1 != 0) && (local_120 < local_130)) {
          local_130 = local_120;
          local_128 = (long)local_118 * 0x38 + 0x1000080e8;
        }
      }
      if (local_128 == 0) {
        _putchar(0x20);
      }
      else {
        _vsub(&local_f0,auStack_90);
        dVar5 = (double)_normalize(auStack_108);
        dVar6 = (double)_dot(local_128,auStack_108);
        local_138 = (dVar6 / dVar5) * 10.0;
        if (0.0 <= local_138) {
          if (1.0 < local_138) {
            local_138 = 1.0;
          }
        }
        else {
          local_138 = 0.0;
        }
        if (local_138 + 0.2 <= 1.0) {
          local_138 = 1.0 - (local_138 + 0.2);
        }
        else {
          local_138 = 0.0;
        }
        _putchar((int)(char)_shades[(int)(local_138 * 6.0)]);
      }
    }
    uVar2 = _putchar(10);
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar3);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#define D_INVALID -1
#define D_UP       1
#define D_DOWN     2
#define D_RIGHT    3
#define D_LEFT     4

const long values[] = {
    0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
};

const char *colors[] = {
    "39", "31", "32", "33", "34", "35", "36", "37", "91", "92", "93", "94"
};

struct gamestate_struct__ {
    int grid[4][4];
    int have_moved;
    long total_score;
    long score_last_move;
    int blocks_in_play;
} game;

struct termios oldt, newt;

void do_draw(void)
{
    printf("\033[2J\033[HScore: %ld", game.total_score);
    if (game.score_last_move)
        printf(" (+%ld)", game.score_last_move);
    printf("\n");

    for (int i = 0; i < 25; ++i)
        printf("-");
    printf("\n");

    for (int y = 0; y < 4; ++y) {
        printf("|");
        for (int x = 0; x < 4; ++x) {
            if (game.grid[x][y])
                printf("\033[7m\033[%sm%*zd \033[0m|", colors[game.grid[x][y]],
                        4, values[game.grid[x][y]]);
            else
                printf("%*s |", 4, "");
        }
        printf("\n");
    }

    for (int i = 0; i < 25; ++i) {
        printf("-");
    }
    printf("\n");
}

void do_merge(int d)
{
/* These macros look pretty scary, but mainly demonstrate some space saving */
#define MERGE_DIRECTION(_v1, _v2, _xs, _xc, _xi, _ys, _yc, _yi, _x, _y)     \
    do {                                                                    \
        for (int _v1 = _xs; _v1 _xc; _v1 += _xi) {                          \
            for (int _v2 = _ys; _v2 _yc; _v2 += _yi) {                      \
                if (game.grid[x][y] && (game.grid[x][y] ==                  \
                                    game.grid[x + _x][y + _y])) {           \
                    game.grid[x][y] += (game.have_moved = 1);               \
                    game.grid[x + _x][y + _y] = (0 * game.blocks_in_play--);\
                    game.score_last_move += values[game.grid[x][y]];        \
                    game.total_score += values[game.grid[x][y]];            \
                }                                                           \
            }                                                               \
        }                                                                   \
    } while (0)

    game.score_last_move = 0;

    switch (d) {
        case D_LEFT:
            MERGE_DIRECTION(x, y, 0, < 3, 1, 0, < 4, 1, 1, 0);
            break;
        case D_RIGHT:
            MERGE_DIRECTION(x, y, 3, > 0, -1, 0, < 4, 1, -1, 0);
            break;
        case D_DOWN:
            MERGE_DIRECTION(y, x, 3, > 0, -1, 0, < 4, 1, 0, -1);
            break;
        case D_UP:
            MERGE_DIRECTION(y, x, 0, < 3, 1, 0, < 4, 1, 0, 1);
            break;
    }

#undef MERGE_DIRECTION
}

void do_gravity(int d)
{
#define GRAVITATE_DIRECTION(_v1, _v2, _xs, _xc, _xi, _ys, _yc, _yi, _x, _y) \
    do {                                                                    \
        int break_cond = 0;                                                 \
        while (!break_cond) {                                               \
            break_cond = 1;                                                 \
            for (int _v1 = _xs; _v1 _xc; _v1 += _xi) {                      \
                for (int _v2 = _ys; _v2 _yc; _v2 += _yi) {                  \
                    if (!game.grid[x][y] && game.grid[x + _x][y + _y]) {    \
                        game.grid[x][y] = game.grid[x + _x][y + _y];        \
                        game.grid[x + _x][y + _y] = break_cond = 0;         \
                        game.have_moved = 1;                                \
                    }                                                       \
                }                                                           \
            }                                                               \
            do_draw(); usleep(40000);                                       \
        }                                                                   \
    } while (0)

    switch (d) {
        case D_LEFT:
            GRAVITATE_DIRECTION(x, y, 0, < 3, 1, 0, < 4, 1, 1, 0);
            break;
        case D_RIGHT:
            GRAVITATE_DIRECTION(x, y, 3, > 0, -1, 0, < 4, 1, -1, 0);
            break;
        case D_DOWN:
            GRAVITATE_DIRECTION(y, x, 3, > 0, -1, 0, < 4, 1, 0, -1);
            break;
        case D_UP:
            GRAVITATE_DIRECTION(y, x, 0, < 3, 1, 0, < 4, 1, 0, 1);
            break;
    }

#undef GRAVITATE_DIRECTION
}

int do_check_end_condition(void)
{
    int ret = -1;
    for (int x = 0; x < 4; ++x) {
        for (int y = 0; y < 4; ++y) {
            if (values[game.grid[x][y]] == 2048)
                return 1;
            if (!game.grid[x][y] ||
                  ((x + 1 < 4) && (game.grid[x][y] == game.grid[x + 1][y])) ||
                  ((y + 1 < 4) && (game.grid[x][y] == game.grid[x][y + 1])))
                ret = 0;
        }
    }
    return ret;
}

int do_tick(int d)
{
    game.have_moved = 0;
    do_gravity(d);
    do_merge(d);
    do_gravity(d);
    return game.have_moved;
}

void do_newblock(void) {
    if (game.blocks_in_play >= 16) return;

    int bn = rand() % (16 - game.blocks_in_play);
    int pn = 0;

    for (int x = 0; x < 4; ++x) {
        for (int y = 0; y < 4; ++y) {
            if (game.grid[x][y])
                continue;

            if (pn == bn){
                game.grid[x][y] = rand() % 10 ? 1 : 2;
                game.blocks_in_play += 1;
                return;
            }
            else {
                ++pn;
            }
        }
    }
}

int main(void)
{
    /* Initialize terminal settings */
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);

    srand(time(NULL));
    memset(&game, 0, sizeof(game));
    do_newblock();
    do_newblock();
    do_draw();

    while (1) {
        int found_valid_key, direction, value;
        do {
            found_valid_key = 1;
            direction       = D_INVALID;
            value           = getchar();
            switch (value) {
                case 'h': case 'a':
                    direction = D_LEFT;
                    break;
                case 'l': case 'd':
                    direction = D_RIGHT;
                    break;
                case 'j': case 's':
                    direction = D_DOWN;
                    break;
                case 'k': case 'w':
                    direction = D_UP;
                    break;
                case 'q':
                    goto game_quit;
                    break;
                case 27:
                    if (getchar() == 91) {
                        value = getchar();
                        switch (value) {
                            case 65:
                                direction = D_UP;
                                break;
                            case 66:
                                direction = D_DOWN;
                                break;
                            case 67:
                                direction = D_RIGHT;
                                break;
                            case 68:
                                direction = D_LEFT;
                                break;
                            default:
                                found_valid_key = 0;
                                break;
                        }
                    }
                    break;
                default:
                    found_valid_key = 0;
                    break;
            }
        }  while (!found_valid_key);

        do_tick(direction);
        if (game.have_moved != 0){
                do_newblock();
        }
        do_draw();

        switch (do_check_end_condition()) {
            case -1:
                goto game_lose;
            case 1:
                goto game_win;
            case 0:
                break;
        }
    }

    if (0)
game_lose:
    printf("You lose!\n");
    goto game_quit;
    if (0)
game_win:
    printf("You win!\n");
    goto game_quit;
    if (0)
game_quit:

    /* Restore terminal settings */
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return 0;
}
`,`#include "2048-1.h"



int _do_draw(void)

{
  int iVar1;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  
  _printf("\x1b[2J\x1b[HScore: %ld");
  if (DAT_1000080b0 != 0) {
    _printf(" (+%ld)");
  }
  _printf("\n");
  for (local_14 = 0; local_14 < 0x19; local_14 = local_14 + 1) {
    _printf("-");
  }
  _printf("\n");
  for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
    _printf("|");
    for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
      if (*(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) == 0) {
        _printf("%*s |");
      }
      else {
        _printf("\x1b[7m\x1b[%sm%*zd \x1b[0m|");
      }
    }
    _printf("\n");
  }
  for (local_20 = 0; local_20 < 0x19; local_20 = local_20 + 1) {
    _printf("-");
  }
  iVar1 = _printf("\n");
  return iVar1;
}



void _do_merge(undefined4 param_1)

{
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  int local_8;
  
  DAT_1000080b0 = 0;
  switch(param_1) {
  case 1:
    for (local_20 = 0; local_20 < 3; local_20 = local_20 + 1) {
      for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
        if ((*(int *)(&_game + (long)local_20 * 4 + (long)local_24 * 0x10) != 0) &&
           (*(int *)(&_game + (long)local_20 * 4 + (long)local_24 * 0x10) ==
            *(int *)(&_game + (long)(local_20 + 1) * 4 + (long)local_24 * 0x10))) {
          DAT_1000080a0 = 1;
          *(int *)(&_game + (long)local_20 * 4 + (long)local_24 * 0x10) =
               *(int *)(&_game + (long)local_20 * 4 + (long)local_24 * 0x10) + 1;
          DAT_1000080b8 = DAT_1000080b8 + -1;
          *(undefined4 *)(&_game + (long)(local_20 + 1) * 4 + (long)local_24 * 0x10) = 0;
          DAT_1000080b0 =
               DAT_1000080b0 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_20 * 4 + (long)local_24 * 0x10) * 8);
          DAT_1000080a8 =
               DAT_1000080a8 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_20 * 4 + (long)local_24 * 0x10) * 8);
        }
      }
    }
    break;
  case 2:
    for (local_18 = 3; 0 < local_18; local_18 = local_18 + -1) {
      for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
        if ((*(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) != 0) &&
           (*(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) ==
            *(int *)(&_game + (long)(local_18 + -1) * 4 + (long)local_1c * 0x10))) {
          DAT_1000080a0 = 1;
          *(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) =
               *(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) + 1;
          DAT_1000080b8 = DAT_1000080b8 + -1;
          *(undefined4 *)(&_game + (long)(local_18 + -1) * 4 + (long)local_1c * 0x10) = 0;
          DAT_1000080b0 =
               DAT_1000080b0 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) * 8);
          DAT_1000080a8 =
               DAT_1000080a8 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_18 * 4 + (long)local_1c * 0x10) * 8);
        }
      }
    }
    break;
  case 3:
    for (local_10 = 3; 0 < local_10; local_10 = local_10 + -1) {
      for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {
        if ((*(int *)(&_game + (long)local_14 * 4 + (long)local_10 * 0x10) != 0) &&
           (*(int *)(&_game + (long)local_14 * 4 + (long)local_10 * 0x10) ==
            *(int *)(&_game + (long)local_14 * 4 + (long)(local_10 + -1) * 0x10))) {
          DAT_1000080a0 = 1;
          *(int *)(&_game + (long)local_14 * 4 + (long)local_10 * 0x10) =
               *(int *)(&_game + (long)local_14 * 4 + (long)local_10 * 0x10) + 1;
          DAT_1000080b8 = DAT_1000080b8 + -1;
          *(undefined4 *)(&_game + (long)local_14 * 4 + (long)(local_10 + -1) * 0x10) = 0;
          DAT_1000080b0 =
               DAT_1000080b0 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_14 * 4 + (long)local_10 * 0x10) * 8);
          DAT_1000080a8 =
               DAT_1000080a8 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_14 * 4 + (long)local_10 * 0x10) * 8);
        }
      }
    }
    break;
  case 4:
    for (local_8 = 0; local_8 < 3; local_8 = local_8 + 1) {
      for (local_c = 0; local_c < 4; local_c = local_c + 1) {
        if ((*(int *)(&_game + (long)local_c * 4 + (long)local_8 * 0x10) != 0) &&
           (*(int *)(&_game + (long)local_c * 4 + (long)local_8 * 0x10) ==
            *(int *)(&_game + (long)local_c * 4 + (long)(local_8 + 1) * 0x10))) {
          DAT_1000080a0 = 1;
          *(int *)(&_game + (long)local_c * 4 + (long)local_8 * 0x10) =
               *(int *)(&_game + (long)local_c * 4 + (long)local_8 * 0x10) + 1;
          DAT_1000080b8 = DAT_1000080b8 + -1;
          *(undefined4 *)(&_game + (long)local_c * 4 + (long)(local_8 + 1) * 0x10) = 0;
          DAT_1000080b0 =
               DAT_1000080b0 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_c * 4 + (long)local_8 * 0x10) * 8);
          DAT_1000080a8 =
               DAT_1000080a8 +
               *(long *)(&_values +
                        (long)*(int *)(&_game + (long)local_c * 4 + (long)local_8 * 0x10) * 8);
        }
      }
    }
  }
  return;
}



void _do_gravity(ulong param_1)

{
  bool bVar1;
  uint uVar2;
  int local_44;
  int local_40;
  int local_38;
  int local_34;
  int local_2c;
  int local_28;
  int local_20;
  int local_1c;
  
  switch((int)param_1) {
  case 1:
    bVar1 = false;
    while (!bVar1) {
      bVar1 = true;
      for (local_40 = 0; local_40 < 3; local_40 = local_40 + 1) {
        for (local_44 = 0; local_44 < 4; local_44 = local_44 + 1) {
          if ((*(int *)(&_game + (long)local_40 * 4 + (long)local_44 * 0x10) == 0) &&
             (*(int *)(&_game + (long)(local_40 + 1) * 4 + (long)local_44 * 0x10) != 0)) {
            *(undefined4 *)(&_game + (long)local_40 * 4 + (long)local_44 * 0x10) =
                 *(undefined4 *)(&_game + (long)(local_40 + 1) * 4 + (long)local_44 * 0x10);
            bVar1 = false;
            *(undefined4 *)(&_game + (long)(local_40 + 1) * 4 + (long)local_44 * 0x10) = 0;
            DAT_1000080a0 = 1;
          }
        }
      }
      _do_draw(param_1);
      uVar2 = _usleep(40000);
      param_1 = (ulong)uVar2;
    }
    break;
  case 2:
    bVar1 = false;
    while (!bVar1) {
      bVar1 = true;
      for (local_34 = 3; 0 < local_34; local_34 = local_34 + -1) {
        for (local_38 = 0; local_38 < 4; local_38 = local_38 + 1) {
          if ((*(int *)(&_game + (long)local_34 * 4 + (long)local_38 * 0x10) == 0) &&
             (*(int *)(&_game + (long)(local_34 + -1) * 4 + (long)local_38 * 0x10) != 0)) {
            *(undefined4 *)(&_game + (long)local_34 * 4 + (long)local_38 * 0x10) =
                 *(undefined4 *)(&_game + (long)(local_34 + -1) * 4 + (long)local_38 * 0x10);
            bVar1 = false;
            *(undefined4 *)(&_game + (long)(local_34 + -1) * 4 + (long)local_38 * 0x10) = 0;
            DAT_1000080a0 = 1;
          }
        }
      }
      _do_draw(param_1);
      uVar2 = _usleep(40000);
      param_1 = (ulong)uVar2;
    }
    break;
  case 3:
    bVar1 = false;
    while (!bVar1) {
      bVar1 = true;
      for (local_28 = 3; 0 < local_28; local_28 = local_28 + -1) {
        for (local_2c = 0; local_2c < 4; local_2c = local_2c + 1) {
          if ((*(int *)(&_game + (long)local_2c * 4 + (long)local_28 * 0x10) == 0) &&
             (*(int *)(&_game + (long)local_2c * 4 + (long)(local_28 + -1) * 0x10) != 0)) {
            *(undefined4 *)(&_game + (long)local_2c * 4 + (long)local_28 * 0x10) =
                 *(undefined4 *)(&_game + (long)local_2c * 4 + (long)(local_28 + -1) * 0x10);
            bVar1 = false;
            *(undefined4 *)(&_game + (long)local_2c * 4 + (long)(local_28 + -1) * 0x10) = 0;
            DAT_1000080a0 = 1;
          }
        }
      }
      _do_draw(param_1);
      uVar2 = _usleep(40000);
      param_1 = (ulong)uVar2;
    }
    break;
  case 4:
    bVar1 = false;
    while (!bVar1) {
      bVar1 = true;
      for (local_1c = 0; local_1c < 3; local_1c = local_1c + 1) {
        for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
          if ((*(int *)(&_game + (long)local_20 * 4 + (long)local_1c * 0x10) == 0) &&
             (*(int *)(&_game + (long)local_20 * 4 + (long)(local_1c + 1) * 0x10) != 0)) {
            *(undefined4 *)(&_game + (long)local_20 * 4 + (long)local_1c * 0x10) =
                 *(undefined4 *)(&_game + (long)local_20 * 4 + (long)(local_1c + 1) * 0x10);
            bVar1 = false;
            *(undefined4 *)(&_game + (long)local_20 * 4 + (long)(local_1c + 1) * 0x10) = 0;
            DAT_1000080a0 = 1;
          }
        }
      }
      _do_draw(param_1);
      uVar2 = _usleep(40000);
      param_1 = (ulong)uVar2;
    }
  }
  return;
}



undefined4 _do_check_end_condition(void)

{
  int local_10;
  int local_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  local_c = 0;
  do {
    if (3 < local_c) {
      return local_8;
    }
    for (local_10 = 0; local_10 < 4; local_10 = local_10 + 1) {
      if (*(long *)(&_values +
                   (long)*(int *)(&_game + (long)local_10 * 4 + (long)local_c * 0x10) * 8) == 0x800)
      {
        return 1;
      }
      if (((*(int *)(&_game + (long)local_10 * 4 + (long)local_c * 0x10) == 0) ||
          ((local_c + 1 < 4 &&
           (*(int *)(&_game + (long)local_10 * 4 + (long)local_c * 0x10) ==
            *(int *)(&_game + (long)local_10 * 4 + (long)(local_c + 1) * 0x10))))) ||
         ((local_10 + 1 < 4 &&
          (*(int *)(&_game + (long)local_10 * 4 + (long)local_c * 0x10) ==
           *(int *)(&_game + (long)(local_10 + 1) * 4 + (long)local_c * 0x10))))) {
        local_8 = 0;
      }
    }
    local_c = local_c + 1;
  } while( true );
}



undefined4 _do_tick(undefined4 param_1)

{
  DAT_1000080a0 = 0;
  _do_gravity(param_1);
  _do_merge(param_1);
  _do_gravity(param_1);
  return DAT_1000080a0;
}



void _do_newblock(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  int local_20;
  int local_1c;
  int local_18;
  
  if (DAT_1000080b8 < 0x10) {
    iVar2 = _rand();
    iVar1 = 0x10 - DAT_1000080b8;
    iVar3 = 0;
    if (iVar1 != 0) {
      iVar3 = iVar2 / iVar1;
    }
    local_18 = 0;
    for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
      for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
        if (*(int *)(&_game + (long)local_20 * 4 + (long)local_1c * 0x10) == 0) {
          if (local_18 == iVar2 - iVar3 * iVar1) {
            iVar3 = _rand();
            uVar4 = 2;
            if (iVar3 % 10 != 0) {
              uVar4 = 1;
            }
            *(undefined4 *)(&_game + (long)local_20 * 4 + (long)local_1c * 0x10) = uVar4;
            DAT_1000080b8 = DAT_1000080b8 + 1;
            return;
          }
          local_18 = local_18 + 1;
        }
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  time_t tVar3;
  undefined4 local_1c;
  
  _tcgetattr(0,(termios *)&_oldt);
  _memcpy(&_newt,&_oldt,0x48);
  DAT_1000080d8 = DAT_1000080d8 & 0xfffffffffffffef7;
  _tcsetattr(0,0,(termios *)&_newt);
  tVar3 = _time((time_t *)0x0);
  _srand((uint)tVar3);
  _memset(&_game,0,0x60);
  _do_newblock();
  _do_newblock();
  _do_draw();
  while( true ) {
    do {
      bVar1 = true;
      local_1c = 0xffffffff;
      iVar2 = _getchar();
      switch(iVar2) {
      case 0x1b:
        iVar2 = _getchar();
        if (iVar2 == 0x5b) {
          iVar2 = _getchar();
          switch(iVar2) {
          case 0x41:
            local_1c = 1;
            break;
          case 0x42:
            local_1c = 2;
            break;
          case 0x43:
            local_1c = 3;
            break;
          case 0x44:
            local_1c = 4;
            break;
          default:
            bVar1 = false;
          }
        }
        break;
      default:
        bVar1 = false;
        break;
      case 0x61:
      case 0x68:
        local_1c = 4;
        break;
      case 100:
      case 0x6c:
        local_1c = 3;
        break;
      case 0x6a:
      case 0x73:
        local_1c = 2;
        break;
      case 0x6b:
      case 0x77:
        local_1c = 1;
        break;
      case 0x71:
        goto LAB_100003c84;
      }
    } while (!bVar1);
    _do_tick(local_1c);
    if (DAT_1000080a0 != 0) {
      _do_newblock();
    }
    _do_draw();
    iVar2 = _do_check_end_condition();
    if (iVar2 == -1) break;
    if ((iVar2 != 0) && (iVar2 == 1)) {
      _printf("You win!\n");
LAB_100003c84:
      _tcsetattr(0,0,(termios *)&_oldt);
      return 0;
    }
  }
  _printf("You lose!\n");
  goto LAB_100003c84;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004000)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004010)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcgetattr(int param_1,termios *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcgetattr_100004030)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcsetattr(int param_1,int param_2,termios *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcsetattr_100004038)(param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004040)();
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004048)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>

void set_mode(int want_key)
{
	static struct termios old, new;
	if (!want_key) {
		tcsetattr(STDIN_FILENO, TCSANOW, &old);
		return;
	}

	tcgetattr(STDIN_FILENO, &old);
	new = old;
	new.c_lflag &= ~(ICANON);
	tcsetattr(STDIN_FILENO, TCSANOW, &new);
}

int get_key(int no_timeout)
{
	int c = 0;
	struct timeval tv;
	fd_set fs;
	tv.tv_usec = tv.tv_sec = 0;

	FD_ZERO(&fs);
	FD_SET(STDIN_FILENO, &fs);

	select(STDIN_FILENO + 1, &fs, 0, 0, no_timeout ? 0 : &tv);
	if (FD_ISSET(STDIN_FILENO, &fs)) {
		c = getchar();
		set_mode(0);
	}
	return c;
}

int main()
{
	int c;
	while(1) {
		set_mode(1);
		while (get_key(0)); /* clear buffer */
		printf("Prompt again [Y/N]? ");
		fflush(stdout);

		c = get_key(1);
		if (c == 'Y' || c == 'y') {
			printf("\n");
			continue;
		}

		if (c == 'N' || c == 'n') {
			printf("\nDone\n");
			break;
		}

		printf("\nYes or no?\n");
	}

	return 0;
}
`,`#include "keyboard-input-obtain-a-y-or-n-response.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _set_mode(int param_1)

{
  int iVar1;
  
  if (param_1 == 0) {
    iVar1 = _tcsetattr(0,0,(termios *)0x100008000);
  }
  else {
    _tcgetattr(0,(termios *)0x100008000);
    _memcpy((void *)0x100008048,(void *)0x100008000,0x48);
    _DAT_100008060 = _DAT_100008060 & 0xfffffffffffffeff;
    iVar1 = _tcsetattr(0,0,(termios *)0x100008048);
  }
  return iVar1;
}



int _get_key(int param_1)

{
  bool bVar1;
  timeval *local_110;
  fd_set afStack_f8 [32];
  timeval local_78;
  int local_68;
  int local_64;
  fd_set *local_60;
  int local_54;
  fd_set *local_50;
  int local_48;
  uint local_44;
  fd_set *local_40;
  undefined4 local_38;
  int local_34;
  fd_set *local_30;
  undefined4 local_28;
  int local_24;
  
  bVar1 = PTR____darwin_check_fd_set_overflow_100004000 == (undefined *)0x0;
  local_68 = 0;
  local_78.tv_sec = 0;
  local_78.tv_usec = 0;
  local_64 = param_1;
  _memset(afStack_f8,0,0x80);
  local_54 = 0;
  local_28 = 0;
  local_60 = afStack_f8;
  local_30 = afStack_f8;
  if (bVar1) {
    local_24 = 1;
  }
  else {
    local_24 = ___darwin_check_fd_set_overflow(0,afStack_f8,0);
  }
  if (local_24 != 0) {
    *(uint *)(local_60 + (ulong)(long)local_54 / 0x20) =
         *(uint *)(local_60 + (ulong)(long)local_54 / 0x20) |
         (uint)(1L << (ulong)(long)local_54 % 0x20);
  }
  if (local_64 == 0) {
    local_110 = &local_78;
  }
  else {
    local_110 = (timeval *)0x0;
  }
  _select(1,afStack_f8,(fd_set *)0x0,(fd_set *)0x0,local_110);
  local_48 = 0;
  local_38 = 0;
  local_50 = afStack_f8;
  local_40 = afStack_f8;
  if (bVar1) {
    local_34 = 1;
  }
  else {
    local_34 = ___darwin_check_fd_set_overflow(0,afStack_f8,0);
  }
  if (local_34 == 0) {
    local_44 = 0;
  }
  else {
    local_44 = *(uint *)(local_50 + (ulong)(long)local_48 / 0x20) &
               (uint)(1L << (ulong)(long)local_48 % 0x20);
  }
  if (local_44 != 0) {
    local_68 = _getchar();
    _set_mode(0);
  }
  return local_68;
}



undefined8 entry(void)

{
  int iVar1;
  
  while( true ) {
    while( true ) {
      _set_mode(1);
      do {
        iVar1 = _get_key(0);
      } while (iVar1 != 0);
      _printf("Prompt again [Y/N]? ");
      _fflush(*(FILE **)PTR____stdoutp_100004008);
      iVar1 = _get_key(1);
      if ((iVar1 != 0x59) && (iVar1 != 0x79)) break;
      _printf("\n");
    }
    if ((iVar1 == 0x4e) || (iVar1 == 0x6e)) break;
    _printf("\nYes or no?\n");
  }
  _printf("\nDone\n");
  return 0;
}



void ___darwin_check_fd_set_overflow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____darwin_check_fd_set_overflow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004028)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _select(int param_1,fd_set *param_2,fd_set *param_3,fd_set *param_4,timeval *param_5)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__select_100004038)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcgetattr(int param_1,termios *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcgetattr_100004040)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcsetattr(int param_1,int param_2,termios *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcsetattr_100004048)(param_1,param_2);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

#define PICKVALUE(TXT, VM) do {			\
    printf("%s: ", TXT);			\
    scanf("%lf", &VM);				\
  } while(0);

#if !defined(M_PI)
#define M_PI 3.14159265358979323846
#endif

#define DR(X) ((X)*M_PI/180.0)
#define RD(X) ((X)*180.0/M_PI)

int main()
{
  double lat, slat, lng, ref;
  int h;

  PICKVALUE("Enter latitude", lat);
  PICKVALUE("Enter longitude", lng);
  PICKVALUE("Enter legal meridian", ref);
  printf("\n");

  slat = sin(DR(lat));
  printf("sine of latitude: %.3f\n", slat);
  printf("diff longitude: %.3f\n\n", lng - ref);

  printf("Hour, sun hour angle, dial hour line angle from 6am to 6pm\n");

  for(h = -6; h <= 6; h++)
  {
    double hla, hra;
    hra = 15.0*h;
    hra = hra - lng + ref;
    hla = RD(atan(slat * tan(DR(hra))));
    printf("HR= %3d;  \t  HRA=%7.3f;  \t  HLA= %7.3f\n",
	   h, hra, hla);
  }

  return 0;
}
`,`#include "horizontal-sundial-calculations.h"



undefined8 entry(void)

{
  int iVar1;
  double dVar2;
  double dVar3;
  int local_3c;
  double local_38;
  double local_30;
  double local_20;
  
  _printf("%s: ");
  _scanf("%lf");
  _printf("%s: ");
  _scanf("%lf");
  _printf("%s: ");
  _scanf("%lf");
  iVar1 = _printf("\n");
  dVar2 = (double)_sin((local_20 * 3.141592653589793) / 180.0,iVar1);
  _printf("sine of latitude: %.3f\n");
  _printf("diff longitude: %.3f\n\n");
  iVar1 = _printf("Hour, sun hour angle, dial hour line angle from 6am to 6pm\n");
  for (local_3c = -6; local_3c < 7; local_3c = local_3c + 1) {
    dVar3 = (double)_tan(((((double)(long)local_3c * 15.0 - local_30) + local_38) *
                         3.141592653589793) / 180.0,iVar1);
    _atan(dVar2 * dVar3);
    iVar1 = _printf("HR= %3d;  \t  HRA=%7.3f;  \t  HLA= %7.3f\n");
  }
  return 0;
}



void _atan(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004010)((int)param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004018)();
  return;
}



void _tan(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__tan_100004020)();
  return;
}


`
`#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <err.h>
#include <string.h>

int main()
{
    struct stat s;
    int fd = open("mlijobs.txt", O_RDONLY);
    int cnt, max_cnt, occur;
    char *buf, *ptr;

    if (fd == -1) err(1, "open");
    fstat(fd, &s);
    ptr = buf = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);

    cnt = max_cnt = 0;
    while(ptr - buf < s.st_size - 33) {
        if (!strncmp(ptr, "License OUT", 11) && ++cnt >= max_cnt) {
            if (cnt > max_cnt) {
                max_cnt = cnt;
                occur = 0;
            }
            /* can't sprintf time stamp: might overlap */
            memmove(buf + 26 * occur, ptr + 14, 19);
            sprintf(buf + 26 * occur + 19, "%6d\n", cnt);
            occur++;
        } else if (!strncmp(ptr, "License IN ", 11)) cnt --;

        while (ptr < buf + s.st_size && *ptr++ != '\n');
    }

    printf(buf);
    munmap(buf, s.st_size);
    return close(fd);
}
`,`#include "text-processing-max-licenses-in-use-2.h"



int entry(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  char *pcVar4;
  char *local_c8;
  int local_b8;
  int local_b4;
  int local_b0;
  stat sStack_a8;
  undefined4 local_14;
  
  local_14 = 0;
  iVar2 = _open("mlijobs.txt",0);
  if (iVar2 == -1) {
    _err(1,"open");
  }
  _fstat(iVar2,&sStack_a8);
  pcVar4 = (char *)_mmap(0,sStack_a8.st_size,3,2,iVar2,0);
  local_b4 = 0;
  local_b0 = 0;
  local_c8 = pcVar4;
  while ((long)local_c8 - (long)pcVar4 < sStack_a8.st_size + -0x21) {
    iVar3 = _strncmp(local_c8,"License OUT",0xb);
    if ((iVar3 == 0) && (local_b0 = local_b0 + 1, local_b4 <= local_b0)) {
      if (local_b4 < local_b0) {
        local_b8 = 0;
        local_b4 = local_b0;
      }
      ___memmove_chk(pcVar4 + local_b8 * 0x1a,local_c8 + 0xe,0x13);
      ___sprintf_chk(pcVar4 + (long)(local_b8 * 0x1a) + 0x13,0,0xffffffffffffffff,"%6d\n");
      local_b8 = local_b8 + 1;
    }
    else {
      iVar3 = _strncmp(local_c8,"License IN ",0xb);
      if (iVar3 == 0) {
        local_b0 = local_b0 + -1;
      }
    }
    do {
      bVar1 = false;
      if (local_c8 < pcVar4 + sStack_a8.st_size) {
        bVar1 = *local_c8 != '\n';
        local_c8 = local_c8 + 1;
      }
    } while (bVar1);
  }
  _printf(pcVar4);
  _munmap(pcVar4,sStack_a8.st_size);
  iVar2 = _close(iVar2);
  return iVar2;
}



void ___memmove_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memmove_chk_100004000)();
  return;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004010)(param_1);
  return iVar1;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004020)(param_1);
  return iVar1;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004028)();
  return;
}



void _munmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__munmap_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004038)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strncmp(char *param_1,char *param_2,size_t param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strncmp_100004048)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

char input[] =
	"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\n"
	"dw01             ieee dw01 dware gtech\n"
	"dw02             ieee dw02 dware\n"
	"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\n"
	"dw04             dw04 ieee dw01 dware gtech\n"
	"dw05             dw05 ieee dware\n"
	"dw06             dw06 ieee dware\n"
	"dw07             ieee dware\n"
	"dware            ieee dware\n"
	"gtech            ieee gtech\n"
	"ramlib           std ieee\n"
	"std_cell_lib     ieee std_cell_lib\n"
	"synopsys\n"
	"cycle_11	  cycle_12\n"
	"cycle_12	  cycle_11\n"
	"cycle_21	  dw01 cycle_22 dw02 dw03\n"
	"cycle_22	  cycle_21 dw01 dw04";

typedef struct item_t item_t, *item;
struct item_t { const char *name; int *deps, n_deps, idx, depth; };

int get_item(item *list, int *len, const char *name)
{
	int i;
	item lst = *list;

	for (i = 0; i < *len; i++)
		if (!strcmp(lst[i].name, name)) return i;

	lst = *list = realloc(lst, ++*len * sizeof(item_t));
	i = *len - 1;
	memset(lst + i, 0, sizeof(item_t));
	lst[i].idx = i;
	lst[i].name = name;
	return i;
}

void add_dep(item it, int i)
{
	if (it->idx == i) return;
	it->deps = realloc(it->deps, (it->n_deps + 1) * sizeof(int));
	it->deps[it->n_deps++] = i;
}

int parse_input(item *ret)
{
	int n_items = 0;
	int i, parent, idx;
	item list = 0;

	char *s, *e, *word, *we;
	for (s = input; ; s = 0) {
		if (!(s = strtok_r(s, "\n", &e))) break;

		for (i = 0, word = s; ; i++, word = 0) {
			if (!(word = strtok_r(word, " \t", &we))) break;
			idx = get_item(&list, &n_items, word);

			if (!i) parent = idx;
			else    add_dep(list + parent, idx);
		}
	}

	*ret = list;
	return n_items;
}

/* recursively resolve compile order; negative means loop */
int get_depth(item list, int idx, int bad)
{
	int max, i, t;

	if (!list[idx].deps)
		return list[idx].depth = 1;

	if ((t = list[idx].depth) < 0) return t;

	list[idx].depth = bad;
	for (max = i = 0; i < list[idx].n_deps; i++) {
		if ((t = get_depth(list, list[idx].deps[i], bad)) < 0) {
			max = t;
			break;
		}
		if (max < t + 1) max = t + 1;
	}
	return list[idx].depth = max;
}

int main()
{
	int i, j, n, bad = -1, max, min;
	item items;
	n = parse_input(&items);

	for (i = 0; i < n; i++)
		if (!items[i].depth && get_depth(items, i, bad) < 0) bad--;

	for (i = 0, max = min = 0; i < n; i++) {
		if (items[i].depth > max) max = items[i].depth;
		if (items[i].depth < min) min = items[i].depth;
	}

	printf("Compile order:\n");
	for (i = min; i <= max; i++) {
		if (!i) continue;

		if (i < 0) printf("   [unorderable]");
		else	   printf("%d:", i);

		for (j = 0; j < n || !putchar('\n'); j++)
			if (items[j].depth == i)
				printf(" %s", items[j].name);
	}

	return 0;
}
`,`#include "topological-sort-1.h"



int _get_item(undefined8 *param_1,int *param_2,char *param_3)

{
  int iVar1;
  void *pvVar2;
  int local_34;
  
  pvVar2 = (void *)*param_1;
  local_34 = 0;
  while( true ) {
    if (*param_2 <= local_34) {
      iVar1 = *param_2;
      *param_2 = iVar1 + 1;
      pvVar2 = _realloc(pvVar2,(long)(iVar1 + 1) << 5);
      *param_1 = pvVar2;
      iVar1 = *param_2 + -1;
      ___memset_chk((void *)((long)pvVar2 + (long)iVar1 * 0x20),0,0x20,0xffffffffffffffff);
      *(int *)((long)pvVar2 + (long)iVar1 * 0x20 + 0x14) = iVar1;
      *(char **)((long)pvVar2 + (long)iVar1 * 0x20) = param_3;
      return iVar1;
    }
    iVar1 = _strcmp(*(char **)((long)pvVar2 + (long)local_34 * 0x20),param_3);
    if (iVar1 == 0) break;
    local_34 = local_34 + 1;
  }
  return local_34;
}



void _add_dep(long param_1,int param_2)

{
  int iVar1;
  void *pvVar2;
  
  if (*(int *)(param_1 + 0x14) != param_2) {
    pvVar2 = _realloc(*(void **)(param_1 + 8),(long)(*(int *)(param_1 + 0x10) + 1) << 2);
    *(void **)(param_1 + 8) = pvVar2;
    iVar1 = *(int *)(param_1 + 0x10);
    *(int *)(param_1 + 0x10) = iVar1 + 1;
    *(int *)(*(long *)(param_1 + 8) + (long)iVar1 * 4) = param_2;
  }
  return;
}



undefined4 _parse_input(long *param_1)

{
  int iVar1;
  char *pcStack_50;
  char *local_48;
  char *pcStack_40;
  char *local_38;
  long local_30;
  int local_28;
  int local_24;
  int local_20;
  undefined4 local_1c;
  long *local_18;
  
  local_1c = 0;
  local_30 = 0;
  local_38 = _input;
  local_18 = param_1;
  while (local_48 = _strtok_r(local_38,"\n",&pcStack_40), local_48 != (char *)0x0) {
    local_20 = 0;
    local_38 = local_48;
    while (local_48 = _strtok_r(local_48," \t",&pcStack_50), local_48 != (char *)0x0) {
      local_28 = _get_item(&local_30,&local_1c,local_48);
      iVar1 = local_28;
      if (local_20 != 0) {
        _add_dep(local_30 + (long)local_24 * 0x20,local_28);
        iVar1 = local_24;
      }
      local_24 = iVar1;
      local_20 = local_20 + 1;
      local_48 = (char *)0x0;
    }
    local_38 = (char *)0x0;
    local_48 = (char *)0x0;
  }
  *local_18 = local_30;
  return local_1c;
}



int _get_depth(long param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  int local_30;
  int local_2c;
  int local_14;
  
  if (*(long *)(param_1 + (long)param_2 * 0x20 + 8) == 0) {
    *(undefined4 *)(param_1 + (long)param_2 * 0x20 + 0x18) = 1;
    local_14 = 1;
  }
  else {
    local_14 = *(int *)(param_1 + (long)param_2 * 0x20 + 0x18);
    if (-1 < local_14) {
      *(undefined4 *)(param_1 + (long)param_2 * 0x20 + 0x18) = param_3;
      local_30 = 0;
      local_2c = 0;
      while ((iVar1 = local_2c, local_30 < *(int *)(param_1 + (long)param_2 * 0x20 + 0x10) &&
             (iVar1 = _get_depth(param_1,*(undefined4 *)
                                          (*(long *)(param_1 + (long)param_2 * 0x20 + 8) +
                                          (long)local_30 * 4),param_3), -1 < iVar1))) {
        if (local_2c < iVar1 + 1) {
          local_2c = iVar1 + 1;
        }
        local_30 = local_30 + 1;
      }
      local_2c = iVar1;
      *(int *)(param_1 + (long)param_2 * 0x20 + 0x18) = local_2c;
      local_14 = local_2c;
    }
  }
  return local_14;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  long local_38;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_24 = -1;
  local_20 = _parse_input(&local_38);
  for (local_18 = 0; local_18 < local_20; local_18 = local_18 + 1) {
    if ((*(int *)(local_38 + (long)local_18 * 0x20 + 0x18) == 0) &&
       (iVar2 = _get_depth(local_38,local_18,local_24), iVar2 < 0)) {
      local_24 = local_24 + -1;
    }
  }
  local_2c = 0;
  local_28 = 0;
  for (local_18 = 0; local_18 < local_20; local_18 = local_18 + 1) {
    if (local_28 < *(int *)(local_38 + (long)local_18 * 0x20 + 0x18)) {
      local_28 = *(int *)(local_38 + (long)local_18 * 0x20 + 0x18);
    }
    if (*(int *)(local_38 + (long)local_18 * 0x20 + 0x18) < local_2c) {
      local_2c = *(int *)(local_38 + (long)local_18 * 0x20 + 0x18);
    }
  }
  _printf("Compile order:\n");
  for (local_18 = local_2c; local_18 <= local_28; local_18 = local_18 + 1) {
    if (local_18 != 0) {
      if (local_18 < 0) {
        _printf("   [unorderable]");
      }
      else {
        _printf("%d:");
      }
      local_1c = 0;
      while( true ) {
        bVar1 = true;
        if (local_20 <= local_1c) {
          iVar2 = _putchar(10);
          bVar1 = iVar2 == 0;
        }
        if (!bVar1) break;
        if (*(int *)(local_38 + (long)local_1c * 0x20 + 0x18) == local_18) {
          _printf(" %s");
        }
        local_1c = local_1c + 1;
      }
    }
  }
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strtok_r(char *param_1,char *param_2,char **param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strtok_r_100004028)();
  return pcVar1;
}


`
`#include <stdio.h>
static char const *animals[] = {
    "fly",
    "spider",
    "bird",
    "cat",
    "dog",
    "goat",
    "cow",
    "horse"
};
static char const *verses[]  = {
    "I don't know why she swallowed that fly.\nPerhaps she'll die\n",
    "That wiggled and jiggled and tickled inside her",
    "How absurd, to swallow a bird",
    "Imagine that. She swallowed a cat",
    "What a hog to swallow a dog",
    "She just opened her throat and swallowed that goat",
    "I don't know how she swallowed that cow",
    "She's dead of course"
};

#define LEN(ARR) (sizeof ARR / sizeof *ARR)

int main(void)
{
    for (size_t i = 0; i < LEN(animals); i++) {
        printf("There was an old lady who swallowed a %s\n%s\n", animals[i], verses[i]);
        for (size_t j = i; j > 0 && i < LEN(animals) - 1; j--) {
            printf("She swallowed the %s to catch the %s\n", animals[j], animals[j-1]);
            if (j == 1) {
                printf("%s\n", verses[0]);
            }
        }
    }
}
`,`#include "old-lady-swallowed-a-fly.h"



undefined4 entry(void)

{
  ulong local_28;
  ulong local_20;
  
  for (local_20 = 0; local_20 < 8; local_20 = local_20 + 1) {
    _printf("There was an old lady who swallowed a %s\n%s\n");
    for (local_28 = local_20; local_28 != 0 && local_20 < 7; local_28 = local_28 - 1) {
      _printf("She swallowed the %s to catch the %s\n");
      if (local_28 == 1) {
        _printf("%s\n");
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdio.h>
#include <assert.h>

int nonsqr(int n) {
    return n + (int)(0.5 + sqrt(n));
    /* return n + (int)round(sqrt(n)); in C99 */
}

int main() {
    int i;

    /* first 22 values (as a list) has no squares: */
    for (i = 1; i < 23; i++)
        printf("%d ", nonsqr(i));
    printf("\n");

    /* The following check shows no squares up to one million: */
    for (i = 1; i < 1000000; i++) {
        double j = sqrt(nonsqr(i));
        assert(j != floor(j));
    }
    return 0;
}
`,`#include "sequence-of-non-squares.h"



int _nonsqr(int param_1)

{
  return param_1 + (int)(SQRT((double)(long)param_1) + 0.5);
}



undefined8 entry(void)

{
  int iVar1;
  int local_18;
  
  for (local_18 = 1; local_18 < 0x17; local_18 = local_18 + 1) {
    _nonsqr(local_18);
    _printf("%d ");
  }
  _printf("\n");
  local_18 = 1;
  while( true ) {
    if (999999 < local_18) {
      return 0;
    }
    iVar1 = _nonsqr(local_18);
    if (SQRT((double)iVar1) == (double)(long)SQRT((double)iVar1)) break;
    local_18 = local_18 + 1;
  }
                    // WARNING: Subroutine does not return
  ___assert_rtn("main","sequence-of-non-squares.c",0x15,"j != floor(j)");
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include<string.h>
#include<stdio.h>

int main(int argc,char** argv)
{
    int i,len;
    char reference;

    if(argc>2){
        printf("Usage : %s <Test String>\n",argv[0]);
        return 0;
    }

    if(argc==1||strlen(argv[1])==1){
        printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argc==1?"":argv[1],argc==1?0:(int)strlen(argv[1]));
        return 0;
    }

    reference = argv[1][0];
    len = strlen(argv[1]);

    for(i=1;i<len;i++){
        if(argv[1][i]!=reference){
            printf("Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n",argv[1],len,argv[1][i],argv[1][i],i+1);
            return 0;
        }
    }

    printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argv[1],len);

    return 0;

}
`,`#include "determine-if-a-string-has-all-the-same-characters-1.h"



undefined4 entry(int param_1,long param_2)

{
  byte bVar1;
  size_t sVar2;
  int local_24;
  
  if (param_1 < 3) {
    if ((param_1 == 1) || (sVar2 = _strlen(*(char **)(param_2 + 8)), sVar2 == 1)) {
      if (param_1 != 1) {
        _strlen(*(char **)(param_2 + 8));
      }
      _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n");
    }
    else {
      bVar1 = **(byte **)(param_2 + 8);
      sVar2 = _strlen(*(char **)(param_2 + 8));
      for (local_24 = 1; local_24 < (int)sVar2; local_24 = local_24 + 1) {
        if ((int)*(char *)(*(long *)(param_2 + 8) + (long)local_24) != (uint)bVar1) {
          _printf(
                 "Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n"
                 );
          return 0;
        }
      }
      _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n");
    }
  }
  else {
    _printf("Usage : %s <Test String>\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004008)();
  return sVar1;
}


`
`#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

int **m;
int **s;

void optimal_matrix_chain_order(int *dims, int n) {
    int len, i, j, k, temp, cost;
    n--;
    m = (int **)malloc(n * sizeof(int *));
    for (i = 0; i < n; ++i) {
        m[i] = (int *)calloc(n, sizeof(int));
    }

    s = (int **)malloc(n * sizeof(int *));
    for (i = 0; i < n; ++i) {
        s[i] = (int *)calloc(n, sizeof(int));
    }

    for (len = 1; len < n; ++len) {
        for (i = 0; i < n - len; ++i) {
            j = i + len;
            m[i][j] = INT_MAX;
            for (k = i; k < j; ++k) {
                temp = dims[i] * dims[k + 1] * dims[j + 1];
                cost = m[i][k] + m[k + 1][j] + temp;
                if (cost < m[i][j]) {
                    m[i][j] = cost;
                    s[i][j] = k;
                }
            }
        }
    }
}

void print_optimal_chain_order(int i, int j) {
    if (i == j)
        printf("%c", i + 65);
    else {
        printf("(");
        print_optimal_chain_order(i, s[i][j]);
        print_optimal_chain_order(s[i][j] + 1, j);
        printf(")");
    }
}

int main() {
    int i, j, n;
    int a1[4]  = {5, 6, 3, 1};
    int a2[13] = {1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2};
    int a3[12] = {1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10};
    int *dims_list[3] = {a1, a2, a3};
    int sizes[3] = {4, 13, 12};
    for (i = 0; i < 3; ++i) {
        printf("Dims  : [");
        n = sizes[i];
        for (j = 0; j < n; ++j) {
            printf("%d", dims_list[i][j]);
            if (j < n - 1) printf(", "); else printf("]\n");
        }
        optimal_matrix_chain_order(dims_list[i], n);
        printf("Order : ");
        print_optimal_chain_order(0, n - 2);
        printf("\nCost  : %d\n\n", m[0][n - 2]);
        for (j = 0; j <= n - 2; ++j) free(m[j]);
        free(m);
        for (j = 0; j <= n - 2; ++j) free(s[j]);
        free(s);
    }
    return 0;
}
`,`#include "matrix-chain-multiplication.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _optimal_matrix_chain_order(long param_1,int param_2)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  undefined4 local_2c;
  undefined4 local_24;
  undefined4 local_20;
  
  param_2 = param_2 + -1;
  __m = _malloc((long)param_2 << 3);
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    pvVar3 = _calloc((long)param_2,4);
    *(void **)((long)__m + (long)local_24 * 8) = pvVar3;
  }
  __s = _malloc((long)param_2 << 3);
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    pvVar3 = _calloc((long)param_2,4);
    *(void **)((long)__s + (long)local_24 * 8) = pvVar3;
  }
  for (local_20 = 1; local_20 < param_2; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < param_2 - local_20; local_24 = local_24 + 1) {
      iVar1 = local_24 + local_20;
      *(undefined4 *)(*(long *)((long)__m + (long)local_24 * 8) + (long)iVar1 * 4) = 0x7fffffff;
      for (local_2c = local_24; local_2c < iVar1; local_2c = local_2c + 1) {
        iVar2 = *(int *)(*(long *)((long)__m + (long)local_24 * 8) + (long)local_2c * 4) +
                *(int *)(*(long *)((long)__m + (long)(local_2c + 1) * 8) + (long)iVar1 * 4) +
                *(int *)(param_1 + (long)local_24 * 4) *
                *(int *)(param_1 + (long)(local_2c + 1) * 4) *
                *(int *)(param_1 + (long)(iVar1 + 1) * 4);
        if (iVar2 < *(int *)(*(long *)((long)__m + (long)local_24 * 8) + (long)iVar1 * 4)) {
          *(int *)(*(long *)((long)__m + (long)local_24 * 8) + (long)iVar1 * 4) = iVar2;
          *(int *)(*(long *)((long)__s + (long)local_24 * 8) + (long)iVar1 * 4) = local_2c;
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _print_optimal_chain_order(int param_1,int param_2)

{
  int iVar1;
  
  if (param_1 == param_2) {
    iVar1 = _printf("%c");
  }
  else {
    _printf("(");
    _print_optimal_chain_order
              (param_1,*(undefined4 *)(*(long *)(__s + (long)param_1 * 8) + (long)param_2 * 4));
    _print_optimal_chain_order
              (*(int *)(*(long *)(__s + (long)param_1 * 8) + (long)param_2 * 4) + 1,param_2);
    iVar1 = _printf(")");
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  int iVar1;
  int local_cc;
  int local_c8;
  int local_c0 [4];
  undefined *local_b0 [3];
  undefined auStack_94 [48];
  undefined auStack_64 [52];
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 0x100000003;
  local_30 = 0x600000005;
  _memcpy(auStack_64,&DAT_100003f30,0x34);
  _memcpy(auStack_94,&DAT_100003f64,0x30);
  local_c0[0] = 4;
  local_c0[1] = 0xd;
  local_c0[2] = 0xc;
  local_b0[0] = (undefined *)&local_30;
  local_b0[1] = auStack_64;
  local_b0[2] = auStack_94;
  for (local_c8 = 0; local_c8 < 3; local_c8 = local_c8 + 1) {
    _printf("Dims  : [");
    iVar1 = local_c0[local_c8];
    for (local_cc = 0; local_cc < iVar1; local_cc = local_cc + 1) {
      _printf("%d");
      if (local_cc < iVar1 + -1) {
        _printf(", ");
      }
      else {
        _printf("]\n");
      }
    }
    _optimal_matrix_chain_order(local_b0[local_c8],iVar1);
    _printf("Order : ");
    _print_optimal_chain_order(0,iVar1 + -2);
    _printf("\nCost  : %d\n\n");
    for (local_cc = 0; local_cc <= iVar1 + -2; local_cc = local_cc + 1) {
      _free(*(void **)((long)__m + (long)local_cc * 8));
    }
    _free(__m);
    for (local_cc = 0; local_cc <= iVar1 + -2; local_cc = local_cc + 1) {
      _free(*(void **)((long)__s + (long)local_cc * 8));
    }
    _free(__s);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DEFAULT_LENGTH 4
#define DEFAULT_COUNT 1

char* symbols[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz", "0123456789", "!\"#$%&'()*+,-./:;<=>?@[]^_{|}~"};
int length = DEFAULT_LENGTH;
int count = DEFAULT_COUNT;
unsigned seed;
char exSymbols = 0;

void GetPassword () {
    //create an array of values that determine the number of characters from each category
    int lengths[4] = {1, 1, 1, 1};
    int count = 4;
    while (count < length) {
        lengths[rand()%4]++;
        count++;
    }

    //loop through the array of lengths and set the characters in password
    char password[length + 1];
    for (int i = 0; i < length; ) {
        //pick which string to read from
        int str = rand()%4;
        if (!lengths[str])continue;   //if the number of characters for that string have been reached, continue to the next interation

        char c;
        switch (str) {
            case 2:
                c = symbols[str][rand()%10];
                while (exSymbols && (c == 'I' || c == 'l' || c == '1' || c == 'O' || c == '0' || c == '5' || c == 'S' || c == '2' || c == 'Z'))
                    c = symbols[str][rand()%10];
                password[i] = c;
            break;

            case 3:
                c = symbols[str][rand()%30];
                while (exSymbols && (c == 'I' || c == 'l' || c == '1' || c == 'O' || c == '0' || c == '5' || c == 'S' || c == '2' || c == 'Z'))
                    c = symbols[str][rand()%30];
                password[i] = c;
            break;

            default:
                c = symbols[str][rand()%26];
                while (exSymbols && (c == 'I' || c == 'l' || c == '1' || c == 'O' || c == '0' || c == '5' || c == 'S' || c == '2' || c == 'Z'))
                    c = symbols[str][rand()%26];
                password[i] = c;
            break;
        }

        i++;
        lengths[str]--;
    }

    password [length] = '\0';
    printf ("%s\n", password);
}

int main (int argc, char* argv[]) {
    seed = (unsigned)time(NULL);

    //handle user input from the command line
    for (int i = 1; i < argc; i++) {
        switch (argv[i][1]) {
            case 'l':
                if (sscanf (argv[i+1], "%d", &length) != 1) {
                    puts ("Unrecognized input. Syntax: -l [integer]");
                    return -1;
                }

                if (length < 4) {
                    puts ("Password length must be at least 4 characters.");
                    return -1;
                }
                i++;
            break;

            case 'c':
                if (sscanf (argv[i+1], "%d", &count) != 1) {
                    puts ("Unrecognized input. Syntax: -c [integer]");
                    return -1;
                }

                if (count <= 0) {
                    puts ("Count must be at least 1.");
                    return -1;
                }
                i++;
            break;

            case 's':
                if (sscanf (argv[i+1], "%d", &seed) != 1) {
                    puts ("Unrecognized input. Syntax: -s [integer]");
                    return -1;
                }
                i++;
            break;

            case 'e':
                exSymbols = 1;
            break;

            default:
                help:
                printf ("Help:\nThis program generates a random password.\n"
                "Commands:"
                   "Set password length: -l [integer]\n"
                   "Set password count: -c [integer]\n"
                   "Set seed: -s [integer]\n"
                   "Exclude similiar characters: -e\n"
                   "Display help: -h");
                return 0;
            break;
        }
    }

    srand (seed);

    for (int i = 0; i < count; i++)
        GetPassword();

    return 0;
}
`,`#include "password-generator.h"



void _GetPassword(void)

{
  long lVar1;
  int iVar2;
  long alStack_d0 [2];
  undefined *local_c0;
  undefined *local_b8;
  uint local_b0;
  uint local_ac;
  undefined *local_a8;
  undefined *local_a0;
  uint local_98;
  uint local_94;
  undefined *local_90;
  undefined *local_88;
  uint local_80;
  uint local_7c;
  undefined *local_78;
  int local_6c;
  ulong local_68;
  long local_60;
  char local_51;
  int local_50;
  int local_4c;
  undefined *local_40;
  int local_34;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_30[2] = 1;
  local_30[3] = 1;
  local_30[0] = 1;
  local_30[1] = 1;
  for (local_34 = 4; local_34 < _length; local_34 = local_34 + 1) {
    iVar2 = _rand();
    local_30[iVar2 % 4] = local_30[iVar2 % 4] + 1;
  }
  local_68 = (ulong)(_length + 1) + 0xf & 0xfffffffffffffff0;
  local_40 = (undefined *)&local_c0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar1 = -local_68;
  local_60 = (long)&local_c0 + lVar1;
  local_4c = 0;
  while (local_4c < _length) {
    local_50 = _rand();
    local_50 = local_50 % 4;
    if (local_30[local_50] != 0) {
      local_6c = local_50;
      if (local_50 == 2) {
        local_78 = PTR_s_0123456789_100008010;
        iVar2 = _rand();
        local_51 = local_78[iVar2 % 10];
        while( true ) {
          local_7c = 0;
          if (_exSymbols != '\0') {
            local_80 = 1;
            if ((((((local_51 != 'I') && (local_80 = 1, local_51 != 'l')) &&
                  (local_80 = 1, local_51 != '1')) &&
                 ((local_80 = 1, local_51 != 'O' && (local_80 = 1, local_51 != '0')))) &&
                (local_80 = 1, local_51 != '5')) &&
               ((local_80 = 1, local_51 != 'S' && (local_80 = 1, local_51 != '2')))) {
              local_80 = (uint)(local_51 == 'Z');
            }
            local_7c = local_80;
          }
          if (local_7c == 0) break;
          local_88 = (&_symbols)[local_50];
          iVar2 = _rand();
          local_51 = local_88[iVar2 % 10];
        }
        *(char *)(local_60 + local_4c) = local_51;
      }
      else if (local_50 == 3) {
        local_90 = PTR_s__________________<_>___________100008018;
        iVar2 = _rand();
        local_51 = local_90[iVar2 % 0x1e];
        while( true ) {
          local_94 = 0;
          if (_exSymbols != '\0') {
            local_98 = 1;
            if ((((local_51 != 'I') && (local_98 = 1, local_51 != 'l')) &&
                (local_98 = 1, local_51 != '1')) &&
               (((local_98 = 1, local_51 != 'O' && (local_98 = 1, local_51 != '0')) &&
                ((local_98 = 1, local_51 != '5' &&
                 ((local_98 = 1, local_51 != 'S' && (local_98 = 1, local_51 != '2')))))))) {
              local_98 = (uint)(local_51 == 'Z');
            }
            local_94 = local_98;
          }
          if (local_94 == 0) break;
          local_a0 = (&_symbols)[local_50];
          iVar2 = _rand();
          local_51 = local_a0[iVar2 % 0x1e];
        }
        *(char *)(local_60 + local_4c) = local_51;
      }
      else {
        local_a8 = (&_symbols)[local_50];
        iVar2 = _rand();
        local_51 = local_a8[iVar2 % 0x1a];
        while( true ) {
          local_ac = 0;
          if (_exSymbols != '\0') {
            local_b0 = 1;
            if ((((local_51 != 'I') && (local_b0 = 1, local_51 != 'l')) &&
                (local_b0 = 1, local_51 != '1')) &&
               (((local_b0 = 1, local_51 != 'O' && (local_b0 = 1, local_51 != '0')) &&
                ((local_b0 = 1, local_51 != '5' &&
                 ((local_b0 = 1, local_51 != 'S' && (local_b0 = 1, local_51 != '2')))))))) {
              local_b0 = (uint)(local_51 == 'Z');
            }
            local_ac = local_b0;
          }
          if (local_ac == 0) break;
          local_b8 = (&_symbols)[local_50];
          iVar2 = _rand();
          local_51 = local_b8[iVar2 % 0x1a];
        }
        *(char *)(local_60 + local_4c) = local_51;
      }
      local_4c = local_4c + 1;
      local_30[local_50] = local_30[local_50] + -1;
    }
  }
  *(undefined *)(local_60 + _length) = 0;
  *(long *)((long)alStack_d0 + lVar1) = local_60;
  iVar2 = _printf("%s\n");
  local_c0 = local_40;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar2);
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  time_t tVar2;
  int local_28;
  int local_24;
  
  tVar2 = _time((time_t *)0x0);
  _seed = (uint)tVar2;
  local_24 = 1;
  do {
    if (param_1 <= local_24) {
      _srand(_seed);
      for (local_28 = 0; local_28 < _count; local_28 = local_28 + 1) {
        _GetPassword();
      }
      return 0;
    }
    switch(*(undefined *)(*(long *)(param_2 + (long)local_24 * 8) + 1)) {
    case 99:
      iVar1 = _sscanf(*(char **)(param_2 + (long)(local_24 + 1) * 8),"%d");
      if (iVar1 != 1) {
        _puts("Unrecognized input. Syntax: -c [integer]");
        return 0xffffffff;
      }
      if (_count < 1) {
        _puts("Count must be at least 1.");
        return 0xffffffff;
      }
      local_24 = local_24 + 1;
      break;
    default:
      _printf(
             "Help:\nThis program generates a random password.\nCommands:Set password length: -l [integer]\nSet password count: -c [integer]\nSet seed: -s [integer]\nExclude similiar characters: -e\nDisplay help: -h"
             );
      return 0;
    case 0x65:
      _exSymbols = 1;
      break;
    case 0x6c:
      iVar1 = _sscanf(*(char **)(param_2 + (long)(local_24 + 1) * 8),"%d");
      if (iVar1 != 1) {
        _puts("Unrecognized input. Syntax: -l [integer]");
        return 0xffffffff;
      }
      if (_length < 4) {
        _puts("Password length must be at least 4 characters.");
        return 0xffffffff;
      }
      local_24 = local_24 + 1;
      break;
    case 0x73:
      iVar1 = _sscanf(*(char **)(param_2 + (long)(local_24 + 1) * 8),"%d");
      if (iVar1 != 1) {
        _puts("Unrecognized input. Syntax: -s [integer]");
        return 0xffffffff;
      }
      local_24 = local_24 + 1;
    }
    local_24 = local_24 + 1;
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003d84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d9c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004040)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

long long x, y, dx, dy, scale, clen, cscale;
typedef struct { double r, g, b; } rgb;
rgb ** pix;

void sc_up()
{
	scale *= 2; x *= 2; y *= 2;
	cscale *= 3;
}

void h_rgb(long long x, long long y)
{
	rgb *p = &pix[y][x];

#	define SAT 1
	double h = 6.0 * clen / cscale;
	double VAL = 1;
	double c = SAT * VAL;
	double X = c * (1 - fabs(fmod(h, 2) - 1));

	switch((int)h) {
	case 0: p->r += c; p->g += X; return;
	case 1:	p->r += X; p->g += c; return;
	case 2: p->g += c; p->b += X; return;
	case 3: p->g += X; p->b += c; return;
	case 4: p->r += X; p->b += c; return;
	default:
		p->r += c; p->b += X;
	}
}

void iter_string(const char * str, int d)
{
	long long len;
	while (*str != '\0') {
		switch(*(str++)) {
		case 'X':
			if (d)	iter_string("XHXVX", d - 1);
			else{
				clen ++;
				h_rgb(x/scale, y/scale);
				x += dx;
				y -= dy;
			}
			continue;
		case 'V':
			len = 1LLU << d;
			while (len--) {
				clen ++;
				h_rgb(x/scale, y/scale);
				y += dy;
			}
			continue;
		case 'H':
			len = 1LLU << d;
			while(len --) {
				clen ++;
				h_rgb(x/scale, y/scale);
				x -= dx;
			}
			continue;
		}
	}
}

void sierp(long leng, int depth)
{
	long i;
	long h = leng + 20, w = leng + 20;

	/* allocate pixel buffer */
	rgb *buf = malloc(sizeof(rgb) * w * h);
	pix = malloc(sizeof(rgb *) * h);
	for (i = 0; i < h; i++)
		pix[i] = buf + w * i;
	memset(buf, 0, sizeof(rgb) * w * h);

        /* init coords; scale up to desired; exec string */
	x = y = 10; dx = leng; dy = leng; scale = 1; clen = 0; cscale = 3;
	for (i = 0; i < depth; i++) sc_up();
	iter_string("VXH", depth);

	/* write color PNM file */
	unsigned char *fpix = malloc(w * h * 3);
	double maxv = 0, *dbuf = (double*)buf;

	for (i = 3 * w * h - 1; i >= 0; i--)
		if (dbuf[i] > maxv) maxv = dbuf[i];
	for (i = 3 * h * w - 1; i >= 0; i--)
		fpix[i] = 255 * dbuf[i] / maxv;

	printf("P6\n%ld %ld\n255\n", w, h);
	fflush(stdout); /* printf and fwrite may treat buffer differently */
	fwrite(fpix, h * w * 3, 1, stdout);
}

int main(int c, char ** v)
{
	int size, depth;

	depth  = (c > 1) ? atoi(v[1]) : 10;
	size = 1 << depth;

	fprintf(stderr, "size: %d depth: %d\n", size, depth);
	sierp(size, depth + 2);

	return 0;
}
`,`#include "sierpinski-triangle-graphical.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _sc_up(void)

{
  __scale = __scale << 1;
  __x = __x << 1;
  __y = __y << 1;
  __cscale = __cscale * 3;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _h_rgb(long param_1,long param_2)

{
  double *pdVar1;
  double dVar2;
  double dVar3;
  
  pdVar1 = (double *)(*(long *)(__pix + param_2 * 8) + param_1 * 0x18);
  dVar2 = ((double)__clen * 6.0) / (double)__cscale;
  dVar3 = (double)_fmod(dVar2,0x4000000000000000);
  dVar3 = (1.0 - ABS(dVar3 - 1.0)) * 1.0;
  switch((int)dVar2) {
  case 0:
    *pdVar1 = *pdVar1 + 1.0;
    pdVar1[1] = pdVar1[1] + dVar3;
    break;
  case 1:
    *pdVar1 = *pdVar1 + dVar3;
    pdVar1[1] = pdVar1[1] + 1.0;
    break;
  case 2:
    pdVar1[1] = pdVar1[1] + 1.0;
    pdVar1[2] = pdVar1[2] + dVar3;
    break;
  case 3:
    pdVar1[1] = pdVar1[1] + dVar3;
    pdVar1[2] = pdVar1[2] + 1.0;
    break;
  case 4:
    *pdVar1 = *pdVar1 + dVar3;
    pdVar1[2] = pdVar1[2] + 1.0;
    break;
  default:
    *pdVar1 = *pdVar1 + 1.0;
    pdVar1[2] = pdVar1[2] + dVar3;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

void _iter_string(char *param_1,uint param_2)

{
  char *pcVar1;
  char cVar2;
  long lVar3;
  long lVar4;
  long local_28;
  char *local_18;
  
  local_18 = param_1;
  while (*local_18 != '\0') {
    pcVar1 = local_18 + 1;
    cVar2 = *local_18;
    local_18 = pcVar1;
    if (cVar2 == 'H') {
      local_28 = 1L << ((ulong)param_2 & 0x3f);
      while (local_28 != 0) {
        __clen = __clen + 1;
        lVar3 = 0;
        if (__scale != 0) {
          lVar3 = __x / __scale;
        }
        lVar4 = 0;
        if (__scale != 0) {
          lVar4 = __y / __scale;
        }
        _h_rgb(lVar3,lVar4);
        __x = __x - __dx;
        local_28 = local_28 + -1;
      }
    }
    else if (cVar2 == 'V') {
      local_28 = 1L << ((ulong)param_2 & 0x3f);
      while (local_28 != 0) {
        __clen = __clen + 1;
        lVar3 = 0;
        if (__scale != 0) {
          lVar3 = __x / __scale;
        }
        lVar4 = 0;
        if (__scale != 0) {
          lVar4 = __y / __scale;
        }
        _h_rgb(lVar3,lVar4);
        __y = __y + __dy;
        local_28 = local_28 + -1;
      }
    }
    else if (cVar2 == 'X') {
      if (param_2 == 0) {
        __clen = __clen + 1;
        lVar3 = 0;
        if (__scale != 0) {
          lVar3 = __x / __scale;
        }
        lVar4 = 0;
        if (__scale != 0) {
          lVar4 = __y / __scale;
        }
        _h_rgb(lVar3,lVar4);
        __x = __x + __dx;
        __y = __y - __dy;
      }
      else {
        _iter_string("XHXVX",param_2 - 1);
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _sierp(long param_1,int param_2)

{
  long lVar1;
  long lVar2;
  undefined *puVar3;
  void *pvVar4;
  void *pvVar5;
  double local_50;
  long local_28;
  
  lVar1 = param_1 + 0x14;
  lVar2 = param_1 + 0x14;
  pvVar4 = _malloc(lVar2 * 0x18 * lVar1);
  __pix = _malloc(lVar1 * 8);
  for (local_28 = 0; local_28 < lVar1; local_28 = local_28 + 1) {
    *(void **)((long)__pix + local_28 * 8) = (void *)((long)pvVar4 + lVar2 * local_28 * 0x18);
  }
  ___memset_chk(pvVar4,0,lVar2 * 0x18 * lVar1,0xffffffffffffffff);
  __y = 10;
  __x = 10;
  __scale = 1;
  __clen = 0;
  __cscale = 3;
  __dx = param_1;
  __dy = param_1;
  for (local_28 = 0; local_28 < param_2; local_28 = local_28 + 1) {
    _sc_up();
  }
  _iter_string("VXH",param_2);
  pvVar5 = _malloc(lVar2 * lVar1 * 3);
  local_50 = 0.0;
  local_28 = lVar2 * 3 * lVar1;
  while (local_28 = local_28 + -1, -1 < local_28) {
    if (local_50 < *(double *)((long)pvVar4 + local_28 * 8)) {
      local_50 = *(double *)((long)pvVar4 + local_28 * 8);
    }
  }
  local_28 = lVar1 * 3 * lVar2;
  while (local_28 = local_28 + -1, -1 < local_28) {
    *(char *)((long)pvVar5 + local_28) =
         (char)(int)((*(double *)((long)pvVar4 + local_28 * 8) * 255.0) / local_50);
  }
  _printf("P6\n%ld %ld\n255\n");
  puVar3 = PTR____stdoutp_100004010;
  _fflush(*(FILE **)PTR____stdoutp_100004010);
  _fwrite(pvVar5,lVar1 * lVar2 * 3,1,*(FILE **)puVar3);
  return;
}



undefined8 entry(int param_1,long param_2)

{
  uint local_2c;
  
  if (param_1 < 2) {
    local_2c = 10;
  }
  else {
    local_2c = _atoi(*(char **)(param_2 + 8));
  }
  _fprintf(*(FILE **)PTR____stderrp_100004008,"size: %d depth: %d\n");
  _sierp((long)(1 << (ulong)(local_2c & 0x1f)),local_2c + 2);
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004020)((int)param_1);
  return iVar1;
}



void _fmod(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__fmod_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004038)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004040)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void swap(char* str, int i, int j) {
    char c = str[i];
    str[i] = str[j];
    str[j] = c;
}

void reverse(char* str, int i, int j) {
    for (; i < j; ++i, --j)
        swap(str, i, j);
}

bool next_permutation(char* str) {
    int len = strlen(str);
    if (len < 2)
        return false;
    for (int i = len - 1; i > 0; ) {
        int j = i, k;
        if (str[--i] < str[j]) {
            k = len;
            while (str[i] >= str[--k]) {}
            swap(str, i, k);
            reverse(str, j, len - 1);
            return true;
        }
    }
    return false;
}

uint32_t next_highest_int(uint32_t n) {
    char str[16];
    snprintf(str, sizeof(str), "%u", n);
    if (!next_permutation(str))
        return 0;
    return strtoul(str, 0, 10);
}

int main() {
    uint32_t numbers[] = {0, 9, 12, 21, 12453, 738440, 45072010, 95322020};
    const int count = sizeof(numbers)/sizeof(int);
    for (int i = 0; i < count; ++i)
        printf("%d -> %d\n", numbers[i], next_highest_int(numbers[i]));
    // Last one is too large to convert to an integer
    const char big[] = "9589776899767587796600";
    char next[sizeof(big)];
    memcpy(next, big, sizeof(big));
    next_permutation(next);
    printf("%s -> %s\n", big, next);
    return 0;
}
`,`#include "next-highest-int-from-digits.h"



void _swap(long param_1,int param_2,int param_3)

{
  undefined uVar1;
  
  uVar1 = *(undefined *)(param_1 + param_2);
  *(undefined *)(param_1 + param_2) = *(undefined *)(param_1 + param_3);
  *(undefined *)(param_1 + param_3) = uVar1;
  return;
}



void _reverse(undefined8 param_1,int param_2,int param_3)

{
  undefined4 local_20;
  undefined4 local_1c;
  
  local_20 = param_3;
  for (local_1c = param_2; local_1c < local_20; local_1c = local_1c + 1) {
    _swap(param_1,local_1c,local_20);
    local_20 = local_20 + -1;
  }
  return;
}



undefined _next_permutation(char *param_1)

{
  int iVar1;
  size_t sVar2;
  int iVar3;
  int local_30;
  int local_28;
  undefined local_11;
  
  sVar2 = _strlen(param_1);
  iVar3 = (int)sVar2;
  if (iVar3 < 2) {
    local_11 = 0;
  }
  else {
    iVar1 = iVar3 + -1;
    do {
      local_28 = iVar1;
      if (local_28 < 1) {
        return 0;
      }
      iVar1 = local_28 + -1;
      local_30 = iVar3;
    } while (param_1[local_28] <= param_1[iVar1]);
    do {
      local_30 = local_30 + -1;
    } while (param_1[local_30] <= param_1[iVar1]);
    _swap(param_1,iVar1,local_30);
    _reverse(param_1,local_28,iVar3 + -1);
    local_11 = 1;
  }
  return local_11;
}



undefined4 _next_highest_int(void)

{
  ulong uVar1;
  undefined4 local_2c;
  char acStack_28 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  ___snprintf_chk(acStack_28,0x10,0,0x10,"%u");
  uVar1 = _next_permutation(acStack_28);
  if ((uVar1 & 1) == 0) {
    local_2c = 0;
  }
  else {
    uVar1 = _strtoul(acStack_28,(char **)0x0,10);
    local_2c = (undefined4)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_2c;
}



undefined8 entry(void)

{
  int iVar1;
  int local_8c;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  uStack_38 = 0x150000000c;
  local_40 = 0x900000000;
  uStack_28 = 0x5ae7fa402afbe8a;
  local_30 = 0xb4488000030a5;
  for (local_8c = 0; local_8c < 8; local_8c = local_8c + 1) {
    _next_highest_int(*(undefined4 *)((long)&local_40 + (long)local_8c * 4));
    _printf("%d -> %d\n");
  }
  _next_permutation();
  iVar1 = _printf("%s -> %s\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___snprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____snprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004020)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulong _strtoul(char *param_1,char **param_2,int param_3)

{
  ulong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoul_100004028)(param_1,param_2,param_3);
  return uVar1;
}


`
`#include <stdlib.h>

#define N 26

int main() {
    unsigned char lower[N];

    for (size_t i = 0; i < N; i++) {
        lower[i] = i + 'a';
    }

    return EXIT_SUCCESS;
}
`,`#include "generate-lower-case-ascii-alphabet.h"



undefined8 entry(void)

{
  ulong local_40;
  char acStack_32 [26];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_40 = 0; local_40 < 0x1a; local_40 = local_40 + 1) {
    acStack_32[local_40] = (char)local_40 + 'a';
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}


`
`#include <stdio.h>

typedef unsigned uint;
uint is_pern(uint n)
{
        uint c = 2693408940u; // int with all prime-th bits set
        while (n) c >>= 1, n &= (n - 1); // take out lowerest set bit one by one
        return c & 1;
}

int main(void)
{
        uint i, c;
        for (i = c = 0; c < 25; i++)
                if (is_pern(i))
                        printf("%u ", i), ++c;
        putchar('\n');

        for (i = 888888877u; i <= 888888888u; i++)
                if (is_pern(i))
                        printf("%u ", i);
        putchar('\n');

        return 0;
}
`,`#include "pernicious-numbers.h"



uint _is_pern(uint param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0xa08a28ac;
  for (local_4 = param_1; local_4 != 0; local_4 = local_4 & local_4 - 1) {
    local_8 = local_8 >> 1;
  }
  return local_8 & 1;
}



undefined8 entry(void)

{
  int iVar1;
  uint local_1c;
  uint local_18;
  
  local_1c = 0;
  local_18 = 0;
  while (local_1c < 0x19) {
    iVar1 = _is_pern(local_18);
    if (iVar1 != 0) {
      _printf("%u ");
      local_1c = local_1c + 1;
    }
    local_18 = local_18 + 1;
  }
  _putchar(10);
  for (local_18 = 0x34fb5e2d; local_18 < 0x34fb5e39; local_18 = local_18 + 1) {
    iVar1 = _is_pern(local_18);
    if (iVar1 != 0) {
      _printf("%u ");
    }
  }
  _putchar(10);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdbool.h>
#include <time.h>

#define n 100
#define nn ((n * (n + 1)) >> 1)

bool Contains(int lst[], int item, int size) {
	for (int i = size - 1; i >= 0; i--)
 		if (item == lst[i]) return true;
	return false;
}

int * MianChowla()
{
	static int mc[n]; mc[0] = 1;
	int sums[nn];	sums[0] = 2;
	int sum, le, ss = 1;
	for (int i = 1; i < n; i++) {
		le = ss;
		for (int j = mc[i - 1] + 1; ; j++) {
			mc[i] = j;
			for (int k = 0; k <= i; k++) {
				sum = mc[k] + j;
				if (Contains(sums, sum, ss)) {
					ss = le; goto nxtJ;
				}
				sums[ss++] = sum;
			}
			break;
		nxtJ:;
		}
	}
	return mc;
}

int main() {
	clock_t st = clock(); int * mc; mc = MianChowla();
        double et = ((double)(clock() - st)) / CLOCKS_PER_SEC;
	printf("The first 30 terms of the Mian-Chowla sequence are:\n");
	for (int i = 0; i < 30; i++) printf("%d ", mc[i]);
	printf("\n\nTerms 91 to 100 of the Mian-Chowla sequence are:\n");
	for (int i = 90; i < 100; i++) printf("%d ", mc[i]);
	printf("\n\nComputation time was %f seconds.", et);
}
`,`#include "mian-chowla-sequence-1.h"



undefined _Contains(long param_1,int param_2,int param_3)

{
  int local_1c;
  
  local_1c = param_3 + -1;
  while( true ) {
    if (local_1c < 0) {
      return 0;
    }
    if (param_2 == *(int *)(param_1 + (long)local_1c * 4)) break;
    local_1c = local_1c + -1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * _MianChowla(void)

{
  int iVar1;
  int iVar2;
  ulong uVar3;
  long lVar4;
  int local_4f28;
  int local_4f24;
  int local_4f20;
  int local_4f1c;
  int local_4f10 [5050];
  long local_28;
  
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _DAT_100008000 = 1;
  local_4f10[0] = 2;
  local_4f1c = 1;
  local_4f20 = 1;
LAB_100003c64:
  iVar2 = local_4f1c;
  if (99 < local_4f20) {
    if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
      return &DAT_100008000;
    }
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  local_4f24 = *(int *)(&DAT_100008000 + (long)(local_4f20 + -1) * 4);
  do {
    local_4f24 = local_4f24 + 1;
    *(int *)(&DAT_100008000 + (long)local_4f20 * 4) = local_4f24;
    local_4f28 = 0;
    local_4f1c = iVar2;
    while( true ) {
      if (local_4f20 < local_4f28) {
        local_4f20 = local_4f20 + 1;
        goto LAB_100003c64;
      }
      iVar1 = *(int *)(&DAT_100008000 + (long)local_4f28 * 4);
      uVar3 = _Contains(local_4f10,iVar1 + local_4f24,local_4f1c);
      if ((uVar3 & 1) != 0) break;
      lVar4 = (long)local_4f1c;
      local_4f1c = local_4f1c + 1;
      local_4f10[lVar4] = iVar1 + local_4f24;
      local_4f28 = local_4f28 + 1;
    }
  } while( true );
}



undefined4 entry(void)

{
  int local_38;
  int local_34;
  
  _clock();
  _MianChowla();
  _clock();
  _printf("The first 30 terms of the Mian-Chowla sequence are:\n");
  for (local_34 = 0; local_34 < 0x1e; local_34 = local_34 + 1) {
    _printf("%d ");
  }
  _printf("\n\nTerms 91 to 100 of the Mian-Chowla sequence are:\n");
  for (local_38 = 0x5a; local_38 < 100; local_38 = local_38 + 1) {
    _printf("%d ");
  }
  _printf("\n\nComputation time was %f seconds.");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004018)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(void)
{
  printf("%s\n",
         ( (727 == 0x2d7) &&
           (727 == 01327)    ) ? "true" : "false");

  return 0;
}
`,`#include "literals-integer.h"



undefined4 entry(void)

{
  _printf("%s\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))

int jacobi(unsigned long a, unsigned long n) {
	if (a >= n) a %= n;
	int result = 1;
	while (a) {
		while ((a & 1) == 0) {
			a >>= 1;
			if ((n & 7) == 3 || (n & 7) == 5) result = -result;
		}
		SWAP(a, n);
		if ((a & 3) == 3 && (n & 3) == 3) result = -result;
		a %= n;
	}
	if (n == 1) return result;
	return 0;
}

void print_table(unsigned kmax, unsigned nmax) {
	printf("n\\k|");
	for (int k = 0; k <= kmax; ++k) printf("%'3u", k);
	printf("\n----");
	for (int k = 0; k <= kmax; ++k) printf("---");
	putchar('\n');
	for (int n = 1; n <= nmax; n += 2) {
		printf("%-2u |", n);
		for (int k = 0; k <= kmax; ++k)
			printf("%'3d", jacobi(k, n));
		putchar('\n');
	}
}

int main() {
	print_table(20, 21);
	return 0;
}
`,`#include "jacobi-symbol.h"



int _jacobi(ulong param_1,ulong param_2)

{
  ulong uVar1;
  ulong uVar2;
  int local_1c;
  ulong local_18;
  ulong local_10;
  int local_4;
  
  local_10 = param_1;
  if (param_2 <= param_1) {
    uVar2 = 0;
    if (param_2 != 0) {
      uVar2 = param_1 / param_2;
    }
    local_10 = param_1 - uVar2 * param_2;
  }
  local_1c = 1;
  local_18 = param_2;
  while (local_10 != 0) {
    while ((local_10 & 1) == 0) {
      local_10 = local_10 >> 1;
      if (((local_18 & 7) == 3) || ((local_18 & 7) == 5)) {
        local_1c = -local_1c;
      }
    }
    uVar2 = local_10;
    if (((local_18 & 3) == 3) && ((local_10 & 3) == 3)) {
      local_1c = -local_1c;
    }
    uVar1 = 0;
    if (local_10 != 0) {
      uVar1 = local_18 / local_10;
    }
    local_10 = local_18 - uVar1 * local_10;
    local_18 = uVar2;
  }
  if (local_18 == 1) {
    local_4 = local_1c;
  }
  else {
    local_4 = 0;
  }
  return local_4;
}



int _print_table(uint param_1,uint param_2)

{
  int iVar1;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  
  _printf("n\\k|");
  for (local_1c = 0; local_1c <= param_1; local_1c = local_1c + 1) {
    _printf("%\'3u");
  }
  _printf("\n----");
  for (local_20 = 0; local_20 <= param_1; local_20 = local_20 + 1) {
    _printf("---");
  }
  iVar1 = _putchar(10);
  for (local_24 = 1; local_24 <= param_2; local_24 = local_24 + 2) {
    _printf("%-2u |");
    for (local_28 = 0; local_28 <= param_1; local_28 = local_28 + 1) {
      _jacobi((long)(int)local_28,(long)(int)local_24);
      _printf("%\'3d");
    }
    iVar1 = _putchar(10);
  }
  return iVar1;
}



undefined4 entry(void)

{
  _print_table(0x14,0x15);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

int main()
{
  char *buffer;
  struct stat s;

  int fd = open("readentirefile_mm.c", O_RDONLY);
  if (fd < 0 ) return EXIT_FAILURE;
  fstat(fd, &s);
  /* PROT_READ disallows writing to buffer: will segv */
  buffer = mmap(0, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

  if ( buffer != (void*)-1 )
  {
    /* do something */
    fwrite(buffer, s.st_size, 1, stdout);
    munmap(buffer, s.st_size);
  }

  close(fd);
  return EXIT_SUCCESS;
}
`,`#include "read-entire-file-2.h"



undefined4 entry(void)

{
  int iVar1;
  stat sStack_b0;
  void *local_20;
  undefined4 local_14;
  
  local_14 = 0;
  iVar1 = _open("readentirefile_mm.c",0);
  if (iVar1 < 0) {
    local_14 = 1;
  }
  else {
    _fstat(iVar1,&sStack_b0);
    local_20 = (void *)_mmap(0,sStack_b0.st_size,1,2,iVar1,0);
    if (local_20 != (void *)0xffffffffffffffff) {
      _fwrite(local_20,sStack_b0.st_size,1,*(FILE **)PTR____stdoutp_100004000);
      _munmap(local_20,sStack_b0.st_size);
    }
    _close(iVar1);
    local_14 = 0;
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004010)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004018)();
  return sVar1;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004020)();
  return;
}



void _munmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__munmap_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004030)((int)param_1,param_2);
  return iVar1;
}


`
`#include <stdio.h>
#include <ctype.h>

int can_make_words(char **b, char *word)
{
	int i, ret = 0, c = toupper(*word);

#define SWAP(a, b) if (a != b) { char * tmp = a; a = b; b = tmp; }

	if (!c) return 1;
	if (!b[0]) return 0;

	for (i = 0; b[i] && !ret; i++) {
		if (b[i][0] != c && b[i][1] != c) continue;
		SWAP(b[i], b[0]);
		ret = can_make_words(b + 1, word + 1);
		SWAP(b[i], b[0]);
	}

	return ret;
}

int main(void)
{
	char* blocks[] = {
		"BO", "XK", "DQ", "CP", "NA",
		"GT", "RE", "TG", "QD", "FS",
		"JW", "HU", "VI", "AN", "OB",
		"ER", "FS", "LY", "PC", "ZM",
		0 };

	char *words[] = {
		"", "A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "Confuse", 0
	};

	char **w;
	for (w = words; *w; w++)
		printf("%s\t%d\n", *w, can_make_words(blocks, *w));

	return 0;
}
`,`#include "abc-problem.h"



int _can_make_words(long *param_1,char *param_2)

{
  int iVar1;
  long lVar2;
  int local_30;
  int local_2c;
  int local_14;
  
  local_30 = 0;
  iVar1 = _toupper((int)*param_2);
  if (iVar1 == 0) {
    local_14 = 1;
  }
  else if (*param_1 == 0) {
    local_14 = 0;
  }
  else {
    local_2c = 0;
    while (param_1[local_2c] != 0 && local_30 == 0) {
      if ((*(char *)param_1[local_2c] == iVar1) || (*(char *)(param_1[local_2c] + 1) == iVar1)) {
        if (param_1[local_2c] != *param_1) {
          lVar2 = param_1[local_2c];
          param_1[local_2c] = *param_1;
          *param_1 = lVar2;
        }
        local_30 = _can_make_words(param_1 + 1,param_2 + 1);
        if (param_1[local_2c] != *param_1) {
          lVar2 = param_1[local_2c];
          param_1[local_2c] = *param_1;
          *param_1 = lVar2;
        }
      }
      local_2c = local_2c + 1;
    }
    local_14 = local_30;
  }
  return local_14;
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  long *local_128;
  long local_118 [9];
  undefined auStack_d0 [168];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_d0,&PTR_s_BO_100004028,0xa8);
  local_128 = local_118;
  pvVar2 = _memcpy(local_128,&PTR_s__1000040d0,0x48);
  for (; *local_128 != 0; local_128 = local_128 + 1) {
    _can_make_words(auStack_d0,*local_128);
    uVar1 = _printf("%s\t%d\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _toupper(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__toupper_100004020)(_c);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

#define FOR(x, y) for(x = 0; x < y; x++)
char *best_shuffle(const char *s, int *diff)
{
	int i, j = 0, max = 0, l = strlen(s), cnt[128] = {0};
	char buf[256] = {0}, *r;

	FOR(i, l) if (++cnt[(int)s[i]] > max) max = cnt[(int)s[i]];
	FOR(i, 128) while (cnt[i]--) buf[j++] = i;

	r = strdup(s);
	FOR(i, l) FOR(j, l)
		if (r[i] == buf[j]) {
			r[i] = buf[(j + max) % l] & ~128;
			buf[j] |= 128;
			break;
		}

	*diff = 0;
	FOR(i, l) *diff += r[i] == s[i];

	return r;
}

int main()
{
	int i, d;
	const char *r, *t[] = {"abracadabra", "seesaw", "elk", "grrrrrr", "up", "a", 0};
	for (i = 0; t[i]; i++) {
		r = best_shuffle(t[i], &d);
		printf("%s %s (%d)\n", t[i], r, d);
	}
	return 0;
}
`,`#include "best-shuffle-4.h"



char * _best_shuffle(char *param_1,int *param_2)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  int iVar4;
  long lVar5;
  int local_344;
  int local_340;
  int local_33c;
  byte abStack_328 [256];
  int aiStack_228 [128];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_340 = 0;
  local_344 = 0;
  sVar2 = _strlen(param_1);
  iVar4 = (int)sVar2;
  _bzero(aiStack_228,0x200);
  _memset(abStack_328,0,0x100);
  for (local_33c = 0; local_33c < iVar4; local_33c = local_33c + 1) {
    iVar1 = aiStack_228[param_1[local_33c]] + 1;
    aiStack_228[param_1[local_33c]] = iVar1;
    if (local_344 < iVar1) {
      local_344 = aiStack_228[param_1[local_33c]];
    }
  }
  for (local_33c = 0; local_33c < 0x80; local_33c = local_33c + 1) {
    while (iVar1 = aiStack_228[local_33c], aiStack_228[local_33c] = iVar1 + -1, iVar1 != 0) {
      lVar5 = (long)local_340;
      local_340 = local_340 + 1;
      abStack_328[lVar5] = (byte)local_33c;
    }
  }
  pcVar3 = _strdup(param_1);
  local_33c = 0;
  do {
    if (iVar4 <= local_33c) {
      *param_2 = 0;
      for (local_33c = 0; local_33c < iVar4; local_33c = local_33c + 1) {
        *param_2 = *param_2 + (uint)(pcVar3[local_33c] == param_1[local_33c]);
      }
      if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
        return pcVar3;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    for (local_340 = 0; local_340 < iVar4; local_340 = local_340 + 1) {
      if (pcVar3[local_33c] == abStack_328[local_340]) {
        iVar1 = 0;
        if (iVar4 != 0) {
          iVar1 = (local_340 + local_344) / iVar4;
        }
        pcVar3[local_33c] = abStack_328[(local_340 + local_344) - iVar1 * iVar4] & 0x7f;
        abStack_328[local_340] = abStack_328[local_340] | 0x80;
        break;
      }
    }
    local_33c = local_33c + 1;
  } while( true );
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  undefined local_5c [4];
  int local_58;
  undefined4 local_54;
  long alStack_50 [7];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_54 = 0;
  pvVar2 = _memcpy(alStack_50,&PTR_s_abracadabra_100004040,0x38);
  for (local_58 = 0; alStack_50[local_58] != 0; local_58 = local_58 + 1) {
    _best_shuffle(alStack_50[local_58],local_5c);
    uVar1 = _printf("%s %s (%d)\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004020)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004030)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}


`
`#include <stdio.h>

#define MAX_N 33	/* max number of tree nodes */
#define BRANCH 4	/* max number of edges a single node can have */

/* The basic idea: a paraffin molecule can be thought as a simple tree
   with each node being a carbon atom.  Counting molecules is thus the
   problem of counting free (unrooted) trees of given number of nodes.

   An unrooted tree needs to be uniquely represented, so we need a way
   to cannonicalize equivalent free trees.  For that, we need to first
   define the cannonical form of rooted trees.  Since rooted trees can
   be constructed by a root node and up to BRANCH rooted subtrees that
   are arranged in some definite order, we can define it thusly:
     * Given the root of a tree, the weight of each of its branches is
       the number of nodes contained in that branch;
     * A cannonical rooted tree would have its direct subtrees ordered
       in descending order by weight;
     * In case multiple subtrees are the same weight, they are ordered
       by some unstated, but definite, order (this code doesn't really
       care what the ordering is; it only counts the number of choices
       in such a case, not enumerating individual trees.)

   A rooted tree of N nodes can then be constructed by adding smaller,
   cannonical rooted trees to a root node, such that:
     * Each subtree has fewer than BRANCH branches (since it must have
       an empty slot for an edge to connect to the new root);
     * Weight of those subtrees added later are no higher than earlier
       ones;
     * Their weight total N-1.
   A rooted tree so constructed would be itself cannonical.

   For an unrooted tree, we can define the radius of any of its nodes:
   it's the maximum weight of any of the subtrees if this node is used
   as the root.  A node is the center of a tree if it has the smallest
   radius among all the nodes.  A tree can have either one or two such
   centers; if two, they must be adjacent (cf. Knuth, tAoCP 2.3.4.4).

   An important fact is that, a node in a tree is its sole center, IFF
   its radius times 2 is no greater than the sum of the weights of all
   branches (ibid).  While we are making rooted trees, we can add such
   trees encountered to the count of cannonical unrooted trees.

   A bi-centered unrooted tree with N nodes can be made by joining two
   trees, each with N/2 nodes and fewer than BRANCH subtrees, at root.
   The pair must be ordered in aforementioned implicit way so that the
   product is cannonical. */

typedef unsigned long long xint;
#define FMT "llu"

xint rooted[MAX_N] = {1, 1, 0};
xint unrooted[MAX_N] = {1, 1, 0};

/* choose k out of m possible values; chosen values may repeat, but the
   ordering of them does not matter.  It's binomial(m + k - 1, k) */
xint choose(xint m, xint k)
{
	xint i, r;

	if (k == 1) return m;
	for (r = m, i = 1; i < k; i++)
		r = r * (m + i) / (i + 1);
	return r;
}

/* constructing rooted trees of BR branches at root, with at most
   N radius, and SUM nodes in the partial tree already built. It's
   recursive, and CNT and L carry down the number of combinations
   and the tree radius already encountered. */
void tree(xint br, xint n, xint cnt, xint sum, xint l)
{
	xint b, c, m, s;

	for (b = br + 1; b <= BRANCH; b++) {
		s = sum + (b - br) * n;
		if (s >= MAX_N) return;

		/* First B of BR branches are all of weight n; the
		   rest are at most of weight N-1 */
		c = choose(rooted[n], b - br) * cnt;

		/* This partial tree is singly centered as is */
		if (l * 2 < s) unrooted[s] += c;

		/* Trees saturate at root can't be used as building
		   blocks for larger trees, so forget them */
		if (b == BRANCH) return;
		rooted[s] += c;

		/* Build the rest of the branches */
		for (m = n; --m; ) tree(b, m, c, s, l);
	}
}

void bicenter(int s)
{
	if (s & 1) return;

	/* Pick two of the half-size building blocks, allowing
	   repetition. */
	unrooted[s] += rooted[s/2] * (rooted[s/2] + 1) / 2;
}

int main()
{
	xint n;
	for (n = 1; n < MAX_N; n++) {
		tree(0, n, 1, 1, n);
		bicenter(n);
		printf("%"FMT": %"FMT"\n", n, unrooted[n]);
	}

	return 0;
}
`,`#include "paraffins-1.h"



ulong _choose(ulong param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_8;
  
  local_8 = param_1;
  if (param_2 != 1) {
    local_28 = param_1;
    for (local_20 = 1; local_20 < param_2; local_20 = local_20 + 1) {
      uVar1 = local_28 * (param_1 + local_20);
      local_28 = 0;
      if (local_20 + 1 != 0) {
        local_28 = uVar1 / (local_20 + 1);
      }
    }
    local_8 = local_28;
  }
  return local_8;
}



void _tree(long param_1,long param_2,long param_3,long param_4,long param_5)

{
  ulong uVar1;
  long lVar2;
  long local_50;
  ulong local_40;
  
  local_40 = param_1 + 1;
  while( true ) {
    if ((4 < local_40) || (uVar1 = param_4 + (local_40 - param_1) * param_2, 0x20 < uVar1)) {
      return;
    }
    lVar2 = _choose(*(undefined8 *)(&_rooted + param_2 * 8),local_40 - param_1);
    lVar2 = lVar2 * param_3;
    if ((ulong)(param_5 * 2) < uVar1) {
      *(long *)(&_unrooted + uVar1 * 8) = *(long *)(&_unrooted + uVar1 * 8) + lVar2;
    }
    if (local_40 == 4) break;
    *(long *)(&_rooted + uVar1 * 8) = *(long *)(&_rooted + uVar1 * 8) + lVar2;
    local_50 = param_2;
    while (local_50 = local_50 + -1, local_50 != 0) {
      _tree(local_40,local_50,lVar2,uVar1,param_5);
    }
    local_40 = local_40 + 1;
  }
  return;
}



void _bicenter(uint param_1)

{
  if ((param_1 & 1) == 0) {
    *(ulong *)(&_unrooted + (long)(int)param_1 * 8) =
         *(long *)(&_unrooted + (long)(int)param_1 * 8) +
         (ulong)(*(long *)(&_rooted + (long)((int)param_1 / 2) * 8) *
                (*(long *)(&_rooted + (long)((int)param_1 / 2) * 8) + 1)) / 2;
  }
  return;
}



undefined8 entry(void)

{
  ulong local_20;
  
  for (local_20 = 1; local_20 < 0x21; local_20 = local_20 + 1) {
    _tree(0,local_20,1,1,local_20);
    _bicenter(local_20);
    _printf("%llu: %llu\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>

#define TRUE    1
#define FALSE   0

#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))

double jaro(const char *str1, const char *str2) {
    // length of the strings
    int str1_len = strlen(str1);
    int str2_len = strlen(str2);

    // if both strings are empty return 1
    // if only one of the strings is empty return 0
    if (str1_len == 0) return str2_len == 0 ? 1.0 : 0.0;

    // max distance between two chars to be considered matching
    // floor() is ommitted due to integer division rules
    int match_distance = (int) max(str1_len, str2_len)/2 - 1;

    // arrays of bools that signify if that char in the matching string has a match
    int *str1_matches = calloc(str1_len, sizeof(int));
    int *str2_matches = calloc(str2_len, sizeof(int));

    // number of matches and transpositions
    double matches = 0.0;
    double transpositions = 0.0;

    // find the matches
    for (int i = 0; i < str1_len; i++) {
        // start and end take into account the match distance
        int start = max(0, i - match_distance);
        int end = min(i + match_distance + 1, str2_len);

        for (int k = start; k < end; k++) {
            // if str2 already has a match continue
            if (str2_matches[k]) continue;
            // if str1 and str2 are not
            if (str1[i] != str2[k]) continue;
            // otherwise assume there is a match
            str1_matches[i] = TRUE;
            str2_matches[k] = TRUE;
            matches++;
            break;
        }
    }

    // if there are no matches return 0
    if (matches == 0) {
        free(str1_matches);
        free(str2_matches);
        return 0.0;
    }

    // count transpositions
    int k = 0;
    for (int i = 0; i < str1_len; i++) {
        // if there are no matches in str1 continue
        if (!str1_matches[i]) continue;
        // while there is no match in str2 increment k
        while (!str2_matches[k]) k++;
        // increment transpositions
        if (str1[i] != str2[k]) transpositions++;
        k++;
    }

    // divide the number of transpositions by two as per the algorithm specs
    // this division is valid because the counted transpositions include both
    // instances of the transposed characters.
    transpositions /= 2.0;

    // free the allocated memory
    free(str1_matches);
    free(str2_matches);

    // return the Jaro distance
    return ((matches / str1_len) +
        (matches / str2_len) +
        ((matches - transpositions) / matches)) / 3.0;
}

int main() {
    printf("%f\n", jaro("MARTHA",    "MARHTA"));
    printf("%f\n", jaro("DIXON",     "DICKSONX"));
    printf("%f\n", jaro("JELLYFISH", "SMELLYFISH"));
}
`,`#include "jaro-similarity.h"



undefined  [16] _jaro(char *param_1,char *param_2)

{
  int iVar1;
  size_t sVar2;
  void *pvVar3;
  void *pvVar4;
  int iVar5;
  int iVar6;
  undefined auVar7 [16];
  int local_88;
  int local_84;
  int local_74;
  int local_70;
  int local_6c;
  int local_68;
  int local_5c;
  double local_58;
  double local_50;
  double local_18;
  
  sVar2 = _strlen(param_1);
  iVar5 = (int)sVar2;
  sVar2 = _strlen(param_2);
  iVar6 = (int)sVar2;
  if (iVar5 == 0) {
    local_18 = 1.0;
    if (iVar6 != 0) {
      local_18 = 0.0;
    }
  }
  else {
    local_74 = iVar6;
    if (iVar6 < iVar5) {
      local_74 = iVar5;
    }
    iVar1 = local_74 / 2 + -1;
    pvVar3 = _calloc((long)iVar5,4);
    pvVar4 = _calloc((long)iVar6,4);
    local_50 = 0.0;
    local_58 = 0.0;
    for (local_5c = 0; local_5c < iVar5; local_5c = local_5c + 1) {
      if (local_5c - iVar1 < 0) {
        local_84 = 0;
      }
      else {
        local_84 = local_5c - iVar1;
      }
      local_88 = iVar6;
      if (local_5c + iVar1 + 1 < iVar6) {
        local_88 = local_5c + iVar1 + 1;
      }
      for (local_68 = local_84; local_68 < local_88; local_68 = local_68 + 1) {
        if ((*(int *)((long)pvVar4 + (long)local_68 * 4) == 0) &&
           (param_1[local_5c] == param_2[local_68])) {
          *(undefined4 *)((long)pvVar3 + (long)local_5c * 4) = 1;
          *(undefined4 *)((long)pvVar4 + (long)local_68 * 4) = 1;
          local_50 = local_50 + 1.0;
          break;
        }
      }
    }
    if (local_50 == 0.0) {
      _free(pvVar3);
      _free(pvVar4);
      local_18 = 0.0;
    }
    else {
      local_6c = 0;
      for (local_70 = 0; local_70 < iVar5; local_70 = local_70 + 1) {
        if (*(int *)((long)pvVar3 + (long)local_70 * 4) != 0) {
          while (*(int *)((long)pvVar4 + (long)local_6c * 4) == 0) {
            local_6c = local_6c + 1;
          }
          if (param_1[local_70] != param_2[local_6c]) {
            local_58 = local_58 + 1.0;
          }
          local_6c = local_6c + 1;
        }
      }
      _free(pvVar3);
      _free(pvVar4);
      local_18 = (local_50 / (double)(long)iVar5 + local_50 / (double)(long)iVar6 +
                 (local_50 - local_58 / 2.0) / local_50) / 3.0;
    }
  }
  auVar7._8_8_ = 0;
  auVar7._0_8_ = local_18;
  return auVar7;
}



undefined8 entry(void)

{
  _jaro("MARTHA","MARHTA");
  _printf("%f\n");
  _jaro("DIXON","DICKSONX");
  _printf("%f\n");
  _jaro("JELLYFISH","SMELLYFISH");
  _printf("%f\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004018)();
  return sVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h>

typedef struct{
	double x,y;
}point;

double shoelace(char* inputFile){
	int i,numPoints;
	double leftSum = 0,rightSum = 0;
	
	point* pointSet;
	FILE* fp = fopen(inputFile,"r");
	
	fscanf(fp,"%d",&numPoints);
	
	pointSet = (point*)malloc((numPoints + 1)*sizeof(point));
	
	for(i=0;i<numPoints;i++){
		fscanf(fp,"%lf %lf",&pointSet[i].x,&pointSet[i].y);
	}
	
	fclose(fp);
	
	pointSet[numPoints] = pointSet[0];
	
	for(i=0;i<numPoints;i++){
		leftSum += pointSet[i].x*pointSet[i+1].y;
		rightSum += pointSet[i+1].x*pointSet[i].y;
	}
	
	free(pointSet);
	
	return 0.5*fabs(leftSum - rightSum);
}

int main(int argC,char* argV[])
{
	if(argC==1)
		printf("\nUsage : %s <full path of polygon vertices file>",argV[0]);
	
	else
		printf("The polygon area is %lf square units.",shoelace(argV[1]));
	
	return 0;
}
`,`#include "shoelace-formula-for-polygonal-area.h"



undefined  [16] _shoelace(char *param_1)

{
  FILE *pFVar1;
  undefined8 *puVar2;
  undefined8 uVar3;
  undefined auVar4 [16];
  double local_30;
  double local_28;
  int local_20;
  int local_1c;
  
  local_28 = 0.0;
  local_30 = 0.0;
  pFVar1 = _fopen(param_1,"r");
  _fscanf(pFVar1,"%d");
  puVar2 = (undefined8 *)_malloc((long)(local_20 + 1) << 4);
  for (local_1c = 0; local_1c < local_20; local_1c = local_1c + 1) {
    _fscanf(pFVar1,"%lf %lf");
  }
  _fclose(pFVar1);
  uVar3 = *puVar2;
  (puVar2 + (long)local_20 * 2)[1] = puVar2[1];
  puVar2[(long)local_20 * 2] = uVar3;
  for (local_1c = 0; local_1c < local_20; local_1c = local_1c + 1) {
    local_28 = (double)NEON_fmadd(puVar2[(long)local_1c * 2],puVar2[(long)(local_1c + 1) * 2 + 1],
                                  local_28);
    local_30 = (double)NEON_fmadd(puVar2[(long)(local_1c + 1) * 2],puVar2[(long)local_1c * 2 + 1],
                                  local_30);
  }
  _free(puVar2);
  auVar4._0_8_ = ABS(local_28 - local_30) * 0.5;
  auVar4._8_8_ = 0;
  return auVar4;
}



undefined8 entry(int param_1,long param_2)

{
  if (param_1 == 1) {
    _printf("\nUsage : %s <full path of polygon vertices file>");
  }
  else {
    _shoelace(*(undefined8 *)(param_2 + 8));
    _printf("The polygon area is %lf square units.");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004008)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define for_x for (int x = 0; x < w; x++)
#define for_y for (int y = 0; y < h; y++)
#define for_xy for_x for_y
void show(void *u, int w, int h)
{
	int (*univ)[w] = u;
	printf("\033[H");
	for_y {
		for_x printf(univ[y][x] ? "\033[07m  \033[m" : "  ");
		printf("\033[E");
	}
	fflush(stdout);
}

void evolve(void *u, int w, int h)
{
	unsigned (*univ)[w] = u;
	unsigned new[h][w];

	for_y for_x {
		int n = 0;
		for (int y1 = y - 1; y1 <= y + 1; y1++)
			for (int x1 = x - 1; x1 <= x + 1; x1++)
				if (univ[(y1 + h) % h][(x1 + w) % w])
					n++;

		if (univ[y][x]) n--;
		new[y][x] = (n == 3 || (n == 2 && univ[y][x]));
	}
	for_y for_x univ[y][x] = new[y][x];
}

void game(int w, int h)
{
	unsigned univ[h][w];
	for_xy univ[y][x] = rand() < RAND_MAX / 10 ? 1 : 0;
	while (1) {
		show(univ, w, h);
		evolve(univ, w, h);
		usleep(200000);
	}
}

int main(int c, char **v)
{
	int w = 0, h = 0;
	if (c > 1) w = atoi(v[1]);
	if (c > 2) h = atoi(v[2]);
	if (w <= 0) w = 30;
	if (h <= 0) h = 30;
	game(w, h);
}
`,`#include "conways-game-of-life-1.h"



int _show(long param_1,uint param_2,int param_3)

{
  char *pcVar1;
  int iVar2;
  int local_30;
  int local_2c;
  
  _printf("\x1b[H");
  for (local_2c = 0; local_2c < param_3; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < (int)param_2; local_30 = local_30 + 1) {
      pcVar1 = "\x1b[07m  \x1b[m";
      if (*(int *)(param_1 + (long)local_2c * (ulong)param_2 * 4 + (long)local_30 * 4) == 0) {
        pcVar1 = "  ";
      }
      _printf(pcVar1);
    }
    _printf("\x1b[E");
  }
  iVar2 = _fflush(*(FILE **)PTR____stdoutp_100004018);
  return iVar2;
}



void _evolve(long param_1,uint param_2,uint param_3)

{
  int iVar1;
  int iVar2;
  undefined *local_a0;
  uint local_98;
  uint local_94;
  ulong local_90;
  ulong local_88;
  ulong local_80;
  ulong local_78;
  long local_70;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  ulong local_40;
  undefined *local_38;
  long local_30;
  uint local_28;
  uint local_24;
  long local_20;
  long local_18;
  
  local_38 = (undefined *)&local_a0;
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_90 = (ulong)param_2;
  local_78 = (ulong)param_3;
  local_88 = (ulong)param_2;
  local_80 = local_78 * local_88 * 4 + 0xf & 0xfffffffffffffff0;
  local_30 = param_1;
  local_28 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_70 = (long)&local_a0 - local_80;
  local_40 = local_78;
  for (local_4c = 0; local_4c < (int)local_28; local_4c = local_4c + 1) {
    for (local_50 = 0; local_50 < (int)local_24; local_50 = local_50 + 1) {
      local_54 = 0;
      for (local_58 = local_4c + -1; local_58 <= local_4c + 1; local_58 = local_58 + 1) {
        for (local_5c = local_50 + -1; local_5c <= local_50 + 1; local_5c = local_5c + 1) {
          iVar1 = 0;
          if (local_28 != 0) {
            iVar1 = (int)(local_58 + local_28) / (int)local_28;
          }
          iVar2 = 0;
          if (local_24 != 0) {
            iVar2 = (int)(local_5c + local_24) / (int)local_24;
          }
          if (*(int *)(local_30 +
                       (long)(int)((local_58 + local_28) - iVar1 * local_28) * local_90 * 4 +
                      (long)(int)((local_5c + local_24) - iVar2 * local_24) * 4) != 0) {
            local_54 = local_54 + 1;
          }
        }
      }
      if (*(int *)(local_30 + (long)local_4c * local_90 * 4 + (long)local_50 * 4) != 0) {
        local_54 = local_54 + -1;
      }
      local_94 = 1;
      if (local_54 != 3) {
        local_98 = 0;
        if (local_54 == 2) {
          local_98 = (uint)(*(int *)(local_30 + (long)local_4c * local_90 * 4 + (long)local_50 * 4)
                           != 0);
        }
        local_94 = local_98;
      }
      *(uint *)(local_70 + (long)local_4c * local_88 * 4 + (long)local_50 * 4) = local_94;
    }
  }
  for (local_60 = 0; local_60 < (int)local_28; local_60 = local_60 + 1) {
    for (local_64 = 0; local_64 < (int)local_24; local_64 = local_64 + 1) {
      *(undefined4 *)(local_30 + (long)local_60 * local_90 * 4 + (long)local_64 * 4) =
           *(undefined4 *)(local_70 + (long)local_60 * local_88 * 4 + (long)local_64 * 4);
    }
  }
  local_a0 = local_38;
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void _game(uint param_1,uint param_2)

{
  int iVar1;
  undefined auStack_60 [8];
  ulong local_58;
  ulong local_50;
  ulong local_48;
  undefined *local_40;
  int local_38;
  int local_34;
  ulong local_28;
  undefined *local_20;
  uint local_18;
  uint local_14;
  
  local_20 = auStack_60;
  local_48 = (ulong)param_2;
  local_58 = (ulong)param_1;
  local_50 = local_48 * local_58 * 4 + 0xf & 0xfffffffffffffff0;
  local_18 = param_2;
  local_14 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_40 = auStack_60 + -local_50;
  local_28 = local_48;
  for (local_34 = 0; local_34 < (int)local_14; local_34 = local_34 + 1) {
    for (local_38 = 0; local_38 < (int)local_18; local_38 = local_38 + 1) {
      iVar1 = _rand();
      *(uint *)(local_40 + (long)local_34 * 4 + (long)local_38 * local_58 * 4) =
           (uint)(iVar1 < 0xccccccc);
    }
  }
  do {
    _show(local_40,local_14,local_18);
    _evolve(local_40,local_14,local_18);
    _usleep(200000);
  } while( true );
}



undefined4 entry(int param_1,long param_2)

{
  undefined4 local_28;
  undefined4 local_24;
  
  local_24 = 0;
  local_28 = 0;
  if (1 < param_1) {
    local_24 = _atoi(*(char **)(param_2 + 8));
  }
  if (2 < param_1) {
    local_28 = _atoi(*(char **)(param_2 + 0x10));
  }
  if (local_24 < 1) {
    local_24 = 0x1e;
  }
  if (local_28 < 1) {
    local_28 = 0x1e;
  }
  _game(local_24,local_28);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004038)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004040)(param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

unsigned long long bruteForceProperDivisorSum(unsigned long long n){
	unsigned long long i,sum = 0;
	
	for(i=1;i<(n+1)/2;i++)
		if(n%i==0 && n!=i)
			sum += i;
		
	return sum;
}

void printSeries(unsigned long long* arr,int size,char* type){
	int i;
	
	printf("\nInteger : %llu, Type : %s, Series : ",arr[0],type);
	
	for(i=0;i<size-1;i++)
		printf("%llu, ",arr[i]);
	printf("%llu",arr[i]);
}

void aliquotClassifier(unsigned long long n){
	unsigned long long arr[16];
	int i,j;
	
	arr[0] = n;
	
	for(i=1;i<16;i++){
		arr[i] = bruteForceProperDivisorSum(arr[i-1]);
		
		if(arr[i]==0||arr[i]==n||(arr[i]==arr[i-1] && arr[i]!=n)){
			printSeries(arr,i+1,(arr[i]==0)?"Terminating":(arr[i]==n && i==1)?"Perfect":(arr[i]==n && i==2)?"Amicable":(arr[i]==arr[i-1] && arr[i]!=n)?"Aspiring":"Sociable");
			return;
		}
		
		for(j=1;j<i;j++){
			if(arr[j]==arr[i]){
				printSeries(arr,i+1,"Cyclic");
				return;
			}
		}
	}
	
	printSeries(arr,i+1,"Non-Terminating");
}

void processFile(char* fileName){
	FILE* fp = fopen(fileName,"r");
	char str[21];
	
	while(fgets(str,21,fp)!=NULL)
		aliquotClassifier(strtoull(str,(char**)NULL,10));
	
	fclose(fp);
}

int main(int argC,char* argV[])
{
    if(argC!=2)
		printf("Usage : %s <positive integer>",argV[0]);
	else{
		if(strchr(argV[1],'.')!=NULL)
			processFile(argV[1]);
		else
			aliquotClassifier(strtoull(argV[1],(char**)NULL,10));
	}
	return 0;
}
`,`#include "aliquot-sequence-classifications-1.h"



long _bruteForceProperDivisorSum(ulong param_1)

{
  ulong uVar1;
  undefined8 local_18;
  undefined8 local_10;
  
  local_18 = 0;
  for (local_10 = 1; local_10 < (param_1 + 1) / 2; local_10 = local_10 + 1) {
    uVar1 = 0;
    if (local_10 != 0) {
      uVar1 = param_1 / local_10;
    }
    if ((param_1 == uVar1 * local_10) && (param_1 != local_10)) {
      local_18 = local_18 + local_10;
    }
  }
  return local_18;
}



int _printSeries(undefined8 param_1,int param_2)

{
  int iVar1;
  int local_2c;
  
  _printf("\nInteger : %llu, Type : %s, Series : ");
  for (local_2c = 0; local_2c < param_2 + -1; local_2c = local_2c + 1) {
    _printf("%llu, ");
  }
  iVar1 = _printf("%llu");
  return iVar1;
}



void _aliquotClassifier(long param_1)

{
  bool bVar1;
  long lVar2;
  char *local_d0;
  char *local_c8;
  char *local_c0;
  int local_a8;
  int local_a4;
  long local_98 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_98[0] = param_1;
  local_a4 = 1;
  do {
    if (0xf < local_a4) {
      _printSeries(local_98,local_a4 + 1,"Non-Terminating");
LAB_100003d30:
      if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
        return;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    lVar2 = _bruteForceProperDivisorSum(local_98[local_a4 + -1]);
    local_98[local_a4] = lVar2;
    if (((local_98[local_a4] == 0) || (local_98[local_a4] == param_1)) ||
       ((local_98[local_a4] == local_98[local_a4 + -1] && (local_98[local_a4] != param_1)))) {
      if (local_98[local_a4] == 0) {
        local_c0 = "Terminating";
      }
      else {
        if ((local_98[local_a4] == param_1) && (local_a4 == 1)) {
          local_c8 = "Perfect";
        }
        else {
          if ((local_98[local_a4] == param_1) && (local_a4 == 2)) {
            local_d0 = "Amicable";
          }
          else {
            bVar1 = false;
            if (local_98[local_a4] == local_98[local_a4 + -1]) {
              bVar1 = local_98[local_a4] != param_1;
            }
            local_d0 = "Aspiring";
            if (!bVar1) {
              local_d0 = "Sociable";
            }
          }
          local_c8 = local_d0;
        }
        local_c0 = local_c8;
      }
      _printSeries(local_98,local_a4 + 1,local_c0);
      goto LAB_100003d30;
    }
    for (local_a8 = 1; local_a8 < local_a4; local_a8 = local_a8 + 1) {
      if (local_98[local_a8] == local_98[local_a4]) {
        _printSeries(local_98,local_a4 + 1,"Cyclic");
        goto LAB_100003d30;
      }
    }
    local_a4 = local_a4 + 1;
  } while( true );
}



void _processFile(char *param_1)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  char acStack_2d [21];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pFVar2 = _fopen(param_1,"r");
  while (pcVar3 = _fgets(acStack_2d,0x15,pFVar2), pcVar3 != (char *)0x0) {
    _strtoull(acStack_2d,(char **)0x0,10);
    _aliquotClassifier();
  }
  iVar1 = _fclose(pFVar2);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  char *pcVar1;
  
  if (param_1 == 2) {
    pcVar1 = _strchr(*(char **)(param_2 + 8),0x2e);
    if (pcVar1 == (char *)0x0) {
      _strtoull(*(char **)(param_2 + 8),(char **)0x0,10);
      _aliquotClassifier();
    }
    else {
      _processFile(*(undefined8 *)(param_2 + 8));
    }
  }
  else {
    _printf("Usage : %s <positive integer>");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004030)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulonglong _strtoull(char *param_1,char **param_2,int param_3)

{
  ulonglong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoull_100004038)(param_1,param_2,param_3);
  return uVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

typedef struct {
        int power;
        double * coef;
} poly_t, *poly;

#define E(x, i) (x)->coef[i]

/* passing in negative power to have a zeroed poly */
poly p_new(int power, ...)
{
        int i, zeroed = 0;
        va_list ap;

        if (power < 0) {
                power = -power;
                zeroed = 1;
        }

        poly p = malloc(sizeof(poly_t));
        p->power = power;
        p->coef = malloc(sizeof(double) * ++power);

        if (zeroed)
                for (i = 0; i < power; i++) p->coef[i] = 0;
        else {
                va_start(ap, power);
                for (i = 0; i < power; i++)
                        E(p, i) = va_arg(ap, double);
                va_end(ap);
        }

        return p;
}

void p_del(poly p)
{
        free(p->coef);
        free(p);
}

void p_print(poly p)
{
        int i;
        for (i = 0; i <= p->power; i++)
                printf("%g ", E(p, i));
        printf("\n");
}

poly p_copy(poly p)
{
        poly q = p_new(-p->power);
        memcpy(q->coef, p->coef, sizeof(double) * (1 + p->power));
        return q;
}

/* p: poly;  d: divisor;  r: remainder; returns quotient */
poly p_div(poly p, poly d, poly* r)
{
        poly q;
        int i, j;
        int power = p->power - d->power;
        double ratio;

        if (power < 0) return 0;

        q = p_new(-power);
        *r= p_copy(p);

        for (i = p->power; i >= d->power; i--) {
                E(q, i - d->power) = ratio = E(*r, i) / E(d, d->power);
                E(*r ,i) = 0;

                for (j = 0; j < d->power; j++)
                        E(*r, i - d->power + j) -= E(d, j) * ratio;
        }
        while (! E(*r, --(*r)->power));

        return q;
}

int main()
{
        poly p = p_new(3, 1., 2., 3., 4.);
        poly d = p_new(2, 1., 2., 1.);
        poly r;
        poly q = p_div(p, d, &r);

        printf("poly: "); p_print(p);
        printf("div:  "); p_print(d);
        printf("quot: "); p_print(q);
        printf("rem:  "); p_print(r);

        p_del(p);
        p_del(q);
        p_del(r);
        p_del(d);

        return 0;
}
`,`#include "polynomial-long-division-3.h"



int * _p_new(int param_1)

{
  int *piVar1;
  void *pvVar2;
  undefined8 uVar3;
  int local_18;
  int local_14;
  
  local_14 = param_1;
  if (param_1 < 0) {
    local_14 = -param_1;
  }
  piVar1 = (int *)_malloc(0x10);
  *piVar1 = local_14;
  local_14 = local_14 + 1;
  pvVar2 = _malloc((long)local_14 * 8);
  *(void **)(piVar1 + 2) = pvVar2;
  if (param_1 < 0) {
    for (local_18 = 0; local_18 < local_14; local_18 = local_18 + 1) {
      *(undefined8 *)(*(long *)(piVar1 + 2) + (long)local_18 * 8) = 0;
    }
  }
  else {
    for (local_18 = 0; local_18 < local_14; local_18 = local_18 + 1) {
      uVar3 = *(undefined8 *)register0x00000008;
      register0x00000008 = (BADSPACEBASE *)((long)register0x00000008 + 8);
      *(undefined8 *)(*(long *)(piVar1 + 2) + (long)local_18 * 8) = uVar3;
    }
  }
  return piVar1;
}



void _p_del(void *param_1)

{
  _free(*(void **)((long)param_1 + 8));
  _free(param_1);
  return;
}



int _p_print(int *param_1)

{
  int iVar1;
  int local_1c;
  
  for (local_1c = 0; local_1c <= *param_1; local_1c = local_1c + 1) {
    _printf("%g ");
  }
  iVar1 = _printf("\n");
  return iVar1;
}



long _p_copy(int *param_1)

{
  long lVar1;
  
  lVar1 = _p_new(-*param_1);
  ___memcpy_chk(*(undefined8 *)(lVar1 + 8),*(undefined8 *)(param_1 + 2),(long)(*param_1 + 1) * 8,
                0xffffffffffffffff);
  return lVar1;
}



long _p_div(int *param_1,int *param_2,long *param_3)

{
  undefined8 *puVar1;
  int iVar2;
  long lVar3;
  double dVar4;
  undefined8 uVar5;
  int local_40;
  int local_3c;
  long local_18;
  
  if (*param_1 - *param_2 < 0) {
    local_18 = 0;
  }
  else {
    local_18 = _p_new(-(*param_1 - *param_2));
    lVar3 = _p_copy(param_1);
    *param_3 = lVar3;
    for (local_3c = *param_1; *param_2 <= local_3c; local_3c = local_3c + -1) {
      dVar4 = *(double *)(*(long *)(*param_3 + 8) + (long)local_3c * 8) /
              *(double *)(*(long *)(param_2 + 2) + (long)*param_2 * 8);
      *(double *)(*(long *)(local_18 + 8) + (long)(local_3c - *param_2) * 8) = dVar4;
      *(undefined8 *)(*(long *)(*param_3 + 8) + (long)local_3c * 8) = 0;
      for (local_40 = 0; local_40 < *param_2; local_40 = local_40 + 1) {
        puVar1 = (undefined8 *)
                 (*(long *)(*param_3 + 8) + (long)((local_3c - *param_2) + local_40) * 8);
        uVar5 = NEON_fmsub(*(undefined8 *)(*(long *)(param_2 + 2) + (long)local_40 * 8),dVar4,
                           *puVar1);
        *puVar1 = uVar5;
      }
    }
    do {
      lVar3 = *(long *)(*param_3 + 8);
      iVar2 = *(int *)*param_3 + -1;
      *(int *)*param_3 = iVar2;
    } while (*(double *)(lVar3 + (long)iVar2 * 8) == 0.0);
  }
  return local_18;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = _p_new(3);
  local_28 = _p_new(2);
  uVar1 = _p_div(local_20,local_28,&local_30);
  _printf("poly: ");
  _p_print(local_20);
  _printf("div:  ");
  _p_print(local_28);
  _printf("quot: ");
  _p_print(uVar1);
  _printf("rem:  ");
  _p_print(local_30);
  _p_del(local_20);
  _p_del(uVar1);
  _p_del(local_30);
  _p_del(local_28);
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`/*
subject: Elliptic curve digital signature algorithm,
         toy version for small modulus N.
tested : gcc 4.6.3, tcc 0.9.27
*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 64-bit integer type
typedef long long int dlong;
// rational ec point
typedef struct {
   dlong x, y;
} epnt;
// elliptic curve parameters
typedef struct {
   long a, b;
   dlong N;
   epnt G;
   dlong r;
} curve;
// signature pair
typedef struct {
   long a, b;
} pair;

// dlong for holding intermediate results,
// long variables in exgcd() for efficiency,
// maximum parameter size 2 * p.y (line 129)
// limits the modulus size to 30 bits.

// maximum modulus
const long mxN = 1073741789;
// max order G = mxN + 65536
const long mxr = 1073807325;
// symbolic infinity
const long inf = -2147483647;

// single global curve
curve e;
// point at infinity zerO
epnt zerO;
// impossible inverse mod N
int inverr;


// return mod(v^-1, u)
long exgcd (long v, long u)
{
register long q, t;
long r = 0, s = 1;
if (v < 0) v += u;

   while (v) {
      q = u / v;
      t = u - q * v;
      u = v; v = t;
      t = r - q * s;
      r = s; s = t;
   }
   if (u != 1) {
      printf (" impossible inverse mod N, gcd = %d\n", u);
      inverr = 1;
   }
return r;
}

// return mod(a, N)
static inline dlong modn (dlong a)
{
   a %= e.N;
   if (a < 0) a += e.N;
return a;
}

// return mod(a, r)
dlong modr (dlong a)
{
   a %= e.r;
   if (a < 0) a += e.r;
return a;
}


// return the discriminant of E
long disc (void)
{
dlong c, a = e.a, b = e.b;
   c = 4 * modn(a * modn(a * a));
return modn(-16 * (c + 27 * modn(b * b)));
}

// return 1 if P = zerO
int isO (epnt p)
{
return (p.x == inf) && (p.y == 0);
}

// return 1 if P is on curve E
int ison (epnt p)
{
long r, s;
if (! isO (p)) {
   r = modn(e.b + p.x * modn(e.a + p.x * p.x));
   s = modn(p.y * p.y);
}
return (r == s);
}


// full ec point addition
void padd (epnt *r, epnt p, epnt q)
{
dlong la, t;

if (isO(p)) {*r = q; return;}
if (isO(q)) {*r = p; return;}

if (p.x != q.x) {                    // R:= P + Q
   t = p.y - q.y;
   la = modn(t * exgcd(p.x - q.x, e.N));
}
else                                 // P = Q, R := 2P
   if ((p.y == q.y) && (p.y != 0)) {
      t = modn(3 * modn(p.x * p.x) + e.a);
      la = modn(t * exgcd (2 * p.y, e.N));
   }
   else
      {*r = zerO; return;}           // P = -Q, R := O

t = modn(la * la - p.x - q.x);
r->y = modn(la * (p.x - t) - p.y);
r->x = t; if (inverr) *r = zerO;
}

// R:= multiple kP
void pmul (epnt *r, epnt p, long k)
{
epnt s = zerO, q = p;

   for (; k; k >>= 1) {
      if (k & 1) padd(&s, s, q);
      if (inverr) {s = zerO; break;}
      padd(&q, q, q);
   }
*r = s;
}


// print point P with prefix f
void pprint (char *f, epnt p)
{
dlong y = p.y;

   if (isO (p))
      printf ("%s (0)\n", f);

   else {
      if (y > e.N - y) y -= e.N;
      printf ("%s (%lld, %lld)\n", f, p.x, y);
   }
}

// initialize elliptic curve
int ellinit (long i[])
{
long a = i[0], b = i[1];
   e.N = i[2]; inverr = 0;

if ((e.N < 5) || (e.N > mxN)) return 0;

   e.a = modn(a);
   e.b = modn(b);
   e.G.x = modn(i[3]);
   e.G.y = modn(i[4]);
   e.r = i[5];

if ((e.r < 5) || (e.r > mxr)) return 0;

printf ("\nE: y^2 = x^3 + %dx + %d", a, b);
printf (" (mod %lld)\n", e.N);
pprint ("base point G", e.G);
printf ("order(G, E) = %lld\n", e.r);

return 1;
}

// pseudorandom number [0..1)
double rnd(void)
{
return rand() / ((double)RAND_MAX + 1);
}

// signature primitive
pair signature (dlong s, long f)
{
long c, d, u, u1;
pair sg;
epnt V;

printf ("\nsignature computation\n");
do {
   do {
      u = 1 + (long)(rnd() * (e.r - 1));
      pmul (&V, e.G, u);
      c = modr(V.x);
   }
   while (c == 0);

   u1 = exgcd (u, e.r);
   d = modr(u1 * (f + modr(s * c)));
}
while (d == 0);
printf ("one-time u = %d\n", u);
pprint ("V = uG", V);

sg.a = c; sg.b = d;
return sg;
}

// verification primitive
int verify (epnt W, long f, pair sg)
{
long c = sg.a, d = sg.b;
long t, c1, h1, h2;
dlong h;
epnt V, V2;

   // domain check
   t = (c > 0) && (c < e.r);
   t &= (d > 0) && (d < e.r);
   if (! t) return 0;

printf ("\nsignature verification\n");
   h = exgcd (d, e.r);
   h1 = modr(f * h);
   h2 = modr(c * h);
   printf ("h1,h2 = %d, %d\n", h1,h2);
   pmul (&V, e.G, h1);
   pmul (&V2, W, h2);
   pprint ("h1G", V);
   pprint ("h2W", V2);
   padd (&V, V, V2);
   pprint ("+ =", V);
   if (isO (V)) return 0;
   c1 = modr(V.x);
   printf ("c' = %d\n", c1);

return (c1 == c);
}

// digital signature on message hash f, error bit d
void ec_dsa (long f, long d)
{
long i, s, t;
pair sg;
epnt W;

   // parameter check
   t = (disc() == 0);
   t |= isO (e.G);
   pmul (&W, e.G, e.r);
   t |= ! isO (W);
   t |= ! ison (e.G);
   if (t) goto errmsg;

printf ("\nkey generation\n");
   s = 1 + (long)(rnd() * (e.r - 1));
   pmul (&W, e.G, s);
   printf ("private key s = %d\n", s);
   pprint ("public key W = sG", W);

   // next highest power of 2 - 1
   t = e.r;
   for (i = 1; i < 32; i <<= 1)
      t |= t >> i;
   while (f > t) f >>= 1;
   printf ("\naligned hash %x\n", f);

   sg = signature (s, f);
   if (inverr) goto errmsg;
   printf ("signature c,d = %d, %d\n", sg.a, sg.b);

   if (d > 0) {
      while (d > t) d >>= 1;
      f ^= d;
      printf ("\ncorrupted hash %x\n", f);
   }

   t = verify (W, f, sg);
   if (inverr) goto errmsg;
   if (t)
      printf ("Valid\n_____\n");
   else
      printf ("invalid\n_______\n");

   return;

errmsg:
printf ("invalid parameter set\n");
printf ("_____________________\n");
}


void main (void)
{
typedef long eparm[6];
long d, f;
zerO.x = inf; zerO.y = 0;
srand(time(NULL));

// Test vectors: elliptic curve domain parameters,
// short Weierstrass model y^2 = x^3 + ax + b (mod N)
eparm *sp, sets[10] = {
//    a,   b,  modulus N, base point G, order(G, E), cofactor
   {355, 671, 1073741789, 13693, 10088, 1073807281},
   {  0,   7,   67096021,  6580,   779,   16769911}, // 4
   { -3,   1,     877073,     0,     1,     878159},
   {  0,  14,      22651,    63,    30,        151}, // 151
   {  3,   2,          5,     2,     1,          5},

// ecdsa may fail if...
// the base point is of composite order
   {  0,   7,   67096021,  2402,  6067,   33539822}, // 2
// the given order is a multiple of the true order
   {  0,   7,   67096021,  6580,   779,   67079644}, // 1
// the modulus is not prime (deceptive example)
   {  0,   7,     877069,     3, 97123,     877069},
// fails if the modulus divides the discriminant
   { 39, 387,      22651,    95,    27,      22651},
};
// Digital signature on message hash f,
// set d > 0 to simulate corrupted data
   f = 0x789abcde; d = 0;

   for (sp = sets; ; sp++) {
      if (ellinit (*sp))
         ec_dsa (f, d);

      else
         break;
   }
}
`,`#include "elliptic-curve-digital-signature-algorithm.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long _exgcd(long param_1,long param_2)

{
  long lVar1;
  long lVar2;
  long local_40;
  long local_38;
  long local_20;
  long local_18;
  
  local_38 = 0;
  local_40 = 1;
  local_20 = param_2;
  local_18 = param_1;
  if (param_1 < 0) {
    local_18 = param_1 + param_2;
  }
  while (local_18 != 0) {
    lVar1 = 0;
    if (local_18 != 0) {
      lVar1 = local_20 / local_18;
    }
    lVar2 = local_20 - lVar1 * local_18;
    local_20 = local_18;
    lVar1 = local_38 - lVar1 * local_40;
    local_38 = local_40;
    local_40 = lVar1;
    local_18 = lVar2;
  }
  if (local_20 != 1) {
    _printf(" impossible inverse mod N, gcd = %d\n");
    __inverr = 1;
  }
  return local_38;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long _modr(long param_1)

{
  long lVar1;
  undefined8 local_8;
  
  lVar1 = 0;
  if (_DAT_100008028 != 0) {
    lVar1 = param_1 / _DAT_100008028;
  }
  local_8 = param_1 - lVar1 * _DAT_100008028;
  if (local_8 < 0) {
    local_8 = local_8 + _DAT_100008028;
  }
  return local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _disc(void)

{
  long lVar1;
  long lVar2;
  long lVar3;
  
  lVar3 = _DAT_100008008;
  lVar2 = __e;
  lVar1 = FUN_100002c8c(__e * __e);
  lVar2 = FUN_100002c8c(lVar2 * lVar1);
  lVar3 = FUN_100002c8c(lVar3 * lVar3);
  FUN_100002c8c((lVar2 * 4 + lVar3 * 0x1b) * -0x10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long FUN_100002c8c(long param_1)

{
  long lVar1;
  undefined8 local_8;
  
  lVar1 = 0;
  if (_DAT_100008010 != 0) {
    lVar1 = param_1 / _DAT_100008010;
  }
  local_8 = param_1 - lVar1 * _DAT_100008010;
  if (local_8 < 0) {
    local_8 = local_8 + _DAT_100008010;
  }
  return local_8;
}



bool _isO(long param_1,long param_2)

{
  return param_1 == -0x7fffffff && param_2 == 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool _ison(long param_1,long param_2)

{
  long lVar1;
  int iVar2;
  long lVar3;
  undefined8 local_30;
  undefined8 local_28;
  
  iVar2 = _isO(param_1,param_2);
  lVar1 = _DAT_100008008;
  if (iVar2 == 0) {
    lVar3 = FUN_100002c8c(__e + param_1 * param_1);
    local_28 = FUN_100002c8c(lVar1 + param_1 * lVar3);
    local_30 = FUN_100002c8c(param_2 * param_2);
  }
  return local_28 == local_30;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _padd(long *param_1,long param_2,long param_3,long param_4,long param_5)

{
  int iVar1;
  long lVar2;
  long lVar3;
  long local_40;
  
  iVar1 = _isO(param_2,param_3);
  if (iVar1 == 0) {
    iVar1 = _isO(param_4,param_5);
    lVar2 = __zerO;
    if (iVar1 == 0) {
      if (param_2 == param_4) {
        if ((param_3 != param_5) || (param_3 == 0)) {
          param_1[1] = _DAT_100008040;
          *param_1 = lVar2;
          return;
        }
        lVar2 = FUN_100002c8c(param_2 * param_2);
        lVar2 = FUN_100002c8c(lVar2 * 3 + __e);
        lVar3 = _exgcd(param_3 * 2,_DAT_100008010);
        local_40 = FUN_100002c8c(lVar2 * lVar3);
      }
      else {
        lVar2 = _exgcd(param_2 - param_4,_DAT_100008010);
        local_40 = FUN_100002c8c((param_3 - param_5) * lVar2);
      }
      lVar2 = FUN_100002c8c((local_40 * local_40 - param_2) - param_4);
      lVar3 = FUN_100002c8c(local_40 * (param_2 - lVar2) - param_3);
      param_1[1] = lVar3;
      *param_1 = lVar2;
      lVar2 = __zerO;
      if (__inverr != 0) {
        param_1[1] = _DAT_100008040;
        *param_1 = lVar2;
      }
    }
    else {
      param_1[1] = param_3;
      *param_1 = param_2;
    }
  }
  else {
    param_1[1] = param_5;
    *param_1 = param_4;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _pmul(undefined8 *param_1,undefined8 param_2,undefined8 param_3,ulong param_4)

{
  undefined8 local_50;
  undefined8 uStack_48;
  undefined8 local_40;
  undefined8 uStack_38;
  ulong local_30;
  undefined8 *local_28;
  undefined8 local_20;
  undefined8 uStack_18;
  
  uStack_38 = _DAT_100008040;
  local_40 = __zerO;
  local_50 = param_2;
  uStack_48 = param_3;
  local_30 = param_4;
  local_28 = param_1;
  local_20 = param_2;
  uStack_18 = param_3;
  do {
    if (local_30 == 0) {
LAB_1000030e8:
      local_28[1] = uStack_38;
      *local_28 = local_40;
      return;
    }
    if ((local_30 & 1) != 0) {
      _padd(&local_40,local_40,uStack_38,local_50,uStack_48);
    }
    if (__inverr != 0) {
      uStack_38 = _DAT_100008040;
      local_40 = __zerO;
      goto LAB_1000030e8;
    }
    _padd(&local_50,local_50,uStack_48,local_50,uStack_48);
    local_30 = (long)local_30 >> 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _pprint(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  int iVar1;
  
  iVar1 = _isO(param_2,param_3);
  if (iVar1 == 0) {
    iVar1 = _printf("%s (%lld, %lld)\n");
  }
  else {
    iVar1 = _printf("%s (0)\n");
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

undefined4 _ellinit(undefined8 *param_1)

{
  undefined8 uVar1;
  undefined4 local_14;
  
  uVar1 = param_1[1];
  _DAT_100008010 = param_1[2];
  __inverr = 0;
  if ((_DAT_100008010 < 5) || (0x3fffffdd < _DAT_100008010)) {
    local_14 = 0;
  }
  else {
    __e = FUN_100002c8c(*param_1);
    _DAT_100008008 = FUN_100002c8c(uVar1);
    _DAT_100008018 = FUN_100002c8c(param_1[3]);
    _DAT_100008020 = FUN_100002c8c(param_1[4]);
    _DAT_100008028 = param_1[5];
    if ((_DAT_100008028 < 5) || (0x4000ffdd < _DAT_100008028)) {
      local_14 = 0;
    }
    else {
      _printf("\nE: y^2 = x^3 + %dx + %d");
      _printf(" (mod %lld)\n");
      _pprint("base point G",_DAT_100008018,_DAT_100008020);
      _printf("order(G, E) = %lld\n");
      local_14 = 1;
    }
  }
  return local_14;
}



undefined  [16] _rnd(void)

{
  int iVar1;
  undefined auVar2 [16];
  
  iVar1 = _rand();
  auVar2._0_8_ = (double)iVar1 / 2147483648.0;
  auVar2._8_8_ = 0;
  return auVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined  [16] _signature(long param_1,long param_2)

{
  undefined auVar1 [16];
  long lVar2;
  uint uVar3;
  ulong uVar4;
  long lVar5;
  long lVar6;
  double dVar7;
  undefined8 local_60;
  undefined8 local_58;
  long local_50;
  long local_48;
  ulong local_40;
  ulong local_38;
  long local_30;
  long local_28;
  
  local_30 = param_2;
  local_28 = param_1;
  uVar3 = _printf("\nsignature computation\n");
  uVar4 = (ulong)uVar3;
  do {
    do {
      dVar7 = (double)_rnd(uVar4);
      local_48 = (long)(dVar7 * (double)(_DAT_100008028 + -1)) + 1;
      _pmul(&local_60,_DAT_100008018,_DAT_100008020,local_48);
      uVar4 = _modr(local_60);
      local_38 = uVar4;
    } while (uVar4 == 0);
    lVar5 = _exgcd(local_48,_DAT_100008028);
    lVar2 = local_30;
    local_50 = lVar5;
    lVar6 = _modr(local_28 * local_38);
    uVar4 = _modr(lVar5 * (lVar2 + lVar6));
    local_40 = uVar4;
  } while (uVar4 == 0);
  _printf("one-time u = %d\n");
  _pprint("V = uG",local_60,local_58);
  auVar1._8_8_ = local_40;
  auVar1._0_8_ = local_38;
  return auVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool _verify(undefined8 param_1,undefined8 param_2,long param_3,long param_4,long param_5)

{
  bool bVar1;
  int iVar2;
  uint local_a0;
  uint local_9c;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_80;
  long local_78;
  undefined8 local_70;
  undefined8 local_68;
  long local_60;
  ulong local_58;
  long local_50;
  long local_48;
  long local_40;
  long local_38;
  long local_30;
  undefined8 local_28;
  undefined8 local_20;
  
  local_9c = 0;
  if (0 < param_4) {
    local_9c = (uint)(param_4 < _DAT_100008028);
  }
  local_a0 = 0;
  if (0 < param_5) {
    local_a0 = (uint)(param_5 < _DAT_100008028);
  }
  local_58 = (ulong)(local_9c & local_a0);
  if (local_58 == 0) {
    bVar1 = false;
  }
  else {
    local_50 = param_5;
    local_48 = param_4;
    local_40 = param_3;
    local_38 = param_4;
    local_30 = param_5;
    local_28 = param_1;
    local_20 = param_2;
    _printf("\nsignature verification\n");
    local_78 = _exgcd(local_50,_DAT_100008028);
    local_68 = _modr(local_40 * local_78);
    local_70 = _modr(local_48 * local_78);
    _printf("h1,h2 = %d, %d\n");
    _pmul(&local_88,_DAT_100008018,_DAT_100008020,local_68);
    _pmul(&local_98,local_28,local_20,local_70);
    _pprint("h1G",local_88,local_80);
    _pprint("h2W",local_98,local_90);
    _padd(&local_88,local_88,local_80,local_98,local_90);
    _pprint("+ =",local_88,local_80);
    iVar2 = _isO(local_88,local_80);
    if (iVar2 == 0) {
      local_60 = _modr(local_88);
      _printf("c\' = %d\n");
      bVar1 = local_60 == local_48;
    }
    else {
      bVar1 = false;
    }
  }
  return bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _ec_dsa(ulong param_1,ulong param_2)

{
  int iVar1;
  long lVar2;
  double dVar3;
  undefined8 local_60;
  undefined8 local_58;
  undefined local_50 [16];
  ulong local_38;
  long local_30;
  ulong local_28;
  ulong local_20;
  ulong local_18;
  
  local_20 = param_2;
  local_18 = param_1;
  lVar2 = _disc();
  local_38 = (ulong)(lVar2 == 0);
  iVar1 = _isO(_DAT_100008018,_DAT_100008020);
  local_38 = local_38 | (long)iVar1;
  _pmul(&local_60,_DAT_100008018,_DAT_100008020,_DAT_100008028);
  iVar1 = _isO(local_60,local_58);
  local_38 = local_38 | iVar1 == 0;
  iVar1 = _ison(_DAT_100008018,_DAT_100008020);
  local_38 = local_38 | iVar1 == 0;
  if (local_38 == 0) {
    iVar1 = _printf("\nkey generation\n");
    dVar3 = (double)_rnd(iVar1);
    local_30 = (long)(dVar3 * (double)(long)(_DAT_100008028 - 1)) + 1;
    _pmul(&local_60,_DAT_100008018,_DAT_100008020,local_30);
    _printf("private key s = %d\n");
    _pprint("public key W = sG",local_60,local_58);
    local_38 = _DAT_100008028;
    for (local_28 = 1; (long)local_28 < 0x20; local_28 = local_28 << 1) {
      local_38 = local_38 | (long)local_38 >> (local_28 & 0x3f);
    }
    for (; (long)local_38 < (long)local_18; local_18 = (long)local_18 >> 1) {
    }
    _printf("\naligned hash %x\n");
    local_50 = _signature(local_30,local_18);
    if (__inverr == 0) {
      _printf("signature c,d = %d, %d\n");
      if (0 < (long)local_20) {
        for (; (long)local_38 < (long)local_20; local_20 = (long)local_20 >> 1) {
        }
        local_18 = local_18 ^ local_20;
        _printf("\ncorrupted hash %x\n");
      }
      iVar1 = _verify(local_60,local_58,local_18,local_50._0_8_,local_50._8_8_);
      local_38 = (ulong)iVar1;
      if (__inverr == 0) {
        if (local_38 != 0) {
          iVar1 = _printf("Valid\n_____\n");
          return iVar1;
        }
        iVar1 = _printf("invalid\n_______\n");
        return iVar1;
      }
    }
  }
  _printf("invalid parameter set\n");
  iVar1 = _printf("_____________________\n");
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void entry(void)

{
  int iVar1;
  time_t tVar2;
  undefined *local_220;
  undefined auStack_208 [480];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  __zerO = 0xffffffff80000001;
  _DAT_100008040 = 0;
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  local_220 = auStack_208;
  _memcpy(local_220,&DAT_100003bf0,0x1e0);
  while( true ) {
    iVar1 = _ellinit(local_220);
    if (iVar1 == 0) break;
    _ec_dsa(0x789abcde,0);
    local_220 = local_220 + 0x30;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003b90. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b9c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ba8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bb4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003bc0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bcc. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004030)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int hailstone(int n, int *arry)
{
    int hs = 1;

    while (n!=1) {
        hs++;
        if (arry) *arry++ = n;
        n = (n&1) ? (3*n+1) : (n/2);
    }
    if (arry) *arry++ = n;
    return hs;
}

int main()
{
    int j, hmax = 0;
    int jatmax, n;
    int *arry;

    for (j=1; j<100000; j++) {
       n = hailstone(j, NULL);
       if (hmax < n) {
           hmax = n;
           jatmax = j;
       }
    }
    n = hailstone(27, NULL);
    arry = malloc(n*sizeof(int));
    n = hailstone(27, arry);

    printf("[ %d, %d, %d, %d, ...., %d, %d, %d, %d] len=%d\n",
        arry[0],arry[1],arry[2],arry[3],
        arry[n-4], arry[n-3], arry[n-2], arry[n-1], n);
    printf("Max %d at j= %d\n", hmax, jatmax);
    free(arry);

    return 0;
}
`,`#include "hailstone-sequence-1.h"



int _hailstone(uint param_1,uint *param_2)

{
  uint local_18;
  int local_14;
  uint *local_10;
  uint local_4;
  
  local_14 = 1;
  local_10 = param_2;
  local_4 = param_1;
  while (local_4 != 1) {
    local_14 = local_14 + 1;
    if (local_10 != (uint *)0x0) {
      *local_10 = local_4;
      local_10 = local_10 + 1;
    }
    if ((local_4 & 1) == 0) {
      local_18 = (int)local_4 / 2;
    }
    else {
      local_18 = local_4 * 3 + 1;
    }
    local_4 = local_18;
  }
  if (local_10 != (uint *)0x0) {
    *local_10 = 1;
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  void *pvVar2;
  int local_1c;
  int local_18;
  
  local_1c = 0;
  for (local_18 = 1; local_18 < 100000; local_18 = local_18 + 1) {
    iVar1 = _hailstone(local_18,0);
    if (local_1c < iVar1) {
      local_1c = iVar1;
    }
  }
  iVar1 = _hailstone(0x1b,0);
  pvVar2 = _malloc((long)iVar1 << 2);
  _hailstone(0x1b,pvVar2);
  _printf("[ %d, %d, %d, %d, ...., %d, %d, %d, %d] len=%d\n");
  _printf("Max %d at j= %d\n");
  _free(pvVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include<stdio.h>

int main ()
{
  int i;
  const char *s[] = { "%d\n", "Fizz\n", s[3] + 4, "FizzBuzz\n" };
  for (i = 1; i <= 100; i++)
    printf(s[!(i % 3) + 2 * !(i % 5)], i);
  return 0;
}
`,`#include "fizzbuzz-5.h"



undefined8 entry(ulong param_1)

{
  uint uVar1;
  int local_40;
  char *local_38 [2];
  long local_28;
  char *local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_38[0] = "%d\n";
  local_38[1] = "Fizz\n";
  local_28 = (long)local_20 + 4;
  local_20 = "FizzBuzz\n";
  for (local_40 = 1; local_40 < 0x65; local_40 = local_40 + 1) {
    uVar1 = _printf(local_38[(int)((uint)(local_40 % 3 == 0) + (uint)(local_40 % 5 == 0) * 2)]);
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <inttypes.h> /* requires c99 */
#include <stdbool.h>  /* requires c99 */
#include <stdio.h>
#include <stdlib.h>

#define N_EL 5

uintmax_t sec_to_week(uintmax_t);
uintmax_t sec_to_day(uintmax_t);
uintmax_t sec_to_hour(uintmax_t);
uintmax_t sec_to_min(uintmax_t);

uintmax_t week_to_sec(uintmax_t);
uintmax_t day_to_sec(uintmax_t);
uintmax_t hour_to_sec(uintmax_t);
uintmax_t min_to_sec(uintmax_t);

char *format_sec(uintmax_t);
    /* the primary function */


int main(int argc, char *argv[])
{
    uintmax_t input;
    char *a;

    if(argc<2) {
        printf("usage: %s #seconds\n", argv[0]);
        return 1;
    }
    input = strtoumax(argv[1],(void *)0, 10 /*base 10*/);
    if(input<1) {
        printf("Bad input: %s\n", argv[1]);
        printf("usage: %s #seconds\n", argv[0]);
        return 1;
    }
    printf("Number entered: %" PRIuMAX "\n", input);
    a = format_sec(input);
    printf(a);
    free(a);

    return 0;
}

/* note: must free memory
 * after using this function */
char *format_sec(uintmax_t input)
{
    int i;
    bool first;
    uintmax_t weeks, days, hours, mins;
    /*seconds kept in input*/

    char *retval;
    FILE *stream;
    size_t size;
    uintmax_t *traverse[N_EL]={&weeks,&days,
            &hours,&mins,&input};
    char *labels[N_EL]={"wk","d","hr","min","sec"};

    weeks = sec_to_week(input);
    input = input - week_to_sec(weeks);

    days = sec_to_day(input);
    input = input - day_to_sec(days);

    hours = sec_to_hour(input);
    input = input - hour_to_sec(hours);

    mins = sec_to_min(input);
    input = input - min_to_sec(mins);
    /* input now has the remaining seconds */

    /* open stream */
    stream = open_memstream(&retval,&size);
    if(stream == 0) {
        fprintf(stderr,"Unable to allocate memory");
        return 0;
    }

    /* populate stream */
    first = true;
    for(i=0;i<N_EL;i++) {
        if ( *(traverse[i]) != 0 ) {
            if(!first) {
                fprintf(stream,", %" PRIuMAX " %s",
                        *(traverse[i]), labels[i]);
            } else {
                fprintf(stream,"%" PRIuMAX " %s",
                        *(traverse[i]), labels[i]);
            }
            fflush(stream);
            first=false;
        }
    }
    fprintf(stream,"\n");
    fclose(stream);
    return retval;

}

uintmax_t sec_to_week(uintmax_t seconds)
{
    return sec_to_day(seconds)/7;
}

uintmax_t sec_to_day(uintmax_t seconds)
{
    return sec_to_hour(seconds)/24;
}

uintmax_t sec_to_hour(uintmax_t seconds)
{
    return sec_to_min(seconds)/60;
}

uintmax_t sec_to_min(uintmax_t seconds)
{
    return seconds/60;
}

uintmax_t week_to_sec(uintmax_t weeks)
{
    return day_to_sec(weeks*7);
}

uintmax_t day_to_sec(uintmax_t days)
{
    return hour_to_sec(days*24);
}

uintmax_t hour_to_sec(uintmax_t hours)
{
    return min_to_sec(hours*60);
}

uintmax_t min_to_sec(uintmax_t minutes)
{
    return minutes*60;
}
`,`#include "convert-seconds-to-compound-duration-2.h"



undefined4 entry(int param_1,long param_2)

{
  uintmax_t uVar1;
  char *pcVar2;
  undefined4 local_14;
  
  if (param_1 < 2) {
    _printf("usage: %s #seconds\n");
    local_14 = 1;
  }
  else {
    uVar1 = _strtoumax(*(char **)(param_2 + 8),(char **)0x0,10);
    if (uVar1 == 0) {
      _printf("Bad input: %s\n");
      _printf("usage: %s #seconds\n");
      local_14 = 1;
    }
    else {
      _printf("Number entered: %ju\n");
      pcVar2 = (char *)_format_sec(uVar1);
      _printf(pcVar2);
      _free(pcVar2);
      local_14 = 0;
    }
  }
  return local_14;
}



undefined8 _format_sec(long param_1)

{
  long lVar1;
  int iVar2;
  undefined auStack_b8 [8];
  FILE *local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  char local_7d;
  int local_7c;
  long local_78;
  undefined8 local_70;
  undefined auStack_68 [40];
  undefined8 *local_40 [4];
  long *local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_20 = &local_78;
  local_40[0] = &local_88;
  local_40[1] = &local_90;
  local_40[2] = &local_98;
  local_40[3] = &local_a0;
  local_78 = param_1;
  _memcpy(auStack_68,&PTR_s_wk_100004058,0x28);
  local_88 = _sec_to_week(local_78);
  lVar1 = local_78;
  local_78 = _week_to_sec(local_88);
  local_78 = lVar1 - local_78;
  local_90 = _sec_to_day(local_78);
  lVar1 = local_78;
  local_78 = _day_to_sec(local_90);
  local_78 = lVar1 - local_78;
  local_98 = _sec_to_hour(local_78);
  lVar1 = local_78;
  local_78 = _hour_to_sec(local_98);
  local_78 = lVar1 - local_78;
  local_a0 = _sec_to_min(local_78);
  lVar1 = local_78;
  local_78 = _min_to_sec(local_a0);
  local_78 = lVar1 - local_78;
  local_b0 = (FILE *)_open_memstream(&local_a8,auStack_b8);
  if (local_b0 == (FILE *)0x0) {
    iVar2 = _fprintf(*(FILE **)PTR____stderrp_100004010,"Unable to allocate memory");
    local_70 = 0;
  }
  else {
    local_7d = '\x01';
    for (local_7c = 0; local_7c < 5; local_7c = local_7c + 1) {
      if (*local_40[local_7c] != 0) {
        if (local_7d == '\0') {
          _fprintf(local_b0,", %ju %s");
        }
        else {
          _fprintf(local_b0,"%ju %s");
        }
        _fflush(local_b0);
        local_7d = '\0';
      }
    }
    _fprintf(local_b0,"\n");
    iVar2 = _fclose(local_b0);
    local_70 = local_a8;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return local_70;
}



ulong _sec_to_week(undefined8 param_1)

{
  ulong uVar1;
  
  uVar1 = _sec_to_day(param_1);
  return uVar1 / 7;
}



void _week_to_sec(long param_1)

{
  _day_to_sec(param_1 * 7);
  return;
}



ulong _sec_to_day(undefined8 param_1)

{
  ulong uVar1;
  
  uVar1 = _sec_to_hour(param_1);
  return uVar1 / 0x18;
}



void _day_to_sec(long param_1)

{
  _hour_to_sec(param_1 * 0x18);
  return;
}



ulong _sec_to_hour(undefined8 param_1)

{
  ulong uVar1;
  
  uVar1 = _sec_to_min(param_1);
  return uVar1 / 0x3c;
}



void _hour_to_sec(long param_1)

{
  _min_to_sec(param_1 * 0x3c);
  return;
}



ulong _sec_to_min(ulong param_1)

{
  return param_1 / 0x3c;
}



long _min_to_sec(long param_1)

{
  return param_1 * 0x3c;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004038)();
  return pvVar1;
}



void _open_memstream(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__open_memstream_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uintmax_t _strtoumax(char *__nptr,char **__endptr,int __base)

{
  uintmax_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoumax_100004050)(__nptr,__endptr,__base);
  return uVar1;
}


`
`#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct philData {
    pthread_mutex_t *fork_lft, *fork_rgt;
    const char *name;
    pthread_t thread;
    int   fail;
} Philosopher;

int running = 1;

void *PhilPhunction(void *p) {
    Philosopher *phil = (Philosopher*)p;
    int failed;
    int tries_left;
    pthread_mutex_t *fork_lft, *fork_rgt, *fork_tmp;

    while (running) {
        printf("%s is sleeping --er thinking\n", phil->name);
        sleep( 1+ rand()%8);

        fork_lft = phil->fork_lft;
        fork_rgt = phil->fork_rgt;
        printf("%s is hungry\n", phil->name);
        tries_left = 2;   /* try twice before being forceful */
        do {
            failed = pthread_mutex_lock( fork_lft);
            failed = (tries_left>0)? pthread_mutex_trylock( fork_rgt )
                                   : pthread_mutex_lock(fork_rgt);
            if (failed) {
                pthread_mutex_unlock( fork_lft);
                fork_tmp = fork_lft;
                fork_lft = fork_rgt;
                fork_rgt = fork_tmp;
                tries_left -= 1;
            }
        } while(failed && running);

        if (!failed) {
            printf("%s is eating\n", phil->name);
            sleep( 1+ rand() % 8);
            pthread_mutex_unlock( fork_rgt);
            pthread_mutex_unlock( fork_lft);
        }
    }
    return NULL;
}

void Ponder()
{
    const char *nameList[] = { "Kant", "Guatma", "Russel", "Aristotle", "Bart" };
    pthread_mutex_t forks[5];
    Philosopher philosophers[5];
    Philosopher *phil;
    int i;
    int failed;

    for (i=0;i<5; i++) {
        failed = pthread_mutex_init(&forks[i], NULL);
        if (failed) {
            printf("Failed to initialize mutexes.");
            exit(1);
        }
    }

    for (i=0;i<5; i++) {
        phil = &philosophers[i];
        phil->name = nameList[i];
        phil->fork_lft = &forks[i];
        phil->fork_rgt = &forks[(i+1)%5];
        phil->fail = pthread_create( &phil->thread, NULL, PhilPhunction, phil);
    }

    sleep(40);
    running = 0;
    printf("cleanup time\n");

    for(i=0; i<5; i++) {
        phil = &philosophers[i];
        if ( !phil->fail && pthread_join( phil->thread, NULL) ) {
            printf("error joining thread for %s", phil->name);
            exit(1);
        }
    }
}

int main()
{
    Ponder();
    return 0;
}
`,`#include "dining-philosophers-2.h"



undefined8 _PhilPhunction(undefined8 *param_1)

{
  pthread_mutex_t *ppVar1;
  int iVar2;
  int local_44;
  pthread_mutex_t *local_38;
  pthread_mutex_t *local_30;
  int local_28;
  
  while (_running != 0) {
    _printf("%s is sleeping --er thinking\n");
    iVar2 = _rand();
    _sleep(iVar2 % 8 + 1);
    local_30 = (pthread_mutex_t *)*param_1;
    local_38 = (pthread_mutex_t *)param_1[1];
    _printf("%s is hungry\n");
    local_28 = 2;
    do {
      ppVar1 = local_30;
      _pthread_mutex_lock(local_30);
      if (local_28 < 1) {
        local_44 = _pthread_mutex_lock(local_38);
      }
      else {
        local_44 = _pthread_mutex_trylock(local_38);
      }
      if (local_44 != 0) {
        _pthread_mutex_unlock(local_30);
        local_30 = local_38;
        local_38 = ppVar1;
        local_28 = local_28 + -1;
      }
    } while (local_44 != 0 && _running != 0);
    if (local_44 == 0) {
      _printf("%s is eating\n");
      iVar2 = _rand();
      _sleep(iVar2 % 8 + 1);
      _pthread_mutex_unlock(local_38);
      _pthread_mutex_unlock(local_30);
    }
  }
  return 0;
}



void _Ponder(void)

{
  int iVar1;
  long lVar2;
  int local_264;
  long alStack_258 [3];
  pthread_t p_Stack_240;
  int aiStack_238 [42];
  pthread_mutex_t apStack_190 [5];
  long alStack_50 [5];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(alStack_50,&PTR_s_Kant_100004068,0x28);
  local_264 = 0;
  while( true ) {
    if (4 < local_264) {
      for (local_264 = 0; local_264 < 5; local_264 = local_264 + 1) {
        lVar2 = (long)local_264;
        alStack_258[lVar2 * 5 + 2] = alStack_50[local_264];
        alStack_258[lVar2 * 5] = (long)(apStack_190 + local_264);
        alStack_258[lVar2 * 5 + 1] = (long)(apStack_190 + (local_264 + 1) % 5);
        iVar1 = _pthread_create(&p_Stack_240 + lVar2 * 5,(pthread_attr_t *)0x0,
                                (void **)_PhilPhunction,alStack_258 + lVar2 * 5);
        aiStack_238[lVar2 * 10] = iVar1;
      }
      _sleep(0x28);
      _running = 0;
      iVar1 = _printf("cleanup time\n");
      local_264 = 0;
      do {
        if (4 < local_264) {
          if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
            return;
          }
                    // WARNING: Subroutine does not return
          ___stack_chk_fail(iVar1);
        }
        if (aiStack_238[(long)local_264 * 10] == 0) {
          iVar1 = _pthread_join((&p_Stack_240)[(long)local_264 * 5],(void **)0x0);
          if (iVar1 != 0) {
            _printf("error joining thread for %s");
                    // WARNING: Subroutine does not return
            _exit(1);
          }
        }
        local_264 = local_264 + 1;
      } while( true );
    }
    iVar1 = _pthread_mutex_init(apStack_190 + local_264,(pthread_mutexattr_t *)0x0);
    if (iVar1 != 0) break;
    local_264 = local_264 + 1;
  }
  _printf("Failed to initialize mutexes.");
                    // WARNING: Subroutine does not return
  _exit(1);
}



undefined4 entry(void)

{
  _Ponder();
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_create(pthread_t *param_1,pthread_attr_t *param_2,void **param_3,void *param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_create_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_join(pthread_t param_1,void **param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_join_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_init(pthread_mutex_t *param_1,pthread_mutexattr_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_init_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_lock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_lock_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_trylock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_trylock_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_unlock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_unlock_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004058)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint _sleep(uint param_1)

{
  uint uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__sleep_100004060)(param_1);
  return uVar1;
}


`
`/*
 * Rosetta Code - stream merge in C.
 *
 * Two streams (text files) with integer numbers, C89, Visual Studio 2010.
 *
 */

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

#define GET(N) { if(fscanf(f##N,"%d",&b##N ) != 1) f##N = NULL; }
#define PUT(N) { printf("%d\n", b##N); GET(N) }

void merge(FILE* f1, FILE* f2, FILE* out)
{
    int b1;
    int b2;

    if(f1) GET(1)
    if(f2) GET(2)

    while ( f1 && f2 )
    {
        if ( b1 <= b2 ) PUT(1)
        else            PUT(2)
    }
    while (f1 ) PUT(1)
    while (f2 ) PUT(2)
}

int main(int argc, char* argv[])
{
    if ( argc < 3 || argc > 3 )
    {
        puts("streammerge filename1 filename2");
        exit(EXIT_FAILURE);
    }
    else
        merge(fopen(argv[1],"r"),fopen(argv[2],"r"),stdout);

    return EXIT_SUCCESS;
}
`,`#include "stream-merge.h"



void _merge(FILE *param_1,FILE *param_2)

{
  int iVar1;
  int local_30;
  int local_2c;
  FILE *local_20;
  FILE *local_18;
  
  local_18 = param_1;
  if ((param_1 != (FILE *)0x0) && (iVar1 = _fscanf(param_1,"%d"), iVar1 != 1)) {
    local_18 = (FILE *)0x0;
  }
  local_20 = param_2;
  if ((param_2 != (FILE *)0x0) && (iVar1 = _fscanf(param_2,"%d"), iVar1 != 1)) {
    local_20 = (FILE *)0x0;
  }
  while (local_18 != (FILE *)0x0 && local_20 != (FILE *)0x0) {
    if (local_30 < local_2c) {
      _printf("%d\n");
      iVar1 = _fscanf(local_20,"%d");
      if (iVar1 != 1) {
        local_20 = (FILE *)0x0;
      }
    }
    else {
      _printf("%d\n");
      iVar1 = _fscanf(local_18,"%d");
      if (iVar1 != 1) {
        local_18 = (FILE *)0x0;
      }
    }
  }
  while (local_18 != (FILE *)0x0) {
    _printf("%d\n");
    iVar1 = _fscanf(local_18,"%d");
    if (iVar1 != 1) {
      local_18 = (FILE *)0x0;
    }
  }
  while (local_20 != (FILE *)0x0) {
    _printf("%d\n");
    iVar1 = _fscanf(local_20,"%d");
    if (iVar1 != 1) {
      local_20 = (FILE *)0x0;
    }
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  FILE *pFVar1;
  FILE *pFVar2;
  
  if ((2 < param_1) && (param_1 < 4)) {
    pFVar1 = _fopen(*(char **)(param_2 + 8),"r");
    pFVar2 = _fopen(*(char **)(param_2 + 0x10),"r");
    _merge(pFVar1,pFVar2,*(undefined8 *)PTR____stdoutp_100004000);
    return 0;
  }
  _puts("streammerge filename1 filename2");
                    // WARNING: Subroutine does not return
  _exit(1);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004008)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004010)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <wchar.h>

const char *sa = "abcdef";
const char *su = "as⃝df̅"; /* Should be in your native locale encoding. Mine is UTF-8 */

int is_comb(wchar_t c)
{
	if (c >= 0x300 && c <= 0x36f) return 1;
	if (c >= 0x1dc0 && c <= 0x1dff) return 1;
	if (c >= 0x20d0 && c <= 0x20ff) return 1;
	if (c >= 0xfe20 && c <= 0xfe2f) return 1;
	return 0;
}

wchar_t* mb_to_wchar(const char *s)
{
	wchar_t *u;
	size_t len = mbstowcs(0, s, 0) + 1;
	if (!len) return 0;

	u = malloc(sizeof(wchar_t) * len);
	mbstowcs(u, s, len);
	return u;
}

wchar_t* ws_reverse(const wchar_t* u)
{
	size_t len, i, j;
	wchar_t *out;
	for (len = 0; u[len]; len++);
	out = malloc(sizeof(wchar_t) * (len + 1));
	out[len] = 0;
	j = 0;
	while (len) {
		for (i = len - 1; i && is_comb(u[i]); i--);
		wcsncpy(out + j, u + i, len - i);
		j += len - i;
		len = i;
	}
	return out;
}

char *mb_reverse(const char *in)
{
	size_t len;
	char *out;
	wchar_t *u = mb_to_wchar(in);
	wchar_t *r = ws_reverse(u);
	len = wcstombs(0, r, 0) + 1;
	out = malloc(len);
	wcstombs(out, r, len);
	free(u);
	free(r);
	return out;
}

int main(void)
{
	setlocale(LC_CTYPE, "");

	printf("%s => %s\n", sa, mb_reverse(sa));
	printf("%s => %s\n", su, mb_reverse(su));
	return 0;
}
`,`#include "reverse-a-string-1.h"



undefined4 _is_comb(int param_1)

{
  undefined4 local_4;
  
  if ((param_1 < 0x300) || (0x36f < param_1)) {
    if ((param_1 < 0x1dc0) || (0x1dff < param_1)) {
      if ((param_1 < 0x20d0) || (0x20ff < param_1)) {
        if ((param_1 < 0xfe20) || (0xfe2f < param_1)) {
          local_4 = 0;
        }
        else {
          local_4 = 1;
        }
      }
      else {
        local_4 = 1;
      }
    }
    else {
      local_4 = 1;
    }
  }
  else {
    local_4 = 1;
  }
  return local_4;
}



wchar_t * _mb_to_wchar(char *param_1)

{
  size_t sVar1;
  undefined8 local_18;
  
  sVar1 = _mbstowcs((wchar_t *)0x0,param_1,0);
  sVar1 = sVar1 + 1;
  if (sVar1 == 0) {
    local_18 = (wchar_t *)0x0;
  }
  else {
    local_18 = (wchar_t *)_malloc(sVar1 * 4);
    _mbstowcs(local_18,param_1,sVar1);
  }
  return local_18;
}



void * _ws_reverse(long param_1)

{
  bool bVar1;
  int iVar2;
  void *pvVar3;
  long local_30;
  long local_28;
  long local_20;
  
  for (local_20 = 0; *(int *)(param_1 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  pvVar3 = _malloc((local_20 + 1) * 4);
  *(undefined4 *)((long)pvVar3 + local_20 * 4) = 0;
  local_30 = 0;
  while (local_28 = local_20, local_20 != 0) {
    do {
      local_28 = local_28 + -1;
      bVar1 = false;
      if (local_28 != 0) {
        iVar2 = _is_comb(*(undefined4 *)(param_1 + local_28 * 4));
        bVar1 = iVar2 != 0;
      }
    } while (bVar1);
    _wcsncpy((wchar_t *)((long)pvVar3 + local_30 * 4),(wchar_t *)(param_1 + local_28 * 4),
             local_20 - local_28);
    local_30 = local_30 + (local_20 - local_28);
    local_20 = local_28;
  }
  return pvVar3;
}



char * _mb_reverse(undefined8 param_1)

{
  void *pvVar1;
  wchar_t *pwVar2;
  size_t sVar3;
  char *pcVar4;
  
  pvVar1 = (void *)_mb_to_wchar(param_1);
  pwVar2 = (wchar_t *)_ws_reverse(pvVar1);
  sVar3 = _wcstombs((char *)0x0,pwVar2,0);
  pcVar4 = (char *)_malloc(sVar3 + 1);
  _wcstombs(pcVar4,pwVar2,sVar3 + 1);
  _free(pvVar1);
  _free(pwVar2);
  return pcVar4;
}



undefined4 entry(void)

{
  _setlocale(2,"");
  _mb_reverse(_sa);
  _printf("%s => %s\n");
  _mb_reverse(_su);
  _printf("%s => %s\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _mbstowcs(wchar_t *param_1,char *param_2,size_t param_3)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__mbstowcs_100004010)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

wchar_t * _wcsncpy(wchar_t *param_1,wchar_t *param_2,size_t param_3)

{
  wchar_t *pwVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  pwVar1 = (wchar_t *)(*(code *)PTR__wcsncpy_100004028)();
  return pwVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _wcstombs(char *param_1,wchar_t *param_2,size_t param_3)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__wcstombs_100004030)();
  return sVar1;
}


`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

typedef int bool;
typedef enum { ENCRYPT, DECRYPT } cmode;

const char *l_alphabet = "HXUCZVAMDSLKPEFJRIGTWOBNYQ";
const char *r_alphabet = "PTLNBQDEOYSFAVZKGJRIHWXUMC";

void chao(const char *in, char *out, cmode mode, bool show_steps) {
    int i, j, index;
    char store;
    size_t len = strlen(in);
    char left[27], right[27], temp[27];
    strcpy(left, l_alphabet);
    strcpy(right, r_alphabet);
    temp[26] = '\0';

    for (i = 0; i < len; ++i ) {
        if (show_steps) printf("%s  %s\n", left, right);
        if (mode == ENCRYPT) {
            index = strchr(right, in[i]) - right;
            out[i] = left[index];
        }
        else {
            index = strchr(left, in[i]) - left;
            out[i] = right[index];
        }
        if (i == len - 1) break;

        /* permute left */

        for (j = index; j < 26; ++j) temp[j - index] = left[j];
        for (j = 0; j < index; ++j) temp[26 - index + j] = left[j];
        store = temp[1];
        for (j = 2; j < 14; ++j) temp[j - 1] = temp[j];
        temp[13] = store;
        strcpy(left, temp);

        /* permute right */

        for (j = index; j < 26; ++j) temp[j - index] = right[j];
        for (j = 0; j < index; ++j) temp[26 - index + j] = right[j];
        store = temp[0];
        for (j = 1; j < 26; ++j) temp[j - 1] = temp[j];
        temp[25] = store;
        store = temp[2];
        for (j = 3; j < 14; ++j) temp[j - 1] = temp[j];
        temp[13] = store;
        strcpy(right, temp);
    }
}

int main() {
    const char *plain_text = "WELLDONEISBETTERTHANWELLSAID";
    char *cipher_text = malloc(strlen(plain_text) + 1);
    char *plain_text2 = malloc(strlen(plain_text) + 1);
    printf("The original plaintext is : %s\n", plain_text);
    printf("\nThe left and right alphabets after each permutation"
           " during encryption are :\n\n");
    chao(plain_text, cipher_text, ENCRYPT, TRUE);
    printf("\nThe ciphertext is : %s\n", cipher_text);
    chao(cipher_text, plain_text2, DECRYPT, FALSE);
    printf("\nThe recovered plaintext is : %s\n", plain_text2);
    free(cipher_text);
    free(plain_text2);
    return 0;
}
`,`#include "chaocipher.h"



void _chao(char *param_1,long param_2,int param_3,int param_4)

{
  size_t sVar1;
  char *pcVar2;
  int local_94;
  int local_90;
  int local_8c;
  char local_69 [26];
  undefined local_4f;
  char acStack_4e [27];
  char acStack_33 [27];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  sVar1 = _strlen(param_1);
  ___strcpy_chk(acStack_33,_l_alphabet);
  ___strcpy_chk(acStack_4e,_r_alphabet,0x1b);
  local_4f = 0;
  for (local_8c = 0; (ulong)(long)local_8c < sVar1; local_8c = local_8c + 1) {
    if (param_4 != 0) {
      _printf("%s  %s\n");
    }
    if (param_3 == 0) {
      pcVar2 = _strchr(acStack_4e,(int)param_1[local_8c]);
      local_94 = (int)pcVar2 - (int)acStack_4e;
      *(char *)(param_2 + local_8c) = acStack_33[local_94];
    }
    else {
      pcVar2 = _strchr(acStack_33,(int)param_1[local_8c]);
      local_94 = (int)pcVar2 - (int)acStack_33;
      *(char *)(param_2 + local_8c) = acStack_4e[local_94];
    }
    if ((long)local_8c == sVar1 - 1) break;
    for (local_90 = local_94; local_90 < 0x1a; local_90 = local_90 + 1) {
      local_69[local_90 - local_94] = acStack_33[local_90];
    }
    for (local_90 = 0; local_69[0xd] = local_69[1], local_90 < local_94; local_90 = local_90 + 1) {
      local_69[(0x1a - local_94) + local_90] = acStack_33[local_90];
    }
    for (local_90 = 2; local_90 < 0xe; local_90 = local_90 + 1) {
      local_69[local_90 + -1] = local_69[local_90];
    }
    ___strcpy_chk(acStack_33,local_69,0x1b);
    for (local_90 = local_94; local_90 < 0x1a; local_90 = local_90 + 1) {
      local_69[local_90 - local_94] = acStack_4e[local_90];
    }
    for (local_90 = 0; local_69[0x19] = local_69[0], local_90 < local_94; local_90 = local_90 + 1) {
      local_69[(0x1a - local_94) + local_90] = acStack_4e[local_90];
    }
    for (local_90 = 1; local_69[0xd] = local_69[2], local_90 < 0x1a; local_90 = local_90 + 1) {
      local_69[local_90 + -1] = local_69[local_90];
    }
    for (local_90 = 3; local_90 < 0xe; local_90 = local_90 + 1) {
      local_69[local_90 + -1] = local_69[local_90];
    }
    ___strcpy_chk(acStack_4e,local_69,0x1b);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined4 entry(void)

{
  size_t sVar1;
  void *pvVar2;
  void *pvVar3;
  
  sVar1 = _strlen("WELLDONEISBETTERTHANWELLSAID");
  pvVar2 = _malloc(sVar1 + 1);
  sVar1 = _strlen("WELLDONEISBETTERTHANWELLSAID");
  pvVar3 = _malloc(sVar1 + 1);
  _printf("The original plaintext is : %s\n");
  _printf("\nThe left and right alphabets after each permutation during encryption are :\n\n");
  _chao("WELLDONEISBETTERTHANWELLSAID",pvVar2,0);
  _printf("\nThe ciphertext is : %s\n");
  _chao(pvVar2,pvVar3,1,0);
  _printf("\nThe recovered plaintext is : %s\n");
  _free(pvVar2);
  _free(pvVar3);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004030)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}


`
`#include <stdio.h>

int data[] = {  85, 88, 75, 66, 25, 29, 83, 39, 97,
                68, 41, 10, 49, 16, 65, 32, 92, 28, 98 };

int pick(int at, int remain, int accu, int treat)
{
        if (!remain) return (accu > treat) ? 1 : 0;

        return  pick(at - 1, remain - 1, accu + data[at - 1], treat) +
                ( at > remain ? pick(at - 1, remain, accu, treat) : 0 );
}

int main()
{
        int treat = 0, i;
        int le, gt;
        double total = 1;
        for (i = 0; i < 9; i++) treat += data[i];
        for (i = 19; i > 10; i--) total *= i;
        for (i = 9; i > 0; i--) total /= i;

        gt = pick(19, 9, 0, treat);
        le = total - gt;

        printf("<= : %f%%  %d\n > : %f%%  %d\n",
               100 * le / total, le, 100 * gt / total, gt);
        return 0;
}
`,`#include "permutation-test-1.h"



uint _pick(int param_1,int param_2,int param_3,int param_4)

{
  int iVar1;
  int local_2c;
  uint local_14;
  
  if (param_2 == 0) {
    local_14 = (uint)(param_4 < param_3);
  }
  else {
    iVar1 = _pick(param_1 + -1,param_2 + -1,param_3 + *(int *)(&_data + (long)(param_1 + -1) * 4),
                  param_4);
    if (param_2 < param_1) {
      local_2c = _pick(param_1 + -1,param_2,param_3,param_4);
    }
    else {
      local_2c = 0;
    }
    local_14 = iVar1 + local_2c;
  }
  return local_14;
}



undefined4 entry(void)

{
  int local_1c;
  int local_18;
  
  local_18 = 0;
  for (local_1c = 0; local_1c < 9; local_1c = local_1c + 1) {
    local_18 = local_18 + *(int *)(&_data + (long)local_1c * 4);
  }
  for (local_1c = 0x13; 10 < local_1c; local_1c = local_1c + -1) {
  }
  for (local_1c = 9; 0 < local_1c; local_1c = local_1c + -1) {
  }
  _pick(0x13,9,0,local_18);
  _printf("<= : %f%%  %d\n > : %f%%  %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INPUT_FILE_NAME     "Traceback.txt"
#define KEYWORD_STRING      "SystemError"
#define TRACEBACK_STRING    "Traceback (most recent call last):"
#define END_OF_PARAGRAPH    "\n----------------\n"

char *load_paragraph( FILE *f );

int main() {
    FILE *f   = fopen( INPUT_FILE_NAME, "r" );

    if( f ) {
        char *par = NULL;

        while( (par=load_paragraph(f)) ) {
            if( strstr(par,KEYWORD_STRING) ) {
                char *p = strstr( par, TRACEBACK_STRING );

                if( p ) printf( p );
                else printf( "%s\n%s", TRACEBACK_STRING, par );

                printf( END_OF_PARAGRAPH );
            }

            free( par ); par = NULL;
        }

        if( !feof(f) )
            puts( "End of file not reached." );

        fclose( f ); f = NULL;
    }
    else {
        puts( "Input file not opened." );
    }

    return 0;
}

/*===========================================================================
Starting from the current position, looks for the first occurrence of "\n\n"
in the file f, counting the number of characters from the current position
to "\n\n" itself (not included) or to the end of the file (whichever occurs
first). Resets the file to its original position, then returns the number of
characters.
If the funtions fails, it returns ((size_t)-1).
===========================================================================*/

size_t get_paragraph_length( FILE *f ) {
    size_t l = ((size_t)-1);

    if( f && !feof(f) ) {
        fpos_t ex_pos;

        if( 0==fgetpos(f,&ex_pos) ) {
            int c;

            for( c=fgetc(f); c!=EOF; c=fgetc(f) ) {
                if( '\n'==c ) {
                    if( '\n'!=(c=fgetc(f)) ) {
                        ungetc( c, f );
                    }
                    else {
                        ++l;
                        break;
                    }
                }

                ++l;
            }

            l += EOF==c;

            fsetpos( f, &ex_pos );
        }
    }

    return l;
}

/*===========================================================================
Loads a paragraph from the file f. Paragraphs are detected looking for the
occurrences of "\n\n" separators. The loaded paragraph is put into a chunk of
memory allocated with malloc(). The pointer to that memory is returned.
If the function fails, no memory is allocated and NULL is returned.
===========================================================================*/

char *load_paragraph( FILE *f ) {
    char *par = NULL;

    if( !feof(f) ) {
        size_t i, l = get_paragraph_length( f );

        if( ((size_t)-1)!=l ) {
            par = malloc( l+1 );

            if( par ) {
                for( i=0; i<l; ++i )
                    par[i] = fgetc( f );
                par[i] = '\0';

                /* just jump beyond the paragraph delimiter */
                fgetc( f ); fgetc( f );
            }
        }
    }

    return par;
}
`,`#include "search-in-paragraphs-text.h"



undefined8 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  char *pcVar4;
  
  pFVar2 = _fopen("Traceback.txt","r");
  if (pFVar2 == (FILE *)0x0) {
    _puts("Input file not opened.");
  }
  else {
    while (pcVar3 = (char *)_load_paragraph(pFVar2), pcVar3 != (char *)0x0) {
      pcVar4 = _strstr(pcVar3,"SystemError");
      if (pcVar4 != (char *)0x0) {
        pcVar4 = _strstr(pcVar3,"Traceback (most recent call last):");
        if (pcVar4 == (char *)0x0) {
          _printf("%s\n%s");
        }
        else {
          _printf(pcVar4);
        }
        _printf("\n----------------\n");
      }
      _free(pcVar3);
    }
    iVar1 = _feof(pFVar2);
    if (iVar1 == 0) {
      _puts("End of file not reached.");
    }
    _fclose(pFVar2);
  }
  return 0;
}



void * _load_paragraph(FILE *param_1)

{
  int iVar1;
  ulong uVar2;
  ulong local_28;
  void *local_20;
  
  local_20 = (void *)0x0;
  iVar1 = _feof(param_1);
  if (((iVar1 == 0) && (uVar2 = _get_paragraph_length(param_1), uVar2 != 0xffffffffffffffff)) &&
     (local_20 = _malloc(uVar2 + 1), local_20 != (void *)0x0)) {
    for (local_28 = 0; local_28 < uVar2; local_28 = local_28 + 1) {
      iVar1 = _fgetc(param_1);
      *(char *)((long)local_20 + local_28) = (char)iVar1;
    }
    *(undefined *)((long)local_20 + local_28) = 0;
    _fgetc(param_1);
    _fgetc(param_1);
  }
  return local_20;
}



long _get_paragraph_length(FILE *param_1)

{
  int iVar1;
  int local_2c;
  fpos_t fStack_28;
  long local_20;
  FILE *local_18;
  
  local_20 = -1;
  if (((param_1 != (FILE *)0x0) && (local_18 = param_1, iVar1 = _feof(param_1), iVar1 == 0)) &&
     (iVar1 = _fgetpos(local_18,&fStack_28), iVar1 == 0)) {
    local_2c = _fgetc(local_18);
    while (local_2c != -1) {
      if (local_2c == 10) {
        iVar1 = _fgetc(local_18);
        if (iVar1 == 10) {
          local_20 = local_20 + 1;
          local_2c = 10;
          break;
        }
        _ungetc(iVar1,local_18);
      }
      local_20 = local_20 + 1;
      local_2c = _fgetc(local_18);
    }
    local_20 = local_20 + (ulong)(local_2c == -1);
    _fsetpos(local_18,&fStack_28);
  }
  return local_20;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _feof(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__feof_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetpos(FILE *param_1,fpos_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetpos_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fsetpos(FILE *param_1,fpos_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fsetpos_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strstr(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strstr_100004050)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _ungetc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__ungetc_100004058)(param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>

int* patienceSort(int* arr,int size){
	int decks[size][size],i,j,min,pickedRow;
	
	int *count = (int*)calloc(sizeof(int),size),*sortedArr = (int*)malloc(size*sizeof(int));
	
	for(i=0;i<size;i++){
		for(j=0;j<size;j++){
			if(count[j]==0 || (count[j]>0 && decks[j][count[j]-1]>=arr[i])){
				decks[j][count[j]] = arr[i];
				count[j]++;
				break;
			}
		}
	}
	
	min = decks[0][count[0]-1];
	pickedRow = 0;
	
	for(i=0;i<size;i++){
		for(j=0;j<size;j++){
			if(count[j]>0 && decks[j][count[j]-1]<min){
				min = decks[j][count[j]-1];
				pickedRow = j;
			}
		}
		sortedArr[i] = min;
		count[pickedRow]--;
		
		for(j=0;j<size;j++)
			if(count[j]>0){
				min = decks[j][count[j]-1];
				pickedRow = j;
				break;
			}
	}
	
	free(count);
	free(decks);
	
	return sortedArr;
}

int main(int argC,char* argV[])
{
	int *arr, *sortedArr, i;
	
	if(argC==0)
		printf("Usage : %s <integers to be sorted separated by space>");
	else{
		arr = (int*)malloc((argC-1)*sizeof(int));
		
		for(i=1;i<=argC;i++)
			arr[i-1] = atoi(argV[i]);
		
		sortedArr = patienceSort(arr,argC-1);
		
		for(i=0;i<argC-1;i++)
			printf("%d ",sortedArr[i]);
	}
	
	return 0;
}
`,`#include "sorting-algorithms-patience-sort.h"



void * _patienceSort(long param_1,uint param_2)

{
  void *local_90;
  undefined *local_88;
  ulong local_80;
  ulong local_78;
  ulong local_70;
  void *local_68;
  void *local_60;
  int *local_58;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  ulong local_38;
  undefined *local_30;
  uint local_24;
  long local_20;
  long local_18;
  
  local_30 = (undefined *)&local_90;
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_70 = (ulong)param_2;
  local_80 = (ulong)param_2;
  local_78 = local_70 * local_80 * 4 + 0xf & 0xfffffffffffffff0;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_68 = (void *)((long)&local_90 - local_78);
  local_38 = local_70;
  local_58 = (int *)_calloc(4,(long)(int)local_24);
  local_60 = _malloc((long)(int)local_24 << 2);
  local_44 = 0;
  do {
    if ((int)local_24 <= local_44) {
      local_4c = *(int *)((long)local_68 + (long)(*local_58 + -1) * 4);
      local_50 = 0;
      local_44 = 0;
      do {
        if ((int)local_24 <= local_44) {
          _free(local_58);
          _free(local_68);
          local_90 = local_60;
          local_88 = local_30;
          if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
            return local_60;
          }
                    // WARNING: Subroutine does not return
          ___stack_chk_fail();
        }
        for (local_48 = 0; local_48 < (int)local_24; local_48 = local_48 + 1) {
          if ((0 < local_58[local_48]) &&
             (*(int *)((long)local_68 +
                      (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4) <
              local_4c)) {
            local_4c = *(int *)((long)local_68 +
                               (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4);
            local_50 = local_48;
          }
        }
        *(int *)((long)local_60 + (long)local_44 * 4) = local_4c;
        local_58[local_50] = local_58[local_50] + -1;
        for (local_48 = 0; local_48 < (int)local_24; local_48 = local_48 + 1) {
          if (0 < local_58[local_48]) {
            local_4c = *(int *)((long)local_68 +
                               (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4);
            local_50 = local_48;
            break;
          }
        }
        local_44 = local_44 + 1;
      } while( true );
    }
    for (local_48 = 0; local_48 < (int)local_24; local_48 = local_48 + 1) {
      if ((local_58[local_48] == 0) ||
         ((0 < local_58[local_48] &&
          (*(int *)(local_20 + (long)local_44 * 4) <=
           *(int *)((long)local_68 +
                   (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4))))) {
        *(undefined4 *)
         ((long)local_68 + (long)local_58[local_48] * 4 + (long)local_48 * local_80 * 4) =
             *(undefined4 *)(local_20 + (long)local_44 * 4);
        local_58[local_48] = local_58[local_48] + 1;
        break;
      }
    }
    local_44 = local_44 + 1;
  } while( true );
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  void *pvVar2;
  int local_34;
  
  if (param_1 == 0) {
    _printf("Usage : %s <integers to be sorted separated by space>");
  }
  else {
    pvVar2 = _malloc((long)(param_1 + -1) << 2);
    for (local_34 = 1; local_34 <= param_1; local_34 = local_34 + 1) {
      iVar1 = _atoi(*(char **)(param_2 + (long)local_34 * 8));
      *(int *)((long)pvVar2 + (long)(local_34 + -1) * 4) = iVar1;
    }
    _patienceSort(pvVar2,param_1 + -1);
    for (local_34 = 0; local_34 < param_1 + -1; local_34 = local_34 + 1) {
      _printf("%d ");
    }
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
    const char *fruit[2] = { "apples", "oranges" };

    // Acquire the length of the array by dividing the size of all elements (found
    // with sizeof(fruit)) by the size of the first element.

    // Note that since the array elements are pointers to null-terminated character
    // arrays, the size of the first element is actually the size of the pointer
    // type - not the length of the string.

    // This size, regardless of the type being pointed to, is 8 bytes, 4 bytes, or
    // 2 bytes on 64-bit, 32-bit, or 16-bit platforms respectively.
    int length = sizeof(fruit) / sizeof(fruit[0]);

    printf("%d\n", length);

    return 0;
}
`,`#include "array-length-1.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  iVar1 = _printf("%d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

#define MAX_ENQUEUED 20
#define BUF_LEN 256
#define PORT_STR "12321"

/* ------------------------------------------------------------ */
/* How to clean up after dead child processes                   */
/* ------------------------------------------------------------ */

void wait_for_zombie(int s)
{
    while(waitpid(-1, NULL, WNOHANG) > 0) ;
}

/* ------------------------------------------------------------ */
/* Core of implementation of a child process                    */
/* ------------------------------------------------------------ */

void echo_lines(int csock)
{
    char buf[BUF_LEN];
    int r;

    while( (r = read(csock, buf, BUF_LEN)) > 0 ) {
        (void)write(csock, buf, r);
    }
    exit(EXIT_SUCCESS);
}

/* ------------------------------------------------------------ */
/* Core of implementation of the parent process                 */
/* ------------------------------------------------------------ */

void take_connections_forever(int ssock)
{
    for(;;) {
        struct sockaddr addr;
        socklen_t addr_size = sizeof(addr);
        int csock;

        /* Block until we take one connection to the server socket */
        csock = accept(ssock, &addr, &addr_size);

        /* If it was a successful connection, spawn a worker process to service it */
        if ( csock == -1 ) {
            perror("accept");
        } else if ( fork() == 0 ) {
            close(ssock);
            echo_lines(csock);
        } else {
            close(csock);
        }
    }
}

/* ------------------------------------------------------------ */
/* The server process's one-off setup code                      */
/* ------------------------------------------------------------ */

int main()
{
    struct addrinfo hints, *res;
    struct sigaction sa;
    int sock;

    /* Look up the address to bind to */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ( getaddrinfo(NULL, PORT_STR, &hints, &res) != 0 ) {
        perror("getaddrinfo");
        exit(EXIT_FAILURE);
    }

    /* Make a socket */
    if ( (sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1 ) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    /* Arrange to clean up child processes (the workers) */
    sa.sa_handler = wait_for_zombie;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if ( sigaction(SIGCHLD, &sa, NULL) == -1 ) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    /* Associate the socket with its address */
    if ( bind(sock, res->ai_addr, res->ai_addrlen) != 0 ) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(res);

    /* State that we've opened a server socket and are listening for connections */
    if ( listen(sock, MAX_ENQUEUED) != 0 ) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    /* Serve the listening socket until killed */
    take_connections_forever(sock);
    return EXIT_SUCCESS;
}
`,`#include "echo-server.h"



void _wait_for_zombie(void)

{
  pid_t pVar1;
  
  do {
    pVar1 = _waitpid(-1,(int *)0x0,1);
  } while (0 < pVar1);
  return;
}



void _echo_lines(int param_1)

{
  ssize_t sVar1;
  undefined auStack_128 [256];
  undefined8 local_28;
  
  local_28 = *(undefined8 *)PTR____stack_chk_guard_100004000;
  while( true ) {
    sVar1 = _read(param_1,auStack_128,0x100);
    if ((int)sVar1 < 1) break;
    _write(param_1,auStack_128,(long)(int)sVar1);
  }
                    // WARNING: Subroutine does not return
  _exit(0);
}



void _take_connections_forever(int param_1)

{
  int iVar1;
  pid_t pVar2;
  socklen_t local_28;
  sockaddr sStack_24;
  int local_14;
  
  local_14 = param_1;
  do {
    while( true ) {
      while( true ) {
        local_28 = 0x10;
        iVar1 = _accept(local_14,&sStack_24,&local_28);
        if (iVar1 != -1) break;
        _perror("accept");
      }
      pVar2 = _fork();
      if (pVar2 != 0) break;
      _close(local_14);
      _echo_lines(iVar1);
    }
    _close(iVar1);
  } while( true );
}



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  sigaction local_60;
  addrinfo *local_50;
  addrinfo local_48;
  undefined4 local_14;
  
  local_14 = 0;
  _memset(&local_48,0,0x30);
  local_48.ai_family = 0;
  local_48.ai_socktype = 1;
  local_48.ai_flags = 1;
  iVar1 = _getaddrinfo((char *)0x0,"12321",&local_48,&local_50);
  if (iVar1 != 0) {
    _perror("getaddrinfo");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  iVar1 = _socket(local_50->ai_family,local_50->ai_socktype,local_50->ai_protocol);
  if (iVar1 == -1) {
    _perror("socket");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  local_60.__sigaction_u.__sa_handler = _wait_for_zombie;
  local_60.sa_mask = 0;
  local_60.sa_flags = 2;
  iVar2 = _sigaction(0x14,&local_60,(sigaction *)0x0);
  if (iVar2 == -1) {
    _perror("sigaction");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  iVar2 = _bind(iVar1,local_50->ai_addr,local_50->ai_addrlen);
  if (iVar2 != 0) {
    _perror("bind");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  _freeaddrinfo(local_50);
  iVar2 = _listen(iVar1,0x14);
  if (iVar2 != 0) {
    _perror("listen");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  _take_connections_forever(iVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _accept(int param_1,sockaddr *param_2,socklen_t *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__accept_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _bind(int param_1,sockaddr *param_2,socklen_t param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__bind_100004010)(param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _fork(void)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__fork_100004028)();
  return pVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _freeaddrinfo(addrinfo *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__freeaddrinfo_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getaddrinfo(char *param_1,char *param_2,addrinfo *param_3,addrinfo **param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getaddrinfo_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _listen(int param_1,int param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__listen_100004040)(param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004048)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _read(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__read_100004058)(param_1);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sigaction(int param_1,sigaction *param_2,sigaction *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sigaction_100004060)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _socket(int param_1,int param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__socket_100004068)(param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _waitpid(pid_t param_1,int *param_2,int param_3)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__waitpid_100004070)(param_1,param_2,param_3);
  return pVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _write(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__write_100004078)(param_1);
  return sVar1;
}


`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

typedef struct genome{
    char* strand;
    int length;
    struct genome* next;
}genome;

genome* genomeData;
int totalLength = 0, Adenine = 0, Cytosine = 0, Guanine = 0, Thymine = 0;

int numDigits(int num){
    int len = 1;

    while(num>10){
        num = num/10;
        len++;
    }

    return len;
}

void buildGenome(char str[100]){
    int len = strlen(str),i;
    genome *genomeIterator, *newGenome;

    totalLength += len;

    for(i=0;i<len;i++){
        switch(str[i]){
            case 'A': Adenine++;
                break;
            case 'T': Thymine++;
                break;
            case 'C': Cytosine++;
                break;
            case 'G': Guanine++;
                break;
        };
    }

    if(genomeData==NULL){
        genomeData = (genome*)malloc(sizeof(genome));

        genomeData->strand = (char*)malloc(len*sizeof(char));
        strcpy(genomeData->strand,str);
        genomeData->length = len;

        genomeData->next = NULL;
    }

    else{
        genomeIterator = genomeData;

        while(genomeIterator->next!=NULL)
            genomeIterator = genomeIterator->next;

        newGenome = (genome*)malloc(sizeof(genome));

        newGenome->strand = (char*)malloc(len*sizeof(char));
        strcpy(newGenome->strand,str);
        newGenome->length = len;

        newGenome->next = NULL;
        genomeIterator->next = newGenome;
    }
}

void printGenome(){
    genome* genomeIterator = genomeData;

    int width = numDigits(totalLength), len = 0;

    printf("Sequence:\n");

    while(genomeIterator!=NULL){
        printf("\n%*d%3s%3s",width+1,len,":",genomeIterator->strand);
        len += genomeIterator->length;

        genomeIterator = genomeIterator->next;
    }

    printf("\n\nBase Count\n----------\n\n");

    printf("%3c%3s%*d\n",'A',":",width+1,Adenine);
    printf("%3c%3s%*d\n",'T',":",width+1,Thymine);
    printf("%3c%3s%*d\n",'C',":",width+1,Cytosine);
    printf("%3c%3s%*d\n",'G',":",width+1,Guanine);
    printf("\n%3s%*d\n","Total:",width+1,Adenine + Thymine + Cytosine + Guanine);

    free(genomeData);
}

int main(int argc,char** argv)
{
    char str[100];
    int counter = 0, len;

    if(argc!=2){
        printf("Usage : %s <Gene file name>\n",argv[0]);
        return 0;
    }

    FILE *fp = fopen(argv[1],"r");

    while(fscanf(fp,"%s",str)!=EOF)
        buildGenome(str);
    fclose(fp);

    printGenome();

    return 0;
}
`,`#include "bioinformatics-base-count-1.h"



int _numDigits(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 1;
  for (local_4 = param_1; 10 < local_4; local_4 = local_4 / 10) {
    local_8 = local_8 + 1;
  }
  return local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

void _buildGenome(char *param_1)

{
  size_t sVar1;
  void *pvVar2;
  undefined8 *puVar3;
  int iVar4;
  undefined8 *local_28;
  int local_20;
  
  sVar1 = _strlen(param_1);
  iVar4 = (int)sVar1;
  __totalLength = __totalLength + iVar4;
  for (local_20 = 0; local_20 < iVar4; local_20 = local_20 + 1) {
    switch(param_1[local_20]) {
    case 'A':
      __Adenine = __Adenine + 1;
      break;
    case 'C':
      __Cytosine = __Cytosine + 1;
      break;
    case 'G':
      __Guanine = __Guanine + 1;
      break;
    case 'T':
      __Thymine = __Thymine + 1;
    }
  }
  if (__genomeData == (undefined8 *)0x0) {
    __genomeData = (undefined8 *)_malloc(0x18);
    pvVar2 = _malloc((long)iVar4);
    *__genomeData = pvVar2;
    ___strcpy_chk(*__genomeData,param_1,0xffffffffffffffff);
    *(int *)(__genomeData + 1) = iVar4;
    __genomeData[2] = 0;
  }
  else {
    for (local_28 = __genomeData; local_28[2] != 0; local_28 = (undefined8 *)local_28[2]) {
    }
    puVar3 = (undefined8 *)_malloc(0x18);
    pvVar2 = _malloc((long)iVar4);
    *puVar3 = pvVar2;
    ___strcpy_chk(*puVar3,param_1,0xffffffffffffffff);
    *(int *)(puVar3 + 1) = iVar4;
    puVar3[2] = 0;
    local_28[2] = puVar3;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _printGenome(void)

{
  void *local_18;
  
  local_18 = __genomeData;
  _numDigits(__totalLength);
  _printf("Sequence:\n");
  for (; local_18 != (void *)0x0; local_18 = *(void **)((long)local_18 + 0x10)) {
    _printf("\n%*d%3s%3s");
  }
  _printf("\n\nBase Count\n----------\n\n");
  _printf("%3c%3s%*d\n");
  _printf("%3c%3s%*d\n");
  _printf("%3c%3s%*d\n");
  _printf("%3c%3s%*d\n");
  _printf("\n%3s%*d\n");
  _free(__genomeData);
  return;
}



undefined4 entry(int param_1,long param_2)

{
  uint uVar1;
  int iVar2;
  FILE *pFVar3;
  ulong uVar4;
  undefined auStack_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  if (param_1 == 2) {
    pFVar3 = _fopen(*(char **)(param_2 + 8),"r");
    while( true ) {
      iVar2 = _fscanf(pFVar3,"%s");
      if (iVar2 == -1) break;
      _buildGenome(auStack_7c);
    }
    iVar2 = _fclose(pFVar3);
    uVar4 = _printGenome(iVar2);
  }
  else {
    uVar1 = _printf("Usage : %s <Gene file name>\n");
    uVar4 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar4);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004048)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef unsigned char bool;

#define TRUE 1
#define FALSE 0
#define MILLION 1000000
#define BILLION 1000 * MILLION
#define MAX_COUNT 2*BILLION + 9*9 + 1

void sieve(bool *sv) {
    int n = 0, s[8], a, b, c, d, e, f, g, h, i, j;
    for (a = 0; a < 2; ++a) {
        for (b = 0; b < 10; ++b) {
            s[0] = a + b;
            for (c = 0; c < 10; ++c) {
                s[1] = s[0] + c;
                for (d = 0; d < 10; ++d) {
                    s[2] = s[1] + d;
                    for (e = 0; e < 10; ++e) {
                        s[3] = s[2] + e;
                        for (f = 0; f < 10; ++f) {
                            s[4] = s[3] + f;
                            for (g = 0; g < 10; ++g) {
                                s[5] = s[4] + g;
                                for (h = 0; h < 10; ++h) {
                                    s[6] = s[5] + h;
                                    for (i = 0; i < 10; ++i) {
                                        s[7] = s[6] + i;
                                        for (j = 0; j < 10; ++j) {
                                            sv[s[7] + j+ n++] = TRUE;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

int main() {
    int count = 0;
    clock_t begin = clock();
    bool *p, *sv = (bool*) calloc(MAX_COUNT, sizeof(bool));
    sieve(sv);
    printf("The first 50 self numbers are:\n");
    for (p = sv; p < sv + MAX_COUNT; ++p) {
        if (!*p) {
            if (++count <= 50) printf("%ld ", p-sv);
            if (count == 100 * MILLION) {
                printf("\n\nThe 100 millionth self number is %ld\n", p-sv);
                break;
            }
        }
    }
    free(sv);
    printf("Took %lf seconds.\n", (double)(clock() - begin) / CLOCKS_PER_SEC);
    return 0;
}
`,`#include "self-numbers-1.h"



void _sieve(long param_1)

{
  long lVar1;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  
  lVar1 = *(long *)PTR____stack_chk_guard_100004008;
  local_44 = 0;
  for (local_48 = 0; local_48 < 2; local_48 = local_48 + 1) {
    for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
      for (local_50 = 0; local_50 < 10; local_50 = local_50 + 1) {
        for (local_54 = 0; local_54 < 10; local_54 = local_54 + 1) {
          for (local_58 = 0; local_58 < 10; local_58 = local_58 + 1) {
            for (local_5c = 0; local_5c < 10; local_5c = local_5c + 1) {
              for (local_60 = 0; local_60 < 10; local_60 = local_60 + 1) {
                for (local_64 = 0; local_64 < 10; local_64 = local_64 + 1) {
                  for (local_68 = 0; local_68 < 10; local_68 = local_68 + 1) {
                    for (local_6c = 0; local_6c < 10; local_6c = local_6c + 1) {
                      *(undefined *)
                       (param_1 +
                       (local_48 + local_4c + local_50 + local_54 + local_58 + local_5c + local_60 +
                        local_64 + local_68 + local_6c + local_44)) = 1;
                      local_44 = local_44 + 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar1) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



undefined8 entry(void)

{
  char *pcVar1;
  char *local_28;
  int local_18;
  
  local_18 = 0;
  _clock();
  pcVar1 = (char *)_calloc(0x77359452,1);
  _sieve(pcVar1);
  _printf("The first 50 self numbers are:\n");
  local_28 = pcVar1;
  do {
    if (pcVar1 + 0x77359452 <= local_28) {
LAB_100003ebc:
      _free(pcVar1);
      _clock();
      _printf("Took %lf seconds.\n");
      return 0;
    }
    if (*local_28 == '\0') {
      local_18 = local_18 + 1;
      if (local_18 < 0x33) {
        _printf("%ld ");
      }
      if (local_18 == 100000000) {
        _printf("\n\nThe 100 millionth self number is %ld\n");
        goto LAB_100003ebc;
      }
    }
    local_28 = local_28 + 1;
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004018)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`// return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
static unsigned multiplication_modulo(unsigned a, unsigned b, const unsigned mod) {
	unsigned res = 0, tmp;
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (tmp = b) >= mod - b ? tmp -= mod : 0, b += tmp);
	return res % mod;
}

// return (n ^ exp) % mod
static unsigned mod_pow(unsigned n, unsigned exp, const unsigned mod) {
	unsigned res = 1;
	for (n %= mod; exp; exp & 1 ? res = multiplication_modulo(res, n, mod) : 0, n = multiplication_modulo(n, n, mod), exp >>= 1);
	return res;
}

static unsigned tonelli_shanks_1(const unsigned n, const unsigned mod) {
	// return root such that (root * root) % mod congruent to n % mod.
	// return 0 if no solution to the congruence exists.
	// mod is assumed odd prime.
	const unsigned a = n % mod;
	unsigned res, b, c, d, e, f, g, h;
	if (mod_pow(a, (mod - 1) >> 1, mod) != 1)
		res = 0;
	else
		switch (mod & 7) {
			case 3 : case 7 :
				res = mod_pow(a, (mod + 1) >> 2, mod);
				break;
			case 5 :
				res = mod_pow(a, (mod + 3) >> 3, mod);
				if (multiplication_modulo(res, res, mod) != a){
					b = mod_pow(2, (mod - 1) >> 2, mod);
					res = multiplication_modulo(res, b, mod);
				}
				break;
			default :
				if (a == 1)
					res = 1;
				else {
					for (c = mod - 1, d = 2; d < mod && mod_pow(d, c >> 1, mod) != c; ++d);
					for (e = 0; !(c & 1); ++e, c >>= 1);
					f = mod_pow(a, c, mod);
					b = mod_pow(d, c, mod);
					for (h = 0, g = 0; h < e; h++) {
						d = mod_pow(b, g, mod);
						d = multiplication_modulo(d, f, mod);
						d = mod_pow(d, 1 << (e - 1 - h), mod);
						if (d == mod - 1)
							g += 1 << h;
					}
					f = mod_pow(a, (c + 1) >> 1, mod);
					b = mod_pow(b, g >> 1, mod);
					res = multiplication_modulo(f, b, mod);
				}
		}
	return res;
}

// return root such that (root * root) % mod congruent to n % mod.
// return 0 (the default value of a) if no solution to the congruence exists.
static unsigned tonelli_shanks_2(unsigned n, const unsigned mod) {
	unsigned a = 0, b = mod - 1, c, d = b, e = 0, f = 2, g;
	if (mod_pow(n, b >> 1, mod) == 1) {
		for (; !(d & 1); ++e, d >>= 1);
		if (e == 1)
			a = mod_pow(n, (mod + 1) >> 2, mod);
		else {
			for (; b != mod_pow(f, b >> 1, mod); ++f);
			for (b = mod_pow(f, d, mod), a = mod_pow(n, (d + 1) >> 1, mod), c = mod_pow(n, d, mod), g = e; c != 1; g = d) {
				for (d = 0, e = c, --g; e != 1 && d < g; ++d)
					e = multiplication_modulo(e, e, mod);
				for (f = b, n = g - d; n--;)
					f = multiplication_modulo(f, f, mod);
				a = multiplication_modulo(a, f, mod);
				b = multiplication_modulo(f, f, mod);
				c = multiplication_modulo(c, b, mod);
			}
		}
	}
	return a;
}

#include <assert.h>
int main() {
	unsigned n, mod, root ; /* root_2 = mod - root */

	n = 27875, mod = 26371, root = tonelli_shanks_1(n, mod);
	assert(root == 14320); // 14320 * 14320  mod  26371 = 1504     and   1504 =    27875 mod 26371

	n = 1111111111, mod = 1111111121, root = tonelli_shanks_1(n, mod);
	assert(root == 88664850);

	n = 5258, mod = 3851, root = tonelli_shanks_1(n, mod);
	assert(root == 0); // no solution to the congruence exists.
}
`,`#include "tonelli-shanks-algorithm-2.h"



undefined4 entry(void)

{
  int iVar1;
  
  iVar1 = FUN_100003a0c(0x6ce3,0x6703);
  if (iVar1 != 0x37f0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","tonelli-shanks-algorithm-2.c",0x57,"root == 14320");
  }
  iVar1 = FUN_100003a0c(0x423a35c7,0x423a35d1);
  if (iVar1 != 0x548eb12) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","tonelli-shanks-algorithm-2.c",0x5a,"root == 88664850");
  }
  iVar1 = FUN_100003a0c(0x148a,0xf0b);
  if (iVar1 != 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","tonelli-shanks-algorithm-2.c",0x5d,"root == 0");
  }
  return 0;
}



undefined4 FUN_100003a0c(uint param_1,uint param_2)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  uint local_3c;
  uint local_38;
  uint local_30;
  uint local_2c;
  uint local_28;
  
  uVar5 = 0;
  if (param_2 != 0) {
    uVar5 = param_1 / param_2;
  }
  iVar1 = param_1 - uVar5 * param_2;
  iVar3 = FUN_100003d6c(iVar1,param_2 - 1 >> 1,param_2);
  if (iVar3 != 1) {
    return 0;
  }
  uVar5 = param_2 & 7;
  if (uVar5 != 3) {
    if (uVar5 == 5) {
      uVar4 = FUN_100003d6c(iVar1,param_2 + 3 >> 3,param_2);
      iVar3 = FUN_100003e24(uVar4,uVar4,param_2);
      if (iVar3 == iVar1) {
        return uVar4;
      }
      uVar6 = FUN_100003d6c(2,param_2 - 1 >> 2,param_2);
      uVar4 = FUN_100003e24(uVar4,uVar6,param_2);
      return uVar4;
    }
    if (uVar5 != 7) {
      if (iVar1 == 1) {
        return 1;
      }
      local_28 = param_2 - 1;
      local_2c = 2;
      while( true ) {
        bVar2 = false;
        if (local_2c < param_2) {
          uVar5 = FUN_100003d6c(local_2c,local_28 >> 1,param_2);
          bVar2 = uVar5 != local_28;
        }
        if (!bVar2) break;
        local_2c = local_2c + 1;
      }
      local_30 = 0;
      for (; (local_28 & 1) == 0; local_28 = local_28 >> 1) {
        local_30 = local_30 + 1;
      }
      uVar4 = FUN_100003d6c(iVar1,local_28,param_2);
      uVar6 = FUN_100003d6c(local_2c,local_28,param_2);
      local_38 = 0;
      for (local_3c = 0; local_3c < local_30; local_3c = local_3c + 1) {
        uVar7 = FUN_100003d6c(uVar6,local_38,param_2);
        uVar7 = FUN_100003e24(uVar7,uVar4,param_2);
        iVar3 = FUN_100003d6c(uVar7,1 << (ulong)((local_30 - 1) - local_3c & 0x1f),param_2);
        if (iVar3 == param_2 - 1) {
          local_38 = local_38 + (1 << (ulong)(local_3c & 0x1f));
        }
      }
      uVar4 = FUN_100003d6c(iVar1,local_28 + 1 >> 1,param_2);
      uVar6 = FUN_100003d6c(uVar6,local_38 >> 1,param_2);
      uVar4 = FUN_100003e24(uVar4,uVar6,param_2);
      return uVar4;
    }
  }
  uVar4 = FUN_100003d6c(iVar1,param_2 + 1 >> 2,param_2);
  return uVar4;
}



undefined4 FUN_100003d6c(uint param_1,uint param_2,uint param_3)

{
  uint uVar1;
  undefined4 local_20;
  uint local_18;
  int local_14;
  
  local_20 = 1;
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = param_1 / param_3;
  }
  local_14 = param_1 - uVar1 * param_3;
  for (local_18 = param_2; local_18 != 0; local_18 = local_18 >> 1) {
    if ((local_18 & 1) != 0) {
      local_20 = FUN_100003e24(local_20,local_14,param_3);
    }
    local_14 = FUN_100003e24(local_14,local_14,param_3);
  }
  return local_20;
}



int FUN_100003e24(uint param_1,uint param_2,uint param_3)

{
  uint uVar1;
  uint local_14;
  uint local_10;
  uint local_8;
  uint local_4;
  
  local_10 = 0;
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = param_2 / param_3;
  }
  local_8 = param_2 - uVar1 * param_3;
  local_4 = param_1;
  while (local_4 != 0) {
    if ((local_4 & 1) != 0) {
      if (param_3 - local_10 <= local_8) {
        local_10 = local_10 - param_3;
      }
      local_10 = local_10 + local_8;
    }
    local_4 = local_4 >> 1;
    local_14 = local_8;
    if (param_3 - local_8 <= local_8) {
      local_14 = local_8 - param_3;
    }
    local_8 = local_8 + local_14;
  }
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = local_10 / param_3;
  }
  return local_10 - uVar1 * param_3;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}


`
`#include <stdio.h>
#include <stdint.h>

typedef uint32_t uint;
typedef uint64_t ulong;

ulong ipow(const uint x, const uint y) {
    ulong result = 1;
    for (uint i = 1; i <= y; i++)
        result *= x;
    return result;
}

uint min(const uint x, const uint y) {
    return (x < y) ? x : y;
}

void throw_die(const uint n_sides, const uint n_dice, const uint s, uint counts[]) {
    if (n_dice == 0) {
        counts[s]++;
        return;
    }

    for (uint i = 1; i < n_sides + 1; i++)
        throw_die(n_sides, n_dice - 1, s + i, counts);
}

double beating_probability(const uint n_sides1, const uint n_dice1,
                           const uint n_sides2, const uint n_dice2) {
    const uint len1 = (n_sides1 + 1) * n_dice1;
    uint C1[len1];
    for (uint i = 0; i < len1; i++)
        C1[i] = 0;
    throw_die(n_sides1, n_dice1, 0, C1);

    const uint len2 = (n_sides2 + 1) * n_dice2;
    uint C2[len2];
    for (uint j = 0; j < len2; j++)
        C2[j] = 0;
    throw_die(n_sides2, n_dice2, 0, C2);

    const double p12 = (double)(ipow(n_sides1, n_dice1) * ipow(n_sides2, n_dice2));

    double tot = 0;
    for (uint i = 0; i < len1; i++)
        for (uint j = 0; j < min(i, len2); j++)
            tot += (double)C1[i] * C2[j] / p12;
    return tot;
}

int main() {
    printf("%1.16f\n", beating_probability(4, 9, 6, 6));
    printf("%1.16f\n", beating_probability(10, 5, 7, 6));
    return 0;
}
`,`#include "dice-game-probabilities.h"



long _ipow(uint param_1,uint param_2)

{
  undefined4 local_14;
  undefined8 local_10;
  
  local_10 = 1;
  for (local_14 = 1; local_14 <= param_2; local_14 = local_14 + 1) {
    local_10 = local_10 * (ulong)param_1;
  }
  return local_10;
}



uint _min(uint param_1,uint param_2)

{
  uint local_c;
  
  local_c = param_2;
  if (param_1 < param_2) {
    local_c = param_1;
  }
  return local_c;
}



void _throw_die(int param_1,int param_2,uint param_3,long param_4)

{
  int *piVar1;
  undefined4 local_2c;
  
  if (param_2 == 0) {
    piVar1 = (int *)(param_4 + (ulong)param_3 * 4);
    *piVar1 = *piVar1 + 1;
  }
  else {
    for (local_2c = 1; local_2c < param_1 + 1U; local_2c = local_2c + 1) {
      _throw_die(param_1,param_2 + -1,param_3 + local_2c,param_4);
    }
  }
  return;
}



undefined  [16] _beating_probability(int param_1,int param_2,int param_3,int param_4)

{
  uint uVar1;
  long lVar2;
  double dVar3;
  undefined auVar4 [16];
  double dVar5;
  double local_b0;
  undefined *local_a8;
  uint local_9c;
  long local_98;
  ulong local_90;
  long local_88;
  ulong local_80;
  long local_78;
  uint local_70;
  uint local_6c;
  double local_68;
  double local_60;
  uint local_54;
  uint local_48;
  uint local_44;
  undefined *local_38;
  uint local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  long local_18;
  
  local_38 = (undefined *)&local_b0;
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_2c = (param_1 + 1) * param_2;
  local_80 = (ulong)local_2c * 4 + 0xf & 0xfffffffffffffff0;
  local_28 = param_4;
  local_24 = param_3;
  local_20 = param_2;
  local_1c = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_88 = (long)&local_b0 - local_80;
  for (local_44 = 0; local_44 < local_2c; local_44 = local_44 + 1) {
    *(undefined4 *)(local_88 + (ulong)local_44 * 4) = 0;
  }
  local_78 = local_88;
  _throw_die(local_1c,local_20,0,local_88);
  local_48 = (local_24 + 1) * local_28;
  local_90 = (ulong)local_48 * 4 + 0xf & 0xfffffffffffffff0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_88 = local_88 - local_90;
  for (local_54 = 0; local_54 < local_48; local_54 = local_54 + 1) {
    *(undefined4 *)(local_88 + (ulong)local_54 * 4) = 0;
  }
  _throw_die(local_24,local_28,0,local_88);
  local_98 = _ipow(local_1c,local_20);
  lVar2 = _ipow(local_24,local_28);
  local_60 = (double)(ulong)(local_98 * lVar2);
  local_68 = 0.0;
  for (local_6c = 0; local_6c < local_2c; local_6c = local_6c + 1) {
    local_70 = 0;
    while( true ) {
      local_9c = local_70;
      uVar1 = _min(local_6c,local_48);
      if (uVar1 <= local_9c) break;
      dVar3 = (double)NEON_ucvtf((ulong)*(uint *)(local_78 + (ulong)local_6c * 4));
      dVar5 = (double)NEON_ucvtf((ulong)*(uint *)(local_88 + (ulong)local_70 * 4));
      local_68 = local_68 + (dVar3 * dVar5) / local_60;
      local_70 = local_70 + 1;
    }
  }
  local_b0 = local_68;
  local_a8 = local_38;
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  auVar4._8_8_ = 0;
  auVar4._0_8_ = local_68;
  return auVar4;
}



undefined4 entry(void)

{
  _beating_probability(4,9,6);
  _printf("%1.16f\n");
  _beating_probability(10,5,7,6);
  _printf("%1.16f\n");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  int num;

  sscanf("0123459", "%d", &num);
  printf("%d\n", num); /* prints 123459 */

  sscanf("abcf123", "%x", &num);
  printf("%d\n", num); /* prints 180154659 */

  sscanf("7651", "%o", &num);
  printf("%d\n", num); /* prints 4009 */

  /* binary not supported */

  return 0;
}
`,`#include "non-decimal-radices-input-1.h"



undefined4 entry(void)

{
  _sscanf("0123459","%d");
  _printf("%d\n");
  _sscanf("abcf123","%x");
  _printf("%d\n");
  _sscanf("7651","%o");
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void vc(int n, int base, int *num, int *denom)
{
        int p = 0, q = 1;

        while (n) {
                p = p * base + (n % base);
                q *= base;
                n /= base;
        }

        *num = p;
        *denom = q;

        while (p) { n = p; p = q % p; q = n; }
        *num /= q;
        *denom /= q;
}

int main()
{
        int d, n, i, b;
        for (b = 2; b < 6; b++) {
                printf("base %d:", b);
                for (i = 0; i < 10; i++) {
                        vc(i, b, &n, &d);
                        if (n) printf("  %d/%d", n, d);
                        else   printf("  0");
                }
                printf("\n");
        }

        return 0;
}
`,`#include "van-der-corput-sequence.h"



void _vc(int param_1,int param_2,int *param_3,int *param_4)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_4;
  
  local_1c = 0;
  local_20 = 1;
  iVar2 = param_1;
  while (local_4 = iVar2, local_4 != 0) {
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = local_4 / param_2;
    }
    local_1c = local_1c * param_2 + (local_4 - iVar2 * param_2);
    local_20 = local_20 * param_2;
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = local_4 / param_2;
    }
  }
  *param_3 = local_1c;
  *param_4 = local_20;
  while (local_1c != 0) {
    iVar2 = 0;
    if (local_1c != 0) {
      iVar2 = local_20 / local_1c;
    }
    iVar1 = local_1c;
    local_1c = local_20 - iVar2 * local_1c;
    local_20 = iVar1;
  }
  iVar2 = 0;
  if (local_20 != 0) {
    iVar2 = *param_3 / local_20;
  }
  *param_3 = iVar2;
  iVar2 = 0;
  if (local_20 != 0) {
    iVar2 = *param_4 / local_20;
  }
  *param_4 = iVar2;
  return;
}



undefined8 entry(void)

{
  int local_24;
  int local_20;
  int local_1c;
  undefined local_18 [4];
  undefined4 local_14;
  
  local_14 = 0;
  for (local_24 = 2; local_24 < 6; local_24 = local_24 + 1) {
    _printf("base %d:");
    for (local_20 = 0; local_20 < 10; local_20 = local_20 + 1) {
      _vc(local_20,local_24,&local_1c,local_18);
      if (local_1c == 0) {
        _printf("  0");
      }
      else {
        _printf("  %d/%d");
      }
    }
    _printf("\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

long long c[100];

void coef(int n)
{
	int i, j;

	if (n < 0 || n > 63) abort(); // gracefully deal with range issue

	for (c[i=0] = 1; i < n; c[0] = -c[0], i++)
		for (c[1 + (j=i)] = 1; j > 0; j--)
			c[j] = c[j-1] - c[j];
}

int is_prime(int n)
{
	int i;

	coef(n);
	c[0] += 1, c[i=n] -= 1;
	while (i-- && !(c[i] % n));

	return i < 0;
}

void show(int n)
{
	do printf("%+lldx^%d", c[n], n); while (n--);
}

int main(void)
{
	int n;

	for (n = 0; n < 10; n++) {
		coef(n);
		printf("(x-1)^%d = ", n);
		show(n);
		putchar('\n');
	}

	printf("\nprimes (never mind the 1):");
	for (n = 1; n <= 63; n++)
		if (is_prime(n))
			printf(" %d", n);

	putchar('\n');
	return 0;
}
`,`#include "aks-test-for-primes.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _coef(int param_1)

{
  int local_1c;
  int local_18;
  
  if ((-1 < param_1) && (param_1 < 0x40)) {
    __c = 1;
    for (local_18 = 0; local_18 < param_1; local_18 = local_18 + 1) {
      local_1c = local_18;
      *(undefined8 *)(&_c + (long)(local_18 + 1) * 8) = 1;
      for (; 0 < local_1c; local_1c = local_1c + -1) {
        *(long *)(&_c + (long)local_1c * 8) =
             *(long *)(&_c + (long)(local_1c + -1) * 8) - *(long *)(&_c + (long)local_1c * 8);
      }
      __c = -__c;
    }
    return;
  }
                    // WARNING: Subroutine does not return
  _abort();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool _is_prime(int param_1)

{
  long lVar1;
  int iVar2;
  bool bVar3;
  long lVar4;
  int local_18;
  
  _coef(param_1);
  __c = __c + 1;
  *(long *)(&_c + (long)param_1 * 8) = *(long *)(&_c + (long)param_1 * 8) + -1;
  local_18 = param_1;
  do {
    iVar2 = local_18 + -1;
    bVar3 = false;
    if (local_18 != 0) {
      lVar4 = (long)param_1;
      lVar1 = 0;
      if (lVar4 != 0) {
        lVar1 = *(long *)(&_c + (long)iVar2 * 8) / lVar4;
      }
      bVar3 = *(long *)(&_c + (long)iVar2 * 8) == lVar1 * lVar4;
    }
    local_18 = iVar2;
  } while (bVar3);
  return iVar2 < 0;
}



int _show(int param_1)

{
  bool bVar1;
  int iVar2;
  int local_14;
  
  local_14 = param_1;
  do {
    iVar2 = _printf("%+lldx^%d");
    bVar1 = local_14 != 0;
    local_14 = local_14 + -1;
  } while (bVar1);
  return iVar2;
}



undefined8 entry(void)

{
  int iVar1;
  int local_18;
  
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _coef(local_18);
    _printf("(x-1)^%d = ");
    _show(local_18);
    _putchar(10);
  }
  _printf("\nprimes (never mind the 1):");
  for (local_18 = 1; local_18 < 0x40; local_18 = local_18 + 1) {
    iVar1 = _is_prime(local_18);
    if (iVar1 != 0) {
      _printf(" %d");
    }
  }
  _putchar(10);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _abort(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__abort_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdio.h>
#include <stdint.h>

int64_t mod(int64_t x, int64_t y) {
    int64_t m = x % y;
    if (m < 0) {
        if (y < 0) {
            return m - y;
        } else {
            return m + y;
        }
    }
    return m;
}

// Constants
// First generator
const static int64_t a1[3] = { 0, 1403580, -810728 };
const static int64_t m1 = (1LL << 32) - 209;
// Second generator
const static int64_t a2[3] = { 527612, 0, -1370589 };
const static int64_t m2 = (1LL << 32) - 22853;

const static int64_t d = (1LL << 32) - 209 + 1; // m1 + 1

// the last three values of the first generator
static int64_t x1[3];
// the last three values of the second generator
static int64_t x2[3];

void seed(int64_t seed_state) {
    x1[0] = seed_state;
    x1[1] = 0;
    x1[2] = 0;

    x2[0] = seed_state;
    x2[1] = 0;
    x2[2] = 0;
}

int64_t next_int() {
    int64_t x1i = mod((a1[0] * x1[0] + a1[1] * x1[1] + a1[2] * x1[2]), m1);
    int64_t x2i = mod((a2[0] * x2[0] + a2[1] * x2[1] + a2[2] * x2[2]), m2);
    int64_t z = mod(x1i - x2i, m1);

    // keep last three values of the first generator
    x1[2] = x1[1];
    x1[1] = x1[0];
    x1[0] = x1i;

    // keep last three values of the second generator
    x2[2] = x2[1];
    x2[1] = x2[0];
    x2[0] = x2i;

    return z + 1;
}

double next_float() {
    return (double)next_int() / d;
}

int main() {
    int counts[5] = { 0, 0, 0, 0, 0 };
    int i;

    seed(1234567);
    printf("%lld\n", next_int());
    printf("%lld\n", next_int());
    printf("%lld\n", next_int());
    printf("%lld\n", next_int());
    printf("%lld\n", next_int());
    printf("\n");

    seed(987654321);
    for (i = 0; i < 100000; i++) {
        int64_t value = floor(next_float() * 5);
        counts[value]++;
    }
    for (i = 0; i < 5; i++) {
        printf("%d: %d\n", i, counts[i]);
    }

    return 0;
}
`,`#include "pseudo-random-numbers-combined-recursive-generator-mrg32k3a.h"



long _mod(long param_1,long param_2)

{
  long lVar1;
  long local_8;
  
  lVar1 = 0;
  if (param_2 != 0) {
    lVar1 = param_1 / param_2;
  }
  local_8 = param_1 - lVar1 * param_2;
  if (local_8 < 0) {
    if (param_2 < 0) {
      local_8 = local_8 - param_2;
    }
    else {
      local_8 = local_8 + param_2;
    }
  }
  return local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _seed(undefined8 param_1)

{
  _DAT_100008000 = param_1;
  _DAT_100008008 = 0;
  _DAT_100008010 = 0;
  _DAT_100008018 = param_1;
  _DAT_100008020 = 0;
  _DAT_100008028 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long _next_int(void)

{
  long lVar1;
  long lVar2;
  long lVar3;
  
  lVar1 = _mod(_DAT_100008008 * 0x156abc + _DAT_100008010 * -0xc5ee8);
  lVar2 = _mod(_DAT_100008018 * 0x80cfc + _DAT_100008028 * -0x14e9dd,0xffffa6bb);
  lVar3 = _mod(lVar1 - lVar2,0xffffff2f);
  _DAT_100008010 = _DAT_100008008;
  _DAT_100008008 = _DAT_100008000;
  _DAT_100008000 = lVar1;
  _DAT_100008028 = _DAT_100008020;
  _DAT_100008020 = _DAT_100008018;
  _DAT_100008018 = lVar2;
  return lVar3 + 1;
}



undefined  [16] _next_float(void)

{
  long lVar1;
  undefined auVar2 [16];
  
  lVar1 = _next_int();
  auVar2._0_8_ = (double)lVar1 / 4294967088.0;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  double extraout_d0;
  int local_38;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30[0] = 0;
  local_30[1] = 0;
  local_30[2] = 0;
  local_30[3] = 0;
  local_30[4] = 0;
  _seed(0x12d687);
  _next_int();
  iVar1 = _printf("%lld\n");
  _next_int(iVar1);
  iVar1 = _printf("%lld\n");
  _next_int(iVar1);
  iVar1 = _printf("%lld\n");
  _next_int(iVar1);
  iVar1 = _printf("%lld\n");
  _next_int(iVar1);
  _printf("%lld\n");
  _printf("\n");
  uVar3 = _seed(0x3ade68b1);
  for (local_38 = 0; local_38 < 100000; local_38 = local_38 + 1) {
    uVar3 = _next_float();
    local_30[(long)(extraout_d0 * 5.0)] = local_30[(long)(extraout_d0 * 5.0)] + 1;
  }
  for (local_38 = 0; local_38 < 5; local_38 = local_38 + 1) {
    uVar2 = _printf("%d: %d\n");
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar3);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int even_sel(int x) { return !(x & 1); }
int tri_sel(int x) { return x % 3; }

/* using a predicate function sel() to select elements */
int* grep(int *in, int len, int *outlen, int (*sel)(int), int inplace)
{
	int i, j, *out;

	if (inplace)	out = in;
	else		out = malloc(sizeof(int) * len);

	for (i = j = 0; i < len; i++)
		if (sel(in[i]))
			out[j++] = in[i];

	if (!inplace && j < len)
		out = realloc(out, sizeof(int) * j);

	*outlen = j;
	return out;
}

int main()
{
	int in[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int i, len;

	int *even = grep(in, 10, &len, even_sel, 0);
	printf("Filtered even:");
	for (i = 0; i < len; i++) printf(" %d", even[i]);
	printf("\n");

	grep(in, 8, &len, tri_sel, 1);
	printf("In-place filtered not multiple of 3:");
	for (i = 0; i < len; i++) printf(" %d", in[i]);

	printf("\n");

	return 0;
}
`,`#include "filter.h"



bool _even_sel(uint param_1)

{
  return (param_1 & 1) == 0;
}



int _tri_sel(int param_1)

{
  return param_1 % 3;
}



void * _grep(void *param_1,int param_2,int *param_3,code *param_4,int param_5)

{
  int iVar1;
  long lVar2;
  void *local_48;
  int local_3c;
  int local_38;
  
  local_48 = param_1;
  if (param_5 == 0) {
    local_48 = _malloc((long)param_2 * 4);
  }
  local_3c = 0;
  for (local_38 = 0; local_38 < param_2; local_38 = local_38 + 1) {
    iVar1 = (*param_4)(*(undefined4 *)((long)param_1 + (long)local_38 * 4));
    if (iVar1 != 0) {
      lVar2 = (long)local_3c;
      local_3c = local_3c + 1;
      *(undefined4 *)((long)local_48 + lVar2 * 4) =
           *(undefined4 *)((long)param_1 + (long)local_38 * 4);
    }
  }
  if ((param_5 == 0) && (local_3c < param_2)) {
    local_48 = _realloc(local_48,(long)local_3c * 4);
  }
  *param_3 = local_3c;
  return local_48;
}



undefined8 entry(void)

{
  int iVar1;
  int local_4c;
  int local_48;
  undefined4 local_44;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_44 = 0;
  _memcpy(auStack_40,&DAT_100003f3c,0x28);
  _grep(auStack_40,10,&local_4c,_even_sel,0);
  _printf("Filtered even:");
  for (local_48 = 0; local_48 < local_4c; local_48 = local_48 + 1) {
    _printf(" %d");
  }
  _printf("\n");
  _grep(auStack_40,8,&local_4c,_tri_sel,1);
  _printf("In-place filtered not multiple of 3:");
  for (local_48 = 0; local_48 < local_4c; local_48 = local_48 + 1) {
    _printf(" %d");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004028)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

bool is_sorted(int *a, int n)
{
  while ( --n >= 1 ) {
    if ( a[n] < a[n-1] ) return false;
  }
  return true;
}

void shuffle(int *a, int n)
{
  int i, t, r;
  for(i=0; i < n; i++) {
    t = a[i];
    r = rand() % n;
    a[i] = a[r];
    a[r] = t;
  }
}

void bogosort(int *a, int n)
{
  while ( !is_sorted(a, n) ) shuffle(a, n);
}

int main()
{
  int numbers[] = { 1, 10, 9,  7, 3, 0 };
  int i;

  bogosort(numbers, 6);
  for (i=0; i < 6; i++) printf("%d ", numbers[i]);
  printf("\n");
}
`,`#include "sorting-algorithms-bogosort.h"



undefined _is_sorted(long param_1,int param_2)

{
  int iVar1;
  int iVar2;
  int local_14;
  
  local_14 = param_2;
  do {
    iVar1 = local_14 + -1;
    if (iVar1 < 1) {
      return 1;
    }
    iVar2 = local_14 + -2;
    local_14 = iVar1;
  } while (*(int *)(param_1 + (long)iVar2 * 4) <= *(int *)(param_1 + (long)iVar1 * 4));
  return 0;
}



void _shuffle(long param_1,int param_2)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  undefined4 local_20;
  
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    uVar1 = *(undefined4 *)(param_1 + (long)local_20 * 4);
    iVar3 = _rand();
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = iVar3 / param_2;
    }
    iVar3 = iVar3 - iVar2 * param_2;
    *(undefined4 *)(param_1 + (long)local_20 * 4) = *(undefined4 *)(param_1 + (long)iVar3 * 4);
    *(undefined4 *)(param_1 + (long)iVar3 * 4) = uVar1;
  }
  return;
}



void _bogosort(undefined8 param_1,undefined4 param_2)

{
  ulong uVar1;
  
  while (uVar1 = _is_sorted(param_1,param_2), (uVar1 & 1) == 0) {
    _shuffle(param_1,param_2);
  }
  return;
}



undefined4 entry(void)

{
  int iVar1;
  int local_38;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 0x700000009;
  local_30 = 0xa00000001;
  local_20 = 3;
  _bogosort(&local_30,6);
  for (local_38 = 0; local_38 < 6; local_38 = local_38 + 1) {
    _printf("%d ");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}


`
`#include <stdio.h>
int main()
{
	printf("\033[6;3HHello\n");
	return 0;
}
`,`#include "terminal-control-cursor-positioning-1.h"



undefined4 entry(void)

{
  _printf("\x1b[6;3HHello\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`// A doubly linked list of strings;
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct sListEntry {
    const char *value;
    struct sListEntry *next;
    struct sListEntry *prev;
} *ListEntry, *LinkedList;

typedef struct sListIterator{
    ListEntry  link;
    LinkedList head;
} *LIterator;

LinkedList NewList() {
    ListEntry le = malloc(sizeof(struct sListEntry));
    if (le) {
        le->value = NULL;
        le->next = le->prev = NULL;
    }
    return le;
}

int LL_Append(LinkedList ll, const char *newVal)
{
    ListEntry le = malloc(sizeof(struct sListEntry));
    if (le) {
        le->value = strdup(newVal);
        le->prev = ll->prev;
        le->next = NULL;
        if (le->prev)
            le->prev->next = le;
        else
            ll->next = le;
        ll->prev = le;
    }
    return (le!= NULL);
}

int LI_Insert(LIterator iter, const char *newVal)
{
    ListEntry crnt = iter->link;
    ListEntry le = malloc(sizeof(struct sListEntry));
    if (le) {
        le->value = strdup(newVal);
        if ( crnt == iter->head) {
            le->prev = NULL;
            le->next = crnt->next;
            crnt->next = le;
            if (le->next)
                le->next->prev = le;
            else
                crnt->prev = le;
        }
        else {
            le->prev = ( crnt == NULL)? iter->head->prev : crnt->prev;
            le->next = crnt;
            if (le->prev)
                le->prev->next = le;
            else
                iter->head->next = le;
            if (crnt)
                crnt->prev = le;
            else
                iter->head->prev = le;
        }
    }
    return (le!= NULL);
}

LIterator LL_GetIterator(LinkedList ll )
{
    LIterator liter = malloc(sizeof(struct sListIterator));
    liter->head = ll;
    liter->link = ll;
    return liter;
}

#define LLI_Delete( iter ) \
    {free(iter); \
    iter = NULL;}

int LLI_AtEnd(LIterator iter)
{
    return iter->link == NULL;
}
const char *LLI_Value(LIterator iter)
{
    return (iter->link)? iter->link->value: NULL;
}
int LLI_Next(LIterator iter)
{
    if (iter->link) iter->link = iter->link->next;
    return(iter->link != NULL);
}
int LLI_Prev(LIterator iter)
{
    if (iter->link) iter->link = iter->link->prev;
    return(iter->link != NULL);
}

int main()
{
    static const char *contents[] = {"Read", "Orage", "Yeller",
                                     "Glean", "Blew", "Burple"};
    int ix;
    LinkedList ll = NewList();    //new linked list
    LIterator iter;

    for (ix=0; ix<6; ix++)        //insert contents
        LL_Append(ll, contents[ix]);

    iter = LL_GetIterator(ll);    //get an iterator
    printf("forward\n");
    while(LLI_Next(iter))         //iterate forward
        printf("value=%s\n", LLI_Value(iter));
    LLI_Delete(iter);             //delete iterator

    printf("\nreverse\n");
    iter = LL_GetIterator(ll);
    while(LLI_Prev(iter))         //iterate reverse
        printf("value=%s\n", LLI_Value(iter));
    LLI_Delete(iter);
                        //uhhh-- delete list??
    return 0;
}
`,`#include "doubly-linked-list-traversal.h"



undefined8 * _NewList(void)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x18);
  if (puVar1 != (undefined8 *)0x0) {
    *puVar1 = 0;
    puVar1[2] = 0;
    puVar1[1] = 0;
  }
  return puVar1;
}



bool _LL_Append(long param_1,char *param_2)

{
  undefined8 *puVar1;
  char *pcVar2;
  
  puVar1 = (undefined8 *)_malloc(0x18);
  if (puVar1 != (undefined8 *)0x0) {
    pcVar2 = _strdup(param_2);
    *puVar1 = pcVar2;
    puVar1[2] = *(undefined8 *)(param_1 + 0x10);
    puVar1[1] = 0;
    if (puVar1[2] == 0) {
      *(undefined8 **)(param_1 + 8) = puVar1;
    }
    else {
      *(undefined8 **)(puVar1[2] + 8) = puVar1;
    }
    *(undefined8 **)(param_1 + 0x10) = puVar1;
  }
  return puVar1 != (undefined8 *)0x0;
}



bool _LI_Insert(long *param_1,char *param_2)

{
  undefined8 *puVar1;
  char *pcVar2;
  long lVar3;
  undefined8 local_38;
  
  lVar3 = *param_1;
  puVar1 = (undefined8 *)_malloc(0x18);
  if (puVar1 != (undefined8 *)0x0) {
    pcVar2 = _strdup(param_2);
    *puVar1 = pcVar2;
    if (lVar3 == param_1[1]) {
      puVar1[2] = 0;
      puVar1[1] = *(undefined8 *)(lVar3 + 8);
      *(undefined8 **)(lVar3 + 8) = puVar1;
      if (puVar1[1] == 0) {
        *(undefined8 **)(lVar3 + 0x10) = puVar1;
      }
      else {
        *(undefined8 **)(puVar1[1] + 0x10) = puVar1;
      }
    }
    else {
      if (lVar3 == 0) {
        local_38 = *(undefined8 *)(param_1[1] + 0x10);
      }
      else {
        local_38 = *(undefined8 *)(lVar3 + 0x10);
      }
      puVar1[2] = local_38;
      puVar1[1] = lVar3;
      if (puVar1[2] == 0) {
        *(undefined8 **)(param_1[1] + 8) = puVar1;
      }
      else {
        *(undefined8 **)(puVar1[2] + 8) = puVar1;
      }
      if (lVar3 == 0) {
        *(undefined8 **)(param_1[1] + 0x10) = puVar1;
      }
      else {
        *(undefined8 **)(lVar3 + 0x10) = puVar1;
      }
    }
  }
  return puVar1 != (undefined8 *)0x0;
}



undefined8 * _LL_GetIterator(undefined8 param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x10);
  puVar1[1] = param_1;
  *puVar1 = param_1;
  return puVar1;
}



bool _LLI_AtEnd(long *param_1)

{
  return *param_1 == 0;
}



undefined8 _LLI_Value(long *param_1)

{
  undefined8 local_10;
  
  if (*param_1 == 0) {
    local_10 = 0;
  }
  else {
    local_10 = *(undefined8 *)*param_1;
  }
  return local_10;
}



bool _LLI_Next(long *param_1)

{
  if (*param_1 != 0) {
    *param_1 = *(long *)(*param_1 + 8);
  }
  return *param_1 != 0;
}



bool _LLI_Prev(long *param_1)

{
  if (*param_1 != 0) {
    *param_1 = *(long *)(*param_1 + 0x10);
  }
  return *param_1 != 0;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 uVar2;
  void *pvVar3;
  int local_18;
  
  uVar2 = _NewList();
  for (local_18 = 0; local_18 < 6; local_18 = local_18 + 1) {
    _LL_Append(uVar2,(&PTR_s_Read_100008000)[local_18]);
  }
  pvVar3 = (void *)_LL_GetIterator(uVar2);
  _printf("forward\n");
  while( true ) {
    iVar1 = _LLI_Next(pvVar3);
    if (iVar1 == 0) break;
    _LLI_Value(pvVar3);
    _printf("value=%s\n");
  }
  _free(pvVar3);
  _printf("\nreverse\n");
  pvVar3 = (void *)_LL_GetIterator(uVar2);
  while( true ) {
    iVar1 = _LLI_Prev(pvVar3);
    if (iVar1 == 0) break;
    _LLI_Value(pvVar3);
    _printf("value=%s\n");
  }
  _free(pvVar3);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004018)();
  return pcVar1;
}


`
`#include <stdio.h>

int main(int argc, char **argv) {
	printf("Executable: %s\n", argv[0]);

	return 0;
}
`,`#include "program-name-1.h"



undefined4 entry(void)

{
  _printf("Executable: %s\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int isBal(const char*s,int l){
    signed c=0;
    while(l--)
	if(s[l]==']') ++c;
	else if(s[l]=='[') if(--c<0) break;
    return !c;
}

void shuffle(char*s,int h){
    int x,t,i=h;
    while(i--){
	t=s[x=rand()%h];
	s[x]=s[i];
	s[i]=t;
    }
}

void genSeq(char*s,int n){
    if(n){
	memset(s,'[',n);
	memset(s+n,']',n);
	shuffle(s,n*2);
    }
    s[n*2]=0;
}

void doSeq(int n){
    char s[64];
    const char *o="False";
    genSeq(s,n);
    if(isBal(s,n*2)) o="True";
    printf("'%s': %s\n",s,o);
}

int main(){
    int n=0;
    while(n<9) doSeq(n++);
    return 0;
}
`,`#include "balanced-brackets-1.h"



bool _isBal(long param_1,int param_2)

{
  int iVar1;
  int local_10;
  int local_c;
  
  local_10 = 0;
  local_c = param_2;
  do {
    while( true ) {
      iVar1 = local_c + -1;
      if (local_c == 0) goto LAB_100003cfc;
      local_c = iVar1;
      if (*(char *)(param_1 + iVar1) != ']') break;
      local_10 = local_10 + 1;
    }
  } while ((*(char *)(param_1 + iVar1) != '[') || (local_10 = local_10 + -1, -1 < local_10));
LAB_100003cfc:
  return local_10 == 0;
}



void _shuffle(long param_1,int param_2)

{
  undefined uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined4 local_28;
  
  local_28 = param_2;
  while (iVar3 = local_28 + -1, local_28 != 0) {
    iVar4 = _rand();
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = iVar4 / param_2;
    }
    iVar4 = iVar4 - iVar2 * param_2;
    uVar1 = *(undefined *)(param_1 + iVar4);
    *(undefined *)(param_1 + iVar4) = *(undefined *)(param_1 + iVar3);
    *(undefined *)(param_1 + iVar3) = uVar1;
    local_28 = iVar3;
  }
  return;
}



void _genSeq(long param_1,int param_2)

{
  if (param_2 != 0) {
    ___memset_chk(param_1,0x5b,(long)param_2);
    ___memset_chk(param_1 + param_2,0x5d,(long)param_2,0xffffffffffffffff);
    _shuffle(param_1,param_2 << 1);
  }
  *(undefined *)(param_1 + (param_2 << 1)) = 0;
  return;
}



void _doSeq(int param_1)

{
  int iVar1;
  undefined auStack_58 [64];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  _genSeq(auStack_58,param_1);
  _isBal(auStack_58,param_1 << 1);
  iVar1 = _printf("\'%s\': %s\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined8 entry(void)

{
  undefined4 local_18;
  
  local_18 = 0;
  while (local_18 < 9) {
    local_18 = local_18 + 1;
    _doSeq();
  }
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// we return a static buffer; caller wants it, caller copies it
char * mid3(int n)
{
	static char buf[32];
	int l;
	sprintf(buf, "%d", n > 0 ? n : -n);
	l = strlen(buf);
	if (l < 3 || !(l & 1)) return 0;
	l = l / 2 - 1;
	buf[l + 3] = 0;
	return buf + l;
}

int main(void)
{
	int x[] = {123, 12345, 1234567, 987654321, 10001, -10001,
		-123, -100, 100, -12345, 1, 2, -1, -10, 2002, -2002, 0,
		1234567890};

	int i;
	char *m;
	for (i = 0; i < sizeof(x)/sizeof(x[0]); i++) {
		if (!(m = mid3(x[i])))
			m = "error";
		printf("%d: %s\n", x[i], m);
	}
	return 0;
}
`,`#include "middle-three-digits-1.h"



long _mid3(void)

{
  int iVar1;
  size_t sVar2;
  long local_18;
  
  ___sprintf_chk(0x100008000,0,0x20,"%d");
  sVar2 = _strlen((char *)0x100008000);
  if (((int)sVar2 < 3) || ((sVar2 & 1) == 0)) {
    local_18 = 0;
  }
  else {
    iVar1 = (int)sVar2 / 2;
    *(undefined *)((long)(iVar1 + 2) + 0x100008000) = 0;
    local_18 = (long)(iVar1 + -1) + 0x100008000;
  }
  return local_18;
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  uint local_68;
  undefined4 auStack_60 [18];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  pvVar2 = _memcpy(auStack_60,&DAT_100003f60,0x48);
  for (local_68 = 0; local_68 < 0x12; local_68 = local_68 + 1) {
    _mid3(auStack_60[(int)local_68]);
    uVar1 = _printf("%d: %s\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004028)();
  return sVar1;
}


`
`#include <stdio.h>

#define MAXN 1000000
int maxl, maxr;

int is_prime(int n)
{
	int p;
	if (n % 3 == 0) return 0;

	for (p = 6; p * p <= n; p += 6)
		if (!(n % (p + 1) && n % (p + 5)))
			return 0;
	return 1;
}

void left(int n, int tens)
{
	int i, nn;

	if (n > maxl) maxl = n;
	if (n < MAXN / 10)
		for (tens *= 10, i = 1; i < 10; i++)
			if (is_prime(nn = i * tens + n))
				left(nn, tens);
}

void right(int n)
{
	int i, nn;
	static int d[] = {1,3,7,9};

	if (n > maxr) maxr = n;
	if (n < MAXN / 10)
		for (i = 1; i < 4; i++)
			if (is_prime(nn = n * 10 + d[i])) right(nn);
}

int main(void)
{
	left(3, 1); left(7, 1);
	right(3); right(5); right(7);

	printf("%d %d\n", maxl, maxr);

	return 0;
}
`,`#include "truncatable-primes-3.h"



undefined4 _is_prime(int param_1)

{
  int iVar1;
  int iVar2;
  int local_c;
  undefined4 local_4;
  
  if (param_1 % 3 == 0) {
    local_4 = 0;
  }
  else {
    for (local_c = 6; local_c * local_c <= param_1; local_c = local_c + 6) {
      iVar1 = local_c + 1;
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = param_1 / iVar1;
      }
      if (param_1 == iVar2 * iVar1) {
        return 0;
      }
      iVar1 = local_c + 5;
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = param_1 / iVar1;
      }
      if (param_1 == iVar2 * iVar1) {
        return 0;
      }
    }
    local_4 = 1;
  }
  return local_4;
}



void _left(int param_1,int param_2)

{
  int iVar1;
  undefined4 local_1c;
  
  if (_maxl < param_1) {
    _maxl = param_1;
  }
  if (param_1 < 100000) {
    for (local_1c = 1; local_1c < 10; local_1c = local_1c + 1) {
      iVar1 = _is_prime();
      if (iVar1 != 0) {
        _left(local_1c * param_2 * 10 + param_1,param_2 * 10);
      }
    }
  }
  return;
}



void _right(int param_1)

{
  int iVar1;
  int iVar2;
  undefined4 local_18;
  
  if (_maxr < param_1) {
    _maxr = param_1;
  }
  if (param_1 < 100000) {
    for (local_18 = 1; local_18 < 4; local_18 = local_18 + 1) {
      iVar1 = *(int *)((long)local_18 * 4 + 0x100008000);
      iVar2 = _is_prime();
      if (iVar2 != 0) {
        _right(param_1 * 10 + iVar1);
      }
    }
  }
  return;
}



undefined4 entry(void)

{
  _left();
  _left(7,1);
  _right(3);
  _right(5);
  _right(7);
  _printf("%d %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned uint;
typedef struct { uint i, v; } filt_t;

// ludics with at least so many elements and reach at least such value
uint* ludic(uint min_len, uint min_val, uint *len)
{
	uint cap, i, v, active = 1, nf = 0;
	filt_t *f = calloc(cap = 2, sizeof(*f));
	f[1].i = 4;

	for (v = 1; ; ++v) {
		for (i = 1; i < active && --f[i].i; i++);

		if (i < active)
			f[i].i = f[i].v;
		else if (nf == f[i].i)
			f[i].i = f[i].v, ++active;  // enable one more filter
		else {
			if (nf >= cap)
				f = realloc(f, sizeof(*f) * (cap*=2));
			f[nf] = (filt_t){ v + nf, v };
			if (++nf >= min_len && v >= min_val) break;
		}
	}

	// pack the sequence into a uint[]
	// filt_t struct was used earlier for cache locality in loops
	uint *x = (void*) f;
	for (i = 0; i < nf; i++) x[i] = f[i].v;
	x = realloc(x, sizeof(*x) * nf);

	*len = nf;
	return x;
}

int find(uint *a, uint v)
{
	uint i;
	for (i = 0; a[i] <= v; i++)
		if (v == a[i]) return 1;
	return 0;
}

int main(void)
{
	uint len, i, *x = ludic(2005, 1000, &len);

	printf("First 25:");
	for (i = 0; i < 25; i++) printf(" %u", x[i]);
	putchar('\n');

	for (i = 0; x[i] <= 1000; i++);
	printf("Ludics below 1000: %u\n", i);

	printf("Ludic 2000 to 2005:");
	for (i = 2000; i <= 2005; i++) printf(" %u", x[i - 1]);
	putchar('\n');

	printf("Triples below 250:");
	for (i = 0; x[i] + 6 <= 250; i++)
		if (find(x, x[i] + 2) && find(x, x[i] + 6))
			printf(" (%u %u %u)", x[i], x[i] + 2, x[i] + 6);

	putchar('\n');

	free(x);
	return 0;
}
`,`#include "ludic-numbers.h"



void * _ludic(uint param_1,uint param_2,uint *param_3)

{
  int *piVar1;
  int iVar2;
  bool bVar3;
  void *pvVar4;
  void *local_40;
  uint local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  
  local_30 = 1;
  local_34 = 0;
  local_24 = 2;
  local_40 = _calloc(2,8);
  *(undefined4 *)((long)local_40 + 8) = 4;
  local_2c = 1;
  do {
    local_28 = 1;
    while( true ) {
      bVar3 = false;
      if (local_28 < local_30) {
        piVar1 = (int *)((long)local_40 + (ulong)local_28 * 8);
        iVar2 = *piVar1 + -1;
        *piVar1 = iVar2;
        bVar3 = iVar2 != 0;
      }
      if (!bVar3) break;
      local_28 = local_28 + 1;
    }
    if (local_28 < local_30) {
      *(undefined4 *)((long)local_40 + (ulong)local_28 * 8) =
           *(undefined4 *)((long)local_40 + (ulong)local_28 * 8 + 4);
    }
    else if (local_34 == *(uint *)((long)local_40 + (ulong)local_28 * 8)) {
      *(undefined4 *)((long)local_40 + (ulong)local_28 * 8) =
           *(undefined4 *)((long)local_40 + (ulong)local_28 * 8 + 4);
      local_30 = local_30 + 1;
    }
    else {
      if (local_24 <= local_34) {
        local_24 = local_24 << 1;
        local_40 = _realloc(local_40,(ulong)local_24 * 8);
      }
      *(ulong *)((long)local_40 + (ulong)local_34 * 8) = CONCAT44(local_2c,local_2c + local_34);
      local_34 = local_34 + 1;
      if ((param_1 <= local_34) && (param_2 <= local_2c)) {
        for (local_28 = 0; local_28 < local_34; local_28 = local_28 + 1) {
          *(undefined4 *)((long)local_40 + (ulong)local_28 * 4) =
               *(undefined4 *)((long)local_40 + (ulong)local_28 * 8 + 4);
        }
        pvVar4 = _realloc(local_40,(ulong)local_34 * 4);
        *param_3 = local_34;
        return pvVar4;
      }
    }
    local_2c = local_2c + 1;
  } while( true );
}



undefined4 _find(long param_1,uint param_2)

{
  uint local_18;
  
  local_18 = 0;
  while( true ) {
    if (param_2 < *(uint *)(param_1 + (ulong)local_18 * 4)) {
      return 0;
    }
    if (param_2 == *(uint *)(param_1 + (ulong)local_18 * 4)) break;
    local_18 = local_18 + 1;
  }
  return 1;
}



undefined8 entry(void)

{
  int iVar1;
  void *pvVar2;
  uint local_1c;
  undefined auStack_18 [4];
  undefined4 local_14;
  
  local_14 = 0;
  pvVar2 = (void *)_ludic(0x7d5,1000,auStack_18);
  _printf("First 25:");
  for (local_1c = 0; local_1c < 0x19; local_1c = local_1c + 1) {
    _printf(" %u");
  }
  _putchar(10);
  local_1c = 0;
  while (*(uint *)((long)pvVar2 + (ulong)local_1c * 4) < 0x3e9) {
    local_1c = local_1c + 1;
  }
  _printf("Ludics below 1000: %u\n");
  _printf("Ludic 2000 to 2005:");
  for (local_1c = 2000; local_1c < 0x7d6; local_1c = local_1c + 1) {
    _printf(" %u");
  }
  _putchar(10);
  _printf("Triples below 250:");
  local_1c = 0;
  while (*(int *)((long)pvVar2 + (ulong)local_1c * 4) + 6U < 0xfb) {
    iVar1 = _find(pvVar2,*(int *)((long)pvVar2 + (ulong)local_1c * 4) + 2);
    if ((iVar1 != 0) &&
       (iVar1 = _find(pvVar2,*(int *)((long)pvVar2 + (ulong)local_1c * 4) + 6), iVar1 != 0)) {
      _printf(" (%u %u %u)");
    }
    local_1c = local_1c + 1;
  }
  _putchar(10);
  _free(pvVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004020)();
  return pvVar1;
}


`
`#include<stdio.h>
#define de 0
#define pe 1
#define ab 2

int main(){
	int sum = 0, i, j;
	int try_max = 0;
	//1 is deficient by default and can add it deficient list
	int   count_list[3] = {1,0,0};
	for(i=2; i <= 20000; i++){
		//Set maximum to check for proper division
		try_max = i/2;
		//1 is in all proper division number
		sum = 1;
		for(j=2; j<try_max; j++){
			//Check for proper division
			if (i % j)
				continue; //Pass if not proper division
			//Set new maximum for divisibility check
			try_max = i/j;
			//Add j to sum
			sum += j;
			if (j != try_max)
				sum += try_max;
		}
		//Categorize summation
		if (sum < i){
			count_list[de]++;
			continue;
		}
		if (sum > i){
			count_list[ab]++;
			continue;
		}
		count_list[pe]++;
	}
	printf("\nThere are %d deficient," ,count_list[de]);
	printf(" %d perfect," ,count_list[pe]);
	printf(" %d abundant numbers between 1 and 20000.\n" ,count_list[ab]);
return 0;
}
`,`#include "abundant-deficient-and-perfect-number-classifications.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  int local_3c;
  int local_38;
  int local_34;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_34 = 2; local_34 < 0x4e21; local_34 = local_34 + 1) {
    local_3c = local_34 / 2;
    for (local_38 = 2; local_38 < local_3c; local_38 = local_38 + 1) {
      iVar1 = 0;
      if (local_38 != 0) {
        iVar1 = local_34 / local_38;
      }
      if ((local_34 == iVar1 * local_38) && (local_3c = 0, local_38 != 0)) {
        local_3c = local_34 / local_38;
      }
    }
  }
  _printf("\nThere are %d deficient,");
  _printf(" %d perfect,");
  iVar1 = _printf(" %d abundant numbers between 1 and 20000.\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
typedef unsigned long long LONG;

LONG deranged(int depth, int len, int *d, int show)
{
        int i;
        char tmp;
        LONG count = 0;

        if (depth == len) {
                if (show) {
                        for (i = 0; i < len; i++) putchar(d[i] + 'a');
                        putchar('\n');
                }
                return 1;
        }
        for (i = len - 1; i >= depth; i--) {
                if (i == d[depth]) continue;

                tmp = d[i]; d[i] = d[depth]; d[depth] = tmp;
                count += deranged(depth + 1, len, d, show);
                tmp = d[i]; d[i] = d[depth]; d[depth] = tmp;
        }
        return count;
}

LONG gen_n(int n, int show)
{
        LONG i;
        int a[1024]; /* 1024 ought to be big enough for anybody */

        for (i = 0; i < n; i++) a[i] = i;
        return deranged(0, n, a, show);
}

LONG sub_fact(int n)
{
        return n < 2 ? 1 - n : (sub_fact(n - 1) + sub_fact(n - 2)) * (n - 1);
}

int main()
{
        int i;

        printf("Deranged Four:\n");
        gen_n(4, 1);

        printf("\nCompare list vs calc:\n");
        for (i = 0; i < 10; i++)
                printf("%d:\t%llu\t%llu\n", i, gen_n(i, 0), sub_fact(i));

        printf("\nfurther calc:\n");
        for (i = 10; i <= 20; i++)
                printf("%d: %llu\n", i, sub_fact(i));

        return 0;
}
`,`#include "permutations-derangements.h"



long _deranged(int param_1,int param_2,long param_3,int param_4)

{
  undefined4 uVar1;
  long lVar2;
  undefined8 local_40;
  undefined4 local_30;
  undefined8 local_18;
  
  local_40 = 0;
  if (param_1 == param_2) {
    if (param_4 != 0) {
      for (local_30 = 0; local_30 < param_2; local_30 = local_30 + 1) {
        _putchar(*(int *)(param_3 + (long)local_30 * 4) + 0x61);
      }
      _putchar(10);
    }
    local_18 = 1;
  }
  else {
    for (local_30 = param_2 + -1; param_1 <= local_30; local_30 = local_30 + -1) {
      if (local_30 != *(int *)(param_3 + (long)param_1 * 4)) {
        uVar1 = *(undefined4 *)(param_3 + (long)local_30 * 4);
        *(undefined4 *)(param_3 + (long)local_30 * 4) = *(undefined4 *)(param_3 + (long)param_1 * 4)
        ;
        *(int *)(param_3 + (long)param_1 * 4) = (int)(char)uVar1;
        lVar2 = _deranged(param_1 + 1,param_2,param_3,param_4);
        local_40 = local_40 + lVar2;
        uVar1 = *(undefined4 *)(param_3 + (long)local_30 * 4);
        *(undefined4 *)(param_3 + (long)local_30 * 4) = *(undefined4 *)(param_3 + (long)param_1 * 4)
        ;
        *(int *)(param_3 + (long)param_1 * 4) = (int)(char)uVar1;
      }
    }
    local_18 = local_40;
  }
  return local_18;
}



undefined8 _gen_n(void)

{
  int iVar1;
  undefined8 uVar2;
  undefined4 extraout_w1;
  ulong local_1038;
  undefined4 auStack_1028 [1024];
  long local_28;
  
  iVar1 = (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  for (local_1038 = 0; local_1038 < (ulong)(long)iVar1; local_1038 = local_1038 + 1) {
    auStack_1028[local_1038] = (int)local_1038;
  }
  uVar2 = _deranged(0,iVar1,auStack_1028,extraout_w1);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return uVar2;
}



long _sub_fact(int param_1)

{
  long lVar1;
  long lVar2;
  undefined8 local_20;
  
  if (param_1 < 2) {
    local_20 = (long)(1 - param_1);
  }
  else {
    lVar1 = _sub_fact(param_1 + -1);
    lVar2 = _sub_fact(param_1 + -2);
    local_20 = (lVar1 + lVar2) * (long)(param_1 + -1);
  }
  return local_20;
}



undefined8 entry(void)

{
  int local_18;
  
  _printf("Deranged Four:\n");
  _gen_n(4,1);
  _printf("\nCompare list vs calc:\n");
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _gen_n(local_18,0);
    _sub_fact(local_18);
    _printf("%d:\t%llu\t%llu\n");
  }
  _printf("\nfurther calc:\n");
  for (local_18 = 10; local_18 < 0x15; local_18 = local_18 + 1) {
    _sub_fact(local_18);
    _printf("%d: %llu\n");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004020)(param_1);
  return iVar1;
}


`
`/**
  ascii Mandelbrot using 16 bits of fixed point integer maths with a selectable fractional precision in bits.

  This is still only 16 bits mathc and allocating more than 6 bits of fractional precision leads to an overflow that adds noise to the plot..

  This code frequently casts to short to ensure we're not accidentally benefitting from GCC promotion from short 16 bits to int.

  gcc fixedPoint.c  -lm

 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <string.h>

short s(short i);
short toPrec(double f, int bitsPrecision);

int main(int argc, char* argv[])
{
  // chosen to match https://www.youtube.com/watch?v=DC5wi6iv9io
  int width = 32; // basic width of a zx81
  int height = 22; // basic width of a zx81
  int zoom=3;  // bigger with finer detail ie a smaller step size - leave at 1 for 32x22

  // params
  short bitsPrecision = 6;
  printf("PRECISION=%d\n", bitsPrecision);

  short X1 = toPrec(3.5,bitsPrecision) / zoom;
  short X2 = toPrec(2.25,bitsPrecision) ;
  short Y1 = toPrec(3,bitsPrecision)/zoom ;   // horiz pos
  short Y2 = toPrec(1.5,bitsPrecision) ; // vert pos
  short LIMIT = toPrec(4,bitsPrecision);


  // fractal
  //char * chr = ".:-=X$#@.";
  char * chr = "abcdefghijklmnopqr ";
  //char * chr = ".,'~=+:;[/<&?oxOX#.";
  short maxIters = strlen(chr);

  short py=0;
  while (py < height*zoom) {
    short px=0;
    while (px < width*zoom) {

      short x0 = s(s(px*X1) / width) - X2;
      short y0 = s(s(py*Y1) / height) - Y2;

      short x=0;
      short y=0;

      short i=0;

      short xSqr;
      short ySqr;
      while (i < maxIters) {
        xSqr = s(x * x) >> bitsPrecision;
        ySqr = s(y * y) >> bitsPrecision;

        // Breakout if sum is > the limit OR breakout also if sum is negative which indicates overflow of the addition has occurred
        // The overflow check is only needed for precisions of over 6 bits because for 7 and above the sums come out overflowed and negative therefore we always run to maxIters and we see nothing.
        // By including the overflow break out we can see the fractal again though with noise.
        if ((xSqr + ySqr) >= LIMIT || (xSqr+ySqr) < 0) {
          break;
        }

        short xt = xSqr - ySqr + x0;
        y = s(s(s(x * y) >> bitsPrecision) * 2) + y0;
        x=xt;

        i = i + 1;
      }
      i = i - 1;

      printf("%c", chr[i]);

      px = px + 1;
    }

    printf("\n");
    py = py + 1;
  }
}

// convert decimal value to a fixed point value in the given precision
short toPrec(double f, int bitsPrecision) {
  short whole = ((short)floor(f) << (bitsPrecision));
  short part = (f-floor(f))*(pow(2,bitsPrecision));
  short ret = whole + part;
  return ret;
}

// convenient casting
short s(short i) {
  return i;
}
`,`#include "mandelbrot-set-5.h"



undefined4 entry(void)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  short sVar7;
  short sVar8;
  short sVar9;
  short sVar10;
  size_t sVar11;
  short local_50;
  short local_4e;
  short local_4c;
  short local_46;
  short local_44;
  
  _printf("PRECISION=%d\n");
  sVar1 = _toPrec(0x400c000000000000,6);
  sVar2 = _toPrec(0x4002000000000000,6);
  sVar3 = _toPrec(0x4008000000000000,6);
  sVar4 = _toPrec(0x3ff8000000000000,6);
  sVar5 = _toPrec(0x4010000000000000,6);
  sVar11 = _strlen("abcdefghijklmnopqr ");
  local_44 = 0;
  do {
    if (0x41 < local_44) {
      return 0;
    }
    for (local_46 = 0; local_46 < 0x60; local_46 = local_46 + 1) {
      sVar6 = _s((int)(short)(local_46 * (sVar1 / 3)));
      sVar6 = _s((int)(sVar6 / 0x20));
      sVar7 = _s((int)(short)(local_44 * (sVar3 / 3)));
      sVar7 = _s((int)(sVar7 / 0x16));
      local_4c = 0;
      local_4e = 0;
      for (local_50 = 0; local_50 < (short)sVar11; local_50 = local_50 + 1) {
        sVar8 = _s((int)(short)(local_4c * local_4c));
        sVar8 = sVar8 >> 6;
        sVar9 = _s((int)(short)(local_4e * local_4e));
        sVar9 = sVar9 >> 6;
        if (((int)sVar5 <= (int)sVar8 + (int)sVar9) || ((int)sVar8 + (int)sVar9 < 0)) break;
        sVar10 = _s((int)(short)(local_4c * local_4e));
        sVar10 = _s((int)(sVar10 >> 6));
        local_4e = _s((int)(short)((int)sVar10 << 1));
        local_4e = (sVar7 - sVar4) + local_4e;
        local_4c = (sVar8 - sVar9) + (sVar6 - sVar2);
      }
      _printf("%c");
    }
    _printf("\n");
    local_44 = local_44 + 1;
  } while( true );
}



long _toPrec(double param_1,uint param_2)

{
  double dVar1;
  
  dVar1 = (double)_pow(0x4000000000000000,(double)(long)(int)param_2);
  return (long)(short)((short)((int)(short)(int)param_1 << (ulong)(param_2 & 0x1f)) +
                      (short)(int)((param_1 - (double)(long)param_1) * dVar1));
}



long _s(short param_1)

{
  return (long)param_1;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004010)();
  return sVar1;
}


`
`#include <stdio.h>

int main()
{
	int i, j, dim, d;
	int depth = 3;

	for (i = 0, dim = 1; i < depth; i++, dim *= 3);

	for (i = 0; i < dim; i++) {
		for (j = 0; j < dim; j++) {
			for (d = dim / 3; d; d /= 3)
				if ((i % (d * 3)) / d == 1 && (j % (d * 3)) / d == 1)
					break;
			printf(d ? "  " : "##");
		}
		printf("\n");
	}

	return 0;
}
`,`#include "sierpinski-carpet-1.h"



undefined8 entry(void)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  
  local_20 = 1;
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    local_20 = local_20 * 3;
  }
  local_18 = 0;
  do {
    if (local_20 <= local_18) {
      return 0;
    }
    for (local_1c = 0; local_24 = local_20, local_1c < local_20; local_1c = local_1c + 1) {
      do {
        do {
          local_24 = local_24 / 3;
          if (local_24 == 0) goto LAB_100003f24;
          iVar2 = local_24 * 3;
          iVar3 = 0;
          if (iVar2 != 0) {
            iVar3 = local_18 / iVar2;
          }
          iVar4 = 0;
          if (local_24 != 0) {
            iVar4 = (local_18 - iVar3 * iVar2) / local_24;
          }
        } while (iVar4 != 1);
        iVar2 = local_24 * 3;
        iVar3 = 0;
        if (iVar2 != 0) {
          iVar3 = local_1c / iVar2;
        }
        iVar4 = 0;
        if (local_24 != 0) {
          iVar4 = (local_1c - iVar3 * iVar2) / local_24;
        }
      } while (iVar4 != 1);
LAB_100003f24:
      pcVar1 = "  ";
      if (local_24 == 0) {
        pcVar1 = "##";
      }
      _printf(pcVar1);
    }
    _printf("\n");
    local_18 = local_18 + 1;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <limits.h>

typedef unsigned long long ull;
#define N  (sizeof(ull) * CHAR_BIT)
#define B(x) (1ULL << (x))

void evolve(ull state, int rule)
{
	int i;
	ull st;

	printf("Rule %d:\n", rule);
	do {
		st = state;
		for (i = N; i--; ) putchar(st & B(i) ? '#' : '.');
		putchar('\n');

		for (state = i = 0; i < N; i++)
			if (rule & B(7 & (st>>(i-1) | st<<(N+1-i))))
				state |= B(i);
	} while (st != state);
}

int main(int argc, char **argv)
{
	evolve(B(N/2), 90);
	evolve(B(N/4)|B(N - N/4), 30); // well, enjoy the fireworks

	return 0;
}
`,`#include "elementary-cellular-automaton.h"



int _evolve(ulong param_1,int param_2)

{
  ulong uVar1;
  int iVar2;
  uint local_20;
  ulong local_18;
  
  _printf("Rule %d:\n");
  local_18 = param_1;
  do {
    uVar1 = local_18;
    local_20 = 0x40;
    while (local_20 != 0) {
      iVar2 = 0x23;
      if ((local_18 & 1L << ((ulong)(local_20 - 1) & 0x3f)) == 0) {
        iVar2 = 0x2e;
      }
      _putchar(iVar2);
      local_20 = local_20 - 1;
    }
    iVar2 = _putchar(10);
    local_18 = 0;
    for (local_20 = 0; local_20 < 0x40; local_20 = local_20 + 1) {
      if (((long)param_2 &
          1L << ((uVar1 >> ((ulong)(local_20 - 1) & 0x3f) |
                 uVar1 << (0x41U - (long)(int)local_20 & 0x3f)) & 7)) != 0) {
        local_18 = local_18 | 1L << ((ulong)local_20 & 0x3f);
      }
    }
  } while (uVar1 != local_18);
  return iVar2;
}



undefined4 entry(void)

{
  _evolve(0x100000000,0x5a);
  _evolve(0x1000000010000,0x1e);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <wchar.h>
#include <stdlib.h>
#include <locale.h>

int main(void)
{
    /* If your native locale doesn't use UTF-8 encoding
     * you need to replace the empty string with a
     * locale like "en_US.utf8"
     */
    char *locale = setlocale(LC_ALL, "");
    FILE *in = fopen("input.txt", "r");

    wint_t c;
    while ((c = fgetwc(in)) != WEOF)
        putwchar(c);
    fclose(in);

    return EXIT_SUCCESS;
}
`,`#include "read-a-file-character-by-character-utf8.h"



undefined8 entry(void)

{
  wchar_t wVar1;
  FILE *pFVar2;
  
  _setlocale(0,"");
  pFVar2 = _fopen("input.txt","r");
  while( true ) {
    wVar1 = _fgetwc(pFVar2);
    if (wVar1 == L'\xffffffff') break;
    _putwchar(wVar1);
  }
  _fclose(pFVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

wint_t _fgetwc(FILE *param_1)

{
  wint_t wVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  wVar1 = (*(code *)PTR__fgetwc_100004008)((int)param_1);
  return wVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004010)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

wint_t _putwchar(wchar_t param_1)

{
  wint_t wVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  wVar1 = (*(code *)PTR__putwchar_100004018)(param_1);
  return wVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004020)();
  return;
}


`
`#include <stdio.h>
#include <time.h>

static const char *months[] = {"January", "February", "March", "April", "May",
    "June", "July", "August", "September", "October", "November", "December"};
static int long_months[] = {0, 2, 4, 6, 7, 9, 11};

int main() {
    int n = 0, y, i, m;
    struct tm t = {0};
    printf("Months with five weekends:\n");
    for (y = 1900; y <= 2100; y++) {
        for (i = 0; i < 7; i++) {
            m = long_months[i];
            t.tm_year = y-1900;
	    t.tm_mon = m;
	    t.tm_mday = 1;
            if (mktime(&t) == -1) { /* date not supported */
                printf("Error: %d %s\n", y, months[m]);
                continue;
            }
            if (t.tm_wday == 5) { /* Friday */
                printf("  %d %s\n", y, months[m]);
                n++;
            }
        }
    }
    printf("%d total\n", n);
    return 0;
}
`,`#include "five-weekends-1.h"



undefined8 entry(void)

{
  time_t tVar1;
  tm tStack_60;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_18 = 0;
  _memset(&tStack_60,0,0x38);
  _printf("Months with five weekends:\n");
  for (local_1c = 0x76c; local_1c < 0x835; local_1c = local_1c + 1) {
    for (local_20 = 0; local_20 < 7; local_20 = local_20 + 1) {
      tStack_60.tm_mon = *(int *)(&DAT_100008000 + (long)local_20 * 4);
      tStack_60.tm_year = local_1c + -0x76c;
      tStack_60.tm_mday = 1;
      local_24 = tStack_60.tm_mon;
      tVar1 = _mktime(&tStack_60);
      if (tVar1 == -1) {
        _printf("Error: %d %s\n");
      }
      else if (tStack_60.tm_wday == 5) {
        _printf("  %d %s\n");
        local_18 = local_18 + 1;
      }
    }
  }
  _printf("%d total\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004000)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _mktime(tm *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__mktime_100004008)();
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <execinfo.h>

#define MAX_BT 200

void print_stack_trace()
{
  void *buffer[MAX_BT];
  int n;

  n = backtrace(buffer, MAX_BT);
  fprintf(stderr, "--- (depth %d) ---\n", n);
  backtrace_symbols_fd(buffer, n, STDERR_FILENO);
}


void inner(int k)
{
  print_stack_trace();
}

void middle(int x, int y)
{
  inner(x*y);
}

void outer(int a, int b, int c)
{
  middle(a+b, b+c);
}

int main()
{
  outer(2,3,5);
  return EXIT_SUCCESS;
}
`,`#include "stack-traces-1.h"



void _print_stack_trace(void)

{
  int iVar1;
  void *apvStack_668 [200];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  iVar1 = _backtrace(apvStack_668,200);
  _fprintf(*(FILE **)PTR____stderrp_100004010,"--- (depth %d) ---\n");
  _backtrace_symbols_fd(apvStack_668,iVar1,2);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void _inner(void)

{
  _print_stack_trace();
  return;
}



void _middle(int param_1,int param_2)

{
  _inner(param_1 * param_2);
  return;
}



void _outer(int param_1,int param_2,int param_3)

{
  _middle(param_1 + param_2,param_2 + param_3);
  return;
}



undefined4 entry(void)

{
  _outer(2,3,5);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _backtrace(void **param_1,int param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__backtrace_100004018)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _backtrace_symbols_fd(void **param_1,int param_2,int param_3)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__backtrace_symbols_fd_100004020)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>

int main(void)
{
  char s[] = "Hello, world!";
  size_t length = sizeof s - 1;

  return 0;
}
`,`#include "string-length-3.h"



undefined8 entry(void)

{
  if (*(long *)PTR____stack_chk_guard_100004008 != *(long *)PTR____stack_chk_guard_100004008) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int width = 80, year = 1969;
int cols, lead, gap;

const char *wdays[] = { "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" };
struct months {
	const char *name;
	int days, start_wday, at;
} months[12] = {
	{ "January",	31, 0, 0 },
	{ "February",	28, 0, 0 },
	{ "March",	31, 0, 0 },
	{ "April",	30, 0, 0 },
	{ "May",	31, 0, 0 },
	{ "June",	30, 0, 0 },
	{ "July",	31, 0, 0 },
	{ "August",	31, 0, 0 },
	{ "September",	30, 0, 0 },
	{ "October",	31, 0, 0 },
	{ "November",	30, 0, 0 },
	{ "December",	31, 0, 0 }
};

void space(int n) { while (n-- > 0) putchar(' '); }

void init_months()
{
	int i;

	if ((!(year % 4) && (year % 100)) || !(year % 400))
		months[1].days = 29;

	year--;
	months[0].start_wday
		= (year * 365 + year/4 - year/100 + year/400 + 1) % 7;

	for (i = 1; i < 12; i++)
		months[i].start_wday =
			(months[i-1].start_wday + months[i-1].days) % 7;

	cols = (width + 2) / 22;
	while (12 % cols) cols--;
	gap = cols - 1 ? (width - 20 * cols) / (cols - 1) : 0;
	if (gap > 4) gap = 4;
	lead = (width - (20 + gap) * cols + gap + 1) / 2;
        year++;
}

void print_row(int row)
{
	int c, i, from = row * cols, to = from + cols;
	space(lead);
	for (c = from; c < to; c++) {
		i = strlen(months[c].name);
		space((20 - i)/2);
		printf("%s", months[c].name);
		space(20 - i - (20 - i)/2 + ((c == to - 1) ? 0 : gap));
	}
	putchar('\n');

	space(lead);
	for (c = from; c < to; c++) {
		for (i = 0; i < 7; i++)
			printf("%s%s", wdays[i], i == 6 ? "" : " ");
		if (c < to - 1) space(gap);
		else putchar('\n');
	}

	while (1) {
		for (c = from; c < to; c++)
			if (months[c].at < months[c].days) break;
		if (c == to) break;

		space(lead);
		for (c = from; c < to; c++) {
			for (i = 0; i < months[c].start_wday; i++) space(3);
			while(i++ < 7 && months[c].at < months[c].days) {
				printf("%2d", ++months[c].at);
				if (i < 7 || c < to - 1) putchar(' ');
			}
			while (i++ <= 7 && c < to - 1) space(3);
			if (c < to - 1) space(gap - 1);
			months[c].start_wday = 0;
		}
		putchar('\n');
	}
	putchar('\n');
}

void print_year()
{
	int row;
	char buf[32];
	sprintf(buf, "%d", year);
	space((width - strlen(buf)) / 2);
	printf("%s\n\n", buf);
	for (row = 0; row * cols < 12; row++)
		print_row(row);
}

int main(int c, char **v)
{
	int i, year_set = 0;
	for (i = 1; i < c; i++) {
		if (!strcmp(v[i], "-w")) {
			if (++i == c || (width = atoi(v[i])) < 20)
				goto bail;
		} else if (!year_set) {
			if (!sscanf(v[i], "%d", &year) || year <= 0)
				year = 1969;
			year_set = 1;
		} else
			goto bail;
	}

	init_months();
	print_year();
	return 0;

bail:	fprintf(stderr, "bad args\nUsage: %s year [-w width (>= 20)]\n", v[0]);
	exit(1);
}
`,`#include "calendar-1.h"



ulong _space(ulong param_1)

{
  uint uVar1;
  undefined4 local_14;
  
  local_14 = (int)param_1;
  while (0 < local_14) {
    uVar1 = _putchar(0x20);
    param_1 = (ulong)uVar1;
    local_14 = local_14 + -1;
  }
  return param_1;
}



void _init_months(void)

{
  int iVar1;
  int local_8;
  int local_4;
  
  if (((_year % 4 == 0) && (_year % 100 != 0)) || (_year % 400 == 0)) {
    DAT_100008060 = 0x1d;
  }
  _year = _year + -1;
  DAT_10000804c = (((_year * 0x16d + _year / 4) - _year / 100) + _year / 400 + 1) % 7;
  for (local_4 = 1; local_4 < 0xc; local_4 = local_4 + 1) {
    (&DAT_10000804c)[(long)local_4 * 6] =
         ((&DAT_10000804c)[(long)(local_4 + -1) * 6] + (&DAT_100008048)[(long)(local_4 + -1) * 6]) %
         7;
  }
  _cols = (_width + 2) / 0x16;
  while( true ) {
    iVar1 = 0;
    if (_cols != 0) {
      iVar1 = 0xc / _cols;
    }
    if (iVar1 * _cols == 0xc) break;
    _cols = _cols + -1;
  }
  if (_cols == 1) {
    local_8 = 0;
  }
  else {
    local_8 = 0;
    if (_cols + -1 != 0) {
      local_8 = (_width + _cols * -0x14) / (_cols + -1);
    }
  }
  _gap = local_8;
  if (4 < local_8) {
    _gap = 4;
  }
  _lead = ((_width - (_gap + 0x14) * _cols) + _gap + 1) / 2;
  _year = _year + 1;
  return;
}



int _print_row(int param_1)

{
  bool bVar1;
  int iVar2;
  size_t sVar3;
  int iVar4;
  int local_44;
  int local_1c;
  int local_18;
  
  param_1 = param_1 * _cols;
  iVar2 = param_1 + _cols;
  _space(_lead);
  for (local_18 = param_1; local_18 < iVar2; local_18 = local_18 + 1) {
    sVar3 = _strlen((&_months)[(long)local_18 * 3]);
    iVar4 = (int)sVar3;
    _space((0x14 - iVar4) / 2);
    _printf("%s");
    if (local_18 == iVar2 + -1) {
      local_44 = 0;
    }
    else {
      local_44 = _gap;
    }
    _space(((0x14 - iVar4) - (0x14 - iVar4) / 2) + local_44);
  }
  _putchar(10);
  _space(_lead);
  for (local_18 = param_1; iVar4 = param_1, local_18 < iVar2; local_18 = local_18 + 1) {
    for (local_1c = 0; local_1c < 7; local_1c = local_1c + 1) {
      _printf("%s%s");
    }
    if (local_18 < iVar2 + -1) {
      _space(_gap);
    }
    else {
      _putchar(10);
    }
  }
  while( true ) {
    while ((local_18 = iVar4, local_18 < iVar2 &&
           ((int)(&DAT_100008048)[(long)local_18 * 6] <=
            *(int *)(&DAT_100008050 + (long)local_18 * 0x18)))) {
      iVar4 = local_18 + 1;
    }
    if (local_18 == iVar2) break;
    _space(_lead);
    for (local_18 = param_1; local_18 < iVar2; local_18 = local_18 + 1) {
      for (local_1c = 0; local_1c < (int)(&DAT_10000804c)[(long)local_18 * 6];
          local_1c = local_1c + 1) {
        _space(3);
      }
      while( true ) {
        iVar4 = local_1c + 1;
        bVar1 = false;
        if (local_1c < 7) {
          bVar1 = *(int *)(&DAT_100008050 + (long)local_18 * 0x18) <
                  (int)(&DAT_100008048)[(long)local_18 * 6];
        }
        local_1c = iVar4;
        if (!bVar1) break;
        *(int *)(&DAT_100008050 + (long)local_18 * 0x18) =
             *(int *)(&DAT_100008050 + (long)local_18 * 0x18) + 1;
        _printf("%2d");
        if ((iVar4 < 7) || (local_18 < iVar2 + -1)) {
          _putchar(0x20);
        }
      }
      while( true ) {
        bVar1 = false;
        if (local_1c < 8) {
          bVar1 = local_18 < iVar2 + -1;
        }
        if (!bVar1) break;
        _space(3);
        local_1c = local_1c + 1;
      }
      if (local_18 < iVar2 + -1) {
        _space(_gap + -1);
      }
      (&DAT_10000804c)[(long)local_18 * 6] = 0;
    }
    _putchar(10);
    iVar4 = param_1;
  }
  iVar2 = _putchar(10);
  return iVar2;
}



void _print_year(void)

{
  uint uVar1;
  size_t sVar2;
  ulong uVar3;
  long lVar4;
  int local_3c;
  char acStack_38 [32];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  ___sprintf_chk(acStack_38,0,0x20,"%d");
  lVar4 = (long)_width;
  sVar2 = _strlen(acStack_38);
  _space((lVar4 - sVar2) / 2);
  uVar1 = _printf("%s\n\n");
  uVar3 = (ulong)uVar1;
  for (local_3c = 0; local_3c * _cols < 0xc; local_3c = local_3c + 1) {
    uVar3 = _print_row(local_3c);
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar3);
}



undefined8 entry(int param_1,long param_2)

{
  bool bVar1;
  int iVar2;
  int local_24;
  
  bVar1 = false;
  local_24 = 1;
  do {
    if (param_1 <= local_24) {
      _init_months();
      _print_year();
      return 0;
    }
    iVar2 = _strcmp(*(char **)(param_2 + (long)local_24 * 8),"-w");
    if (iVar2 == 0) {
      local_24 = local_24 + 1;
      if ((local_24 == param_1) ||
         (_width = _atoi(*(char **)(param_2 + (long)local_24 * 8)), _width < 0x14))
      goto LAB_100003e44;
    }
    else {
      if (bVar1) {
LAB_100003e44:
        _fprintf(*(FILE **)PTR____stderrp_100004018,"bad args\nUsage: %s year [-w width (>= 20)]\n")
        ;
                    // WARNING: Subroutine does not return
        _exit(1);
      }
      iVar2 = _sscanf(*(char **)(param_2 + (long)local_24 * 8),"%d");
      if ((iVar2 == 0) || (_year < 1)) {
        _year = 0x7b1;
      }
      bVar1 = true;
    }
    local_24 = local_24 + 1;
  } while( true );
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004040)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004058)();
  return sVar1;
}


`
`#include <stdio.h>

char * base;
void get_diff()
{
	char x;
	if (base - &x < 200)
		printf("%p %d\n", &x, base - &x);
}

void recur()
{
	get_diff();
	recur();
}

int main()
{
	char v = 32;
	printf("pos of v: %p\n", base = &v);
	recur();
	return 0;
}
`,`#include "find-limit-of-recursion-2.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong _get_diff(ulong param_1)

{
  uint uVar1;
  undefined uStack_11;
  
  if (__base - (long)&uStack_11 < 200) {
    uVar1 = _printf("%p %d\n");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



void _recur(void)

{
  _get_diff();
  _recur();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 entry(void)

{
  int iVar1;
  undefined local_15;
  undefined4 local_14;
  
  local_14 = 0;
  __base = &local_15;
  local_15 = 0x20;
  iVar1 = _printf("pos of v: %p\n");
  _recur(iVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

char *get_line(FILE* fp)
{
	int len = 0, got = 0, c;
	char *buf = 0;

	while ((c = fgetc(fp)) != EOF) {
		if (got + 1 >= len) {
			len *= 2;
			if (len < 4) len = 4;
			buf = realloc(buf, len);
		}
		buf[got++] = c;
		if (c == '\n') break;
	}
	if (c == EOF && !got) return 0;

	buf[got++] = '\0';
	return buf;
}

int main()
{
	char *s;
	while ((s = get_line(stdin))) {
		printf("%s",s);
		free(s);
	}
	return 0;
}
`,`#include "input-loop.h"



void * _get_line(FILE *param_1)

{
  int iVar1;
  long lVar2;
  void *local_38;
  int local_28;
  int local_24;
  void *local_18;
  
  local_24 = 0;
  local_28 = 0;
  local_38 = (void *)0x0;
  do {
    iVar1 = _fgetc(param_1);
    if (iVar1 == -1) break;
    if (local_24 <= local_28 + 1) {
      local_24 = local_24 << 1;
      if (local_24 < 4) {
        local_24 = 4;
      }
      local_38 = _realloc(local_38,(long)local_24);
    }
    lVar2 = (long)local_28;
    local_28 = local_28 + 1;
    *(char *)((long)local_38 + lVar2) = (char)iVar1;
  } while (iVar1 != 10);
  if ((iVar1 == -1) && (local_28 == 0)) {
    local_18 = (void *)0x0;
  }
  else {
    *(undefined *)((long)local_38 + (long)local_28) = 0;
    local_18 = local_38;
  }
  return local_18;
}



undefined8 entry(void)

{
  void *pvVar1;
  
  while( true ) {
    pvVar1 = (void *)_get_line(*(undefined8 *)PTR____stdinp_100004000);
    if (pvVar1 == (void *)0x0) break;
    _printf("%s");
    _free(pvVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004020)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

/* to read expanded code, run through cpp | indent -st */
#define DECL_STACK_TYPE(type, name)					\
typedef struct stk_##name##_t{type *buf; size_t alloc,len;}*stk_##name;	\
stk_##name stk_##name##_create(size_t init_size) {			\
	stk_##name s; if (!init_size) init_size = 4;			\
	s = malloc(sizeof(struct stk_##name##_t));			\
	if (!s) return 0;						\
	s->buf = malloc(sizeof(type) * init_size);			\
	if (!s->buf) { free(s); return 0; }				\
	s->len = 0, s->alloc = init_size;				\
	return s; }							\
int stk_##name##_push(stk_##name s, type item) {			\
	type *tmp;							\
	if (s->len >= s->alloc) {					\
		tmp = realloc(s->buf, s->alloc*2*sizeof(type));		\
		if (!tmp) return -1; s->buf = tmp;			\
		s->alloc *= 2; }					\
	s->buf[s->len++] = item;					\
	return s->len; }						\
type stk_##name##_pop(stk_##name s) {					\
	type tmp;							\
	if (!s->len) abort();						\
	tmp = s->buf[--s->len];						\
	if (s->len * 2 <= s->alloc && s->alloc >= 8) {			\
		s->alloc /= 2;						\
		s->buf = realloc(s->buf, s->alloc * sizeof(type));}	\
	return tmp; }							\
void stk_##name##_delete(stk_##name s) {				\
	free(s->buf); free(s); }

#define stk_empty(s) (!(s)->len)
#define stk_size(s) ((s)->len)

DECL_STACK_TYPE(int, int)

int main(void)
{
	int i;
	stk_int stk = stk_int_create(0);

	printf("pushing: ");
	for (i = 'a'; i <= 'z'; i++) {
		printf(" %c", i);
		stk_int_push(stk, i);
	}

	printf("\nsize now: %d", stk_size(stk));
	printf("\nstack is%s empty\n", stk_empty(stk) ? "" : " not");

	printf("\npoppoing:");
	while (stk_size(stk))
		printf(" %c", stk_int_pop(stk));
	printf("\nsize now: %d", stk_size(stk));
	printf("\nstack is%s empty\n", stk_empty(stk) ? "" : " not");

	/* stk_int_pop(stk); <-- will abort() */
	stk_int_delete(stk);
	return 0;
}
`,`#include "stack-1.h"



long * _stk_int_create(long param_1)

{
  void *pvVar1;
  long local_20;
  long *local_18;
  
  local_20 = param_1;
  if (param_1 == 0) {
    local_20 = 4;
  }
  local_18 = (long *)_malloc(0x18);
  if (local_18 == (long *)0x0) {
    local_18 = (long *)0x0;
  }
  else {
    pvVar1 = _malloc(local_20 * 4);
    *local_18 = (long)pvVar1;
    if (*local_18 == 0) {
      _free(local_18);
      local_18 = (long *)0x0;
    }
    else {
      local_18[2] = 0;
      local_18[1] = local_20;
    }
  }
  return local_18;
}



undefined4 _stk_int_push(long *param_1,undefined4 param_2)

{
  void *pvVar1;
  long lVar2;
  
  if ((ulong)param_1[1] <= (ulong)param_1[2]) {
    pvVar1 = _realloc((void *)*param_1,param_1[1] << 3);
    if (pvVar1 == (void *)0x0) {
      return 0xffffffff;
    }
    *param_1 = (long)pvVar1;
    param_1[1] = param_1[1] << 1;
  }
  lVar2 = param_1[2];
  param_1[2] = lVar2 + 1;
  *(undefined4 *)(*param_1 + lVar2 * 4) = param_2;
  return (int)param_1[2];
}



undefined4 _stk_int_pop(long *param_1)

{
  undefined4 uVar1;
  void *pvVar2;
  long lVar3;
  
  if (param_1[2] != 0) {
    lVar3 = param_1[2];
    param_1[2] = lVar3 + -1;
    uVar1 = *(undefined4 *)(*param_1 + (lVar3 + -1) * 4);
    if (((ulong)(param_1[2] << 1) <= (ulong)param_1[1]) && (7 < (ulong)param_1[1])) {
      param_1[1] = (ulong)param_1[1] / 2;
      pvVar2 = _realloc((void *)*param_1,param_1[1] << 2);
      *param_1 = (long)pvVar2;
    }
    return uVar1;
  }
                    // WARNING: Subroutine does not return
  _abort();
}



void _stk_int_delete(undefined8 *param_1)

{
  _free((void *)*param_1);
  _free(param_1);
  return;
}



undefined8 entry(void)

{
  long lVar1;
  int local_18;
  
  lVar1 = _stk_int_create(0);
  _printf("pushing: ");
  for (local_18 = 0x61; local_18 < 0x7b; local_18 = local_18 + 1) {
    _printf(" %c");
    _stk_int_push(lVar1,local_18);
  }
  _printf("\nsize now: %d");
  _printf("\nstack is%s empty\n");
  _printf("\npoppoing:");
  while (*(long *)(lVar1 + 0x10) != 0) {
    _stk_int_pop(lVar1);
    _printf(" %c");
  }
  _printf("\nsize now: %d");
  _printf("\nstack is%s empty\n");
  _stk_int_delete(lVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _abort(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__abort_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004020)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct str_t {
	size_t len, alloc;
	unsigned char *s;
} bstr_t, *bstr;

#define str_len(s) ((s)->len)
bstr str_new(size_t len)
{
	bstr s = malloc(sizeof(bstr_t));
	if (len < 8) len = 8;
	s->alloc = len;
	s->s = malloc(len);
	s->len = 0;
	return s;
}

void str_extend(bstr s)
{
	size_t ns = s->alloc * 2;
	if (ns - s->alloc > 1024) ns = s->alloc + 1024;
	s->s = realloc(s->s, ns);
	s->alloc = ns;
}

void str_del(bstr s)
{
	free(s->s), free(s);
}

int str_cmp(bstr l, bstr r)
{
	int res, len = l->len;
	if (len > r->len) len = r->len;

	if ((res = memcmp(l->s, r->s, len))) return res;
	return l->len > r->len ? 1 : -1;
}

bstr str_dup(bstr src)
{
	bstr x = str_new(src->len);
	memcpy(x->s, src->s, src->len);
	x->len = src->len;
	return x;
}

bstr str_from_chars(const char *t)
{
	if (!t) return str_new(0);
	size_t l = strlen(t);
	bstr x = str_new(l + 1);
	x->len = l;
	memcpy(x->s, t, l);
	return x;
}

void str_append(bstr s, unsigned char b)
{
	if (s->len >= s->alloc) str_extend(s);
	s->s[s->len++] = b;
}

bstr str_substr(bstr s, int from, int to)
{
	if (!to) to = s->len;
	if (from < 0) from += s->len;
	if (from < 0 || from >= s->len)
		return 0;
	if (to < from) to = from + 1;
	bstr x = str_new(to - from);
	x->len = to - from;
	memcpy(x->s, s->s + from, x->len);
	return x;
}

bstr str_cat(bstr s, bstr s2)
{
	while (s->alloc < s->len + s2->len) str_extend(s);
	memcpy(s->s + s->len, s2->s, s2->len);
	s->len += s2->len;
	return s;
}

void str_swap(bstr a, bstr b)
{
	size_t tz;
	unsigned char *ts;
	tz = a->alloc; a->alloc = b->alloc; b->alloc = tz;
	tz = a->len; a->len = b->len; b->len = tz;
	ts = a->s; a->s = b->s; b->s = ts;
}

bstr str_subst(bstr tgt, bstr pat, bstr repl)
{
	bstr tmp = str_new(0);
	int i;
	for (i = 0; i + pat->len <= tgt->len;) {
		if (memcmp(tgt->s + i, pat->s, pat->len)) {
			str_append(tmp, tgt->s[i]);
			i++;
		} else {
			str_cat(tmp, repl);
			i += pat->len;
			if (!pat->len) str_append(tmp, tgt->s[i++]);
		}
	}
	while (i < tgt->len) str_append(tmp, tgt->s[i++]);
	str_swap(tmp, tgt);
	str_del(tmp);
	return tgt;
}

void str_set(bstr dest, bstr src)
{
	while (dest->len < src->len) str_extend(dest);
	memcpy(dest->s, src->s, src->len);
	dest->len = src->len;
}

int main()
{
	bstr s = str_from_chars("aaaaHaaaaaFaaaaHa");
	bstr s2 = str_from_chars("___.");
	bstr s3 = str_from_chars("");

	str_subst(s, s3, s2);
	printf("%.*s\n", s->len, s->s);

	str_del(s);
	str_del(s2);
	str_del(s3);

	return 0;
}
`,`#include "binary-strings.h"



undefined8 * _str_new(ulong param_1)

{
  undefined8 *puVar1;
  void *pvVar2;
  size_t local_18;
  
  puVar1 = (undefined8 *)_malloc(0x18);
  local_18 = param_1;
  if (param_1 < 8) {
    local_18 = 8;
  }
  puVar1[1] = local_18;
  pvVar2 = _malloc(local_18);
  puVar1[2] = pvVar2;
  *puVar1 = 0;
  return puVar1;
}



void _str_extend(long param_1)

{
  void *pvVar1;
  undefined8 local_20;
  
  local_20 = *(long *)(param_1 + 8) * 2;
  if (0x400 < local_20 - *(long *)(param_1 + 8)) {
    local_20 = *(long *)(param_1 + 8) + 0x400;
  }
  pvVar1 = _realloc(*(void **)(param_1 + 0x10),local_20);
  *(void **)(param_1 + 0x10) = pvVar1;
  *(size_t *)(param_1 + 8) = local_20;
  return;
}



void _str_del(void *param_1)

{
  _free(*(void **)((long)param_1 + 0x10));
  _free(param_1);
  return;
}



int _str_cmp(ulong *param_1,ulong *param_2)

{
  int local_30;
  int local_14;
  
  local_30 = (int)*param_1;
  if (*param_2 < (ulong)(long)local_30) {
    local_30 = (int)*param_2;
  }
  local_14 = _memcmp((void *)param_1[2],(void *)param_2[2],(long)local_30);
  if ((local_14 == 0) && (local_14 = -1, *param_2 < *param_1)) {
    local_14 = 1;
  }
  return local_14;
}



undefined8 * _str_dup(undefined8 *param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_str_new(*param_1);
  ___memcpy_chk(puVar1[2],param_1[2],*param_1,0xffffffffffffffff);
  *puVar1 = *param_1;
  return puVar1;
}



size_t * _str_from_chars(char *param_1)

{
  size_t sVar1;
  size_t *local_18;
  
  if (param_1 == (char *)0x0) {
    local_18 = (size_t *)_str_new(0);
  }
  else {
    sVar1 = _strlen(param_1);
    local_18 = (size_t *)_str_new(sVar1 + 1);
    *local_18 = sVar1;
    ___memcpy_chk(local_18[2],param_1,sVar1,0xffffffffffffffff);
  }
  return local_18;
}



void _str_append(ulong *param_1,undefined param_2)

{
  ulong uVar1;
  
  if (param_1[1] <= *param_1) {
    _str_extend(param_1);
  }
  uVar1 = *param_1;
  *param_1 = uVar1 + 1;
  *(undefined *)(param_1[2] + uVar1) = param_2;
  return;
}



long * _str_substr(ulong *param_1,int param_2,int param_3)

{
  int local_28;
  int local_24;
  long *local_18;
  
  local_28 = param_3;
  if (param_3 == 0) {
    local_28 = (int)*param_1;
  }
  local_24 = param_2;
  if (param_2 < 0) {
    local_24 = param_2 + (int)*param_1;
  }
  if ((local_24 < 0) || (*param_1 <= (ulong)(long)local_24)) {
    local_18 = (long *)0x0;
  }
  else {
    if (local_28 < local_24) {
      local_28 = local_24 + 1;
    }
    local_18 = (long *)_str_new((long)(local_28 - local_24));
    *local_18 = (long)(local_28 - local_24);
    ___memcpy_chk(local_18[2],param_1[2] + (long)local_24,*local_18,0xffffffffffffffff);
  }
  return local_18;
}



long * _str_cat(long *param_1,long *param_2)

{
  while ((ulong)param_1[1] < (ulong)(*param_1 + *param_2)) {
    _str_extend(param_1);
  }
  ___memcpy_chk(param_1[2] + *param_1,param_2[2],*param_2,0xffffffffffffffff);
  *param_1 = *param_1 + *param_2;
  return param_1;
}



void _str_swap(undefined8 *param_1,undefined8 *param_2)

{
  undefined8 uVar1;
  
  uVar1 = param_1[1];
  param_1[1] = param_2[1];
  param_2[1] = uVar1;
  uVar1 = *param_1;
  *param_1 = *param_2;
  *param_2 = uVar1;
  uVar1 = param_1[2];
  param_1[2] = param_2[2];
  param_2[2] = uVar1;
  return;
}



ulong * _str_subst(ulong *param_1,size_t *param_2,undefined8 param_3)

{
  int iVar1;
  undefined8 uVar2;
  long lVar3;
  int local_34;
  
  uVar2 = _str_new(0);
  local_34 = 0;
  while ((long)local_34 + *param_2 <= *param_1) {
    iVar1 = _memcmp((void *)(param_1[2] + (long)local_34),(void *)param_2[2],*param_2);
    if (iVar1 == 0) {
      _str_cat(uVar2,param_3);
      local_34 = local_34 + (int)*param_2;
      if (*param_2 == 0) {
        lVar3 = (long)local_34;
        local_34 = local_34 + 1;
        _str_append(uVar2,*(undefined *)(param_1[2] + lVar3));
      }
    }
    else {
      _str_append(uVar2,*(undefined *)(param_1[2] + (long)local_34));
      local_34 = local_34 + 1;
    }
  }
  while ((ulong)(long)local_34 < *param_1) {
    lVar3 = (long)local_34;
    local_34 = local_34 + 1;
    _str_append(uVar2,*(undefined *)(param_1[2] + lVar3));
  }
  _str_swap(uVar2,param_1);
  _str_del(uVar2);
  return param_1;
}



void _str_set(ulong *param_1,ulong *param_2)

{
  while (*param_1 < *param_2) {
    _str_extend(param_1);
  }
  ___memcpy_chk(param_1[2],param_2[2],*param_2,0xffffffffffffffff);
  *param_1 = *param_2;
  return;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  
  uVar1 = _str_from_chars("aaaaHaaaaaFaaaaHa");
  uVar2 = _str_from_chars("___.");
  uVar3 = _str_from_chars("");
  _str_subst(uVar1,uVar3,uVar2);
  _printf("%.*s\n");
  _str_del(uVar1);
  _str_del(uVar2);
  _str_del(uVar3);
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _memcmp(void *param_1,void *param_2,size_t param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__memcmp_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <locale.h>

bool *sieve(int limit) {
    int i, p;
    limit++;
    // True denotes composite, false denotes prime.
    bool *c = calloc(limit, sizeof(bool)); // all false by default
    c[0] = true;
    c[1] = true;
    for (i = 4; i < limit; i += 2) c[i] = true;
    p = 3; // Start from 3.
    while (true) {
        int p2 = p * p;
        if (p2 >= limit) break;
        for (i = p2; i < limit; i += 2 * p) c[i] = true;
        while (true) {
            p += 2;
            if (!c[p]) break;
        }
    }
    return c;
}

void primeFactors(int n, int *factors, int *length) {
    if (n < 2) return;
    int count = 0;
    int inc[8] = {4, 2, 4, 2, 4, 6, 2, 6};
    while (!(n%2)) {
        factors[count++] = 2;
        n /= 2;
    }
    while (!(n%3)) {
        factors[count++] = 3;
        n /= 3;
    }
    while (!(n%5)) {
        factors[count++] = 5;
        n /= 5;
    }
    for (int k = 7, i = 0; k*k <= n; ) {
        if (!(n%k)) {
            factors[count++] = k;
            n /= k;
        } else {
            k += inc[i];
            i = (i + 1) % 8;
        }
    }
    if (n > 1) {
        factors[count++] = n;
    }
    *length = count;
}

int compare(const void* a, const void* b) {
    int arg1 = *(const int*)a;
    int arg2 = *(const int*)b;
    if (arg1 < arg2) return -1;
    if (arg1 > arg2) return 1;
    return 0;
}

int main() {
    const int limit = 1000000;
    int limit2 = (int)cbrt((double)limit);
    int i, j, k, pc = 0, count = 0, prod, res;
    bool *c = sieve(limit/6);
    for (i = 0; i < limit/6; ++i) {
        if (!c[i]) ++pc;
    }
    int *primes = (int *)malloc(pc * sizeof(int));
    for (i = 0, j = 0; i < limit/6; ++i) {
        if (!c[i]) primes[j++] = i;
    }
    int *sphenic = (int *)malloc(210000 * sizeof(int));
    printf("Sphenic numbers less than 1,000:\n");
    for (i = 0; i < pc-2; ++i) {
        if (primes[i] > limit2) break;
        for (j = i+1; j < pc-1; ++j) {
            prod = primes[i] * primes[j];
            if (prod * primes[j+1] >= limit) break;
            for (k = j+1; k < pc; ++k) {
                res = prod * primes[k];
                if (res >= limit) break;
                sphenic[count++] = res;
            }
        }
    }
    qsort(sphenic, count, sizeof(int), compare);
    for (i = 0; ; ++i) {
        if (sphenic[i] >= 1000) break;
        printf("%3d ", sphenic[i]);
        if (!((i+1) % 15)) printf("\n");
    }
    printf("\nSphenic triplets less than 10,000:\n");
    int tripCount = 0, s, t = 0;
    for (i = 0; i < count - 2; ++i) {
        s = sphenic[i];
        if (sphenic[i+1] == s+1 && sphenic[i+2] == s+2) {
            tripCount++;
            if (s < 9998) {
                printf("[%d, %d, %d] ", s, s+1, s+2);
                if (!(tripCount % 3)) printf("\n");
            }
            if (tripCount == 5000) t = s;
        }
    }
    setlocale(LC_NUMERIC, "");
    printf("\nThere are %'d sphenic numbers less than 1,000,000.\n", count);
    printf("There are %'d sphenic triplets less than 1,000,000.\n", tripCount);
    s = sphenic[199999];
    int factors[10], length = 0;
    primeFactors(s, factors, &length);
    printf("The 200,000th sphenic number is %'d (", s);
    for (i = 0; i < length; ++i) {
        printf("%d", factors[i]);
        if (i < length-1) printf("*");
    }
    printf(").\n");
    printf("The 5,000th sphenic triplet is [%d, %d, %d].\n", t, t+1, t+2);
    free(c);
    free(primes);
    free(sphenic);
    return 0;
}
`,`#include "sphenic-numbers.h"



undefined * _sieve(int param_1)

{
  undefined *puVar1;
  int local_1c;
  int local_18;
  
  param_1 = param_1 + 1;
  puVar1 = (undefined *)_calloc((long)param_1,1);
  *puVar1 = 1;
  puVar1[1] = 1;
  for (local_18 = 4; local_18 < param_1; local_18 = local_18 + 2) {
    puVar1[local_18] = 1;
  }
  local_1c = 3;
  while (local_18 = local_1c * local_1c, local_18 < param_1) {
    for (; local_18 < param_1; local_18 = local_18 + local_1c * 2) {
      puVar1[local_18] = 1;
    }
    do {
      local_1c = local_1c + 2;
    } while ((puVar1[local_1c] & 1) != 0);
  }
  return puVar1;
}



void _primeFactors(int param_1,long param_2,int *param_3)

{
  int iVar1;
  long lVar2;
  int local_64;
  int local_60;
  int local_5c;
  int local_44;
  int local_40 [10];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  if (1 < param_1) {
    local_5c = 0;
    local_40[2] = 4;
    local_40[3] = 2;
    local_40[0] = 4;
    local_40[1] = 2;
    local_40[6] = 2;
    local_40[7] = 6;
    local_40[4] = 4;
    local_40[5] = 6;
    for (local_44 = param_1; local_44 % 2 == 0; local_44 = local_44 / 2) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(undefined4 *)(param_2 + lVar2 * 4) = 2;
    }
    for (; local_44 % 3 == 0; local_44 = local_44 / 3) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(undefined4 *)(param_2 + lVar2 * 4) = 3;
    }
    for (; local_44 % 5 == 0; local_44 = local_44 / 5) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(undefined4 *)(param_2 + lVar2 * 4) = 5;
    }
    local_60 = 7;
    local_64 = 0;
    iVar1 = local_44;
    while (local_44 = iVar1, local_60 * local_60 <= local_44) {
      iVar1 = 0;
      if (local_60 != 0) {
        iVar1 = local_44 / local_60;
      }
      if (local_44 == iVar1 * local_60) {
        lVar2 = (long)local_5c;
        local_5c = local_5c + 1;
        *(int *)(param_2 + lVar2 * 4) = local_60;
        iVar1 = 0;
        if (local_60 != 0) {
          iVar1 = local_44 / local_60;
        }
      }
      else {
        local_60 = local_60 + local_40[local_64];
        local_64 = (local_64 + 1) % 8;
        iVar1 = local_44;
      }
    }
    if (1 < local_44) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(int *)(param_2 + lVar2 * 4) = local_44;
    }
    *param_3 = local_5c;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



undefined4 _compare(int *param_1,int *param_2)

{
  undefined4 local_4;
  
  if (*param_1 < *param_2) {
    local_4 = 0xffffffff;
  }
  else if (*param_2 < *param_1) {
    local_4 = 1;
  }
  else {
    local_4 = 0;
  }
  return local_4;
}



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  double dVar3;
  int local_90;
  int local_8c;
  int local_88;
  int local_84;
  void *local_80;
  void *local_78;
  void *local_70;
  int local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_44 = 0;
  local_48 = 1000000;
  dVar3 = (double)_cbrt(0x412e848000000000);
  local_4c = (int)dVar3;
  local_5c = 0;
  local_60 = 0;
  local_70 = (void *)_sieve(0x28b0a);
  for (local_50 = 0; local_50 < 0x28b0a; local_50 = local_50 + 1) {
    if ((*(byte *)((long)local_70 + (long)local_50) & 1) == 0) {
      local_5c = local_5c + 1;
    }
  }
  local_78 = _malloc((long)local_5c << 2);
  local_54 = 0;
  for (local_50 = 0; local_50 < 0x28b0a; local_50 = local_50 + 1) {
    if ((*(byte *)((long)local_70 + (long)local_50) & 1) == 0) {
      lVar2 = (long)local_54;
      local_54 = local_54 + 1;
      *(int *)((long)local_78 + lVar2 * 4) = local_50;
    }
  }
  local_80 = _malloc(840000);
  _printf("Sphenic numbers less than 1,000:\n");
  local_50 = 0;
  while ((local_50 < local_5c + -2 &&
         (iVar1 = local_50, *(int *)((long)local_78 + (long)local_50 * 4) <= local_4c))) {
    while ((local_54 = iVar1 + 1, local_54 < local_5c + -1 &&
           (local_64 = *(int *)((long)local_78 + (long)local_50 * 4) *
                       *(int *)((long)local_78 + (long)local_54 * 4),
           local_64 * *(int *)((long)local_78 + (long)(iVar1 + 2) * 4) < 1000000))) {
      local_58 = iVar1 + 2;
      while ((iVar1 = local_54, local_58 < local_5c &&
             (local_68 = local_64 * *(int *)((long)local_78 + (long)local_58 * 4),
             local_68 < 1000000))) {
        lVar2 = (long)local_60;
        local_60 = local_60 + 1;
        *(int *)((long)local_80 + lVar2 * 4) = local_68;
        local_58 = local_58 + 1;
      }
    }
    local_50 = local_50 + 1;
  }
  _qsort(local_80,(long)local_60,4,(int *)_compare);
  local_50 = 0;
  while (*(int *)((long)local_80 + (long)local_50 * 4) < 1000) {
    _printf("%3d ");
    if ((local_50 + 1) % 0xf == 0) {
      _printf("\n");
    }
    local_50 = local_50 + 1;
  }
  _printf("\nSphenic triplets less than 10,000:\n");
  local_84 = 0;
  local_8c = 0;
  for (local_50 = 0; local_50 < local_60 + -2; local_50 = local_50 + 1) {
    local_88 = *(int *)((long)local_80 + (long)local_50 * 4);
    if ((*(int *)((long)local_80 + (long)(local_50 + 1) * 4) == local_88 + 1) &&
       (*(int *)((long)local_80 + (long)(local_50 + 2) * 4) == local_88 + 2)) {
      local_84 = local_84 + 1;
      if ((local_88 < 0x270e) && (_printf("[%d, %d, %d] "), local_84 % 3 == 0)) {
        _printf("\n");
      }
      if (local_84 == 5000) {
        local_8c = local_88;
      }
    }
  }
  _setlocale(4,"");
  _printf("\nThere are %\'d sphenic numbers less than 1,000,000.\n");
  _printf("There are %\'d sphenic triplets less than 1,000,000.\n");
  local_88 = *(undefined4 *)((long)local_80 + 0xc34fc);
  local_90 = 0;
  _primeFactors(local_88,auStack_40,&local_90);
  _printf("The 200,000th sphenic number is %\'d (");
  for (local_50 = 0; local_50 < local_90; local_50 = local_50 + 1) {
    _printf("%d");
    if (local_50 < local_90 + -1) {
      _printf("*");
    }
  }
  _printf(").\n");
  _printf("The 5,000th sphenic triplet is [%d, %d, %d].\n");
  _free(local_70);
  _free(local_78);
  _free(local_80);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003df8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e04. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



void _cbrt(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cbrt_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e28. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004038)();
  return;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004040)();
  return;
}


`
`#define _ISOC99_SOURCE

#include <math.h>
#include <stdio.h>

int main() {
  printf("%g\n", INFINITY);
  return 0;
}
`,`#include "infinity-2.h"



undefined4 entry(void)

{
  _printf("%g\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(int argc, char **argv) {
  FILE *in, *out;
  int c;

  in = fopen("input.txt", "r");
  if (!in) {
    fprintf(stderr, "Error opening input.txt for reading.\n");
    return 1;
  }

  out = fopen("output.txt", "w");
  if (!out) {
    fprintf(stderr, "Error opening output.txt for writing.\n");
    fclose(in);
    return 1;
  }

  while ((c = fgetc(in)) != EOF) {
    fputc(c, out);
  }

  fclose(out);
  fclose(in);
  return 0;
}
`,`#include "file-input-output-1.h"



undefined4 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  FILE *pFVar3;
  undefined4 local_14;
  
  pFVar2 = _fopen("input.txt","r");
  if (pFVar2 == (FILE *)0x0) {
    _fprintf(*(FILE **)PTR____stderrp_100004000,"Error opening input.txt for reading.\n");
    local_14 = 1;
  }
  else {
    pFVar3 = _fopen("output.txt","w");
    if (pFVar3 == (FILE *)0x0) {
      _fprintf(*(FILE **)PTR____stderrp_100004000,"Error opening output.txt for writing.\n");
      _fclose(pFVar2);
      local_14 = 1;
    }
    else {
      while (iVar1 = _fgetc(pFVar2), iVar1 != -1) {
        _fputc(iVar1,pFVar3);
      }
      _fclose(pFVar3);
      _fclose(pFVar2);
      local_14 = 0;
    }
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004018)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fputc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fputc_100004028)(param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>


#define MAXLEN 100
typedef char TWord[MAXLEN];


typedef struct Node {
    TWord word;
    struct Node *next;
} Node;


int is_ordered_word(const TWord word) {
    assert(word != NULL);
    int i;

    for (i = 0; word[i] != '\0'; i++)
        if (word[i] > word[i + 1] && word[i + 1] != '\0')
            return 0;

    return 1;
}


Node* list_prepend(Node* words_list, const TWord new_word) {
    assert(new_word != NULL);
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL)
        exit(EXIT_FAILURE);

    strcpy(new_node->word, new_word);
    new_node->next = words_list;
    return new_node;
}


Node* list_destroy(Node *words_list) {
    while (words_list != NULL) {
        Node *temp = words_list;
        words_list = words_list->next;
        free(temp);
    }

    return words_list;
}


void list_print(Node *words_list) {
    while (words_list != NULL) {
        printf("\n%s", words_list->word);
        words_list = words_list->next;
    }
}


int main() {
    FILE *fp = fopen("unixdict.txt", "r");
    if (fp == NULL)
        return EXIT_FAILURE;

    Node *words = NULL;
    TWord line;
    unsigned int max_len = 0;

    while (fscanf(fp, "%99s\n", line) != EOF) {
        if (strlen(line) > max_len && is_ordered_word(line)) {
            max_len = strlen(line);
            words = list_destroy(words);
            words = list_prepend(words, line);
        } else if (strlen(line) == max_len && is_ordered_word(line)) {
            words = list_prepend(words, line);
        }
    }

    fclose(fp);
    list_print(words);

    return EXIT_SUCCESS;
}
`,`#include "ordered-words-1.h"



undefined4 _is_ordered_word(long param_1)

{
  int local_24;
  
  if (param_1 == 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("is_ordered_word","ordered-words-1.c",0x12,"word != NULL");
  }
  local_24 = 0;
  while( true ) {
    if (*(char *)(param_1 + local_24) == '\0') {
      return 1;
    }
    if ((*(char *)(param_1 + (local_24 + 1)) < *(char *)(param_1 + local_24)) &&
       (*(char *)(param_1 + (local_24 + 1)) != '\0')) break;
    local_24 = local_24 + 1;
  }
  return 0;
}



void * _list_prepend(undefined8 param_1,long param_2)

{
  void *pvVar1;
  
  if (param_2 == 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("list_prepend","ordered-words-1.c",0x1e,"new_word != NULL");
  }
  pvVar1 = _malloc(0x70);
  if (pvVar1 == (void *)0x0) {
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  ___strcpy_chk(pvVar1,param_2,100);
  *(undefined8 *)((long)pvVar1 + 0x68) = param_1;
  return pvVar1;
}



undefined8 _list_destroy(void *param_1)

{
  void *pvVar1;
  undefined8 local_18;
  
  local_18 = param_1;
  while (local_18 != (void *)0x0) {
    pvVar1 = *(void **)((long)local_18 + 0x68);
    _free(local_18);
    local_18 = pvVar1;
  }
  return 0;
}



ulong _list_print(ulong param_1)

{
  uint uVar1;
  ulong local_18;
  
  for (local_18 = param_1; local_18 != 0; local_18 = *(ulong *)(local_18 + 0x68)) {
    uVar1 = _printf("\n%s");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined4 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  size_t sVar3;
  undefined8 uVar4;
  uint local_94;
  undefined8 local_90;
  undefined4 local_80;
  char acStack_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  pFVar2 = _fopen("unixdict.txt","r");
  if (pFVar2 == (FILE *)0x0) {
    local_80 = 1;
  }
  else {
    local_90 = 0;
    local_94 = 0;
    while (iVar1 = _fscanf(pFVar2,"%99s\n"), iVar1 != -1) {
      sVar3 = _strlen(acStack_7c);
      if ((local_94 < sVar3) && (iVar1 = _is_ordered_word(acStack_7c), iVar1 != 0)) {
        sVar3 = _strlen(acStack_7c);
        local_94 = (uint)sVar3;
        uVar4 = _list_destroy(local_90);
        local_90 = _list_prepend(uVar4,acStack_7c);
      }
      else {
        sVar3 = _strlen(acStack_7c);
        if ((sVar3 == local_94) && (iVar1 = _is_ordered_word(acStack_7c), iVar1 != 0)) {
          local_90 = _list_prepend(local_90,acStack_7c);
        }
      }
    }
    _fclose(pFVar2);
    _list_print(local_90);
    local_80 = 0;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return local_80;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004030)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004048)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004058)();
  return sVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0
#define da_rewind(name)     _qy_ ## name ## _p = 0
#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)
#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)
#define da_len(name)        _qy_ ## name ## _p
#define da_add(name)        do {da_redim(name); _qy_ ## name ## _p++;} while (0)

typedef enum {
    nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While,
    nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,
    nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or
} NodeType;

typedef struct Tree Tree;
struct Tree {
    NodeType node_type;
    Tree *left;
    Tree *right;
    int value;
};

// dependency: Ordered by NodeType, must remain in same order as NodeType enum

struct {
    char       *enum_text;
    NodeType   node_type;
} atr[] = {
    {"Identifier"  , nd_Ident,  },  {"String"      , nd_String,  },
    {"Integer"     , nd_Integer,},  {"Sequence"    , nd_Sequence,},
    {"If"          , nd_If,     },  {"Prtc"        , nd_Prtc,    },
    {"Prts"        , nd_Prts,   },  {"Prti"        , nd_Prti,    },
    {"While"       , nd_While,  },  {"Assign"      , nd_Assign,  },
    {"Negate"      , nd_Negate, },  {"Not"         , nd_Not,     },
    {"Multiply"    , nd_Mul,    },  {"Divide"      , nd_Div,     },
    {"Mod"         , nd_Mod,    },  {"Add"         , nd_Add,     },
    {"Subtract"    , nd_Sub,    },  {"Less"        , nd_Lss,     },
    {"LessEqual"   , nd_Leq,    },  {"Greater"     , nd_Gtr,     },
    {"GreaterEqual", nd_Geq,    },  {"Equal"       , nd_Eql,     },
    {"NotEqual"    , nd_Neq,    },  {"And"         , nd_And,     },
    {"Or"          , nd_Or,     },
};

FILE *source_fp;
da_dim(string_pool, const char *);
da_dim(global_names, const char *);
da_dim(global_values, int);

void error(const char *fmt, ... ) {
    va_list ap;
    char buf[1000];

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    printf("error: %s\n", buf);
    exit(1);
}

Tree *make_node(NodeType node_type, Tree *left, Tree *right) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->left = left;
    t->right = right;
    return t;
}

Tree *make_leaf(NodeType node_type, int value) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->value = value;
    return t;
}

int interp(Tree *x) {           /* interpret the parse tree */
    if (!x) return 0;
    switch(x->node_type) {
        case nd_Integer:  return x->value;
        case nd_Ident:    return global_values[x->value];
        case nd_String:   return x->value;

        case nd_Assign:   return global_values[x->left->value] = interp(x->right);
        case nd_Add:      return interp(x->left) +  interp(x->right);
        case nd_Sub:      return interp(x->left) -  interp(x->right);
        case nd_Mul:      return interp(x->left) *  interp(x->right);
        case nd_Div:      return interp(x->left) /  interp(x->right);
        case nd_Mod:      return interp(x->left) %  interp(x->right);
        case nd_Lss:      return interp(x->left) <  interp(x->right);
        case nd_Gtr:      return interp(x->left) >  interp(x->right);
        case nd_Leq:      return interp(x->left) <= interp(x->right);
        case nd_Eql:      return interp(x->left) == interp(x->right);
        case nd_Neq:      return interp(x->left) != interp(x->right);
        case nd_And:      return interp(x->left) && interp(x->right);
        case nd_Or:       return interp(x->left) || interp(x->right);
        case nd_Negate:   return -interp(x->left);
        case nd_Not:      return !interp(x->left);

        case nd_If:       if (interp(x->left))
                            interp(x->right->left);
                          else
                            interp(x->right->right);
                          return 0;

        case nd_While:    while (interp(x->left))
                            interp(x->right);
                          return 0;

        case nd_Prtc:     printf("%c", interp(x->left));
                          return 0;
        case nd_Prti:     printf("%d", interp(x->left));
                          return 0;
        case nd_Prts:     printf("%s", string_pool[interp(x->left)]);
                          return 0;

        case nd_Sequence: interp(x->left);
                          interp(x->right);
                          return 0;

        default:          error("interp: unknown tree type %d\n", x->node_type);
    }
    return 0;
}

void init_in(const char fn[]) {
    if (fn[0] == '\0')
        source_fp = stdin;
    else {
        source_fp = fopen(fn, "r");
        if (source_fp == NULL)
            error("Can't open %s\n", fn);
    }
}

NodeType get_enum_value(const char name[]) {
    for (size_t i = 0; i < sizeof(atr) / sizeof(atr[0]); i++) {
        if (strcmp(atr[i].enum_text, name) == 0) {
            return atr[i].node_type;
        }
    }
    error("Unknown token %s\n", name);
    return -1;
}

char *read_line(int *len) {
    static char *text = NULL;
    static int textmax = 0;

    for (*len = 0; ; (*len)++) {
        int ch = fgetc(source_fp);
        if (ch == EOF || ch == '\n') {
            if (*len == 0)
                return NULL;
            break;
        }
        if (*len + 1 >= textmax) {
            textmax = (textmax == 0 ? 128 : textmax * 2);
            text = realloc(text, textmax);
        }
        text[*len] = ch;
    }
    text[*len] = '\0';
    return text;
}

char *rtrim(char *text, int *len) {         // remove trailing spaces
    for (; *len > 0 && isspace(text[*len - 1]); --(*len))
        ;

    text[*len] = '\0';
    return text;
}

int fetch_string_offset(char *st) {
    int len = strlen(st);
    st[len - 1] = '\0';
    ++st;
    char *p, *q;
    p = q = st;

    while ((*p++ = *q++) != '\0') {
        if (q[-1] == '\\') {
            if (q[0] == 'n') {
                p[-1] = '\n';
                ++q;
            } else if (q[0] == '\\') {
                ++q;
            }
        }
    }

    for (int i = 0; i < da_len(string_pool); ++i) {
        if (strcmp(st, string_pool[i]) == 0) {
            return i;
        }
    }
    da_add(string_pool);
    int n = da_len(string_pool) - 1;
    string_pool[n] = strdup(st);
    return da_len(string_pool) - 1;
}

int fetch_var_offset(const char *name) {
    for (int i = 0; i < da_len(global_names); ++i) {
        if (strcmp(name, global_names[i]) == 0)
            return i;
    }
    da_add(global_names);
    int n = da_len(global_names) - 1;
    global_names[n] = strdup(name);
    da_append(global_values, 0);
    return n;
}

Tree *load_ast() {
    int len;
    char *yytext = read_line(&len);
    yytext = rtrim(yytext, &len);

    // get first token
    char *tok = strtok(yytext, " ");

    if (tok[0] == ';') {
        return NULL;
    }
    NodeType node_type = get_enum_value(tok);

    // if there is extra data, get it
    char *p = tok + strlen(tok);
    if (p != &yytext[len]) {
        int n;
        for (++p; isspace(*p); ++p)
            ;
        switch (node_type) {
            case nd_Ident:      n = fetch_var_offset(p);    break;
            case nd_Integer:    n = strtol(p, NULL, 0);     break;
            case nd_String:     n = fetch_string_offset(p); break;
            default:            error("Unknown node type: %s\n", p);
        }
        return make_leaf(node_type, n);
    }

    Tree *left  = load_ast();
    Tree *right = load_ast();
    return make_node(node_type, left, right);
}

int main(int argc, char *argv[]) {
    init_in(argc > 1 ? argv[1] : "");

    Tree *x = load_ast();
    interp(x);

    return 0;
}
`,`#include "compiler-ast-interpreter.h"



void _error(undefined8 param_1)

{
  undefined auStack_410 [1000];
  undefined8 local_28;
  
  local_28 = *(undefined8 *)PTR____stack_chk_guard_100004000;
  ___vsprintf_chk(auStack_410,0,1000,param_1,&stack0x00000000);
  _printf("error: %s\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



undefined4 * _make_node(undefined4 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_calloc(0x20,1);
  *puVar1 = param_1;
  *(undefined8 *)(puVar1 + 2) = param_2;
  *(undefined8 *)(puVar1 + 4) = param_3;
  return puVar1;
}



undefined4 * _make_leaf(undefined4 param_1,undefined4 param_2)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_calloc(0x20,1);
  *puVar1 = param_1;
  puVar1[6] = param_2;
  return puVar1;
}



uint _interp(undefined4 *param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  uint local_58;
  uint local_54;
  uint local_14;
  
  if (param_1 == (undefined4 *)0x0) {
    local_14 = 0;
  }
  else {
    switch(*param_1) {
    case 0:
      local_14 = *(uint *)(_global_values + (long)(int)param_1[6] * 4);
      break;
    case 1:
      local_14 = param_1[6];
      break;
    case 2:
      local_14 = param_1[6];
      break;
    case 3:
      _interp(*(undefined8 *)(param_1 + 2));
      _interp(*(undefined8 *)(param_1 + 4));
      local_14 = 0;
      break;
    case 4:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      if (iVar3 == 0) {
        _interp(*(undefined8 *)(*(long *)(param_1 + 4) + 0x10));
      }
      else {
        _interp(*(undefined8 *)(*(long *)(param_1 + 4) + 8));
      }
      local_14 = 0;
      break;
    case 5:
      _interp(*(undefined8 *)(param_1 + 2));
      _printf("%c");
      local_14 = 0;
      break;
    case 6:
      _interp(*(undefined8 *)(param_1 + 2));
      _printf("%s");
      local_14 = 0;
      break;
    case 7:
      _interp(*(undefined8 *)(param_1 + 2));
      _printf("%d");
      local_14 = 0;
      break;
    case 8:
      while (iVar3 = _interp(*(undefined8 *)(param_1 + 2)), iVar3 != 0) {
        _interp(*(undefined8 *)(param_1 + 4));
      }
      local_14 = 0;
      break;
    case 9:
      local_14 = _interp(*(undefined8 *)(param_1 + 4));
      *(uint *)(_global_values + (long)*(int *)(*(long *)(param_1 + 2) + 0x18) * 4) = local_14;
      break;
    case 10:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      local_14 = -iVar3;
      break;
    case 0xb:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      local_14 = (uint)(iVar3 == 0);
      break;
    case 0xc:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = iVar3 * iVar2;
      break;
    case 0xd:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = 0;
      if (iVar2 != 0) {
        local_14 = iVar3 / iVar2;
      }
      break;
    case 0xe:
      iVar2 = _interp(*(undefined8 *)(param_1 + 2));
      iVar1 = _interp(*(undefined8 *)(param_1 + 4));
      iVar3 = 0;
      if (iVar1 != 0) {
        iVar3 = iVar2 / iVar1;
      }
      local_14 = iVar2 - iVar3 * iVar1;
      break;
    case 0xf:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = iVar3 + iVar2;
      break;
    case 0x10:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = iVar3 - iVar2;
      break;
    case 0x11:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = (uint)(iVar3 < iVar2);
      break;
    case 0x12:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = (uint)(iVar3 <= iVar2);
      break;
    case 0x13:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = (uint)(iVar2 < iVar3);
      break;
    default:
      _error("interp: unknown tree type %d\n");
      local_14 = 0;
      break;
    case 0x15:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = (uint)(iVar3 == iVar2);
      break;
    case 0x16:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      iVar2 = _interp(*(undefined8 *)(param_1 + 4));
      local_14 = (uint)(iVar3 != iVar2);
      break;
    case 0x17:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      local_54 = 0;
      if (iVar3 != 0) {
        iVar3 = _interp(*(undefined8 *)(param_1 + 4));
        local_54 = (uint)(iVar3 != 0);
      }
      local_14 = local_54;
      break;
    case 0x18:
      iVar3 = _interp(*(undefined8 *)(param_1 + 2));
      local_58 = 1;
      if (iVar3 == 0) {
        iVar3 = _interp(*(undefined8 *)(param_1 + 4));
        local_58 = (uint)(iVar3 != 0);
      }
      local_14 = local_58;
    }
  }
  return local_14;
}



void _init_in(char *param_1)

{
  if (*param_1 == '\0') {
    _source_fp = *(FILE **)PTR____stdinp_100004008;
  }
  else {
    _source_fp = _fopen(param_1,"r");
    if (_source_fp == (FILE *)0x0) {
      _error("Can\'t open %s\n");
    }
  }
  return;
}



undefined4 _get_enum_value(char *param_1)

{
  int iVar1;
  ulong local_28;
  
  local_28 = 0;
  while( true ) {
    if (0x18 < local_28) {
      _error("Unknown token %s\n");
      return 0xffffffff;
    }
    iVar1 = _strcmp((&_atr)[local_28 * 2],param_1);
    if (iVar1 == 0) break;
    local_28 = local_28 + 1;
  }
  return *(undefined4 *)(&DAT_100008008 + local_28 * 0x10);
}



void * _read_line(int *param_1)

{
  int iVar1;
  int local_28;
  void *local_18;
  
  *param_1 = 0;
  while ((iVar1 = _fgetc(_source_fp), iVar1 != -1 && (iVar1 != 10))) {
    if (DAT_1000081d0 <= *param_1 + 1) {
      if (DAT_1000081d0 == 0) {
        local_28 = 0x80;
      }
      else {
        local_28 = DAT_1000081d0 << 1;
      }
      DAT_1000081d0 = local_28;
      DAT_1000081c8 = _realloc(DAT_1000081c8,(long)local_28);
    }
    *(char *)((long)DAT_1000081c8 + (long)*param_1) = (char)iVar1;
    *param_1 = *param_1 + 1;
  }
  if (*param_1 == 0) {
    local_18 = (void *)0x0;
  }
  else {
    *(undefined *)((long)DAT_1000081c8 + (long)*param_1) = 0;
    local_18 = DAT_1000081c8;
  }
  return local_18;
}



long _rtrim(long param_1,int *param_2)

{
  bool bVar1;
  int iVar2;
  
  while( true ) {
    bVar1 = false;
    if (0 < *param_2) {
      iVar2 = _isspace((int)*(char *)(param_1 + (*param_2 + -1)));
      bVar1 = iVar2 != 0;
    }
    if (!bVar1) break;
    *param_2 = *param_2 + -1;
  }
  *(undefined *)(param_1 + *param_2) = 0;
  return param_1;
}



// WARNING: Restarted to delay deadcode elimination for space: ram

int _fetch_string_offset(char *param_1)

{
  char *pcVar1;
  char cVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  int local_3c;
  char *local_38;
  char *local_30;
  
  sVar4 = _strlen(param_1);
  param_1[(int)sVar4 + -1] = '\0';
  param_1 = param_1 + 1;
  pcVar5 = param_1;
  pcVar1 = param_1;
  while( true ) {
    local_30 = pcVar1;
    local_38 = pcVar5;
    pcVar5 = local_38 + 1;
    cVar2 = *local_38;
    pcVar1 = local_30 + 1;
    *local_30 = cVar2;
    if (cVar2 == '\0') break;
    if (*local_38 == '\\') {
      if (*pcVar5 == 'n') {
        *local_30 = '\n';
        pcVar5 = local_38 + 2;
      }
      else if (*pcVar5 == '\\') {
        pcVar5 = local_38 + 2;
      }
    }
  }
  local_3c = 0;
  while( true ) {
    if (__qy_string_pool_p <= local_3c) {
      if (__qy_string_pool_max <= __qy_string_pool_p) {
        __qy_string_pool_max = __qy_string_pool_max + 0x20;
        _string_pool = _realloc(_string_pool,(long)__qy_string_pool_max << 3);
      }
      iVar3 = __qy_string_pool_p;
      __qy_string_pool_p = __qy_string_pool_p + 1;
      pcVar5 = _strdup(param_1);
      *(char **)((long)_string_pool + (long)iVar3 * 8) = pcVar5;
      return __qy_string_pool_p + -1;
    }
    iVar3 = _strcmp(param_1,*(char **)((long)_string_pool + (long)local_3c * 8));
    if (iVar3 == 0) break;
    local_3c = local_3c + 1;
  }
  return local_3c;
}



int _fetch_var_offset(char *param_1)

{
  int iVar1;
  char *pcVar2;
  long lVar3;
  int local_24;
  
  local_24 = 0;
  while( true ) {
    if (__qy_global_names_p <= local_24) {
      if (__qy_global_names_max <= __qy_global_names_p) {
        __qy_global_names_max = __qy_global_names_max + 0x20;
        _global_names = _realloc(_global_names,(long)__qy_global_names_max << 3);
      }
      iVar1 = __qy_global_names_p;
      __qy_global_names_p = __qy_global_names_p + 1;
      pcVar2 = _strdup(param_1);
      *(char **)((long)_global_names + (long)iVar1 * 8) = pcVar2;
      if (__qy_global_values_max <= __qy_global_values_p) {
        __qy_global_values_max = __qy_global_values_max + 0x20;
        _global_values = _realloc(_global_values,(long)__qy_global_values_max << 2);
      }
      lVar3 = (long)__qy_global_values_p;
      __qy_global_values_p = __qy_global_values_p + 1;
      *(undefined4 *)((long)_global_values + lVar3 * 4) = 0;
      return iVar1;
    }
    iVar1 = _strcmp(param_1,*(char **)((long)_global_names + (long)local_24 * 8));
    if (iVar1 == 0) break;
    local_24 = local_24 + 1;
  }
  return local_24;
}



undefined8 _load_ast(void)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  char *pcVar4;
  size_t sVar5;
  long lVar6;
  undefined8 uVar7;
  undefined4 local_44;
  char *local_40;
  int local_1c;
  undefined8 local_18;
  
  uVar3 = _read_line();
  pcVar4 = (char *)_rtrim(uVar3,&local_1c);
  local_40 = _strtok(pcVar4," ");
  if (*local_40 == ';') {
    local_18 = 0;
  }
  else {
    iVar1 = _get_enum_value(local_40);
    sVar5 = _strlen(local_40);
    local_40 = local_40 + sVar5;
    if (local_40 == pcVar4 + local_1c) {
      uVar3 = _load_ast();
      uVar7 = _load_ast();
      local_18 = _make_node(iVar1,uVar3,uVar7);
    }
    else {
      do {
        local_40 = local_40 + 1;
        iVar2 = _isspace((int)*local_40);
      } while (iVar2 != 0);
      if (iVar1 == 0) {
        local_44 = _fetch_var_offset(local_40);
      }
      else if (iVar1 == 1) {
        local_44 = _fetch_string_offset(local_40);
      }
      else if (iVar1 == 2) {
        lVar6 = _strtol(local_40,(char **)0x0,0);
        local_44 = (undefined4)lVar6;
      }
      else {
        _error("Unknown node type: %s\n");
      }
      local_18 = _make_leaf(iVar1,local_44);
    }
  }
  return local_18;
}



undefined8 entry(int param_1,long param_2)

{
  undefined8 uVar1;
  char *local_30;
  
  if (param_1 < 2) {
    local_30 = "";
  }
  else {
    local_30 = *(char **)(param_2 + 8);
  }
  _init_in(local_30);
  uVar1 = _load_ast();
  _interp(uVar1);
  return 0;
}



void ___vsprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003dec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____vsprintf_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003df8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004030)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isspace(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isspace_100004038)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004048)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004058)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004060)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strtok(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strtok_100004068)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _strtol(char *param_1,char **param_2,int param_3)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__strtol_100004070)(param_1,param_2,param_3);
  return lVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef double (*f_dbl)(double);
#define TAGF (f_dbl)0xdeadbeef
#define TAGG (f_dbl)0xbaddecaf

double dummy(double x)
{
	f_dbl f = TAGF;
	f_dbl g = TAGG;
	return f(g(x));
}

f_dbl composite(f_dbl f, f_dbl g)
{
	size_t len = (void*)composite - (void*)dummy;
	f_dbl ret = malloc(len);
	char *ptr;
	memcpy(ret, dummy, len);
	for (ptr = (char*)ret; ptr < (char*)ret + len - sizeof(f_dbl); ptr++) {
		if (*(f_dbl*)ptr == TAGF)      *(f_dbl*)ptr = f;
		else if (*(f_dbl*)ptr == TAGG) *(f_dbl*)ptr = g;
	}
	return ret;
}

double cube(double x)
{
	return x * x * x;
}

/* uncomment next line if your math.h doesn't have cbrt() */
/* double cbrt(double x) { return pow(x, 1/3.); } */

int main()
{
	int i;
	double x;

	f_dbl A[3] = { cube, exp, sin };
	f_dbl B[3] = { cbrt, log, asin}; /* not sure about availablity of cbrt() */
	f_dbl C[3];

	for (i = 0; i < 3; i++)
		C[i] = composite(A[i], B[i]);

	for (i = 0; i < 3; i++) {
		for (x = .2; x <= 1; x += .2)
			printf("C%d(%g) = %g\n", i, x, C[i](x));
		printf("\n");
	}
	return 0;
}
`,`#include "first-class-functions-2.h"



void _dummy(undefined8 param_1)

{
  (*(code *)&SUB_baddecaf)(param_1);
  (*(code *)&SUB_deadbeef)();
  return;
}



undefined8 * _composite(undefined8 param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  undefined8 *local_38;
  
  puVar1 = (undefined8 *)_malloc(0x50);
  ___memcpy_chk(puVar1,_dummy,0x50,0xffffffffffffffff);
  for (local_38 = puVar1; local_38 < puVar1 + 9; local_38 = (undefined8 *)((long)local_38 + 1)) {
    if ((undefined *)*local_38 == &SUB_deadbeef) {
      *local_38 = param_1;
    }
    else if ((undefined *)*local_38 == &SUB_baddecaf) {
      *local_38 = param_2;
    }
  }
  return puVar1;
}



undefined  [16] _cube(double param_1)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_1 * param_1;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined8 entry(ulong param_1)

{
  uint uVar1;
  double local_78;
  int local_70;
  ulong auStack_68 [3];
  undefined *local_50 [4];
  code *local_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_30[1] = (code *)&_exp;
  local_30[0] = _cube;
  local_30[2] = (code *)&_sin;
  local_50[1] = &_log;
  local_50[0] = &_cbrt;
  local_50[2] = &_asin;
  for (local_70 = 0; local_70 < 3; local_70 = local_70 + 1) {
    param_1 = _composite(local_30[local_70],local_50[local_70]);
    auStack_68[local_70] = param_1;
  }
  for (local_70 = 0; local_70 < 3; local_70 = local_70 + 1) {
    local_78 = 0.2;
    while( true ) {
      if (1.0 < local_78) break;
      (*(code *)auStack_68[local_70])(local_78,param_1);
      uVar1 = _printf("C%d(%g) = %g\n");
      param_1 = (ulong)uVar1;
      local_78 = local_78 + 0.2;
    }
    uVar1 = _printf("\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>
#include <stdio.h>

int main(int c, char **v)
{
	unsigned int n = 1 << (c - 1), i = n, j, k;
	assert(n);

	while (i--) {
		if (!(i & (i + (i & -(int)i)))) // consecutive 1s
			continue;

		for (j = n, k = 1; j >>= 1; k++)
			if (i & j) printf("%s ", v[k]);

		putchar('\n');
	}

	return 0;
}
`,`#include "non-continuous-subsequences-1.h"



undefined8 entry(int param_1)

{
  uint uVar1;
  uint uVar2;
  uint local_2c;
  uint local_28;
  
  uVar1 = 1 << (ulong)(param_1 - 1U & 0x1f);
  local_28 = uVar1;
  if (uVar1 != 0) {
    while (uVar2 = local_28 - 1, local_28 != 0) {
      local_2c = uVar1;
      local_28 = uVar2;
      if ((uVar2 & uVar2 + (uVar2 & -uVar2)) != 0) {
        while (local_2c = local_2c >> 1, local_2c != 0) {
          if ((uVar2 & local_2c) != 0) {
            _printf("%s ");
          }
        }
        _putchar(10);
      }
    }
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___assert_rtn("main","non-continuous-subsequences-1.c",7,"n");
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  int a, b;
  scanf("%d %d", &a, &b);

  if (a < b)
    printf("%d is less than %d\n", a, b);

  if (a == b)
    printf("%d is equal to %d\n", a, b);

  if (a > b)
    printf("%d is greater than %d\n", a, b);

  return 0;
}
`,`#include "integer-comparison.h"



undefined8 entry(void)

{
  int local_1c;
  int local_18;
  
  _scanf("%d %d");
  if (local_18 < local_1c) {
    _printf("%d is less than %d\n");
  }
  if (local_18 == local_1c) {
    _printf("%d is equal to %d\n");
  }
  if (local_1c < local_18) {
    _printf("%d is greater than %d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

double PI;
typedef double complex cplx;

void _fft(cplx buf[], cplx out[], int n, int step)
{
	if (step < n) {
		_fft(out, buf, n, step * 2);
		_fft(out + step, buf + step, n, step * 2);

		for (int i = 0; i < n; i += 2 * step) {
			cplx t = cexp(-I * PI * i / n) * out[i + step];
			buf[i / 2]     = out[i] + t;
			buf[(i + n)/2] = out[i] - t;
		}
	}
}

void fft(cplx buf[], int n)
{
	cplx out[n];
	for (int i = 0; i < n; i++) out[i] = buf[i];
	_fft(buf, out, n, 1);
}

/* pad array length to power of two */
cplx *pad_two(double g[], int len, int *ns)
{
	int n = 1;
	if (*ns) n = *ns;
	else while (n < len) n *= 2;

	cplx *buf = calloc(sizeof(cplx), n);
	for (int i = 0; i < len; i++) buf[i] = g[i];
	*ns = n;
	return buf;
}

void deconv(double g[], int lg, double f[], int lf, double out[], int row_len) {
	int ns = 0;
	cplx *g2 = pad_two(g, lg, &ns);
	cplx *f2 = pad_two(f, lf, &ns);

	fft(g2, ns);
	fft(f2, ns);

	cplx h[ns];
	for (int i = 0; i < ns; i++) h[i] = g2[i] / f2[i];
	fft(h, ns);

	for (int i = 0; i < ns; i++) {
		if (cabs(creal(h[i])) < 1e-10)
			h[i] = 0;
	}

	for (int i = 0; i > lf - lg - row_len; i--)
		out[-i] = h[(i + ns) % ns]/32;
	free(g2);
	free(f2);
}

double* unpack2(void *m, int rows, int len, int to_len)
{
	double *buf = calloc(sizeof(double), rows * to_len);
	for (int i = 0; i < rows; i++)
		for (int j = 0; j < len; j++)
			buf[i * to_len + j] = ((double(*)[len])m)[i][j];
	return buf;
}

void pack2(double * buf, int rows, int from_len, int to_len, void *out)
{
	for (int i = 0; i < rows; i++)
		for (int j = 0; j < to_len; j++)
			((double(*)[to_len])out)[i][j] = buf[i * from_len + j] / 4;
}

void deconv2(void *g, int row_g, int col_g, void *f, int row_f, int col_f, void *out) {
	double *g2 = unpack2(g, row_g, col_g, col_g);
	double *f2 = unpack2(f, row_f, col_f, col_g);

	double ff[(row_g - row_f + 1) * col_g];
	deconv(g2, row_g * col_g, f2, row_f * col_g, ff, col_g);
	pack2(ff, row_g - row_f + 1, col_g, col_g - col_f + 1, out);

	free(g2);
	free(f2);
}

double* unpack3(void *m, int x, int y, int z, int to_y, int to_z)
{
	double *buf = calloc(sizeof(double), x * to_y * to_z);
	for (int i = 0; i < x; i++)
		for (int j = 0; j < y; j++) {
			for (int k = 0; k < z; k++)
				buf[(i * to_y + j) * to_z + k] =
					((double(*)[y][z])m)[i][j][k];
		}
	return buf;
}

void pack3(double * buf, int x, int y, int z, int to_y, int to_z, void *out)
{
	for (int i = 0; i < x; i++)
		for (int j = 0; j < to_y; j++)
			for (int k = 0; k < to_z; k++)
				((double(*)[to_y][to_z])out)[i][j][k] =
					buf[(i * y + j) * z + k] / 4;
}

void deconv3(void *g, int gx, int gy, int gz, void *f, int fx, int fy, int fz, void *out) {
	double *g2 = unpack3(g, gx, gy, gz, gy, gz);
	double *f2 = unpack3(f, fx, fy, fz, gy, gz);

	double ff[(gx - fx + 1) * gy * gz];
	deconv(g2, gx * gy * gz, f2, fx * gy * gz, ff, gy * gz);
	pack3(ff, gx - fx + 1, gy, gz, gy - fy + 1, gz - fz + 1, out);

	free(g2);
	free(f2);
}

int main()
{
	PI = atan2(1,1) * 4;
	double h[2][3][4] = {
		{{-6, -8, -5,  9}, {-7, 9, -6, -8}, { 2, -7,  9,  8}},
		{{ 7,  4,  4, -6}, { 9, 9,  4, -4}, {-3,  7, -2, -3}}
	};
	int hx = 2, hy = 3, hz = 4;
	double f[3][2][3] = {	{{-9,  5, -8}, { 3,  5,  1}},
				{{-1, -7,  2}, {-5, -6,  6}},
				{{ 8,  5,  8}, {-2, -6, -4}} };
	int fx = 3, fy = 2, fz = 3;
	double g[4][4][6] = {
		{	{ 54,  42,  53, -42,  85, -72}, { 45,-170,  94, -36,  48,  73},
			{-39,  65,-112, -16, -78, -72}, {  6, -11,  -6,  62,  49,   8} },
		{ 	{-57,  49, -23,   52, -135,  66},{-23, 127, -58,   -5, -118,  64},
			{ 87, -16,  121,  23,  -41, -12},{-19,  29,   35,-148,  -11,  45} },
		{	{-55, -147, -146, -31,  55,  60},{-88,  -45,  -28,  46, -26,-144},
			{-12, -107,  -34, 150, 249,  66},{ 11,  -15,  -34,  27, -78, -50} },
		{	{ 56,  67, 108,   4,  2,-48},{ 58,  67,  89,  32, 32, -8},
			{-42, -31,-103, -30,-23, -8},{  6,   4, -26, -10, 26, 12}
		}
	};
	int gx = 4, gy = 4, gz = 6;

	double h2[gx - fx + 1][gy - fy + 1][gz - fz + 1];
	deconv3(g, gx, gy, gz, f, fx, fy, fz, h2);
	printf("deconv3(g, f):\n");
	for (int i = 0; i < gx - fx + 1; i++) {
		for (int j = 0; j < gy - fy + 1; j++) {
			for (int k = 0; k < gz - fz + 1; k++)
				printf("%g ", h2[i][j][k]);
			printf("\n");
		}
		if (i < gx - fx) printf("\n");
	}

	double f2[gx - hx + 1][gy - hy + 1][gz - hz + 1];
	deconv3(g, gx, gy, gz, h, hx, hy, hz, f2);
	printf("\ndeconv3(g, h):\n");
	for (int i = 0; i < gx - hx + 1; i++) {
		for (int j = 0; j < gy - hy + 1; j++) {
			for (int k = 0; k < gz - hz + 1; k++)
				printf("%g ", f2[i][j][k]);
			printf("\n");
		}
		if (i < gx - hx) printf("\n");
	}
}

/* two-D case; since task doesn't require showing it, it's commented out */
/*
int main()
{
	PI = atan2(1,1) * 4;
	double h[][6] = { 	{-8, 1, -7, -2, -9, 4},
				{4, 5, -5, 2, 7, -1},
				{-6, -3, -3, -6, 9, 5} };
	int hr = 3, hc = 6;

	double f[][5] = {	{-5, 2, -2, -6, -7},
				{9, 7, -6, 5, -7},
				{1, -1, 9, 2, -7},
				{5, 9, -9, 2, -5},
				{-8, 5, -2, 8, 5} };
	int fr = 5, fc = 5;
	double g[][10] = {
			{40, -21, 53, 42, 105, 1, 87, 60, 39, -28},
			{-92, -64, 19, -167, -71, -47, 128, -109, 40, -21},
			{58, 85, -93, 37, 101, -14, 5, 37, -76, -56},
			{-90, -135, 60, -125, 68, 53, 223, 4, -36, -48},
			{78, 16, 7, -199, 156, -162, 29, 28, -103, -10},
			{-62, -89, 69, -61, 66, 193, -61, 71, -8, -30},
			{48, -6, 21, -9, -150, -22, -56, 32, 85, 25}	};
	int gr = 7, gc = 10;

	double h2[gr - fr + 1][gc - fc + 1];
	deconv2(g, gr, gc, f, fr, fc, h2);
	for (int i = 0; i < gr - fr + 1; i++) {
		for (int j = 0; j < gc - fc + 1; j++)
			printf(" %g", h2[i][j]);
		printf("\n");
	}

	double f2[gr - hr + 1][gc - hc + 1];
	deconv2(g, gr, gc, h, hr, hc, f2);
	for (int i = 0; i < gr - hr + 1; i++) {
		for (int j = 0; j < gc - hc + 1; j++)
			printf(" %g", f2[i][j]);
		printf("\n");
	}
}*/
`,`#include "deconvolution-2d+-1.h"



// WARNING: Removing unreachable block (ram,0x0001000021c8)
// WARNING: Removing unreachable block (ram,0x0001000021e8)
// WARNING: Removing unreachable block (ram,0x0001000022a8)
// WARNING: Removing unreachable block (ram,0x0001000022c8)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fft(long param_1,long param_2,int param_3,int param_4)

{
  double *pdVar1;
  double *pdVar2;
  undefined8 uVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  int local_2c;
  
  if (param_4 < param_3) {
    __fft(param_2,param_1,param_3,param_4 << 1);
    __fft(param_2 + (long)param_4 * 0x10,param_1 + (long)param_4 * 0x10,param_3,param_4 << 1);
    for (local_2c = 0; local_2c < param_3; local_2c = local_2c + param_4 * 2) {
      dVar6 = __PI * -0.0 * 0.0 + __PI * -1.0 * (double)(long)local_2c;
      uVar3 = FUN_100003550(__PI * -0.0 * (double)(long)local_2c - __PI * -1.0 * 0.0,dVar6,
                            (double)(long)param_3,0);
      dVar4 = (double)_cexp(uVar3);
      pdVar1 = (double *)(param_2 + (long)(local_2c + param_4) * 0x10);
      dVar7 = *pdVar1;
      dVar8 = pdVar1[1];
      dVar5 = dVar4 * dVar7 - dVar6 * dVar8;
      dVar6 = dVar4 * dVar8 + dVar6 * dVar7;
      pdVar2 = (double *)(param_2 + (long)local_2c * 0x10);
      dVar4 = pdVar2[1];
      pdVar1 = (double *)(param_1 + (long)(local_2c / 2) * 0x10);
      *pdVar1 = *pdVar2 + dVar5;
      pdVar1[1] = dVar4 + dVar6;
      pdVar2 = (double *)(param_2 + (long)local_2c * 0x10);
      dVar4 = pdVar2[1];
      pdVar1 = (double *)(param_1 + (long)((local_2c + param_3) / 2) * 0x10);
      *pdVar1 = *pdVar2 - dVar5;
      pdVar1[1] = dVar4 - dVar6;
    }
  }
  return;
}



void _fft(long param_1,uint param_2)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  undefined8 uVar3;
  undefined *apuStack_60 [2];
  long local_50;
  long local_48;
  int local_3c;
  undefined *local_30;
  uint local_24;
  long local_20;
  long local_18;
  
  local_30 = (undefined *)apuStack_60;
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_50 = (ulong)param_2 * 0x10;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_48 = (long)apuStack_60 - local_50;
  for (local_3c = 0; local_3c < (int)local_24; local_3c = local_3c + 1) {
    puVar1 = (undefined8 *)(local_20 + (long)local_3c * 0x10);
    uVar3 = puVar1[1];
    puVar2 = (undefined8 *)(local_48 + (long)local_3c * 0x10);
    *puVar2 = *puVar1;
    puVar2[1] = uVar3;
  }
  __fft(local_20,local_48,local_24,1);
  apuStack_60[1] = local_30;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void * _pad_two(long param_1,int param_2,int *param_3)

{
  undefined8 *puVar1;
  void *pvVar2;
  int local_3c;
  int local_2c;
  
  local_2c = 1;
  if (*param_3 == 0) {
    for (; local_2c < param_2; local_2c = local_2c << 1) {
    }
  }
  else {
    local_2c = *param_3;
  }
  pvVar2 = _calloc(0x10,(long)local_2c);
  for (local_3c = 0; local_3c < param_2; local_3c = local_3c + 1) {
    puVar1 = (undefined8 *)((long)pvVar2 + (long)local_3c * 0x10);
    *puVar1 = *(undefined8 *)(param_1 + (long)local_3c * 8);
    puVar1[1] = 0;
  }
  *param_3 = local_2c;
  return pvVar2;
}



void _deconv(undefined8 param_1,int param_2,undefined8 param_3,int param_4,long param_5,int param_6)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  int iVar3;
  undefined8 uVar4;
  double dVar5;
  undefined8 uVar6;
  undefined auStack_b0 [8];
  undefined *local_a8;
  uint *local_a0;
  long local_98;
  undefined *local_90;
  int local_84;
  undefined8 local_80;
  undefined8 local_78;
  int local_70;
  int local_6c;
  undefined *local_60;
  void *local_58;
  void *local_50;
  uint local_48;
  int local_44;
  long local_40;
  int local_34;
  undefined8 local_30;
  int local_24;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_a0 = &local_48;
  local_48 = 0;
  local_44 = param_6;
  local_40 = param_5;
  local_34 = param_4;
  local_30 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  local_50 = (void *)_pad_two(param_1,param_2);
  local_58 = (void *)_pad_two(local_30,local_34,local_a0);
  _fft(local_50,local_48);
  _fft(local_58,local_48);
  local_98 = (ulong)local_48 * 0x10;
  local_60 = auStack_b0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_90 = auStack_b0 + -local_98;
  for (local_6c = 0; local_6c < (int)local_48; local_6c = local_6c + 1) {
    puVar1 = (undefined8 *)((long)local_50 + (long)local_6c * 0x10);
    uVar6 = puVar1[1];
    puVar2 = (undefined8 *)((long)local_58 + (long)local_6c * 0x10);
    uVar4 = FUN_100003550(*puVar1,uVar6,*puVar2,puVar2[1]);
    *(undefined8 *)(local_90 + (long)local_6c * 0x10) = uVar4;
    *(undefined8 *)((long)(local_90 + (long)local_6c * 0x10) + 8) = uVar6;
  }
  _fft(local_90,local_48);
  for (local_70 = 0; local_70 < (int)local_48; local_70 = local_70 + 1) {
    local_80 = *(undefined8 *)(local_90 + (long)local_70 * 0x10);
    local_78 = 0;
    dVar5 = (double)_cabs(local_80,0);
    if (dVar5 < 1e-10) {
      *(undefined8 *)(local_90 + (long)local_70 * 0x10) = 0;
      *(undefined8 *)((long)(local_90 + (long)local_70 * 0x10) + 8) = 0;
    }
  }
  for (local_84 = 0; (local_34 - local_24) - local_44 < local_84; local_84 = local_84 + -1) {
    iVar3 = 0;
    if (local_48 != 0) {
      iVar3 = (int)(local_84 + local_48) / (int)local_48;
    }
    uVar4 = FUN_100003550(*(undefined8 *)
                           (local_90 + (long)(int)((local_84 + local_48) - iVar3 * local_48) * 0x10)
                          ,*(undefined8 *)
                            ((long)(local_90 +
                                   (long)(int)((local_84 + local_48) - iVar3 * local_48) * 0x10) + 8
                            ),0x4040000000000000,0);
    *(undefined8 *)(local_40 + (long)-local_84 * 8) = uVar4;
  }
  _free(local_50);
  _free(local_58);
  local_a8 = local_60;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void * _unpack2(long param_1,int param_2,uint param_3,int param_4)

{
  void *pvVar1;
  undefined4 local_38;
  undefined4 local_34;
  
  pvVar1 = _calloc(8,(long)(param_2 * param_4));
  for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
    for (local_38 = 0; local_38 < (int)param_3; local_38 = local_38 + 1) {
      *(undefined8 *)((long)pvVar1 + (long)(local_34 * param_4 + local_38) * 8) =
           *(undefined8 *)(param_1 + (long)local_34 * (ulong)param_3 * 8 + (long)local_38 * 8);
    }
  }
  return pvVar1;
}



void _pack2(long param_1,int param_2,int param_3,uint param_4,long param_5)

{
  undefined4 local_28;
  undefined4 local_24;
  
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < (int)param_4; local_28 = local_28 + 1) {
      *(double *)(param_5 + (long)local_24 * (ulong)param_4 * 8 + (long)local_28 * 8) =
           *(double *)(param_1 + (long)(local_24 * param_3 + local_28) * 8) / 4.0;
    }
  }
  return;
}



void _deconv2(undefined8 param_1,int param_2,int param_3,undefined8 param_4,int param_5,int param_6,
             undefined8 param_7)

{
  undefined auStack_80 [8];
  ulong local_78;
  undefined *local_70;
  undefined *local_68;
  undefined *local_58;
  void *local_50;
  void *local_48;
  undefined8 local_40;
  int local_38;
  int local_34;
  undefined8 local_30;
  int local_28;
  int local_24;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_40 = param_7;
  local_38 = param_6;
  local_34 = param_5;
  local_30 = param_4;
  local_28 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  local_48 = (void *)_unpack2(param_1,param_2,param_3,param_3);
  local_50 = (void *)_unpack2(local_30,local_34,local_38,local_28);
  local_78 = (ulong)(uint)(((local_24 - local_34) + 1) * local_28) * 8 + 0xf & 0xfffffffffffffff0;
  local_58 = auStack_80;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_70 = auStack_80 + -local_78;
  _deconv(local_48,local_24 * local_28,local_50,local_34 * local_28,local_70,local_28);
  _pack2(local_70,(local_24 - local_34) + 1,local_28,(local_28 - local_38) + 1,local_40);
  _free(local_48);
  _free(local_50);
  local_68 = local_58;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void * _unpack3(long param_1,int param_2,uint param_3,uint param_4,int param_5,int param_6)

{
  void *pvVar1;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  
  pvVar1 = _calloc(8,(long)(param_2 * param_5 * param_6));
  for (local_3c = 0; local_3c < param_2; local_3c = local_3c + 1) {
    for (local_40 = 0; local_40 < (int)param_3; local_40 = local_40 + 1) {
      for (local_44 = 0; local_44 < (int)param_4; local_44 = local_44 + 1) {
        *(undefined8 *)
         ((long)pvVar1 + (long)((local_3c * param_5 + local_40) * param_6 + local_44) * 8) =
             *(undefined8 *)
              (param_1 + (long)local_3c * (ulong)param_3 * (ulong)param_4 * 8 +
               (long)local_40 * (ulong)param_4 * 8 + (long)local_44 * 8);
      }
    }
  }
  return pvVar1;
}



void _pack3(long param_1,int param_2,int param_3,int param_4,uint param_5,uint param_6,long param_7)

{
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  
  for (local_2c = 0; local_2c < param_2; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < (int)param_5; local_30 = local_30 + 1) {
      for (local_34 = 0; local_34 < (int)param_6; local_34 = local_34 + 1) {
        *(double *)
         (param_7 + (long)local_2c * (ulong)param_5 * (ulong)param_6 * 8 +
          (long)local_30 * (ulong)param_6 * 8 + (long)local_34 * 8) =
             *(double *)(param_1 + (long)((local_2c * param_3 + local_30) * param_4 + local_34) * 8)
             / 4.0;
      }
    }
  }
  return;
}



void _deconv3(undefined8 param_1,int param_2,int param_3,int param_4,undefined8 param_5,int param_6,
             int param_7,int param_8,undefined8 param_9)

{
  undefined auStack_90 [8];
  ulong local_88;
  undefined *local_80;
  undefined *local_78;
  undefined *local_68;
  void *local_60;
  void *local_58;
  undefined8 local_50;
  int local_44;
  int local_40;
  int local_3c;
  undefined8 local_38;
  int local_2c;
  int local_28;
  int local_24;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_50 = param_9;
  local_44 = param_8;
  local_40 = param_7;
  local_3c = param_6;
  local_38 = param_5;
  local_2c = param_4;
  local_28 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  local_58 = (void *)_unpack3(param_1,param_2,param_3,param_4,param_3,param_4);
  local_60 = (void *)_unpack3(local_38,local_3c,local_40,local_44,local_28,local_2c);
  local_88 = (ulong)(uint)(((local_24 - local_3c) + 1) * local_28 * local_2c) * 8 + 0xf &
             0xfffffffffffffff0;
  local_68 = auStack_90;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_80 = auStack_90 + -local_88;
  _deconv(local_58,local_24 * local_28 * local_2c,local_60,local_3c * local_28 * local_2c,local_80,
          local_28 * local_2c);
  _pack3(local_80,(local_24 - local_3c) + 1,local_28,local_2c,(local_28 - local_40) + 1,
         (local_2c - local_44) + 1,local_50);
  _free(local_58);
  _free(local_60);
  local_78 = local_68;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 entry(void)

{
  uint uVar1;
  undefined *puVar2;
  long lVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  undefined8 uVar10;
  long extraout_x12;
  long extraout_x12_00;
  long alStack_580 [2];
  undefined auStack_570 [4];
  undefined4 local_56c;
  uint local_568;
  uint local_564;
  ulong local_560;
  ulong local_558;
  ulong local_550;
  long local_548;
  int local_540;
  int local_53c;
  undefined *local_538;
  int local_52c;
  undefined *local_528;
  uint local_520;
  uint local_51c;
  ulong local_518;
  ulong local_510;
  ulong local_508;
  undefined *local_500;
  int local_4f4;
  int local_4f0;
  int local_4ec;
  ulong local_4e8;
  ulong local_4e0;
  ulong local_4d8;
  int local_4cc;
  int local_4c8;
  int local_4c4;
  ulong local_4c0;
  ulong local_4b8;
  ulong local_4b0;
  undefined *local_4a8;
  int local_4a0;
  int local_49c;
  int local_498;
  int local_494;
  int local_490;
  int local_48c;
  int local_488;
  int local_484;
  int local_480;
  undefined4 local_47c;
  undefined auStack_478 [768];
  undefined auStack_178 [144];
  undefined auStack_e8 [192];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004018;
  local_47c = 0;
  __PI = (double)_atan2(0x3ff0000000000000);
  __PI = __PI * 4.0;
  _memcpy(auStack_e8,&DAT_100003b08,0xc0);
  local_540 = 2;
  local_480 = 2;
  local_53c = 3;
  local_484 = 3;
  local_52c = 4;
  local_488 = 4;
  local_528 = auStack_178;
  _memcpy(local_528,&DAT_100003bc8,0x90);
  local_48c = local_53c;
  local_490 = local_540;
  local_494 = local_53c;
  local_538 = auStack_478;
  _memcpy(local_538,&DAT_100003c58,0x300);
  local_498 = local_52c;
  local_49c = local_52c;
  local_4a0 = 6;
  uVar1 = (local_52c - local_48c) + 1;
  local_518 = (ulong)uVar1;
  local_520 = (local_52c - local_490) + 1;
  local_510 = (ulong)local_520;
  local_51c = 7 - local_494;
  local_508 = (ulong)local_51c;
  local_4a8 = auStack_570;
  uVar10 = (*(code *)PTR____chkstk_darwin_100004000)
                     ((ulong)uVar1 * (ulong)local_520 * local_508 * 8 + 0xf,local_538);
  iVar5 = local_498;
  iVar4 = local_49c;
  iVar9 = local_4a0;
  lVar3 = -extraout_x12;
  puVar2 = auStack_570 + lVar3;
  local_4b0 = local_518;
  local_4b8 = local_510;
  local_4c0 = local_508;
  local_500 = puVar2;
  *(undefined **)((long)alStack_580 + lVar3) = puVar2;
  _deconv3(uVar10,iVar5,iVar4,iVar9);
  iVar9 = _printf("deconv3(g, f):\n");
  for (local_4c4 = 0; local_4c4 < (local_498 - local_48c) + 1; local_4c4 = local_4c4 + 1) {
    for (local_4c8 = 0; local_4c8 < (local_49c - local_490) + 1; local_4c8 = local_4c8 + 1) {
      for (local_4cc = 0; local_4cc < (local_4a0 - local_494) + 1; local_4cc = local_4cc + 1) {
        *(undefined8 *)((long)alStack_580 + lVar3) =
             *(undefined8 *)
              (local_500 +
              (long)local_4cc * 8 +
              (long)local_4c8 * local_508 * 8 +
              (long)local_4c4 * (ulong)local_520 * (ulong)local_51c * 8);
        _printf("%g ");
      }
      iVar9 = _printf("\n");
    }
    if (local_4c4 < local_498 - local_48c) {
      iVar9 = _printf("\n");
    }
  }
  uVar1 = (local_498 - local_480) + 1;
  local_560 = (ulong)uVar1;
  local_568 = (local_49c - local_484) + 1;
  local_558 = (ulong)local_568;
  local_564 = (local_4a0 - local_488) + 1;
  local_550 = (ulong)local_564;
  (*(code *)PTR____chkstk_darwin_100004000)
            ((ulong)uVar1 * (ulong)local_568 * local_550 * 8 + 0xf,iVar9);
  iVar8 = local_480;
  iVar7 = local_484;
  iVar6 = local_488;
  iVar5 = local_498;
  iVar4 = local_49c;
  iVar9 = local_4a0;
  lVar3 = (long)puVar2 - extraout_x12_00;
  local_4d8 = local_560;
  local_4e0 = local_558;
  local_4e8 = local_550;
  local_548 = lVar3;
  *(long *)(lVar3 + -0x10) = lVar3;
  _deconv3(auStack_478,iVar5,iVar4,iVar9,auStack_e8,iVar8,iVar7,iVar6);
  iVar9 = _printf("\ndeconv3(g, h):\n");
  for (local_4ec = 0; local_4ec < (local_498 - local_480) + 1; local_4ec = local_4ec + 1) {
    for (local_4f0 = 0; local_4f0 < (local_49c - local_484) + 1; local_4f0 = local_4f0 + 1) {
      for (local_4f4 = 0; local_4f4 < (local_4a0 - local_488) + 1; local_4f4 = local_4f4 + 1) {
        *(undefined8 *)(lVar3 + -0x10) =
             *(undefined8 *)
              (local_548 + (long)local_4ec * (ulong)local_568 * (ulong)local_564 * 8 +
               (long)local_4f0 * local_550 * 8 + (long)local_4f4 * 8);
        _printf("%g ");
      }
      iVar9 = _printf("\n");
    }
    if (local_4ec < local_498 - local_480) {
      iVar9 = _printf("\n");
    }
  }
  local_56c = local_47c;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar9);
  }
  return local_47c;
}



// WARNING: Removing unreachable block (ram,0x000100003894)
// WARNING: Removing unreachable block (ram,0x00010000389c)
// WARNING: Removing unreachable block (ram,0x0001000038a4)
// WARNING: Removing unreachable block (ram,0x0001000038b4)
// WARNING: Removing unreachable block (ram,0x0001000038cc)
// WARNING: Removing unreachable block (ram,0x0001000038e0)
// WARNING: Removing unreachable block (ram,0x0001000038f4)
// WARNING: Removing unreachable block (ram,0x00010000395c)
// WARNING: Removing unreachable block (ram,0x000100003970)
// WARNING: Removing unreachable block (ram,0x000100003978)
// WARNING: Removing unreachable block (ram,0x00010000398c)
// WARNING: Removing unreachable block (ram,0x0001000039ac)
// WARNING: Removing unreachable block (ram,0x0001000039b0)
// WARNING: Removing unreachable block (ram,0x0001000039c4)
// WARNING: Removing unreachable block (ram,0x0001000039c8)
// WARNING: Removing unreachable block (ram,0x0001000039e8)
// WARNING: Removing unreachable block (ram,0x0001000039ec)
// WARNING: Removing unreachable block (ram,0x0001000039f0)
// WARNING: Removing unreachable block (ram,0x000100003904)
// WARNING: Removing unreachable block (ram,0x000100003910)
// WARNING: Removing unreachable block (ram,0x000100003914)
// WARNING: Removing unreachable block (ram,0x000100003930)
// WARNING: Removing unreachable block (ram,0x000100003934)
// WARNING: Removing unreachable block (ram,0x0001000038ac)
// WARNING: Removing unreachable block (ram,0x0001000039fc)

undefined  [16]
FUN_100003550(double param_1,double param_2,undefined param_3 [16],undefined param_4 [16])

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  ulong uVar6;
  ulong uVar7;
  undefined auVar8 [16];
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  
  dVar9 = param_3._0_8_;
  dVar10 = param_4._0_8_;
  dVar11 = ABS(dVar9);
  if (ABS(dVar9) <= ABS(dVar10)) {
    dVar11 = ABS(dVar10);
  }
  uVar5 = (uint)((ulong)dVar11 >> 0x34) & 0x7ff;
  iVar4 = (((uint)((ulong)((long)dVar11 << ((ulong)((int)LZCOUNT(ABS(dVar11)) - 0xb) & 0x3f)) >>
                  0x34) & 0x7ff) - (int)LZCOUNT(ABS(dVar11))) + -0x3f4;
  if (uVar5 != 0) {
    iVar4 = uVar5 - 0x3ff;
  }
  dVar12 = -INFINITY;
  if (dVar11 != 0.0) {
    dVar12 = (double)iVar4;
  }
  if (dVar11 == -NAN || (long)dVar11 + 1 < 0 != SCARRY8((long)dVar11,1)) {
    dVar11 = -dVar11;
  }
  if (uVar5 == 0x7ff) {
    dVar12 = dVar11;
  }
  if ((ulong)ABS(dVar12) < 0x7ff0000000000000) {
    iVar4 = (int)dVar12;
    iVar3 = -iVar4;
    if ((dVar9 != 0.0) && (uVar5 = param_3._4_4_ >> 0x14 & 0x7ff, uVar5 != 0x7ff)) {
      uVar6 = (ulong)dVar9 & 0xfffffffffffff;
      if (uVar5 == 0) {
        uVar5 = 0xc - (int)LZCOUNT(uVar6);
        uVar6 = uVar6 << ((ulong)((int)LZCOUNT(uVar6) - 0xb) & 0x3f) & 0xffefffffffffffff;
      }
      uVar1 = (int)(uVar5 + iVar3) >> 0x1f ^ 0x80000000;
      if (!SCARRY4(uVar5,iVar3)) {
        uVar1 = uVar5 + iVar3;
      }
      uVar7 = (ulong)dVar9 & 0x8000000000000000;
      if ((int)uVar1 < 0x7ff) {
        if ((int)uVar1 < 1) {
          if (uVar1 == 0xfffffc03 || (int)(uVar1 + 0x3fd) < 0 != SCARRY4(uVar1,0x3fd)) {
            uVar1 = 0xfffffc03;
          }
          dVar9 = (double)(uVar6 | uVar7 | 0x10000000000000) *
                  (double)((ulong)(uVar1 + 0x3fe) << 0x34);
        }
        else {
          dVar9 = (double)(uVar7 | (ulong)uVar1 << 0x34 | uVar6);
        }
      }
      else {
        dVar9 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      }
    }
    if ((dVar10 != 0.0) && (uVar5 = param_4._4_4_ >> 0x14 & 0x7ff, uVar5 != 0x7ff)) {
      uVar6 = (ulong)dVar10 & 0xfffffffffffff;
      if (uVar5 == 0) {
        uVar5 = 0xc - (int)LZCOUNT(uVar6);
        uVar6 = uVar6 << ((ulong)((int)LZCOUNT(uVar6) - 0xb) & 0x3f) & 0xffefffffffffffff;
      }
      uVar1 = (int)(uVar5 + iVar3) >> 0x1f ^ 0x80000000;
      if (!SCARRY4(uVar5,iVar3)) {
        uVar1 = uVar5 + iVar3;
      }
      uVar7 = (ulong)dVar10 & 0x8000000000000000;
      if ((int)uVar1 < 0x7ff) {
        if ((int)uVar1 < 1) {
          if (uVar1 == 0xfffffc03 || (int)(uVar1 + 0x3fd) < 0 != SCARRY4(uVar1,0x3fd)) {
            uVar1 = 0xfffffc03;
          }
          dVar10 = (double)(uVar6 | uVar7 | 0x10000000000000) *
                   (double)((ulong)(uVar1 + 0x3fe) << 0x34);
        }
        else {
          dVar10 = (double)(uVar7 | (ulong)uVar1 << 0x34 | uVar6);
        }
      }
      else {
        dVar10 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      }
    }
  }
  else {
    iVar4 = 0;
  }
  dVar12 = (double)NEON_fmadd(dVar9,dVar9,dVar10 * dVar10);
  dVar11 = (double)NEON_fmadd(param_1,dVar9,dVar10 * param_2);
  dVar11 = dVar11 / dVar12;
  if ((dVar11 != 0.0) && (uVar5 = (uint)((ulong)dVar11 >> 0x34) & 0x7ff, uVar5 != 0x7ff)) {
    uVar7 = (ulong)dVar11 & 0xfffffffffffff;
    uVar6 = uVar7;
    if (uVar5 == 0) {
      uVar6 = uVar7 << ((ulong)((int)LZCOUNT(uVar7) - 0xb) & 0x3f) & 0xffefffffffffffff;
      uVar5 = 0xc - (int)LZCOUNT(uVar7);
    }
    uVar1 = uVar5 + -iVar4;
    uVar2 = (int)uVar1 >> 0x1f ^ 0x80000000;
    if (!SCARRY4(uVar5,-iVar4)) {
      uVar2 = uVar1;
    }
    uVar7 = (ulong)dVar11 & 0x8000000000000000;
    if (0x7fe < (int)uVar2) {
      dVar11 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
      goto code_r0x000100003860;
    }
    if ((int)uVar2 < 1) {
      if (uVar2 == 0xfffffc03 || (int)(uVar2 + 0x3fd) < 0 != SCARRY4(uVar2,0x3fd)) {
        uVar2 = 0xfffffc03;
      }
      dVar11 = (double)(uVar6 | uVar7 | 0x10000000000000) * (double)((ulong)(uVar2 + 0x3fe) << 0x34)
      ;
      NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
      goto code_r0x000100003860;
    }
    dVar11 = (double)(uVar7 | (ulong)uVar2 << 0x34 | uVar6);
  }
  NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
code_r0x000100003860:
  auVar8._8_8_ = 0;
  auVar8._0_8_ = dVar11;
  return auVar8;
}



void ___muldc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003a8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____muldc3_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003a98. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003aa4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004020)();
  return;
}



void _cabs(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ab0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cabs_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003abc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004030)();
  return pvVar1;
}



void _cexp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ac8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cexp_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ad4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ae0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004048)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003aec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004050)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <locale.h>

#define LIMIT 42

int is_prime(long long n) {
    if (n % 2 == 0) return n == 2;
    if (n % 3 == 0) return n == 3;
    long long d = 5;
    while (d * d <= n) {
        if (n % d == 0) return 0;
        d += 2;
        if (n % d == 0) return 0;
        d += 4;
    }
    return 1;
}

int main() {
    long long i;
    int n;
    setlocale(LC_NUMERIC, "");
    for (i = LIMIT, n = 0; n < LIMIT; i++)
        if (is_prime(i)) {
            n++;
            printf("n = %-2d  %'19lld\n", n, i);
            i += i - 1;
        }
    return 0;
}
`,`#include "loops-increment-loop-index-within-loop-body.h"



bool _is_prime(long param_1)

{
  long lVar1;
  long lVar2;
  bool bVar3;
  long local_18;
  
  if (param_1 % 2 == 0) {
    bVar3 = param_1 == 2;
  }
  else if (param_1 % 3 == 0) {
    bVar3 = param_1 == 3;
  }
  else {
    for (local_18 = 5; local_18 * local_18 - param_1 == 0 || local_18 * local_18 < param_1;
        local_18 = local_18 + 6) {
      lVar1 = 0;
      if (local_18 != 0) {
        lVar1 = param_1 / local_18;
      }
      if (param_1 == lVar1 * local_18) {
        return false;
      }
      lVar1 = local_18 + 2;
      lVar2 = 0;
      if (lVar1 != 0) {
        lVar2 = param_1 / lVar1;
      }
      if (param_1 == lVar2 * lVar1) {
        return false;
      }
    }
    bVar3 = true;
  }
  return bVar3;
}



undefined8 entry(void)

{
  int iVar1;
  int local_24;
  long local_20;
  
  _setlocale(4,"");
  local_20 = 0x2a;
  local_24 = 0;
  while (local_24 < 0x2a) {
    iVar1 = _is_prime(local_20);
    if (iVar1 != 0) {
      local_24 = local_24 + 1;
      _printf("n = %-2d  %\'19lld\n");
      local_20 = local_20 * 2 + -1;
    }
    local_20 = local_20 + 1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004008)();
  return;
}


`
`#include <sys/ioctl.h>	/* ioctl, TIOCGWINSZ */
#include <err.h>	/* err */
#include <fcntl.h>	/* open */
#include <stdio.h>	/* printf */
#include <unistd.h>	/* close */

int
main()
{
	struct winsize ws;
	int fd;

	/* Open the controlling terminal. */
	fd = open("/dev/tty", O_RDWR);
	if (fd < 0)
		err(1, "/dev/tty");

	/* Get window size of terminal. */
	if (ioctl(fd, TIOCGWINSZ, &ws) < 0)
		err(1, "/dev/tty");

	printf("%d rows by %d columns\n", ws.ws_row, ws.ws_col);
	printf("(%d by %d pixels)\n", ws.ws_xpixel, ws.ws_ypixel);

	close(fd);	
	return 0;
}
`,`#include "terminal-control-dimensions-1.h"



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = _open("/dev/tty",2);
  if (iVar1 < 0) {
    _err(1,"/dev/tty");
  }
  iVar2 = _ioctl(iVar1,0x40087468);
  if (iVar2 < 0) {
    _err(1,"/dev/tty");
  }
  _printf("%d rows by %d columns\n");
  _printf("(%d by %d pixels)\n");
  _close(iVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004000)(param_1);
  return iVar1;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _ioctl(int param_1,ulong param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__ioctl_100004010)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004018)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>

const uint8_t masks[8] = {1, 2, 4, 8, 16, 32, 64, 128};

#define half(n) ((int64_t)((n) - 1) >> 1)

#define divide(nm, d) ((uint64_t)((double)nm / (double)d))

int64_t countPrimes(uint64_t n) {
    if (n < 9) return (n < 2) ? 0 : ((int64_t)n + 1) / 2;
    uint64_t rtlmt = (uint64_t)sqrt((double)n);
    int64_t mxndx = (int64_t)((rtlmt - 1) / 2);
    int arrlen = (int)(mxndx + 1);
    uint32_t *smalls = malloc(arrlen * 4);
    uint32_t *roughs = malloc(arrlen * 4);
    int64_t *larges  = malloc(arrlen * 8);
    for (int i = 0; i < arrlen; ++i) {
        smalls[i] = (uint32_t)i;
        roughs[i] = (uint32_t)(i + i + 1);
        larges[i] = (int64_t)((n/(uint64_t)(i + i + 1) - 1) / 2);
    }
    int cullbuflen = (int)((mxndx + 8) / 8);
    uint8_t *cullbuf = calloc(cullbuflen, 1);
    int64_t nbps = 0;
    int rilmt = arrlen;
    for (int64_t i = 1; ; ++i) {
        int64_t sqri = (i + i) * (i + 1);
        if (sqri > mxndx) break;
        if (cullbuf[i >> 3] & masks[i & 7]) continue;
        cullbuf[i >> 3] |= masks[i & 7];
        uint64_t bp = (uint64_t)(i + i + 1);
        for (int64_t c = sqri; c < (int64_t)arrlen; c += (int64_t)bp) {
            cullbuf[c >> 3] |= masks[c & 7];
        }
        int nri = 0;
        for (int ori = 0; ori < rilmt; ++ori) {
            uint32_t r = roughs[ori];
            int64_t rci = (int64_t)(r >> 1);
            if (cullbuf[rci >> 3] & masks[rci & 7]) continue;
            uint64_t d = (uint64_t)r * bp;
            int64_t t = (d <= rtlmt) ? larges[(int64_t)smalls[d >> 1] - nbps] :
                                       (int64_t)smalls[half(divide(n, d))];
            larges[nri] = larges[ori] - t + nbps;
            roughs[nri] = r;
            nri++;
        }
        int64_t si = mxndx;
        for (uint64_t pm = (rtlmt/bp - 1) | 1; pm >= bp; pm -= 2) {
            uint32_t c = smalls[pm >> 1];
            uint64_t e = (pm * bp) >> 1;
            for ( ; si >= (int64_t)e; --si) smalls[si] -= c - (uint32_t)nbps;
        }
        rilmt = nri;
        nbps++;
    }
    int64_t ans = larges[0] + (int64_t)((rilmt + 2*(nbps - 1)) * (rilmt - 1) / 2);
    int ri, sri;
    for (ri = 1; ri < rilmt; ++ri) ans -= larges[ri];
    for (ri = 1; ; ++ri) {
        uint64_t p = (uint64_t)roughs[ri];
        uint64_t m = n / p;
        int ei = (int)smalls[half((uint64_t)m/p)] - nbps;
        if (ei <= ri) break;
        ans -= (int64_t)((ei - ri) * (nbps + ri - 1));
        for (sri = ri + 1; sri < ei + 1; ++sri) {
            ans += (int64_t)smalls[half(divide(m, (uint64_t)roughs[sri]))];
        }
    }
    free(smalls);
    free(roughs);
    free(larges);
    free(cullbuf);
    return ans + 1;
}

int main() {
    uint64_t n;
    int i;
    clock_t start = clock();
    for (i = 0, n = 1; i < 10; ++i, n *= 10) {
        printf("10^%d %ld\n", i, countPrimes(n));
    }
    clock_t end = clock();
    printf("\nTook %f seconds\n", (double) (end - start) / CLOCKS_PER_SEC);
    return 0;
}
`,`#include "legendre-prime-counting-function.h"



// WARNING: Restarted to delay deadcode elimination for space: stack

long _countPrimes(ulong param_1)

{
  byte *pbVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  ulong uVar5;
  ulong uVar6;
  void *pvVar7;
  void *pvVar8;
  long *plVar9;
  void *pvVar10;
  int iVar11;
  ulong uVar12;
  ulong uVar13;
  double dVar14;
  double dVar15;
  ulong local_130;
  long local_120;
  int local_f8;
  int local_f4;
  long local_f0;
  ulong local_d8;
  ulong local_d0;
  int local_a8;
  int local_a4;
  ulong local_a0;
  ulong local_88;
  int local_7c;
  long local_78;
  int local_64;
  long local_28;
  
  if (param_1 < 9) {
    if (param_1 < 2) {
      local_120 = 0;
    }
    else {
      local_120 = (long)(param_1 + 1) / 2;
    }
    local_28 = local_120;
  }
  else {
    dVar14 = (double)NEON_ucvtf(param_1);
    uVar12 = (ulong)SQRT(dVar14);
    uVar5 = (uVar12 - 1) / 2;
    iVar11 = (int)uVar5 + 1;
    pvVar7 = _malloc((long)(iVar11 * 4));
    pvVar8 = _malloc((long)(iVar11 * 4));
    plVar9 = (long *)_malloc((long)(iVar11 * 8));
    for (local_64 = 0; local_64 < iVar11; local_64 = local_64 + 1) {
      *(int *)((long)pvVar7 + (long)local_64 * 4) = local_64;
      *(int *)((long)pvVar8 + (long)local_64 * 4) = local_64 * 2 + 1;
      uVar13 = (ulong)(local_64 * 2 + 1);
      uVar6 = 0;
      if (uVar13 != 0) {
        uVar6 = param_1 / uVar13;
      }
      plVar9[local_64] = (uVar6 - 1) / 2;
    }
    pvVar10 = _calloc((long)(int)((long)(uVar5 + 8) / 8),1);
    local_78 = 0;
    local_88 = 1;
    local_7c = iVar11;
    while( true ) {
      local_a0 = local_88 * 2 * (local_88 + 1);
      if ((long)uVar5 < (long)local_a0) break;
      if ((*(byte *)((long)pvVar10 + ((long)local_88 >> 3)) & (&_masks)[local_88 & 7]) == 0) {
        pbVar1 = (byte *)((long)pvVar10 + ((long)local_88 >> 3));
        *pbVar1 = *pbVar1 | (&_masks)[local_88 & 7];
        uVar6 = local_88 * 2 + 1;
        for (; (long)local_a0 < (long)iVar11; local_a0 = local_a0 + uVar6) {
          pbVar1 = (byte *)((long)pvVar10 + ((long)local_a0 >> 3));
          *pbVar1 = *pbVar1 | (&_masks)[local_a0 & 7];
        }
        local_a4 = 0;
        for (local_a8 = 0; local_a8 < local_7c; local_a8 = local_a8 + 1) {
          uVar3 = *(uint *)((long)pvVar8 + (long)local_a8 * 4);
          if ((*(byte *)((long)pvVar10 + ((long)(ulong)(uVar3 >> 1) >> 3)) &
              (&_masks)[(ulong)(uVar3 >> 1) & 7]) == 0) {
            uVar13 = uVar3 * uVar6;
            if (uVar12 < uVar13) {
              dVar14 = (double)NEON_ucvtf(param_1);
              dVar15 = (double)NEON_ucvtf(uVar13);
              local_130 = (ulong)*(uint *)((long)pvVar7 + ((long)(dVar14 / dVar15) + -1 >> 1) * 4);
            }
            else {
              local_130 = plVar9[(ulong)*(uint *)((long)pvVar7 + (uVar13 >> 1) * 4) - local_78];
            }
            plVar9[local_a4] = (plVar9[local_a8] - local_130) + local_78;
            *(uint *)((long)pvVar8 + (long)local_a4 * 4) = uVar3;
            local_a4 = local_a4 + 1;
          }
        }
        uVar13 = 0;
        if (uVar6 != 0) {
          uVar13 = uVar12 / uVar6;
        }
        local_d0 = uVar5;
        for (local_d8 = uVar13 - 1 | 1; uVar6 <= local_d8; local_d8 = local_d8 - 2) {
          iVar4 = *(int *)((long)pvVar7 + (local_d8 >> 1) * 4);
          for (; (long)(local_d8 * uVar6 >> 1) <= (long)local_d0; local_d0 = local_d0 - 1) {
            piVar2 = (int *)((long)pvVar7 + local_d0 * 4);
            *piVar2 = *piVar2 - (iVar4 - (int)local_78);
          }
        }
        local_7c = local_a4;
        local_78 = local_78 + 1;
      }
      local_88 = local_88 + 1;
    }
    local_f0 = *plVar9 + (((long)local_7c + (local_78 + -1) * 2) * (long)(local_7c + -1)) / 2;
    for (local_f4 = 1; local_f4 < local_7c; local_f4 = local_f4 + 1) {
      local_f0 = local_f0 - plVar9[local_f4];
    }
    local_f4 = 1;
    while( true ) {
      uVar12 = (ulong)*(uint *)((long)pvVar8 + (long)local_f4 * 4);
      uVar5 = 0;
      if (uVar12 != 0) {
        uVar5 = param_1 / uVar12;
      }
      uVar6 = 0;
      if (uVar12 != 0) {
        uVar6 = uVar5 / uVar12;
      }
      iVar11 = *(int *)((long)pvVar7 + ((long)(uVar6 - 1) >> 1) * 4) - (int)local_78;
      if (iVar11 <= local_f4) break;
      local_f0 = local_f0 - (long)(iVar11 - local_f4) * (local_78 + local_f4 + -1);
      local_f8 = local_f4;
      while (local_f8 = local_f8 + 1, local_f8 < iVar11 + 1) {
        dVar14 = (double)NEON_ucvtf(uVar5);
        local_f0 = local_f0 +
                   (ulong)*(uint *)((long)pvVar7 +
                                   ((long)(dVar14 / (double)*(uint *)((long)pvVar8 +
                                                                     (long)local_f8 * 4)) + -1 >> 1)
                                   * 4);
      }
      local_f4 = local_f4 + 1;
    }
    _free(pvVar7);
    _free(pvVar8);
    _free(plVar9);
    _free(pvVar10);
    local_28 = local_f0 + 1;
  }
  return local_28;
}



undefined8 entry(void)

{
  int local_24;
  long local_20;
  
  _clock();
  local_20 = 1;
  for (local_24 = 0; local_24 < 10; local_24 = local_24 + 1) {
    _countPrimes(local_20);
    _printf("10^%d %ld\n");
    local_20 = local_20 * 10;
  }
  _clock();
  _printf("\nTook %f seconds\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004008)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

int main(int argc, char **argv) {

   float x[4] = {1,2,3,1e11}, y[4];
   int i = 0;
   FILE *filePtr;

   filePtr = fopen("floatArray","w");

   for (i = 0; i < 4; i++) {
      y[i] = sqrt(x[i]);
      fprintf(filePtr, "%.3g\t%.5g\n", x[i], y[i]);
   }

   return 0;
}
`,`#include "write-float-arrays-to-a-text-file-1.h"



undefined8 entry(void)

{
  uint uVar1;
  FILE *pFVar2;
  int local_54;
  float afStack_40 [4];
  float local_30 [6];
  long local_18;
  FILE *pFVar3;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30[2] = 3.0;
  local_30[3] = 1e+11;
  local_30[0] = 1.0;
  local_30[1] = 2.0;
  pFVar2 = _fopen("floatArray","w");
  pFVar3 = pFVar2;
  for (local_54 = 0; local_54 < 4; local_54 = local_54 + 1) {
    afStack_40[local_54] = SQRT(local_30[local_54]);
    uVar1 = _fprintf(pFVar2,"%.3g\t%.5g\n");
    pFVar3 = (FILE *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pFVar3);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004010)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef unsigned long long u64;

#define FIB_INVALID (~(u64)0)

u64 fib[] = {
	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
	2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
	317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465,
	14930352, 24157817, 39088169, 63245986, 102334155, 165580141,
	267914296, 433494437, 701408733, 1134903170, 1836311903,
	2971215073ULL, 4807526976ULL, 7778742049ULL, 12586269025ULL,
	20365011074ULL, 32951280099ULL, 53316291173ULL, 86267571272ULL,
	139583862445ULL, 225851433717ULL, 365435296162ULL, 591286729879ULL,
	956722026041ULL, 1548008755920ULL, 2504730781961ULL, 4052739537881ULL,
	6557470319842ULL, 10610209857723ULL, 17167680177565ULL,

	27777890035288ULL // this 65-th one is for range check
};

u64 fibbinary(u64 n)
{
	if (n >= fib[64]) return FIB_INVALID;

	u64 ret = 0;
	int i;
	for (i = 64; i--; )
		if (n >= fib[i]) {
			ret |= 1ULL << i;
			n -= fib[i];
		}

	return ret;
}

void bprint(u64 n, int width)
{
	if (width > 64) width = 64;

	u64 b;
	for (b = 1ULL << (width - 1); b; b >>= 1)
		putchar(b == 1 && !n
			? '0'
			: b > n	? ' '
				: b & n ? '1' : '0');
	putchar('\n');
}

int main(void)
{
	int i;

	for (i = 0; i <= 20; i++)
		printf("%2d:", i), bprint(fibbinary(i), 8);

	return 0;
}
`,`#include "zeckendorf-number-representation.h"



ulong _fibbinary(ulong param_1)

{
  uint uVar1;
  uint local_1c;
  ulong local_18;
  ulong local_10;
  ulong local_8;
  
  if (param_1 < DAT_100008200) {
    local_18 = 0;
    local_1c = 0x40;
    local_10 = param_1;
    while (uVar1 = local_1c - 1, local_1c != 0) {
      local_1c = uVar1;
      if (*(ulong *)(&_fib + (long)(int)uVar1 * 8) <= local_10) {
        local_18 = local_18 | 1L << ((ulong)uVar1 & 0x3f);
        local_10 = local_10 - *(long *)(&_fib + (long)(int)uVar1 * 8);
      }
    }
    local_8 = local_18;
  }
  else {
    local_8 = 0xffffffffffffffff;
  }
  return local_8;
}



int _bprint(ulong param_1,int param_2)

{
  int iVar1;
  int local_30;
  int local_2c;
  ulong local_28;
  int local_1c;
  
  local_1c = param_2;
  if (0x40 < param_2) {
    local_1c = 0;
  }
  for (local_28 = 1L << ((ulong)(local_1c - 1) & 0x3f); local_28 != 0; local_28 = local_28 >> 1) {
    if ((local_28 == 1) && (param_1 == 0)) {
      local_2c = 0x30;
    }
    else {
      if (param_1 < local_28) {
        local_30 = 0x20;
      }
      else {
        local_30 = 0x31;
        if ((local_28 & param_1) == 0) {
          local_30 = 0x30;
        }
      }
      local_2c = local_30;
    }
    _putchar(local_2c);
  }
  iVar1 = _putchar(10);
  return iVar1;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  int local_18;
  
  for (local_18 = 0; local_18 < 0x15; local_18 = local_18 + 1) {
    _printf("%2d:");
    uVar1 = _fibbinary((long)local_18);
    _bprint(uVar1,8);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(int argc, char *argv[])
{
        if(argc == 99)
                return 99;
        if(argv[0] != NULL){
                argv[0] = NULL;
                argc = 0;
        }
        argc = main(argc + 1, argv);
        printf("%d bottle%c of beer on the wall\n", argc, argc == 1?'\0': 's');
        printf("%d bottle%c of beer\n", argc, argc == 1?'\0': 's');
        printf("Take one down, pass it around\n");
        printf("%d bottle%c of beer on the wall\n\n", argc - 1, (argc - 1) == 1?'\0': 's');
        return argc - 1;
}
`,`#include "99-bottles-of-beer-2.h"



int entry(int param_1,long *param_2)

{
  int local_18;
  int local_14;
  
  if (param_1 == 99) {
    local_14 = 99;
  }
  else {
    local_18 = param_1;
    if (*param_2 != 0) {
      *param_2 = 0;
      local_18 = 0;
    }
    local_14 = entry(local_18 + 1,param_2);
    _printf("%d bottle%c of beer on the wall\n");
    _printf("%d bottle%c of beer\n");
    _printf("Take one down, pass it around\n");
    _printf("%d bottle%c of beer on the wall\n\n");
    local_14 = local_14 + -1;
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

/* c = a * b.  Caller is responsible for memory.
   c must not be the same as either a or b. */
void longmulti(const char *a, const char *b, char *c)
{
	int i = 0, j = 0, k = 0, n, carry;
	int la, lb;

	/* either is zero, return "0" */
	if (!strcmp(a, "0") || !strcmp(b, "0")) {
		c[0] = '0', c[1] = '\0';
		return;
	}

	/* see if either a or b is negative */
	if (a[0] == '-') { i = 1; k = !k; }
	if (b[0] == '-') { j = 1; k = !k; }

	/* if yes, prepend minus sign if needed and skip the sign */
	if (i || j) {
		if (k) c[0] = '-';
		longmulti(a + i, b + j, c + k);
		return;
	}

	la = strlen(a);
	lb = strlen(b);
	memset(c, '0', la + lb);
	c[la + lb] = '\0';

#	define I(a) (a - '0')
	for (i = la - 1; i >= 0; i--) {
		for (j = lb - 1, k = i + j + 1, carry = 0; j >= 0; j--, k--) {
			n = I(a[i]) * I(b[j]) + I(c[k]) + carry;
			carry = n / 10;
			c[k] = (n % 10) + '0';
		}
		c[k] += carry;
	}
#	undef I
	if (c[0] == '0') memmove(c, c + 1, la + lb);

	return;
}

int main()
{
	char c[1024];
	longmulti("-18446744073709551616", "-18446744073709551616", c);
	printf("%s\n", c);

	return 0;
}
`,`#include "long-multiplication-1.h"



void _longmulti(char *param_1,char *param_2,char *param_3)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  int iVar4;
  int local_3c;
  uint local_34;
  uint local_30;
  uint local_2c;
  
  iVar2 = _strcmp(param_1,"0");
  if ((iVar2 == 0) || (iVar2 = _strcmp(param_2,"0"), iVar2 == 0)) {
    *param_3 = '0';
    param_3[1] = '\0';
  }
  else {
    local_34 = (uint)(*param_1 == '-');
    local_2c = (uint)(*param_1 == '-');
    if (*param_2 == '-') {
      local_34 = (uint)(local_34 == 0);
    }
    local_30 = (uint)(*param_2 == '-');
    if ((local_2c == 0) && (local_30 == 0)) {
      sVar3 = _strlen(param_1);
      iVar2 = (int)sVar3;
      sVar3 = _strlen(param_2);
      iVar4 = (int)sVar3;
      ___memset_chk(param_3,0x30,(long)(iVar2 + iVar4),0xffffffffffffffff);
      param_3[iVar2 + iVar4] = '\0';
      local_2c = iVar2;
      while (local_2c = local_2c + -1, -1 < (int)local_2c) {
        local_30 = iVar4 + -1;
        local_34 = local_2c + local_30 + 1;
        local_3c = 0;
        for (; -1 < (int)local_30; local_30 = local_30 + -1) {
          iVar1 = (param_1[(int)local_2c] + -0x30) * (param_2[(int)local_30] + -0x30) +
                  param_3[(int)local_34] + -0x30 + local_3c;
          local_3c = iVar1 / 10;
          param_3[(int)local_34] = (char)iVar1 + (char)(iVar1 / 10) * -10 + '0';
          local_34 = local_34 + -1;
        }
        param_3[(int)local_34] = param_3[(int)local_34] + (char)local_3c;
      }
      if (*param_3 == '0') {
        ___memmove_chk(param_3,param_3 + 1,(long)(iVar2 + iVar4),0xffffffffffffffff);
      }
    }
    else {
      if (local_34 != 0) {
        *param_3 = '-';
      }
      _longmulti(param_1 + (int)local_2c,param_2 + (int)local_30,param_3 + (int)local_34);
    }
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004018;
  _longmulti("-18446744073709551616");
  iVar1 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004018 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___memmove_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memmove_chk_100004000)();
  return;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct bit_array_tag {
    uint32_t size;
    uint32_t* array;
} bit_array;

bool bit_array_create(bit_array* b, uint32_t size) {
    uint32_t* array = calloc((size + 31)/32, sizeof(uint32_t));
    if (array == NULL)
        return false;
    b->size = size;
    b->array = array;
    return true;
}

void bit_array_destroy(bit_array* b) {
    free(b->array);
    b->array = NULL;
}

void bit_array_set(bit_array* b, uint32_t index, bool value) {
    assert(index < b->size);
    uint32_t* p = &b->array[index >> 5];
    uint32_t bit = 1 << (index & 31);
    if (value)
        *p |= bit;
    else
        *p &= ~bit;
}

bool bit_array_get(const bit_array* b, uint32_t index) {
    assert(index < b->size);
    uint32_t bit = 1 << (index & 31);
    return (b->array[index >> 5] & bit) != 0;
}

typedef struct sieve_tag {
    uint32_t limit;
    bit_array not_prime;
} sieve;

bool sieve_create(sieve* s, uint32_t limit) {
    if (!bit_array_create(&s->not_prime, limit + 1))
        return false;
    bit_array_set(&s->not_prime, 0, true);
    bit_array_set(&s->not_prime, 1, true);
    for (uint32_t p = 2; p * p <= limit; ++p) {
        if (bit_array_get(&s->not_prime, p) == false) {
            for (uint32_t q = p * p; q <= limit; q += p)
                bit_array_set(&s->not_prime, q, true);
        }
    }
    s->limit = limit;
    return true;
}

void sieve_destroy(sieve* s) {
    bit_array_destroy(&s->not_prime);
}

bool is_prime(const sieve* s, uint32_t n) {
    assert(n <= s->limit);
    return bit_array_get(&s->not_prime, n) == false;
}

bool find_prime_partition(const sieve* s, uint32_t number, uint32_t count,
                          uint32_t min_prime, uint32_t* p) {
    if (count == 1) {
        if (number >= min_prime && is_prime(s, number)) {
            *p = number;
            return true;
        }
        return false;
    }
    for (uint32_t prime = min_prime; prime < number; ++prime) {
        if (!is_prime(s, prime))
            continue;
        if (find_prime_partition(s, number - prime, count - 1,
                                 prime + 1, p + 1)) {
            *p = prime;
            return true;
        }
    }
    return false;
}

void print_prime_partition(const sieve* s, uint32_t number, uint32_t count) {
    assert(count > 0);
    uint32_t* primes = malloc(count * sizeof(uint32_t));
    if (primes == NULL) {
        fprintf(stderr, "Out of memory\n");
        return;
    }
    if (!find_prime_partition(s, number, count, 2, primes)) {
        printf("%u cannot be partitioned into %u primes.\n", number, count);
    } else {
        printf("%u = %u", number, primes[0]);
        for (uint32_t i = 1; i < count; ++i)
            printf(" + %u", primes[i]);
        printf("\n");
    }
    free(primes);
}

int main() {
    const uint32_t limit = 100000;
    sieve s = { 0 };
    if (!sieve_create(&s, limit)) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    print_prime_partition(&s, 99809, 1);
    print_prime_partition(&s, 18, 2);
    print_prime_partition(&s, 19, 3);
    print_prime_partition(&s, 20, 4);
    print_prime_partition(&s, 2017, 24);
    print_prime_partition(&s, 22699, 1);
    print_prime_partition(&s, 22699, 2);
    print_prime_partition(&s, 22699, 3);
    print_prime_partition(&s, 22699, 4);
    print_prime_partition(&s, 40355, 3);
    sieve_destroy(&s);
    return 0;
}
`,`#include "partition-an-integer-x-into-n-primes.h"



bool _bit_array_create(int *param_1,int param_2)

{
  void *pvVar1;
  
  pvVar1 = _calloc((ulong)((param_2 + 0x1fU) / 0x20),4);
  if (pvVar1 != (void *)0x0) {
    *param_1 = param_2;
    *(void **)(param_1 + 2) = pvVar1;
  }
  return pvVar1 != (void *)0x0;
}



void _bit_array_destroy(long param_1)

{
  _free(*(void **)(param_1 + 8));
  *(undefined8 *)(param_1 + 8) = 0;
  return;
}



void _bit_array_set(uint *param_1,uint param_2,byte param_3)

{
  uint *puVar1;
  uint uVar2;
  
  if (*param_1 <= param_2) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("bit_array_set","partition-an-integer-x-into-n-primes.c",0x1b,"index < b->size");
  }
  puVar1 = (uint *)(*(long *)(param_1 + 2) + (ulong)(param_2 >> 5) * 4);
  uVar2 = 1 << (ulong)(param_2 & 0x1f);
  if ((param_3 & 1) == 0) {
    *puVar1 = *puVar1 & (uVar2 ^ 0xffffffff);
  }
  else {
    *puVar1 = *puVar1 | uVar2;
  }
  return;
}



bool _bit_array_get(uint *param_1,uint param_2)

{
  if (*param_1 <= param_2) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("bit_array_get","partition-an-integer-x-into-n-primes.c",0x25,"index < b->size");
  }
  return (*(uint *)(*(long *)(param_1 + 2) + (ulong)(param_2 >> 5) * 4) &
         1 << (ulong)(param_2 & 0x1f)) != 0;
}



undefined _sieve_create(uint *param_1,uint param_2)

{
  ulong uVar1;
  uint local_2c;
  int local_28;
  undefined local_11;
  
  uVar1 = _bit_array_create(param_1 + 2,param_2 + 1);
  if ((uVar1 & 1) == 0) {
    local_11 = 0;
  }
  else {
    _bit_array_set(param_1 + 2,0,1);
    _bit_array_set(param_1 + 2,1,1);
    for (local_28 = 2; (uint)(local_28 * local_28) <= param_2; local_28 = local_28 + 1) {
      uVar1 = _bit_array_get(param_1 + 2,local_28);
      if ((uVar1 & 1) == 0) {
        for (local_2c = local_28 * local_28; local_2c <= param_2; local_2c = local_2c + local_28) {
          _bit_array_set(param_1 + 2,local_2c,1);
        }
      }
    }
    *param_1 = param_2;
    local_11 = 1;
  }
  return local_11;
}



void _sieve_destroy(long param_1)

{
  _bit_array_destroy(param_1 + 8);
  return;
}



bool _is_prime(uint *param_1,uint param_2)

{
  ulong uVar1;
  
  if (*param_1 < param_2) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("is_prime","partition-an-integer-x-into-n-primes.c",0x43,"n <= s->limit");
  }
  uVar1 = _bit_array_get(param_1 + 2,param_2);
  return (uVar1 & 1) == 0;
}



undefined _find_prime_partition
                    (undefined8 param_1,uint param_2,int param_3,uint param_4,uint *param_5)

{
  ulong uVar1;
  uint local_3c;
  undefined local_11;
  
  local_3c = param_4;
  if (param_3 == 1) {
    if ((param_2 < param_4) || (uVar1 = _is_prime(param_1,param_2), (uVar1 & 1) == 0)) {
      local_11 = 0;
    }
    else {
      *param_5 = param_2;
      local_11 = 1;
    }
  }
  else {
    for (; local_3c < param_2; local_3c = local_3c + 1) {
      uVar1 = _is_prime(param_1,local_3c);
      if (((uVar1 & 1) != 0) &&
         (uVar1 = _find_prime_partition
                            (param_1,param_2 - local_3c,param_3 + -1,local_3c + 1,param_5 + 1),
         (uVar1 & 1) != 0)) {
        *param_5 = local_3c;
        return 1;
      }
    }
    local_11 = 0;
  }
  return local_11;
}



void _print_prime_partition(undefined8 param_1,undefined4 param_2,uint param_3)

{
  void *pvVar1;
  ulong uVar2;
  uint local_2c;
  
  if (param_3 == 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("print_prime_partition","partition-an-integer-x-into-n-primes.c",0x5d,"count > 0")
    ;
  }
  pvVar1 = _malloc((ulong)param_3 << 2);
  if (pvVar1 == (void *)0x0) {
    _fprintf(*(FILE **)PTR____stderrp_100004008,"Out of memory\n");
  }
  else {
    uVar2 = _find_prime_partition(param_1,param_2,param_3,2,pvVar1);
    if ((uVar2 & 1) == 0) {
      _printf("%u cannot be partitioned into %u primes.\n");
    }
    else {
      _printf("%u = %u");
      for (local_2c = 1; local_2c < param_3; local_2c = local_2c + 1) {
        _printf(" + %u");
      }
      _printf("\n");
    }
    _free(pvVar1);
  }
  return;
}



bool entry(void)

{
  bool bVar1;
  ulong uVar2;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_18 = 100000;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  uVar2 = _sieve_create(&local_30);
  bVar1 = (uVar2 & 1) != 0;
  if (bVar1) {
    _print_prime_partition(&local_30,0x185e1);
    _print_prime_partition(&local_30,0x12);
    _print_prime_partition(&local_30,0x13);
    _print_prime_partition(&local_30,0x14);
    _print_prime_partition(&local_30,0x7e1,0x18);
    _print_prime_partition(&local_30,0x58ab,1);
    _print_prime_partition(&local_30,0x58ab,2);
    _print_prime_partition(&local_30,0x58ab,3);
    _print_prime_partition(&local_30,0x58ab,4);
    _print_prime_partition(&local_30,0x9da3,3);
    _sieve_destroy(&local_30);
  }
  else {
    _fprintf(*(FILE **)PTR____stderrp_100004008,"Out of memory\n");
  }
  return !bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <float.h>

double pow_ (double x, int e) {
    int i;
    double r = 1;
    for (i = 0; i < e; i++) {
        r *= x;
    }
    return r;
}

double root (int n, double x) {
    double d, r = 1;
    if (!x) {
        return 0;
    }
    if (n < 1 || (x < 0 && !(n&1))) {
        return 0.0 / 0.0; /* NaN */
    }
    do {
        d = (x / pow_(r, n - 1) - r) / n;
        r += d;
    }
    while (d >= DBL_EPSILON * 10 || d <= -DBL_EPSILON * 10);
    return r;
}

int main () {
    int n = 15;
    double x = pow_(-3.14159, 15);
    printf("root(%d, %g) = %g\n", n, x, root(n, x));
    return 0;
}
`,`#include "nth-root.h"



undefined  [16] _pow_(double param_1,int param_2)

{
  undefined auVar1 [16];
  undefined8 local_18;
  undefined4 local_10;
  
  local_18 = 1.0;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    local_18 = local_18 * param_1;
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_18;
  return auVar1;
}



undefined  [16] _root(double param_1,uint param_2)

{
  double dVar1;
  undefined auVar2 [16];
  double local_38;
  double local_18;
  
  local_38 = 1.0;
  if (param_1 == 0.0) {
    local_18 = 0.0;
  }
  else if (((int)param_2 < 1) || ((param_1 < 0.0 && ((param_2 & 1) == 0)))) {
    local_18 = NAN;
  }
  else {
    do {
      dVar1 = (double)_pow_(local_38,param_2 - 1);
      dVar1 = (param_1 / dVar1 - local_38) / (double)(long)(int)param_2;
      local_38 = local_38 + dVar1;
      local_18 = local_38;
    } while (2.220446049250313e-15 <= dVar1 || dVar1 <= -2.220446049250313e-15);
  }
  auVar2._8_8_ = 0;
  auVar2._0_8_ = local_18;
  return auVar2;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  
  uVar1 = _pow_(0xc00921f9f01b866e);
  _root(uVar1,0xf);
  _printf("root(%d, %g) = %g\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct object *BaseObj;
typedef struct sclass *Class;
typedef void (*CloneFctn)(BaseObj s, BaseObj clo);
typedef const char * (*SpeakFctn)(BaseObj s);
typedef void (*DestroyFctn)(BaseObj s);

typedef struct sclass {
    size_t csize;		/* size of the class instance */
    const char  *cname;		/* name of the class */
    Class  parent;		/* parent class */

    CloneFctn clone;		/* clone function */
    SpeakFctn speak;		/* speak function */
    DestroyFctn del;		/* delete the object */
} sClass;

typedef struct object {
    Class class;
} SObject;

static
BaseObj obj_copy( BaseObj s, Class c )
{
    BaseObj clo;
    if (c->parent)
        clo = obj_copy( s, c->parent);
    else
        clo = malloc( s->class->csize );

    if (clo)
        c->clone( s, clo );
    return clo;
}

static
void obj_del( BaseObj s, Class c )
{
    if (c->del)
        c->del(s);
    if (c->parent)
        obj_del( s, c->parent);
    else
        free(s);
}

BaseObj ObjClone( BaseObj s )
{ return obj_copy( s, s->class ); }

const char * ObjSpeak( BaseObj s )
{
    return s->class->speak(s);
}

void ObjDestroy( BaseObj s )
{ if (s) obj_del( s, s->class ); }

/* * * * * * */
static
void baseClone( BaseObj s, BaseObj clone)
{
    clone->class = s->class;
}

static
const char *baseSpeak(BaseObj s)
{
    return "Hello, I'm base object";
}

sClass boc = { sizeof(SObject), "BaseObj", NULL,
    &baseClone, &baseSpeak, NULL };
Class BaseObjClass = &boc;

/* * * * * * */
/* Dog - a derived class */

typedef struct sDogPart {
    double weight;
    char color[32];
    char name[24];
} DogPart;

typedef struct sDog *Dog;

struct sDog {
    Class   class;		// parent structure
    DogPart dog;
};

static
void dogClone( BaseObj s, BaseObj c)
{
    Dog src = (Dog)s;
    Dog clone = (Dog)c;
    clone->dog = src->dog;	/* no pointers so strncpys not needed */
}

static
const char *dogSpeak( BaseObj s)
{
    Dog d = (Dog)s;
    static char  response[90];
    sprintf(response, "woof! woof! My name is %s. I'm a %s %s",
            d->dog.name, d->dog.color, d->class->cname);
    return response;
}


sClass dogc = { sizeof(struct sDog), "Dog", &boc,
    &dogClone, &dogSpeak, NULL };
Class DogClass = &dogc;

BaseObj NewDog( const char *name, const char *color, double weight )
{
    Dog dog = malloc(DogClass->csize);
    if (dog) {
        DogPart *dogp = &dog->dog;
        dog->class = DogClass;
        dogp->weight = weight;
        strncpy(dogp->name, name, 23);
        strncpy(dogp->color, color, 31);
    }
    return (BaseObj)dog;
}

/* * * * * * * * * */
/* Ferret - a derived class */

typedef struct sFerretPart {
    char color[32];
    char name[24];
    int  age;
} FerretPart;

typedef struct sFerret *Ferret;

struct sFerret {
    Class   class;		// parent structure
    FerretPart ferret;
};

static
void ferretClone( BaseObj s, BaseObj c)
{
    Ferret src = (Ferret)s;
    Ferret clone = (Ferret)c;
    clone->ferret = src->ferret;  /* no pointers so strncpys not needed */
}

static
const char *ferretSpeak(BaseObj s)
{
    Ferret f = (Ferret)s;
    static char  response[90];
    sprintf(response, "My name is %s. I'm a %d mo. old %s wiley %s",
            f->ferret.name, f->ferret.age, f->ferret.color,
            f->class->cname);
    return response;
}

sClass ferretc = { sizeof(struct sFerret), "Ferret", &boc,
    &ferretClone, &ferretSpeak, NULL };
Class FerretClass = &ferretc;

BaseObj NewFerret( const char *name, const char *color, int age )
{
    Ferret ferret = malloc(FerretClass->csize);
    if (ferret) {
        FerretPart *ferretp = &(ferret->ferret);
        ferret->class = FerretClass;
        strncpy(ferretp->name, name, 23);
        strncpy(ferretp->color, color, 31);
        ferretp->age = age;
    }
    return (BaseObj)ferret;
}

/* * Now you really understand why Bjarne created C++ * */

int main()
{
    BaseObj  o1;
    BaseObj  kara = NewFerret( "Kara", "grey", 15 );
    BaseObj  bruce = NewDog("Bruce", "yellow", 85.0 );
    printf("Ok created things\n");

    o1 = ObjClone(kara );
    printf("Karol says %s\n", ObjSpeak(o1));
    printf("Kara says %s\n", ObjSpeak(kara));
    ObjDestroy(o1);

    o1 = ObjClone(bruce );
    strncpy(((Dog)o1)->dog.name, "Donald", 23);
    printf("Don says %s\n", ObjSpeak(o1));
    printf("Bruce says %s\n", ObjSpeak(bruce));
    ObjDestroy(o1);
    return 0;
}
`,`#include "polymorphic-copy.h"



void _ObjClone(undefined8 *param_1)

{
  FUN_10000389c(param_1,*param_1);
  return;
}



void * FUN_10000389c(undefined8 *param_1,long param_2)

{
  undefined8 local_28;
  
  if (*(long *)(param_2 + 0x10) == 0) {
    local_28 = _malloc(*(size_t *)*param_1);
  }
  else {
    local_28 = (void *)FUN_10000389c(param_1,*(undefined8 *)(param_2 + 0x10));
  }
  if (local_28 != (void *)0x0) {
    (**(code **)(param_2 + 0x18))(param_1,local_28);
  }
  return local_28;
}



void _ObjSpeak(long *param_1)

{
  (**(code **)(*param_1 + 0x20))(param_1);
  return;
}



void _ObjDestroy(undefined8 *param_1)

{
  if (param_1 != (undefined8 *)0x0) {
    FUN_1000039a8(param_1,*param_1);
  }
  return;
}



void FUN_1000039a8(void *param_1,long param_2)

{
  if (*(long *)(param_2 + 0x28) != 0) {
    (**(code **)(param_2 + 0x28))(param_1);
  }
  if (*(long *)(param_2 + 0x10) == 0) {
    _free(param_1);
  }
  else {
    FUN_1000039a8(param_1,*(undefined8 *)(param_2 + 0x10));
  }
  return;
}



void FUN_100003a2c(undefined8 *param_1,undefined8 *param_2)

{
  *param_2 = *param_1;
  return;
}



char * FUN_100003a50(void)

{
  return "Hello, I\'m base object";
}



void FUN_100003a68(long param_1,long param_2)

{
  _memcpy((void *)(param_2 + 8),(void *)(param_1 + 8),0x40);
  return;
}



undefined * FUN_100003ab0(void)

{
  ___sprintf_chk(&DAT_1000080a8,0,0x5a,"woof! woof! My name is %s. I\'m a %s %s");
  return &DAT_1000080a8;
}



undefined8 * _NewDog(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(*(size_t *)_DogClass);
  if (puVar1 != (undefined8 *)0x0) {
    *puVar1 = _DogClass;
    puVar1[1] = param_1;
    ___strncpy_chk(puVar1 + 6,param_2,0x17,0xffffffffffffffff);
    ___strncpy_chk(puVar1 + 2,param_3,0x1f,0x20);
  }
  return puVar1;
}



void FUN_100003bd0(long param_1,long param_2)

{
  _memcpy((void *)(param_2 + 8),(void *)(param_1 + 8),0x3c);
  return;
}



undefined * FUN_100003c18(void)

{
  ___sprintf_chk(&DAT_100008102,0,0x5a,"My name is %s. I\'m a %d mo. old %s wiley %s");
  return &DAT_100008102;
}



undefined8 * _NewFerret(undefined8 param_1,undefined8 param_2,undefined4 param_3)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(*(size_t *)_FerretClass);
  if (puVar1 != (undefined8 *)0x0) {
    *puVar1 = _FerretClass;
    ___strncpy_chk(puVar1 + 5,param_1,0x17,0x18);
    ___strncpy_chk(puVar1 + 1,param_2,0x1f,0x20);
    *(undefined4 *)(puVar1 + 8) = param_3;
  }
  return puVar1;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  long lVar4;
  
  uVar1 = _NewFerret("Kara","grey",0xf);
  uVar2 = _NewDog(0x4055400000000000,"Bruce","yellow");
  _printf("Ok created things\n");
  uVar3 = _ObjClone(uVar1);
  _ObjSpeak(uVar3);
  _printf("Karol says %s\n");
  _ObjSpeak(uVar1);
  _printf("Kara says %s\n");
  _ObjDestroy(uVar3);
  lVar4 = _ObjClone(uVar2);
  ___strncpy_chk(lVar4 + 0x30,"Donald",0x17,0xffffffffffffffff);
  _ObjSpeak(lVar4);
  _printf("Don says %s\n");
  _ObjSpeak(uVar2);
  _printf("Bruce says %s\n");
  _ObjDestroy(lVar4);
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___strncpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strncpy_chk_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
  struct tm ts;
  time_t t;
  const char *d = "March 7 2009 7:30pm EST";

  strptime(d, "%B %d %Y %I:%M%p %Z", &ts);
  /* ts.tm_hour += 12; instead of t += 12*60*60
     works too. */
  t = mktime(&ts);
  t += 12*60*60;
  printf("%s", ctime(&t));

  return EXIT_SUCCESS;
}
`,`#include "date-manipulation-1.h"



undefined4 entry(void)

{
  time_t tVar1;
  long local_58;
  tm tStack_50;
  undefined4 local_14;
  
  local_14 = 0;
  _strptime("March 7 2009 7:30pm EST","%B %d %Y %I:%M%p %Z",&tStack_50);
  tVar1 = _mktime(&tStack_50);
  local_58 = tVar1 + 0xa8c0;
  _ctime(&local_58);
  _printf("%s");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _ctime(time_t *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__ctime_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _mktime(tm *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__mktime_100004008)();
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strptime(char *param_1,char *param_2,tm *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strptime_100004018)();
  return pcVar1;
}


`
`#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

struct Pair {
    uint64_t v1, v2;
};

struct Pair makePair(uint64_t a, uint64_t b) {
    struct Pair r;
    r.v1 = a;
    r.v2 = b;
    return r;
}

struct Pair solvePell(int n) {
    int x = (int) sqrt(n);

    if (x * x == n) {
        // n is a perfect square - no solution other than 1,0
        return makePair(1, 0);
    } else {
        // there are non-trivial solutions
        int y = x;
        int z = 1;
        int r = 2 * x;
        struct Pair e = makePair(1, 0);
        struct Pair f = makePair(0, 1);
        uint64_t a = 0;
        uint64_t b = 0;

        while (true) {
            y = r * z - y;
            z = (n - y * y) / z;
            r = (x + y) / z;
            e = makePair(e.v2, r * e.v2 + e.v1);
            f = makePair(f.v2, r * f.v2 + f.v1);
            a = e.v2 + x * f.v2;
            b = f.v2;
            if (a * a - n * b * b == 1) {
                break;
            }
        }

        return makePair(a, b);
    }
}

void test(int n) {
    struct Pair r = solvePell(n);
    printf("x^2 - %3d * y^2 = 1 for x = %21llu and y = %21llu\n", n, r.v1, r.v2);
}

int main() {
    test(61);
    test(109);
    test(181);
    test(277);

    return 0;
}
`,`#include "pells-equation.h"



undefined  [16] _makePair(undefined8 param_1,undefined8 param_2)

{
  undefined auVar1 [16];
  
  auVar1._8_8_ = param_2;
  auVar1._0_8_ = param_1;
  return auVar1;
}



undefined  [16] _solvePell(int param_1)

{
  long lVar1;
  int iVar2;
  long lVar3;
  int iVar4;
  undefined auVar5 [16];
  undefined auVar6 [16];
  long local_60;
  long lStack_58;
  long local_50;
  long lStack_48;
  int local_34;
  int local_30;
  int local_2c;
  
  iVar4 = (int)SQRT((double)(long)param_1);
  if (iVar4 * iVar4 == param_1) {
    auVar5 = _makePair(1,0);
  }
  else {
    local_30 = 1;
    local_34 = iVar4 * 2;
    auVar5 = _makePair();
    auVar6 = _makePair(0,1);
    local_2c = iVar4;
    do {
      lStack_58 = auVar6._8_8_;
      local_60 = auVar6._0_8_;
      lStack_48 = auVar5._8_8_;
      local_50 = auVar5._0_8_;
      local_2c = local_34 * local_30 - local_2c;
      iVar2 = 0;
      if (local_30 != 0) {
        iVar2 = (param_1 - local_2c * local_2c) / local_30;
      }
      local_34 = 0;
      if (iVar2 != 0) {
        local_34 = (iVar4 + local_2c) / iVar2;
      }
      auVar5 = _makePair(lStack_48,local_34 * lStack_48 + local_50);
      auVar6 = _makePair(lStack_58,local_34 * lStack_58 + local_60);
      lVar3 = auVar6._8_8_;
      lVar1 = auVar5._8_8_ + iVar4 * lVar3;
      local_30 = iVar2;
    } while (lVar1 * lVar1 - param_1 * lVar3 * lVar3 != 1);
    auVar5 = _makePair(lVar1,lVar3);
  }
  return auVar5;
}



int _test(undefined4 param_1)

{
  int iVar1;
  
  _solvePell(param_1);
  iVar1 = _printf("x^2 - %3d * y^2 = 1 for x = %21llu and y = %21llu\n");
  return iVar1;
}



undefined4 entry(void)

{
  _test(0x3d);
  _test(0x6d);
  _test(0xb5);
  _test(0x115);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int interactiveCompare(const void *x1, const void *x2)
{
  const char *s1 = *(const char * const *)x1;
  const char *s2 = *(const char * const *)x2;
  static int count = 0;
  printf("(%d) Is %s <, ==, or > %s? Answer -1, 0, or 1: ", ++count, s1, s2);
  int response;
  scanf("%d", &response);
  return response;
}

void printOrder(const char *items[], int len)
{
  printf("{ ");
  for (int i = 0; i < len; ++i) printf("%s ", items[i]);
  printf("}\n");
}

int main(void)
{
  const char *items[] =
    {
      "violet", "red", "green", "indigo", "blue", "yellow", "orange"
    };

  qsort(items, sizeof(items)/sizeof(*items), sizeof(*items), interactiveCompare);
  printOrder(items, sizeof(items)/sizeof(*items));
  return 0;
}
`,`#include "order-by-pair-comparisons.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 _interactiveCompare(void)

{
  undefined4 local_34;
  
  _DAT_100008000 = _DAT_100008000 + 1;
  _printf("(%d) Is %s <, ==, or > %s? Answer -1, 0, or 1: ");
  _scanf("%d");
  return local_34;
}



int _printOrder(undefined8 param_1,int param_2)

{
  int iVar1;
  int local_20;
  
  _printf("{ ");
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    _printf("%s ");
  }
  iVar1 = _printf("}\n");
  return iVar1;
}



undefined8 entry(void)

{
  undefined auStack_50 [56];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_50,&PTR_s_violet_100004030,0x38);
  _qsort(auStack_50,7,8,(int *)_interactiveCompare);
  _printOrder(auStack_50,7);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void transpose(double *m, int w, int h)
{
	int start, next, i;
	double tmp;

	for (start = 0; start <= w * h - 1; start++) {
		next = start;
		i = 0;
		do {	i++;
			next = (next % h) * w + next / h;
		} while (next > start);
		if (next < start || i == 1) continue;

		tmp = m[next = start];
		do {
			i = (next % h) * w + next / h;
			m[next] = (i == start) ? tmp : m[i];
			next = i;
		} while (next > start);
	}
}

void show_matrix(double *m, int w, int h)
{
	int i, j;
	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++)
			printf("%2g ", m[i * w + j]);
		putchar('\n');
	}
}

int main(void)
{
	int i;
	double m[15];
	for (i = 0; i < 15; i++) m[i] = i + 1;

	puts("before transpose:");
	show_matrix(m, 3, 5);

	transpose(m, 3, 5);

	puts("\nafter transpose:");
	show_matrix(m, 5, 3);

	return 0;
}
`,`#include "matrix-transposition-2.h"



void _transpose(long param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  undefined8 local_30;
  int local_1c;
  int local_18;
  int local_14;
  
  for (local_14 = 0; local_14 <= param_2 * param_3 + -1; local_14 = local_14 + 1) {
    local_18 = local_14;
    local_1c = 0;
    do {
      local_1c = local_1c + 1;
      iVar1 = 0;
      if (param_3 != 0) {
        iVar1 = local_18 / param_3;
      }
      iVar2 = 0;
      if (param_3 != 0) {
        iVar2 = local_18 / param_3;
      }
      local_18 = (local_18 - iVar1 * param_3) * param_2 + iVar2;
    } while (local_14 < local_18);
    if ((local_14 <= local_18) && (local_1c != 1)) {
      local_18 = local_14;
      uVar3 = *(undefined8 *)(param_1 + (long)local_14 * 8);
      do {
        iVar1 = 0;
        if (param_3 != 0) {
          iVar1 = local_18 / param_3;
        }
        iVar2 = 0;
        if (param_3 != 0) {
          iVar2 = local_18 / param_3;
        }
        iVar2 = (local_18 - iVar1 * param_3) * param_2 + iVar2;
        local_30 = uVar3;
        if (iVar2 != local_14) {
          local_30 = *(undefined8 *)(param_1 + (long)iVar2 * 8);
        }
        *(undefined8 *)(param_1 + (long)local_18 * 8) = local_30;
        local_18 = iVar2;
      } while (local_14 < iVar2);
    }
  }
  return;
}



ulong _show_matrix(ulong param_1,int param_2,int param_3)

{
  uint uVar1;
  int local_28;
  int local_24;
  
  for (local_24 = 0; local_24 < param_3; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < param_2; local_28 = local_28 + 1) {
      _printf("%2g ");
    }
    uVar1 = _putchar(10);
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined8 entry(void)

{
  int local_98;
  double adStack_90 [15];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_98 = 0; local_98 < 0xf; local_98 = local_98 + 1) {
    adStack_90[local_98] = (double)(local_98 + 1);
  }
  _puts("before transpose:");
  _show_matrix();
  _transpose(adStack_90,3,5);
  _puts("\nafter transpose:");
  _show_matrix(adStack_90,5,3);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

/* returns 0 if no match, 1 if matched, -1 if matched and at end */
int s_cmp(const char *a, const char *b)
{
        char c1 = 0, c2 = 0;
        while (c1 == c2) {
                c1 = *(a++);
                if ('\0' == (c2 = *(b++)))
                        return c1 == '\0' ? -1 : 1;
        }
        return 0;
}

/* returns times matched */
int s_match(const char *a, const char *b)
{
        int i = 0, count = 0;
        printf("matching %s' with %s':\n", a, b);

        while (a[i] != '\0') {
                switch (s_cmp(a + i, b)) {
                case -1:
                        printf("matched: pos %d (at end)\n\n", i);
                        return ++count;
                case 1:
                        printf("matched: pos %d\n", i);
                        ++count;
                        break;
                }
                i++;
        }
        printf("end match\n\n");
        return count;
}

int main()
{
        s_match("A Short String", "ort S");
        s_match("aBaBaBaBa", "aBa");
        s_match("something random", "Rand");

        return 0;
}
`,`#include "string-matching-2.h"



undefined4 _s_cmp(char *param_1,char *param_2)

{
  char local_1a;
  char local_19;
  char *local_18;
  char *local_10;
  undefined4 local_4;
  
  local_19 = '\0';
  local_1a = '\0';
  local_18 = param_2;
  local_10 = param_1;
  do {
    if (local_19 != local_1a) {
      return 0;
    }
    local_19 = *local_10;
    local_1a = *local_18;
    local_18 = local_18 + 1;
    local_10 = local_10 + 1;
  } while (local_1a != '\0');
  local_4 = 1;
  if (local_19 == '\0') {
    local_4 = 0xffffffff;
  }
  return local_4;
}



int _s_match(long param_1,undefined8 param_2)

{
  int iVar1;
  int local_30;
  int local_2c;
  
  local_2c = 0;
  local_30 = 0;
  _printf("matching %s\' with %s\':\n");
  while( true ) {
    if (*(char *)(param_1 + local_2c) == '\0') {
      _printf("end match\n\n");
      return local_30;
    }
    iVar1 = _s_cmp(param_1 + local_2c,param_2);
    if (iVar1 == -1) break;
    if (iVar1 == 1) {
      _printf("matched: pos %d\n");
      local_30 = local_30 + 1;
    }
    local_2c = local_2c + 1;
  }
  _printf("matched: pos %d (at end)\n\n");
  return local_30 + 1;
}



undefined4 entry(void)

{
  _s_match("A Short String","ort S");
  _s_match("aBaBaBaBa","aBa");
  _s_match("something random","Rand");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

#define MAXLEN 100 //maximum string length

int makehist(unsigned char *S,int *hist,int len){
	int wherechar[256];
	int i,histlen;
	histlen=0;
	for(i=0;i<256;i++)wherechar[i]=-1;
	for(i=0;i<len;i++){
		if(wherechar[(int)S[i]]==-1){
			wherechar[(int)S[i]]=histlen;
			histlen++;
		}
		hist[wherechar[(int)S[i]]]++;
	}
	return histlen;
}

double entropy(int *hist,int histlen,int len){
	int i;
	double H;
	H=0;
	for(i=0;i<histlen;i++){
		H-=(double)hist[i]/len*log2((double)hist[i]/len);
	}
	return H;
}

int main(void){
	unsigned char S[MAXLEN];
	int len,*hist,histlen;
	double H;
	scanf("%[^\n]",S);
	len=strlen(S);
	hist=(int*)calloc(len,sizeof(int));
	histlen=makehist(S,hist,len);
	//hist now has no order (known to the program) but that doesn't matter
	H=entropy(hist,histlen,len);
	printf("%lf\n",H);
	return 0;
}
`,`#include "entropy-1.h"



int _makehist(long param_1,long param_2,int param_3)

{
  int *piVar1;
  int local_444;
  int local_440;
  int aiStack_428 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_444 = 0;
  for (local_440 = 0; local_440 < 0x100; local_440 = local_440 + 1) {
    aiStack_428[local_440] = -1;
  }
  for (local_440 = 0; local_440 < param_3; local_440 = local_440 + 1) {
    if (aiStack_428[(int)(uint)*(byte *)(param_1 + local_440)] == -1) {
      aiStack_428[(int)(uint)*(byte *)(param_1 + local_440)] = local_444;
      local_444 = local_444 + 1;
    }
    piVar1 = (int *)(param_2 + (long)aiStack_428[(int)(uint)*(byte *)(param_1 + local_440)] * 4);
    *piVar1 = *piVar1 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_444;
}



undefined  [16] _entropy(long param_1,int param_2,int param_3)

{
  undefined8 uVar1;
  undefined auVar2 [16];
  int iVar3;
  undefined8 local_30;
  undefined4 local_24;
  
  local_30 = 0;
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    iVar3 = *(int *)(param_1 + (long)local_24 * 4);
    uVar1 = _log2((double)(long)*(int *)(param_1 + (long)local_24 * 4) / (double)(long)param_3);
    local_30 = NEON_fmsub((double)(long)iVar3 / (double)(long)param_3,uVar1,local_30);
  }
  auVar2._8_8_ = 0;
  auVar2._0_8_ = local_30;
  return auVar2;
}



undefined8 entry(void)

{
  undefined4 uVar1;
  int iVar2;
  size_t sVar3;
  void *pvVar4;
  char acStack_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _scanf("%[^\n]");
  sVar3 = _strlen(acStack_7c);
  pvVar4 = _calloc((long)(int)sVar3,4);
  uVar1 = _makehist(acStack_7c,pvVar4,sVar3 & 0xffffffff);
  _entropy(pvVar4,uVar1,sVar3 & 0xffffffff);
  iVar2 = _printf("%lf\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



void _log2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log2_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <stdio.h>
#include <wchar.h>

int main(void)
{
   wchar_t *s = L"\x304A\x306F\x3088\x3046"; /* Japanese hiragana ohayou */
   size_t length;

   length = wcslen(s);
   printf("Length in characters = %d\n", length);
   printf("Length in bytes      = %d\n", sizeof(s) * sizeof(wchar_t));

   return 0;
}
`,`#include "string-length-4.h"



undefined4 entry(void)

{
  _wcslen(L"おはよう");
  _printf("Length in characters = %d\n");
  _printf("Length in bytes      = %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _wcslen(wchar_t *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__wcslen_100004008)();
  return sVar1;
}


`
`#include <stdio.h>

char trans[] = "___#_##_";

int evolve(char c[], int len)
{
	int i, diff = 0;
#	define v(i) ((c[i] & 15) == 1)
#	define each for (i = 0; i < len; i++)

	each c[i]  = (c[i] == '#');
	each c[i] |= (trans[(v(i-1)*4 + v(i)*2 + v(i+1))] == '#') << 4;
	each diff += (c[i] & 0xf) ^ (c[i] >> 4);
	each c[i]  = (c[i] >> 4) ? '#' : '_';

#	undef each
#	undef v
	return diff;
}

int main()
{
	char c[] = "_###_##_#_#_#_#__#__\n";

	do { printf(c + 1); } while (evolve(c + 1, sizeof(c) - 3));
	return 0;
}
`,`#include "one-dimensional-cellular-automata-2.h"



int _evolve(long param_1,int param_2)

{
  undefined uVar1;
  int local_14;
  int local_10;
  
  local_14 = 0;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    *(bool *)(param_1 + local_10) = *(char *)(param_1 + local_10) == '#';
  }
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    *(byte *)(param_1 + local_10) =
         *(byte *)(param_1 + local_10) |
         (_trans[(int)((uint)((*(byte *)(param_1 + local_10) & 0xf) == 1) * 2 +
                       (uint)((*(byte *)(param_1 + (local_10 + -1)) & 0xf) == 1) * 4 +
                      (uint)((*(byte *)(param_1 + (local_10 + 1)) & 0xf) == 1))] == '#') << 4;
  }
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    local_14 = local_14 +
               ((int)*(char *)(param_1 + local_10) & 0xfU ^ (int)*(char *)(param_1 + local_10) >> 4)
    ;
  }
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    uVar1 = 0x23;
    if (*(char *)(param_1 + local_10) >> 4 == '\0') {
      uVar1 = 0x5f;
    }
    *(undefined *)(param_1 + local_10) = uVar1;
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  char local_30 [24];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  builtin_strncpy(local_30,"_###_##_#_#_#_#__#__\n",0x16);
  do {
    _printf(local_30 + 1);
    iVar1 = _evolve(local_30 + 1,0x13);
  } while (iVar1 != 0);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int ispr(unsigned int n) {
    if ((n & 1) == 0 || n < 2) return n == 2;
    for (unsigned int j = 3; j * j <= n; j += 2)
      if (n % j == 0) return 0; return 1; }

int main() {
  unsigned int c = 0, nc, pc = 9, i, a, b, l,
    ps[128], nxt[128];
  for (a = 0, b = 1; a < pc; a = b++) ps[a] = b;
  while (1) {
    nc = 0;
    for (i = 0; i < pc; i++) {
        if (ispr(a = ps[i]))
          printf("%8d%s", a, ++c % 5 == 0 ? "\n" : " ");
        for (b = a * 10, l = a % 10 + b++; b < l; b++)
          nxt[nc++] = b;
      }
      if (nc > 1) for(i = 0, pc = nc; i < pc; i++) ps[i] = nxt[i];
      else break;
    }
    printf("\n%d descending primes found", c);
}
`,`#include "descending-primes.h"



bool _ispr(uint param_1)

{
  uint uVar1;
  bool bVar2;
  uint local_c;
  
  if (((param_1 & 1) == 0) || (param_1 < 2)) {
    bVar2 = param_1 == 2;
  }
  else {
    for (local_c = 3; local_c * local_c <= param_1; local_c = local_c + 2) {
      uVar1 = 0;
      if (local_c != 0) {
        uVar1 = param_1 / local_c;
      }
      if (param_1 == uVar1 * local_c) {
        return false;
      }
    }
    bVar2 = true;
  }
  return bVar2;
}



undefined4 entry(void)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  uint local_444;
  uint local_440;
  uint local_43c;
  uint local_438;
  uint local_434;
  uint auStack_428 [128];
  uint auStack_228 [128];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_438 = 9;
  local_444 = 1;
  local_440 = 0;
  while (local_440 < 9) {
    auStack_228[local_440] = local_444;
    local_440 = local_444;
    local_444 = local_444 + 1;
  }
  while( true ) {
    local_434 = 0;
    for (local_43c = 0; local_43c < local_438; local_43c = local_43c + 1) {
      uVar1 = auStack_228[local_43c];
      iVar2 = _ispr();
      if (iVar2 != 0) {
        _printf("%8d%s");
      }
      local_444 = uVar1 * 10;
      while (local_444 = local_444 + 1, local_444 < uVar1 * 0xb + (uVar1 / 10) * -10) {
        uVar3 = (ulong)local_434;
        local_434 = local_434 + 1;
        auStack_428[uVar3] = local_444;
      }
    }
    if (local_434 < 2) break;
    local_438 = local_434;
    for (local_43c = 0; local_43c < local_434; local_43c = local_43c + 1) {
      auStack_228[local_43c] = auStack_428[local_43c];
    }
  }
  iVar2 = _printf("\n%d descending primes found");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void divisor_count_and_sum(unsigned int n, unsigned int* pcount,
                           unsigned int* psum) {
    unsigned int divisor_count = 1;
    unsigned int divisor_sum = 1;
    unsigned int power = 2;
    for (; (n & 1) == 0; power <<= 1, n >>= 1) {
        ++divisor_count;
        divisor_sum += power;
    }
    for (unsigned int p = 3; p * p <= n; p += 2) {
        unsigned int count = 1, sum = 1;
        for (power = p; n % p == 0; power *= p, n /= p) {
            ++count;
            sum += power;
        }
        divisor_count *= count;
        divisor_sum *= sum;
    }
    if (n > 1) {
        divisor_count *= 2;
        divisor_sum *= n + 1;
    }
    *pcount = divisor_count;
    *psum = divisor_sum;
}

int main() {
    unsigned int arithmetic_count = 0;
    unsigned int composite_count = 0;

    for (unsigned int n = 1; arithmetic_count <= 1000000; ++n) {
        unsigned int divisor_count;
        unsigned int divisor_sum;
        divisor_count_and_sum(n, &divisor_count, &divisor_sum);
        if (divisor_sum % divisor_count != 0)
            continue;
        ++arithmetic_count;
        if (divisor_count > 2)
            ++composite_count;
        if (arithmetic_count <= 100) {
            printf("%3u ", n);
            if (arithmetic_count % 10 == 0)
                printf("\n");
        }
        if (arithmetic_count == 1000 || arithmetic_count == 10000 ||
            arithmetic_count == 100000 || arithmetic_count == 1000000) {
            printf("\n%uth arithmetic number is %u\n", arithmetic_count, n);
            printf("Number of composite arithmetic numbers <= %u: %u\n", n,
                   composite_count);
        }
    }
    return 0;
}
`,`#include "arithmetic-numbers.h"



void _divisor_count_and_sum(uint param_1,int *param_2,int *param_3)

{
  uint uVar1;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_4;
  
  local_1c = 1;
  local_20 = 1;
  local_24 = 2;
  for (local_4 = param_1; (local_4 & 1) == 0; local_4 = local_4 >> 1) {
    local_1c = local_1c + 1;
    local_20 = local_20 + local_24;
    local_24 = local_24 << 1;
  }
  for (local_28 = 3; local_28 * local_28 <= local_4; local_28 = local_28 + 2) {
    local_2c = 1;
    local_30 = 1;
    local_24 = local_28;
    uVar1 = local_4;
    while( true ) {
      local_4 = uVar1;
      uVar1 = 0;
      if (local_28 != 0) {
        uVar1 = local_4 / local_28;
      }
      if (local_4 != uVar1 * local_28) break;
      local_2c = local_2c + 1;
      local_30 = local_30 + local_24;
      local_24 = local_24 * local_28;
      uVar1 = 0;
      if (local_28 != 0) {
        uVar1 = local_4 / local_28;
      }
    }
    local_1c = local_1c * local_2c;
    local_20 = local_20 * local_30;
  }
  if (1 < local_4) {
    local_1c = local_1c << 1;
    local_20 = local_20 * (local_4 + 1);
  }
  *param_2 = local_1c;
  *param_3 = local_20;
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  uint local_28;
  uint local_24;
  int local_20;
  int local_1c;
  uint local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_18 = 0;
  local_1c = 0;
  local_20 = 1;
  while (local_18 < 0xf4241) {
    _divisor_count_and_sum(local_20,&local_24,&local_28);
    uVar1 = 0;
    if (local_24 != 0) {
      uVar1 = local_28 / local_24;
    }
    if (local_28 == uVar1 * local_24) {
      local_18 = local_18 + 1;
      if (2 < local_24) {
        local_1c = local_1c + 1;
      }
      if ((local_18 < 0x65) && (_printf("%3u "), local_18 % 10 == 0)) {
        _printf("\n");
      }
      if ((((local_18 == 1000) || (local_18 == 10000)) || (local_18 == 100000)) ||
         (local_18 == 1000000)) {
        _printf("\n%uth arithmetic number is %u\n");
        _printf("Number of composite arithmetic numbers <= %u: %u\n");
      }
    }
    local_20 = local_20 + 1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(void)
{
    for (int i = 1; i <= 100; ++i) {
        if (i % 3 == 0) printf("fizz");
        if (i % 5 == 0) printf("buzz");
        if (i * i * i * i % 15 == 1) printf("%d", i);
        puts("");
    }
}
`,`#include "fizzbuzz-9.h"



undefined4 entry(void)

{
  int local_18;
  
  for (local_18 = 1; local_18 < 0x65; local_18 = local_18 + 1) {
    if (local_18 % 3 == 0) {
      _printf("fizz");
    }
    if (local_18 % 5 == 0) {
      _printf("buzz");
    }
    if ((local_18 * local_18 * local_18 * local_18) % 0xf == 1) {
      _printf("%d");
    }
    _puts("");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int bsearch (int *a, int n, int x) {
    int i = 0, j = n - 1;
    while (i <= j) {
        int k = i + ((j - i) / 2);
        if (a[k] == x) {
            return k;
        }
        else if (a[k] < x) {
            i = k + 1;
        }
        else {
            j = k - 1;
        }
    }
    return -1;
}

int bsearch_r (int *a, int x, int i, int j) {
    if (j < i) {
        return -1;
    }
    int k = i + ((j - i) / 2);
    if (a[k] == x) {
        return k;
    }
    else if (a[k] < x) {
        return bsearch_r(a, x, k + 1, j);
    }
    else {
        return bsearch_r(a, x, i, k - 1);
    }
}

int main () {
    int a[] = {-31, 0, 1, 2, 2, 4, 65, 83, 99, 782};
    int n = sizeof a / sizeof a[0];
    int x = 2;
    int i = bsearch(a, n, x);
    if (i >= 0)
      printf("%d is at index %d.\n", x, i);
    else
      printf("%d is not found.\n", x);
    x = 5;
    i = bsearch_r(a, x, 0, n - 1);
    if (i >= 0)
      printf("%d is at index %d.\n", x, i);
    else
      printf("%d is not found.\n", x);
    return 0;
}
`,`#include "binary-search.h"



void * _bsearch(void *param_1,void *param_2,size_t param_3,size_t param_4,int *param_5)

{
  int local_20;
  int local_1c;
  uint local_4;
  
  local_1c = 0;
  local_20 = (int)param_2 + -1;
  while (local_1c <= local_20) {
    local_4 = local_1c + (local_20 - local_1c) / 2;
    if (*(int *)((long)param_1 + (long)(int)local_4 * 4) == (int)param_3) goto LAB_100003cb0;
    if (*(int *)((long)param_1 + (long)(int)local_4 * 4) < (int)param_3) {
      local_1c = local_4 + 1;
    }
    else {
      local_20 = local_4 - 1;
    }
  }
  local_4 = 0xffffffff;
LAB_100003cb0:
  return (void *)(ulong)local_4;
}



int _bsearch_r(long param_1,int param_2,int param_3,int param_4)

{
  undefined4 local_14;
  
  if (param_4 < param_3) {
    local_14 = -1;
  }
  else {
    local_14 = param_3 + (param_4 - param_3) / 2;
    if (*(int *)(param_1 + (long)local_14 * 4) != param_2) {
      if (*(int *)(param_1 + (long)local_14 * 4) < param_2) {
        local_14 = _bsearch_r(param_1,param_2,local_14 + 1,param_4);
      }
      else {
        local_14 = _bsearch_r(param_1,param_2,param_3,local_14 + -1);
      }
    }
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  void *pvVar2;
  size_t in_x3;
  int *in_x4;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f50,0x28);
  pvVar2 = _bsearch(auStack_40,(void *)0xa,2,in_x3,in_x4);
  if ((int)pvVar2 < 0) {
    _printf("%d is not found.\n");
  }
  else {
    _printf("%d is at index %d.\n");
  }
  iVar1 = _bsearch_r(auStack_40,5,0,9);
  if (iVar1 < 0) {
    iVar1 = _printf("%d is not found.\n");
  }
  else {
    iVar1 = _printf("%d is at index %d.\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <ctype.h>

static int
owp(int odd)
{
        int ch, ret;
        ch = getc(stdin);
        if (!odd) {
                putc(ch, stdout);
                if (ch == EOF || ch == '.')
                        return EOF;
                if (ispunct(ch))
                        return 0;
                owp(odd);
                return 0;
        } else {
                if (ispunct(ch))
                        return ch;
                ret = owp(odd);
                putc(ch, stdout);
                return ret;
        }
}

int
main(int argc, char **argv)
{
        int ch = 1;
        while ((ch = owp(!ch)) != EOF) {
                if (ch)
                        putc(ch, stdout);
                if (ch == '.')
                        break;
        }
        return 0;
}
`,`#include "odd-word-problem.h"



undefined8 entry(void)

{
  int local_24;
  
  local_24 = 1;
  do {
    local_24 = FUN_100003e74(local_24 == 0);
    if (local_24 == -1) {
      return 0;
    }
    if (local_24 != 0) {
      _putc(local_24,*(FILE **)PTR____stdoutp_100004008);
    }
  } while (local_24 != 0x2e);
  return 0;
}



int FUN_100003e74(int param_1)

{
  int iVar1;
  int local_14;
  
  local_14 = _getc(*(FILE **)PTR____stdinp_100004000);
  if (param_1 == 0) {
    _putc(local_14,*(FILE **)PTR____stdoutp_100004008);
    if ((local_14 == -1) || (local_14 == 0x2e)) {
      local_14 = -1;
    }
    else {
      iVar1 = _ispunct(local_14);
      if (iVar1 == 0) {
        FUN_100003e74(0);
        local_14 = 0;
      }
      else {
        local_14 = 0;
      }
    }
  }
  else {
    iVar1 = _ispunct(local_14);
    if (iVar1 == 0) {
      iVar1 = FUN_100003e74(param_1);
      _putc(local_14,*(FILE **)PTR____stdoutp_100004008);
      local_14 = iVar1;
    }
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getc_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _ispunct(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__ispunct_100004018)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putc_100004020)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  int intspace;
  int *address;

  address = &intspace; // address = 0x100;
  *address = 65535;
  printf("%p: %08x (=%08x)\n", address, *address, intspace);
  // likely we must be worried about endianness, e.g.
  *((char*)address) = 0x00;
  *((char*)address+1) = 0x00;
  *((char*)address+2) = 0xff;
  *((char*)address+3) = 0xff; // if sizeof(int) == 4!
  // which maybe is not the best way of writing 32 bit values...
  printf("%p: %08x (=%08x)\n", address, *address, intspace);
  return 0;
}
`,`#include "create-an-object-at-a-given-address-1.h"



undefined4 entry(void)

{
  _printf("%p: %08x (=%08x)\n");
  _printf("%p: %08x (=%08x)\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define SWAP(r,s)  do{ t=r; r=s; s=t; } while(0)

void StoogeSort(int a[], int i, int j)
{
   int t;

   if (a[j] < a[i]) SWAP(a[i], a[j]);
   if (j - i > 1)
   {
       t = (j - i + 1) / 3;
       StoogeSort(a, i, j - t);
       StoogeSort(a, i + t, j);
       StoogeSort(a, i, j - t);
   }
}

int main(int argc, char *argv[])
{
   int nums[] = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7};
   int i, n;

   n = sizeof(nums)/sizeof(int);
   StoogeSort(nums, 0, n-1);

   for(i = 0; i <= n-1; i++)
      printf("%5d", nums[i]);

   return 0;
}
`,`#include "sorting-algorithms-stooge-sort.h"



void _StoogeSort(long param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  
  if (*(int *)(param_1 + (long)param_3 * 4) < *(int *)(param_1 + (long)param_2 * 4)) {
    uVar1 = *(undefined4 *)(param_1 + (long)param_2 * 4);
    *(undefined4 *)(param_1 + (long)param_2 * 4) = *(undefined4 *)(param_1 + (long)param_3 * 4);
    *(undefined4 *)(param_1 + (long)param_3 * 4) = uVar1;
  }
  if (1 < param_3 - param_2) {
    iVar2 = ((param_3 - param_2) + 1) / 3;
    _StoogeSort(param_1,param_2,param_3 - iVar2);
    _StoogeSort(param_1,param_2 + iVar2,param_3);
    _StoogeSort(param_1,param_2,param_3 - iVar2);
  }
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  int local_6c;
  undefined auStack_54 [60];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_54,&DAT_100003f68,0x3c);
  uVar2 = _StoogeSort(auStack_54,0,0xe);
  for (local_6c = 0; local_6c < 0xf; local_6c = local_6c + 1) {
    uVar1 = _printf("%5d");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <time.h>

#define note_file "NOTES.TXT"

int main(int argc, char**argv)
{
	FILE *note = 0;
	time_t tm;
	int i;
	char *p;

	if (argc < 2) {
		if ((note = fopen(note_file, "r")))
			while ((i = fgetc(note)) != EOF)
				putchar(i);

	} else if ((note = fopen(note_file, "a"))) {
		tm = time(0);
		p = ctime(&tm);

		/* skip the newline */
		while (*p) fputc(*p != '\n'?*p:'\t', note), p++;

		for (i = 1; i < argc; i++)
			fprintf(note, "%s%c", argv[i], 1 + i - argc ? ' ' : '\n');
	}

	if (note) fclose(note);
	return 0;
}
`,`#include "take-notes-on-the-command-line.h"



undefined8 entry(int param_1,undefined8 param_2)

{
  int iVar1;
  int local_44;
  char *local_40;
  int local_34;
  time_t local_30;
  FILE *local_28;
  undefined8 local_20;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_28 = (FILE *)0x0;
  local_20 = param_2;
  local_18 = param_1;
  if (param_1 < 2) {
    local_28 = _fopen("NOTES.TXT","r");
    if (local_28 != (FILE *)0x0) {
      while (iVar1 = _fgetc(local_28), iVar1 != -1) {
        _putchar(iVar1);
      }
    }
  }
  else {
    local_28 = _fopen("NOTES.TXT","a");
    if (local_28 != (FILE *)0x0) {
      local_30 = _time((time_t *)0x0);
      for (local_40 = _ctime(&local_30); *local_40 != '\0'; local_40 = local_40 + 1) {
        if (*local_40 == '\n') {
          local_44 = 9;
        }
        else {
          local_44 = (int)*local_40;
        }
        _fputc(local_44,local_28);
      }
      for (local_34 = 1; local_34 < local_18; local_34 = local_34 + 1) {
        _fprintf(local_28,"%s%c");
      }
    }
  }
  if (local_28 != (FILE *)0x0) {
    _fclose(local_28);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _ctime(time_t *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__ctime_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004018)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fputc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fputc_100004028)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004030)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004038)();
  return tVar1;
}


`
`#include <stdio.h>

double horner(double *coeffs, int s, double x)
{
  int i;
  double res = 0.0;

  for(i=s-1; i >= 0; i--)
  {
    res = res * x + coeffs[i];
  }
  return res;
}


int main()
{
  double coeffs[] = { -19.0, 7.0, -4.0, 6.0 };

  printf("%5.1f\n", horner(coeffs, sizeof(coeffs)/sizeof(double), 3.0));
  return 0;
}
`,`#include "horners-rule-for-polynomial-evaluation.h"



undefined  [16] _horner(undefined8 param_1,long param_2,int param_3)

{
  undefined auVar1 [16];
  undefined8 local_28;
  undefined4 local_1c;
  
  local_28 = 0;
  for (local_1c = param_3 + -1; -1 < local_1c; local_1c = local_1c + -1) {
    local_28 = NEON_fmadd(local_28,param_1,*(undefined8 *)(param_2 + (long)local_1c * 8));
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_28;
  return auVar1;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_38 = 0x401c000000000000;
  local_40 = 0xc033000000000000;
  uStack_28 = 0x4018000000000000;
  local_30 = 0xc010000000000000;
  _horner(0x4008000000000000,&local_40,4);
  iVar1 = _printf("%5.1f\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct node_t {
    int x, y;
    struct node_t *prev, *next;
} node;

node *new_node(int x, int y) {
    node *n = malloc(sizeof(node));
    n->x = x;
    n->y = y;
    n->next = NULL;
    n->prev = NULL;
    return n;
}

void free_node(node **n) {
    if (n == NULL) {
        return;
    }

    (*n)->prev = NULL;
    (*n)->next = NULL;

    free(*n);

    *n = NULL;
}

typedef struct list_t {
    node *head;
    node *tail;
} list;

list make_list() {
    list lst = { NULL, NULL };
    return lst;
}

void append_node(list *const lst, int x, int y) {
    if (lst == NULL) {
        return;
    }

    node *n = new_node(x, y);

    if (lst->head == NULL) {
        lst->head = n;
        lst->tail = n;
    } else {
        n->prev = lst->tail;
        lst->tail->next = n;
        lst->tail = n;
    }
}

void remove_node(list *const lst, const node *const n) {
    if (lst == NULL || n == NULL) {
        return;
    }

    if (n->prev != NULL) {
        n->prev->next = n->next;
        if (n->next != NULL) {
            n->next->prev = n->prev;
        } else {
            lst->tail = n->prev;
        }
    } else {
        if (n->next != NULL) {
            n->next->prev = NULL;
            lst->head = n->next;
        }
    }

    free_node(&n);
}

void free_list(list *const lst) {
    node *ptr;

    if (lst == NULL) {
        return;
    }
    ptr = lst->head;

    while (ptr != NULL) {
        node *nxt = ptr->next;
        free_node(&ptr);
        ptr = nxt;
    }

    lst->head = NULL;
    lst->tail = NULL;
}

void print_list(const list *lst) {
    node *it;

    if (lst == NULL) {
        return;
    }

    for (it = lst->head; it != NULL; it = it->next) {
        int sum = it->x + it->y;
        int prod = it->x * it->y;
        printf("[%d, %d] S=%d P=%d\n", it->x, it->y, sum, prod);
    }
}

void print_count(const list *const lst) {
    node *it;
    int c = 0;

    if (lst == NULL) {
        return;
    }

    for (it = lst->head; it != NULL; it = it->next) {
        c++;
    }

    if (c == 0) {
        printf("no candidates\n");
    } else    if (c == 1) {
        printf("one candidate\n");
    } else {
        printf("%d candidates\n", c);
    }
}

void setup(list *const lst) {
    int x, y;

    if (lst == NULL) {
        return;
    }

    // numbers must be greater than 1
    for (x = 2; x <= 98; x++) {
        // numbers must be unique, and sum no more than 100
        for (y = x + 1; y <= 98; y++) {
            if (x + y <= 100) {
                append_node(lst, x, y);
            }
        }
    }
}

void remove_by_sum(list *const lst, const int sum) {
    node *it;

    if (lst == NULL) {
        return;
    }

    it = lst->head;
    while (it != NULL) {
        int s = it->x + it->y;

        if (s == sum) {
            remove_node(lst, it);
            it = lst->head;
        } else {
            it = it->next;
        }
    }
}

void remove_by_prod(list *const lst, const int prod) {
    node *it;

    if (lst == NULL) {
        return;
    }

    it = lst->head;
    while (it != NULL) {
        int p = it->x * it->y;

        if (p == prod) {
            remove_node(lst, it);
            it = lst->head;
        } else {
            it = it->next;
        }
    }
}

void statement1(list *const lst) {
    short *unique = calloc(100000, sizeof(short));
    node *it, *nxt;

    for (it = lst->head; it != NULL; it = it->next) {
        int prod = it->x * it->y;
        unique[prod]++;
    }

    it = lst->head;
    while (it != NULL) {
        int prod = it->x * it->y;
        nxt = it->next;
        if (unique[prod] == 1) {
            remove_by_sum(lst, it->x + it->y);
            it = lst->head;
        } else {
            it = nxt;
        }
    }

    free(unique);
}

void statement2(list *const candidates) {
    short *unique = calloc(100000, sizeof(short));
    node *it, *nxt;

    for (it = candidates->head; it != NULL; it = it->next) {
        int prod = it->x * it->y;
        unique[prod]++;
    }

    it = candidates->head;
    while (it != NULL) {
        int prod = it->x * it->y;
        nxt = it->next;
        if (unique[prod] > 1) {
            remove_by_prod(candidates, prod);
            it = candidates->head;
        } else {
            it = nxt;
        }
    }

    free(unique);
}

void statement3(list *const candidates) {
    short *unique = calloc(100, sizeof(short));
    node *it, *nxt;

    for (it = candidates->head; it != NULL; it = it->next) {
        int sum = it->x + it->y;
        unique[sum]++;
    }

    it = candidates->head;
    while (it != NULL) {
        int sum = it->x + it->y;
        nxt = it->next;
        if (unique[sum] > 1) {
            remove_by_sum(candidates, sum);
            it = candidates->head;
        } else {
            it = nxt;
        }
    }

    free(unique);
}

int main() {
    list candidates = make_list();

    setup(&candidates);
    print_count(&candidates);

    statement1(&candidates);
    print_count(&candidates);

    statement2(&candidates);
    print_count(&candidates);

    statement3(&candidates);
    print_count(&candidates);

    print_list(&candidates);

    free_list(&candidates);
    return 0;
}
`,`#include "sum-and-product-puzzle.h"



undefined4 * _new_node(undefined4 param_1,undefined4 param_2)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_malloc(0x18);
  *puVar1 = param_1;
  puVar1[1] = param_2;
  *(undefined8 *)(puVar1 + 4) = 0;
  *(undefined8 *)(puVar1 + 2) = 0;
  return puVar1;
}



void _free_node(long *param_1)

{
  if (param_1 != (long *)0x0) {
    *(undefined8 *)(*param_1 + 8) = 0;
    *(undefined8 *)(*param_1 + 0x10) = 0;
    _free((void *)*param_1);
    *param_1 = 0;
  }
  return;
}



undefined  [16] _make_list(void)

{
  return ZEXT816(0);
}



void _append_node(long *param_1,undefined4 param_2,undefined4 param_3)

{
  long lVar1;
  
  if (param_1 != (long *)0x0) {
    lVar1 = _new_node(param_2,param_3);
    if (*param_1 == 0) {
      *param_1 = lVar1;
      param_1[1] = lVar1;
    }
    else {
      *(long *)(lVar1 + 8) = param_1[1];
      *(long *)(param_1[1] + 0x10) = lVar1;
      param_1[1] = lVar1;
    }
  }
  return;
}



void _remove_node(undefined8 *param_1,long param_2)

{
  long local_20;
  undefined8 *local_18;
  
  if ((param_1 != (undefined8 *)0x0) && (param_2 != 0)) {
    if (*(long *)(param_2 + 8) == 0) {
      if (*(long *)(param_2 + 0x10) != 0) {
        *(undefined8 *)(*(long *)(param_2 + 0x10) + 8) = 0;
        *param_1 = *(undefined8 *)(param_2 + 0x10);
      }
    }
    else {
      *(undefined8 *)(*(long *)(param_2 + 8) + 0x10) = *(undefined8 *)(param_2 + 0x10);
      if (*(long *)(param_2 + 0x10) == 0) {
        param_1[1] = *(undefined8 *)(param_2 + 8);
      }
      else {
        *(undefined8 *)(*(long *)(param_2 + 0x10) + 8) = *(undefined8 *)(param_2 + 8);
      }
    }
    local_20 = param_2;
    local_18 = param_1;
    _free_node(&local_20);
  }
  return;
}



void _free_list(long *param_1)

{
  long lVar1;
  long local_20;
  long *local_18;
  
  if (param_1 != (long *)0x0) {
    local_20 = *param_1;
    local_18 = param_1;
    while (local_20 != 0) {
      lVar1 = *(long *)(local_20 + 0x10);
      _free_node(&local_20);
      local_20 = lVar1;
    }
    *local_18 = 0;
    local_18[1] = 0;
  }
  return;
}



long * _print_list(long *param_1)

{
  uint uVar1;
  long local_20;
  
  if (param_1 != (long *)0x0) {
    for (local_20 = *param_1; local_20 != 0; local_20 = *(long *)(local_20 + 0x10)) {
      uVar1 = _printf("[%d, %d] S=%d P=%d\n");
      param_1 = (long *)(ulong)uVar1;
    }
  }
  return param_1;
}



int _print_count(long *param_1)

{
  int iVar1;
  int local_24;
  long local_20;
  
  local_24 = 0;
  if (param_1 == (long *)0x0) {
    iVar1 = 0;
  }
  else {
    for (local_20 = *param_1; local_20 != 0; local_20 = *(long *)(local_20 + 0x10)) {
      local_24 = local_24 + 1;
    }
    if (local_24 == 0) {
      iVar1 = _printf("no candidates\n");
    }
    else if (local_24 == 1) {
      iVar1 = _printf("one candidate\n");
    }
    else {
      iVar1 = _printf("%d candidates\n");
    }
  }
  return iVar1;
}



void _setup(long param_1)

{
  undefined4 local_20;
  undefined4 local_1c;
  
  if (param_1 != 0) {
    for (local_1c = 2; local_20 = local_1c, local_1c < 99; local_1c = local_1c + 1) {
      while (local_20 = local_20 + 1, local_20 < 99) {
        if (local_1c + local_20 < 0x65) {
          _append_node(param_1,local_1c,local_20);
        }
      }
    }
  }
  return;
}



void _remove_by_sum(undefined8 *param_1,int param_2)

{
  int *local_28;
  
  if (param_1 != (undefined8 *)0x0) {
    local_28 = (int *)*param_1;
    while (local_28 != (int *)0x0) {
      if (*local_28 + local_28[1] == param_2) {
        _remove_node(param_1,local_28);
        local_28 = (int *)*param_1;
      }
      else {
        local_28 = *(int **)(local_28 + 4);
      }
    }
  }
  return;
}



void _remove_by_prod(undefined8 *param_1,int param_2)

{
  int *local_28;
  
  if (param_1 != (undefined8 *)0x0) {
    local_28 = (int *)*param_1;
    while (local_28 != (int *)0x0) {
      if (*local_28 * local_28[1] == param_2) {
        _remove_node(param_1,local_28);
        local_28 = (int *)*param_1;
      }
      else {
        local_28 = *(int **)(local_28 + 4);
      }
    }
  }
  return;
}



void _statement1(undefined8 *param_1)

{
  short *psVar1;
  int *piVar2;
  void *pvVar3;
  int *local_28;
  
  pvVar3 = _calloc(100000,2);
  for (local_28 = (int *)*param_1; local_28 != (int *)0x0; local_28 = *(int **)(local_28 + 4)) {
    psVar1 = (short *)((long)pvVar3 + (long)(*local_28 * local_28[1]) * 2);
    *psVar1 = *psVar1 + 1;
  }
  piVar2 = (int *)*param_1;
  while (local_28 = piVar2, local_28 != (int *)0x0) {
    piVar2 = *(int **)(local_28 + 4);
    if (*(short *)((long)pvVar3 + (long)(*local_28 * local_28[1]) * 2) == 1) {
      _remove_by_sum(param_1,*local_28 + local_28[1]);
      piVar2 = (int *)*param_1;
    }
  }
  _free(pvVar3);
  return;
}



void _statement2(undefined8 *param_1)

{
  int *piVar1;
  short *psVar2;
  int iVar3;
  void *pvVar4;
  int *local_28;
  
  pvVar4 = _calloc(100000,2);
  for (local_28 = (int *)*param_1; local_28 != (int *)0x0; local_28 = *(int **)(local_28 + 4)) {
    psVar2 = (short *)((long)pvVar4 + (long)(*local_28 * local_28[1]) * 2);
    *psVar2 = *psVar2 + 1;
  }
  local_28 = (int *)*param_1;
  while (local_28 != (int *)0x0) {
    iVar3 = *local_28;
    piVar1 = local_28 + 1;
    local_28 = *(int **)(local_28 + 4);
    if (1 < *(short *)((long)pvVar4 + (long)(iVar3 * *piVar1) * 2)) {
      _remove_by_prod(param_1,iVar3 * *piVar1);
      local_28 = (int *)*param_1;
    }
  }
  _free(pvVar4);
  return;
}



void _statement3(undefined8 *param_1)

{
  int *piVar1;
  short *psVar2;
  int iVar3;
  void *pvVar4;
  int *local_28;
  
  pvVar4 = _calloc(100,2);
  for (local_28 = (int *)*param_1; local_28 != (int *)0x0; local_28 = *(int **)(local_28 + 4)) {
    psVar2 = (short *)((long)pvVar4 + (long)(*local_28 + local_28[1]) * 2);
    *psVar2 = *psVar2 + 1;
  }
  local_28 = (int *)*param_1;
  while (local_28 != (int *)0x0) {
    iVar3 = *local_28;
    piVar1 = local_28 + 1;
    local_28 = *(int **)(local_28 + 4);
    if (1 < *(short *)((long)pvVar4 + (long)(iVar3 + *piVar1) * 2)) {
      _remove_by_sum(param_1,iVar3 + *piVar1);
      local_28 = (int *)*param_1;
    }
  }
  _free(pvVar4);
  return;
}



undefined4 entry(void)

{
  undefined local_28 [16];
  undefined4 local_14;
  
  local_14 = 0;
  local_28 = _make_list();
  _setup();
  _print_count(local_28);
  _statement1(local_28);
  _print_count(local_28);
  _statement2(local_28);
  _print_count(local_28);
  _statement3(local_28);
  _print_count(local_28);
  _print_list(local_28);
  _free_list(local_28);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef struct stem_t *stem;
struct stem_t { const char *str; stem next; };

void tree(int root, stem head)
{
	static const char *sdown = "  |", *slast = "  ", *snone = "   ";
	struct stem_t col = {0, 0}, *tail;

	for (tail = head; tail; tail = tail->next) {
		printf("%s", tail->str);
		if (!tail->next) break;
	}

	printf("--%d\n", root);

	if (root <= 1) return;

	if (tail && tail->str == slast)
		tail->str = snone;

	if (!tail)	tail = head = &col;
	else		tail->next = &col;

	while (root) { // make a tree by doing something random
		int r = 1 + (rand() % root);
		root -= r;
		col.str = root ? sdown : slast;

		tree(r, head);
	}

	tail->next = 0;
}

int main(int c, char**v)
{
	int n;
	if (c < 2 || (n = atoi(v[1])) < 0) n = 8;

	tree(n, 0);
	return 0;
}
`,`#include "visualize-a-tree.h"



ulong _tree(int param_1,undefined **param_2)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  undefined *local_48;
  undefined **local_38;
  undefined *local_30;
  undefined8 local_28;
  undefined **local_20;
  int local_14;
  
  local_30 = (undefined *)0x0;
  local_28 = 0;
  local_20 = param_2;
  local_14 = param_1;
  for (local_38 = param_2;
      (local_38 != (undefined **)0x0 && (_printf("%s"), local_38[1] != (undefined *)0x0));
      local_38 = (undefined **)local_38[1]) {
  }
  uVar2 = _printf("--%d\n");
  uVar4 = (ulong)uVar2;
  if (1 < local_14) {
    if ((local_38 != (undefined **)0x0) && (*local_38 == PTR_s___100008008)) {
      *local_38 = PTR_s__100008010;
    }
    if (local_38 == (undefined **)0x0) {
      local_20 = &local_30;
      local_38 = local_20;
    }
    else {
      local_38[1] = (undefined *)&local_30;
    }
    while (local_14 != 0) {
      iVar3 = _rand();
      iVar1 = 0;
      if (local_14 != 0) {
        iVar1 = iVar3 / local_14;
      }
      iVar1 = (iVar3 - iVar1 * local_14) + 1;
      local_14 = local_14 - iVar1;
      if (local_14 == 0) {
        local_48 = PTR_s___100008008;
      }
      else {
        local_48 = PTR_s___100008000;
      }
      local_30 = local_48;
      uVar4 = _tree(iVar1,local_20);
    }
    local_38[1] = (undefined *)0x0;
  }
  return uVar4;
}



undefined8 entry(int param_1,long param_2)

{
  int local_24;
  
  if ((param_1 < 2) || (local_24 = _atoi(*(char **)(param_2 + 8)), local_24 < 0)) {
    local_24 = 8;
  }
  _tree(local_24,0);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004010)();
  return iVar1;
}


`
`/* Uses C99 specified complex.h, complex datatype has to be defined and operation provided if used on non-C99 compilers */

#include<stdlib.h>
#include<stdio.h>
#include<complex.h>

typedef struct
{
  int rows, cols;
  complex **z;
} matrix;

matrix
transpose (matrix a)
{
  int i, j;
  matrix b;

  b.rows = a.cols;
  b.cols = a.rows;

  b.z = malloc (b.rows * sizeof (complex *));

  for (i = 0; i < b.rows; i++)
    {
      b.z[i] = malloc (b.cols * sizeof (complex));
      for (j = 0; j < b.cols; j++)
        {
          b.z[i][j] = conj (a.z[j][i]);
        }
    }

  return b;
}

int
isHermitian (matrix a)
{
  int i, j;
  matrix b = transpose (a);

  if (b.rows == a.rows && b.cols == a.cols)
    {
      for (i = 0; i < b.rows; i++)
        {
          for (j = 0; j < b.cols; j++)
            {
              if (b.z[i][j] != a.z[i][j])
                return 0;
            }
        }
    }

  else
    return 0;

  return 1;
}

matrix
multiply (matrix a, matrix b)
{
  matrix c;
  int i, j;

  if (a.cols == b.rows)
    {
      c.rows = a.rows;
      c.cols = b.cols;

      c.z = malloc (c.rows * (sizeof (complex *)));

      for (i = 0; i < c.rows; i++)
        {
          c.z[i] = malloc (c.cols * sizeof (complex));
          c.z[i][j] = 0 + 0 * I;
          for (j = 0; j < b.cols; j++)
            {
              c.z[i][j] += a.z[i][j] * b.z[j][i];
            }
        }

    }

  return c;
}

int
isNormal (matrix a)
{
  int i, j;
  matrix a_ah, ah_a;

  if (a.rows != a.cols)
    return 0;

  a_ah = multiply (a, transpose (a));
  ah_a = multiply (transpose (a), a);

  for (i = 0; i < a.rows; i++)
    {
      for (j = 0; j < a.cols; j++)
        {
          if (a_ah.z[i][j] != ah_a.z[i][j])
            return 0;
        }
    }

  return 1;
}

int
isUnitary (matrix a)
{
  matrix b;
  int i, j;
  if (isNormal (a) == 1)
    {
      b = multiply (a, transpose(a));

      for (i = 0; i < b.rows; i++)
        {
          for (j = 0; j < b.cols; j++)
            {
              if ((i == j && b.z[i][j] != 1) || (i != j && b.z[i][j] != 0))
                return 0;
            }
        }
      return 1;
    }
  return 0;
}


int
main ()
{
  complex z = 3 + 4 * I;
  matrix a, aT;
  int i, j;
  printf ("Enter rows and columns :");
  scanf ("%d%d", &a.rows, &a.cols);

  a.z = malloc (a.rows * sizeof (complex *));
  printf ("Randomly Generated Complex Matrix A is : ");
  for (i = 0; i < a.rows; i++)
    {
      printf ("\n");
      a.z[i] = malloc (a.cols * sizeof (complex));
      for (j = 0; j < a.cols; j++)
        {
          a.z[i][j] = rand () % 10 + rand () % 10 * I;
          printf ("\t%f + %fi", creal (a.z[i][j]), cimag (a.z[i][j]));
        }
    }

  aT = transpose (a);

  printf ("\n\nTranspose of Complex Matrix A is : ");
  for (i = 0; i < aT.rows; i++)
    {
      printf ("\n");
      aT.z[i] = malloc (aT.cols * sizeof (complex));
      for (j = 0; j < aT.cols; j++)
        {
          aT.z[i][j] = rand () % 10 + rand () % 10 * I;
          printf ("\t%f + %fi", creal (aT.z[i][j]), cimag (aT.z[i][j]));
        }
    }

  printf ("\n\nComplex Matrix A %s hermitian",
          isHermitian (a) == 1 ? "is" : "is not");
  printf ("\n\nComplex Matrix A %s unitary",
          isUnitary (a) == 1 ? "is" : "is not");
  printf ("\n\nComplex Matrix A %s normal",
          isNormal (a) == 1 ? "is" : "is not");



  return 0;
}
`,`#include "conjugate-transpose.h"



undefined  [16] _transpose(undefined8 param_1,long param_2)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  undefined auVar3 [16];
  void *pvVar4;
  void *pvVar5;
  double dVar6;
  int local_38;
  int local_34;
  int local_30;
  int iStack_2c;
  
  iStack_2c = (int)((ulong)param_1 >> 0x20);
  local_30 = (int)param_1;
  pvVar4 = _malloc((long)iStack_2c << 3);
  for (local_34 = 0; local_34 < iStack_2c; local_34 = local_34 + 1) {
    pvVar5 = _malloc((long)local_30 << 4);
    *(void **)((long)pvVar4 + (long)local_34 * 8) = pvVar5;
    for (local_38 = 0; local_38 < local_30; local_38 = local_38 + 1) {
      puVar1 = (undefined8 *)(*(long *)(param_2 + (long)local_38 * 8) + (long)local_34 * 0x10);
      dVar6 = (double)puVar1[1];
      puVar2 = (undefined8 *)(*(long *)((long)pvVar4 + (long)local_34 * 8) + (long)local_38 * 0x10);
      *puVar2 = *puVar1;
      puVar2[1] = -dVar6;
    }
  }
  auVar3._4_4_ = local_30;
  auVar3._0_4_ = iStack_2c;
  auVar3._8_8_ = pvVar4;
  return auVar3;
}



undefined4 _isHermitian(undefined8 param_1,long param_2)

{
  double *pdVar1;
  double *pdVar2;
  undefined auVar3 [16];
  int local_40;
  int iStack_3c;
  int local_30;
  int local_2c;
  int local_28;
  int iStack_24;
  
  auVar3 = _transpose(param_1,param_2);
  local_40 = auVar3._0_4_;
  local_28 = (int)param_1;
  if (local_40 == local_28) {
    iStack_3c = auVar3._4_4_;
    iStack_24 = (int)((ulong)param_1 >> 0x20);
    if (iStack_3c == iStack_24) {
      local_2c = 0;
      do {
        if (local_40 <= local_2c) {
          return 1;
        }
        for (local_30 = 0; local_30 < iStack_3c; local_30 = local_30 + 1) {
          pdVar1 = (double *)(*(long *)(auVar3._8_8_ + (long)local_2c * 8) + (long)local_30 * 0x10);
          pdVar2 = (double *)(*(long *)(param_2 + (long)local_2c * 8) + (long)local_30 * 0x10);
          if ((*pdVar1 != *pdVar2) || (pdVar1[1] != pdVar2[1])) {
            return 0;
          }
        }
        local_2c = local_2c + 1;
      } while( true );
    }
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x000100003400)
// WARNING: Removing unreachable block (ram,0x00010000341c)
// WARNING: Removing unreachable block (ram,0x000100003514)
// WARNING: Removing unreachable block (ram,0x000100003534)

undefined  [16] _multiply(undefined8 param_1,long param_2,undefined8 param_3,long param_4)

{
  undefined8 *puVar1;
  double *pdVar2;
  undefined auVar3 [16];
  void *pvVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  int local_48;
  int local_44;
  int local_40;
  int iStack_3c;
  int local_30;
  int iStack_2c;
  int local_20;
  int iStack_1c;
  void *local_18;
  
  iStack_2c = (int)((ulong)param_1 >> 0x20);
  local_40 = (int)param_3;
  if (iStack_2c == local_40) {
    local_30 = (int)param_1;
    local_20 = local_30;
    iStack_3c = (int)((ulong)param_3 >> 0x20);
    iStack_1c = iStack_3c;
    local_18 = _malloc((long)local_30 << 3);
    for (local_44 = 0; local_44 < local_30; local_44 = local_44 + 1) {
      pvVar4 = _malloc((long)iStack_3c << 4);
      *(void **)((long)local_18 + (long)local_44 * 8) = pvVar4;
      puVar1 = (undefined8 *)
               (*(long *)((long)local_18 + (long)local_44 * 8) + (long)local_48 * 0x10);
      *puVar1 = 0;
      puVar1[1] = 0;
      for (local_48 = 0; local_48 < iStack_3c; local_48 = local_48 + 1) {
        pdVar2 = (double *)(*(long *)(param_2 + (long)local_44 * 8) + (long)local_48 * 0x10);
        dVar5 = *pdVar2;
        dVar6 = pdVar2[1];
        pdVar2 = (double *)(*(long *)(param_4 + (long)local_48 * 8) + (long)local_44 * 0x10);
        dVar7 = *pdVar2;
        dVar8 = pdVar2[1];
        pdVar2 = (double *)(*(long *)((long)local_18 + (long)local_44 * 8) + (long)local_48 * 0x10);
        *pdVar2 = *pdVar2 + (dVar5 * dVar7 - dVar6 * dVar8);
        pdVar2[1] = pdVar2[1] + dVar5 * dVar8 + dVar6 * dVar7;
      }
    }
  }
  auVar3._4_4_ = iStack_1c;
  auVar3._0_4_ = local_20;
  auVar3._8_8_ = local_18;
  return auVar3;
}



undefined4 _isNormal(undefined8 param_1,undefined8 param_2)

{
  double *pdVar1;
  double *pdVar2;
  long extraout_x1;
  long extraout_x1_00;
  undefined auVar3 [16];
  int local_30;
  int local_2c;
  int local_28;
  int iStack_24;
  undefined4 local_14;
  
  local_28 = (int)param_1;
  iStack_24 = (int)((ulong)param_1 >> 0x20);
  if (local_28 == iStack_24) {
    auVar3 = _transpose(param_1,param_2);
    _multiply(param_1,param_2,auVar3._0_8_,auVar3._8_8_);
    auVar3 = _transpose(param_1,param_2);
    _multiply(auVar3._0_8_,auVar3._8_8_,param_1,param_2);
    for (local_2c = 0; local_2c < local_28; local_2c = local_2c + 1) {
      for (local_30 = 0; local_30 < iStack_24; local_30 = local_30 + 1) {
        pdVar1 = (double *)(*(long *)(extraout_x1 + (long)local_2c * 8) + (long)local_30 * 0x10);
        pdVar2 = (double *)(*(long *)(extraout_x1_00 + (long)local_2c * 8) + (long)local_30 * 0x10);
        if ((*pdVar1 != *pdVar2) || (pdVar1[1] != pdVar2[1])) {
          return 0;
        }
      }
    }
    local_14 = 1;
  }
  else {
    local_14 = 0;
  }
  return local_14;
}



undefined4 _isUnitary(undefined8 param_1,undefined8 param_2)

{
  double *pdVar1;
  int iVar2;
  undefined auVar3 [16];
  int local_48;
  int local_44;
  int local_40;
  int iStack_3c;
  undefined4 local_14;
  
  iVar2 = _isNormal(param_1,param_2);
  if (iVar2 == 1) {
    auVar3 = _transpose(param_1,param_2);
    auVar3 = _multiply(param_1,param_2,auVar3._0_8_,auVar3._8_8_);
    for (local_44 = 0; local_40 = auVar3._0_4_, local_44 < local_40; local_44 = local_44 + 1) {
      for (local_48 = 0; iStack_3c = auVar3._4_4_, local_48 < iStack_3c; local_48 = local_48 + 1) {
        if (((local_44 == local_48) &&
            ((pdVar1 = (double *)
                       (*(long *)(auVar3._8_8_ + (long)local_44 * 8) + (long)local_48 * 0x10),
             *pdVar1 != 1.0 || (pdVar1[1] != 0.0)))) ||
           ((local_44 != local_48 &&
            ((pdVar1 = (double *)
                       (*(long *)(auVar3._8_8_ + (long)local_44 * 8) + (long)local_48 * 0x10),
             *pdVar1 != 0.0 || (pdVar1[1] != 0.0)))))) {
          return 0;
        }
      }
    }
    local_14 = 1;
  }
  else {
    local_14 = 0;
  }
  return local_14;
}



// WARNING: Removing unreachable block (ram,0x000100003ad0)
// WARNING: Removing unreachable block (ram,0x000100003af0)
// WARNING: Removing unreachable block (ram,0x000100003968)
// WARNING: Removing unreachable block (ram,0x00010000394c)
// WARNING: Removing unreachable block (ram,0x000100003cbc)
// WARNING: Removing unreachable block (ram,0x000100003cdc)

undefined8 entry(void)

{
  double *pdVar1;
  int iVar2;
  int iVar3;
  void *pvVar4;
  void *pvVar5;
  undefined auVar6 [16];
  int local_58;
  int local_54;
  int local_50;
  int iStack_4c;
  int local_38;
  int iStack_34;
  
  _printf("Enter rows and columns :");
  _scanf("%d%d");
  pvVar4 = _malloc((long)local_38 << 3);
  _printf("Randomly Generated Complex Matrix A is : ");
  for (local_54 = 0; local_54 < local_38; local_54 = local_54 + 1) {
    _printf("\n");
    pvVar5 = _malloc((long)iStack_34 << 4);
    *(void **)((long)pvVar4 + (long)local_54 * 8) = pvVar5;
    for (local_58 = 0; local_58 < iStack_34; local_58 = local_58 + 1) {
      iVar2 = _rand();
      iVar3 = _rand();
      pdVar1 = (double *)(*(long *)((long)pvVar4 + (long)local_54 * 8) + (long)local_58 * 0x10);
      *pdVar1 = (double)((float)(iVar2 % 10) + ((float)(iVar3 % 10) * 0.0 - 0.0));
      pdVar1[1] = (double)((float)(iVar3 % 10) * 1.0 + 0.0 + 0.0);
      _printf("\t%f + %fi");
    }
  }
  auVar6 = _transpose(CONCAT44(iStack_34,local_38),pvVar4);
  _printf("\n\nTranspose of Complex Matrix A is : ");
  for (local_54 = 0; local_50 = auVar6._0_4_, local_54 < local_50; local_54 = local_54 + 1) {
    _printf("\n");
    iStack_4c = auVar6._4_4_;
    pvVar5 = _malloc((long)iStack_4c << 4);
    *(void **)(auVar6._8_8_ + (long)local_54 * 8) = pvVar5;
    for (local_58 = 0; local_58 < iStack_4c; local_58 = local_58 + 1) {
      iVar2 = _rand();
      iVar3 = _rand();
      pdVar1 = (double *)(*(long *)(auVar6._8_8_ + (long)local_54 * 8) + (long)local_58 * 0x10);
      *pdVar1 = (double)((float)(iVar2 % 10) + ((float)(iVar3 % 10) * 0.0 - 0.0));
      pdVar1[1] = (double)((float)(iVar3 % 10) * 1.0 + 0.0 + 0.0);
      _printf("\t%f + %fi");
    }
  }
  _isHermitian(CONCAT44(iStack_34,local_38),pvVar4);
  _printf("\n\nComplex Matrix A %s hermitian");
  _isUnitary(CONCAT44(iStack_34,local_38),pvVar4);
  _printf("\n\nComplex Matrix A %s unitary");
  _isNormal(CONCAT44(iStack_34,local_38),pvVar4);
  _printf("\n\nComplex Matrix A %s normal");
  return 0;
}



void ___muldc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____muldc3_100004000)();
  return;
}



void ___mulsc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____mulsc3_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

double squaredsum(double *l, int e)
{
   int i; double sum = 0.0;
   for(i = 0 ; i < e ; i++) sum += l[i]*l[i];
   return sum;
}

int main()
{
   double list[6] = {3.0, 1.0, 4.0, 1.0, 5.0, 9.0};

   printf("%lf\n", squaredsum(list, 6));
   printf("%lf\n", squaredsum(list, 0));
   /* the same without using a real list as if it were 0-element long */
   printf("%lf\n", squaredsum(NULL, 0));
   return 0;
}
`,`#include "sum-of-squares.h"



undefined  [16] _squaredsum(long param_1,int param_2)

{
  undefined auVar1 [16];
  undefined8 local_18;
  undefined4 local_10;
  
  local_18 = 0;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    local_18 = NEON_fmadd(*(undefined8 *)(param_1 + (long)local_10 * 8),
                          *(undefined8 *)(param_1 + (long)local_10 * 8),local_18);
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_18;
  return auVar1;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memset(&local_48,0,0x30);
  local_48 = 0x4008000000000000;
  local_40 = 0x3ff0000000000000;
  local_38 = 0x4010000000000000;
  local_30 = 0x3ff0000000000000;
  local_28 = 0x4014000000000000;
  local_20 = 0x4022000000000000;
  _squaredsum(&local_48,6);
  _printf("%lf\n");
  _squaredsum(&local_48,0);
  _printf("%lf\n");
  _squaredsum(0,0);
  iVar1 = _printf("%lf\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004010)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`typedef unsigned long long int ulong; // define a type that represent the limit (64-bit)

ulong mod_mul(ulong a, ulong b, const ulong mod) {
	ulong res = 0, c; // return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (c = b) >= mod - b ? c -= mod : 0, b += c);
	return res % mod;
}

ulong mod_pow(ulong n, ulong exp, const ulong mod) {
	ulong res = 1; // return (n ^ exp) % mod
	for (n %= mod; exp; exp & 1 ? res = mod_mul(res, n, mod) : 0, n = mod_mul(n, n, mod), exp >>= 1);
	return res;
}

ulong square_root(const ulong N) {
	ulong res = 0, rem = N, c, d;
	for (c = 1 << 62; c; c >>= 2) {
		d = res + c;
		res >>= 1;
		if (rem >= d)
			rem -= d, res += c;
	} // returns the square root of N.
	return res;
}

int is_prime(const ulong N) {
	ulong i = 1; // return a truthy value about the primality of N.
	if (N > 1) for (; i < 64 && mod_pow(i, N - 1, N) <= 1; ++i);
	return i == 64;
}

ulong pollard_rho(const ulong N) {
	// Require : N is a composite number, not a square.
	// Ensure : res is a non-trivial factor of N.
	// Option : change the timeout, change the rand function.
	static const int timeout = 18;
	static unsigned long long rand_val = 2994439072U;
	rand_val = (rand_val * 1025416097U + 286824428U) % 4294967291LLU;
	ulong res = 1, a, b, c, i = 0, j = 1, x = 1, y = 1 + rand_val % (N - 1);
	for (; res == 1; ++i) {
		if (i == j) {
			if (j >> timeout)
				break;
			j <<= 1;
			x = y;
		}
		a = y, b = y; // performs y = (y * y) % N
		for (y = 0; a; a & 1 ? b >= N - y ? y -= N : 0, y += b : 0, a >>= 1, (c = b) >= N - b ? c -= N : 0, b += c);
		y = (1 + y) % N;
		for (a = y > x ? y - x : x - y, b = N; (a %= b) && (b %= a);); // compute the gcd(abs(y - x), N);
		res = a | b;
	}
	return res;
}

void factor(const ulong N, ulong *array) {
	// very basic manager that fill the given array (the size of the result is the first array element)	
	// it does not perform initial trial divisions, which is generally highly recommended.
	if (N < 4 || is_prime(N)) {
		if (N > 1 || !*array) array[++*array] = N;
		return;
	}
	ulong x = square_root(N);
	if (x * x != N) x = pollard_rho(N);
	factor(x, array);
	factor(N / x, array);
}

#include <stdio.h>

int main(void) {
	// simple test.
	unsigned long long n = 18446744073709551615U;
	ulong fac[65] = {0};
	factor(n, fac);
	for (ulong i = 1; i <= *fac; ++i)
		printf("* %llu\n", fac[i]);
}
`,`#include "prime-decomposition-4.h"



long _mod_mul(ulong param_1,ulong param_2,ulong param_3)

{
  ulong uVar1;
  ulong local_28;
  ulong local_20;
  ulong local_10;
  ulong local_8;
  
  local_20 = 0;
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = param_2 / param_3;
  }
  local_10 = param_2 - uVar1 * param_3;
  local_8 = param_1;
  while (local_8 != 0) {
    if ((local_8 & 1) != 0) {
      if (param_3 - local_20 <= local_10) {
        local_20 = local_20 - param_3;
      }
      local_20 = local_20 + local_10;
    }
    local_8 = local_8 >> 1;
    local_28 = local_10;
    if (param_3 - local_10 <= local_10) {
      local_28 = local_10 - param_3;
    }
    local_10 = local_10 + local_28;
  }
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = local_20 / param_3;
  }
  return local_20 - uVar1 * param_3;
}



undefined8 _mod_pow(ulong param_1,ulong param_2,ulong param_3)

{
  ulong uVar1;
  undefined8 local_30;
  ulong local_20;
  long local_18;
  
  local_30 = 1;
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = param_1 / param_3;
  }
  local_18 = param_1 - uVar1 * param_3;
  for (local_20 = param_2; local_20 != 0; local_20 = local_20 >> 1) {
    if ((local_20 & 1) != 0) {
      local_30 = _mod_mul(local_30,local_18,param_3);
    }
    local_18 = _mod_mul(local_18,local_18,param_3);
  }
  return local_30;
}



ulong _square_root(ulong param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;
  
  local_10 = 0;
  local_18 = param_2;
  for (local_20 = param_1; local_20 != 0; local_20 = local_20 >> 2) {
    uVar1 = local_10 + local_20;
    local_10 = local_10 >> 1;
    if (uVar1 <= local_18) {
      local_18 = local_18 - uVar1;
      local_10 = local_10 + local_20;
    }
  }
  return local_10;
}



bool _is_prime(ulong param_1)

{
  bool bVar1;
  ulong uVar2;
  undefined8 local_20;
  
  local_20 = 1;
  if (1 < param_1) {
    while( true ) {
      bVar1 = false;
      if (local_20 < 0x40) {
        uVar2 = _mod_pow(local_20,param_1 - 1,param_1);
        bVar1 = uVar2 < 2;
      }
      if (!bVar1) break;
      local_20 = local_20 + 1;
    }
  }
  return local_20 == 0x40;
}



ulong _pollard_rho(ulong param_1)

{
  ulong uVar1;
  ulong uVar2;
  bool bVar3;
  ulong local_50;
  ulong local_48;
  ulong local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  ulong local_20;
  ulong local_18;
  ulong local_10;
  
  DAT_100008000 = (DAT_100008000 * 0x3d1e9ba1 + 0x111897ec) % 0xfffffffb;
  local_10 = 1;
  local_30 = 0;
  local_38 = 1;
  local_40 = 1;
  uVar1 = param_1 - 1;
  uVar2 = 0;
  if (uVar1 != 0) {
    uVar2 = DAT_100008000 / uVar1;
  }
  local_48 = (DAT_100008000 - uVar2 * uVar1) + 1;
  do {
    if (local_10 != 1) {
      return local_10;
    }
    if (local_30 == local_38) {
      if (local_38 >> 0x12 != 0) {
        return 1;
      }
      local_38 = local_38 << 1;
      local_40 = local_48;
    }
    local_18 = local_48;
    local_20 = local_48;
    local_48 = 0;
    while (local_18 != 0) {
      if ((local_18 & 1) != 0) {
        if (param_1 - local_48 <= local_20) {
          local_48 = local_48 - param_1;
        }
        local_48 = local_48 + local_20;
      }
      local_18 = local_18 >> 1;
      local_28 = local_20;
      if (param_1 - local_20 <= local_20) {
        local_28 = local_20 - param_1;
      }
      local_20 = local_20 + local_28;
    }
    uVar1 = 0;
    if (param_1 != 0) {
      uVar1 = (local_48 + 1) / param_1;
    }
    local_48 = (local_48 + 1) - uVar1 * param_1;
    if (local_40 < local_48) {
      local_50 = local_48 - local_40;
    }
    else {
      local_50 = local_40 - local_48;
    }
    local_18 = local_50;
    local_20 = param_1;
    do {
      uVar1 = 0;
      if (local_20 != 0) {
        uVar1 = local_18 / local_20;
      }
      local_18 = local_18 - uVar1 * local_20;
      bVar3 = false;
      if (local_18 != 0) {
        uVar1 = 0;
        if (local_18 != 0) {
          uVar1 = local_20 / local_18;
        }
        local_20 = local_20 - uVar1 * local_18;
        bVar3 = local_20 != 0;
      }
    } while (bVar3);
    local_10 = local_18 | local_20;
    local_30 = local_30 + 1;
  } while( true );
}



void _factor(ulong param_1,long *param_2)

{
  ulong uVar1;
  int iVar2;
  long lVar3;
  ulong local_28;
  
  if ((param_1 < 4) || (iVar2 = _is_prime(param_1), iVar2 != 0)) {
    if ((1 < param_1) || (*param_2 == 0)) {
      lVar3 = *param_2;
      *param_2 = lVar3 + 1;
      param_2[lVar3 + 1] = param_1;
    }
  }
  else {
    local_28 = _square_root(param_1);
    if (local_28 * local_28 - param_1 != 0) {
      local_28 = _pollard_rho(param_1);
    }
    _factor(local_28,param_2);
    uVar1 = 0;
    if (local_28 != 0) {
      uVar1 = param_1 / local_28;
    }
    _factor(uVar1,param_2);
  }
  return;
}



undefined4 entry(void)

{
  uint uVar1;
  ulong uVar2;
  ulong local_248;
  ulong local_230 [65];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _bzero(local_230,0x208);
  uVar2 = _factor(0xffffffffffffffff,local_230);
  for (local_248 = 1; local_248 <= local_230[0]; local_248 = local_248 + 1) {
    uVar1 = _printf("* %llu\n");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int kprime(int n, int k)
{
	int p, f = 0;
	for (p = 2; f < k && p*p <= n; p++)
		while (0 == n % p)
			n /= p, f++;

	return f + (n > 1) == k;
}

int main(void)
{
	int i, c, k;

	for (k = 1; k <= 5; k++) {
		printf("k = %d:", k);

		for (i = 2, c = 0; c < 10; i++)
			if (kprime(i, k)) {
				printf(" %d", i);
				c++;
			}

		putchar('\n');
	}

	return 0;
}
`,`#include "almost-prime.h"



bool _kprime(int param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_4;
  
  local_10 = 0;
  local_c = 2;
  local_4 = param_1;
  while( true ) {
    bVar1 = false;
    if (local_10 < param_2) {
      bVar1 = local_c * local_c <= local_4;
    }
    if (!bVar1) break;
    while( true ) {
      iVar2 = 0;
      if (local_c != 0) {
        iVar2 = local_4 / local_c;
      }
      if (local_4 != iVar2 * local_c) break;
      iVar2 = 0;
      if (local_c != 0) {
        iVar2 = local_4 / local_c;
      }
      local_10 = local_10 + 1;
      local_4 = iVar2;
    }
    local_c = local_c + 1;
  }
  return local_10 + (uint)(1 < local_4) == param_2;
}



undefined8 entry(void)

{
  int iVar1;
  int local_20;
  int local_1c;
  int local_18;
  
  for (local_20 = 1; local_20 < 6; local_20 = local_20 + 1) {
    _printf("k = %d:");
    local_18 = 2;
    local_1c = 0;
    while (local_1c < 10) {
      iVar1 = _kprime(local_18,local_20);
      if (iVar1 != 0) {
        _printf(" %d");
        local_1c = local_1c + 1;
      }
      local_18 = local_18 + 1;
    }
    _putchar(10);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define TRUE 1
#define FALSE 0

typedef int bool;

char grid[8][8];

void placeKings() {
    int r1, r2, c1, c2;
    for (;;) {
        r1 = rand() % 8;
        c1 = rand() % 8;
        r2 = rand() % 8;
        c2 = rand() % 8;
        if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1) {
            grid[r1][c1] = 'K';
            grid[r2][c2] = 'k';
            return;
        }
    }
}

void placePieces(const char *pieces, bool isPawn) {
    int n, r, c;
    int numToPlace = rand() % strlen(pieces);
    for (n = 0; n < numToPlace; ++n) {
        do {
            r = rand() % 8;
            c = rand() % 8;
        }
        while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));
        grid[r][c] = pieces[n];
    }
}

void toFen() {
    char fen[80], ch;
    int r, c, countEmpty = 0, index = 0;
    for (r = 0; r < 8; ++r) {
        for (c = 0; c < 8; ++c) {
            ch = grid[r][c];
            printf("%2c ", ch == 0 ? '.' : ch);
            if (ch == 0) {
                countEmpty++;
            }
            else {
                if (countEmpty > 0) {
                    fen[index++] = countEmpty + 48;
                    countEmpty = 0;
                }
                fen[index++] = ch;
            }
        }
        if (countEmpty > 0) {
            fen[index++] = countEmpty + 48;
            countEmpty = 0;
        }
        fen[index++]= '/';
        printf("\n");
    }
    strcpy(fen + index, " w - - 0 1");
    printf("%s\n", fen);
}

char *createFen() {
    placeKings();
    placePieces("PPPPPPPP", TRUE);
    placePieces("pppppppp", TRUE);
    placePieces("RNBQBNR", FALSE);
    placePieces("rnbqbnr", FALSE);
    toFen();
}

int main() {
    srand(time(NULL));
    createFen();
    return 0;
}
`,`#include "generate-random-chess-position.h"



void _placeKings(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  
  do {
    do {
      iVar1 = _rand();
      iVar1 = iVar1 % 8;
      iVar2 = _rand();
      iVar3 = _rand();
      iVar3 = iVar3 % 8;
      iVar4 = _rand();
    } while (iVar1 == iVar3);
    iVar5 = _abs(iVar1 - iVar3);
  } while ((iVar5 < 2) || (iVar5 = _abs(iVar2 % 8 - iVar4 % 8), iVar5 < 2));
  (&_grid)[(long)(iVar2 % 8) + (long)iVar1 * 8] = 0x4b;
  (&_grid)[(long)(iVar4 % 8) + (long)iVar3 * 8] = 0x6b;
  return;
}



void _placePieces(char *param_1,int param_2)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  size_t sVar6;
  int local_20;
  
  iVar3 = _rand();
  sVar6 = _strlen(param_1);
  iVar1 = 0;
  if (sVar6 != 0) {
    iVar1 = (int)((ulong)(long)iVar3 / sVar6);
  }
  for (local_20 = 0; local_20 < iVar3 - iVar1 * (int)sVar6; local_20 = local_20 + 1) {
    do {
      iVar4 = _rand();
      iVar4 = iVar4 % 8;
      iVar5 = _rand();
      bVar2 = true;
      if (((&_grid)[(long)(iVar5 % 8) + (long)iVar4 * 8] == '\0') && (bVar2 = false, param_2 != 0))
      {
        bVar2 = iVar4 == 7 || iVar4 == 0;
      }
    } while (bVar2);
    (&_grid)[(long)(iVar5 % 8) + (long)iVar4 * 8] = param_1[local_20];
  }
  return;
}



void _toFen(void)

{
  char cVar1;
  int iVar2;
  long lVar3;
  int local_7c;
  int local_78;
  int local_74;
  int local_70;
  char acStack_68 [80];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_78 = 0;
  local_7c = 0;
  for (local_70 = 0; local_70 < 8; local_70 = local_70 + 1) {
    for (local_74 = 0; local_74 < 8; local_74 = local_74 + 1) {
      cVar1 = (&_grid)[(long)local_74 + (long)local_70 * 8];
      _printf("%2c ");
      if (cVar1 == '\0') {
        local_78 = local_78 + 1;
      }
      else {
        if (0 < local_78) {
          lVar3 = (long)local_7c;
          local_7c = local_7c + 1;
          acStack_68[lVar3] = (char)local_78 + '0';
          local_78 = 0;
        }
        lVar3 = (long)local_7c;
        local_7c = local_7c + 1;
        acStack_68[lVar3] = cVar1;
      }
    }
    if (0 < local_78) {
      lVar3 = (long)local_7c;
      local_7c = local_7c + 1;
      acStack_68[lVar3] = (char)local_78 + '0';
      local_78 = 0;
    }
    lVar3 = (long)local_7c;
    local_7c = local_7c + 1;
    acStack_68[lVar3] = '/';
    _printf("\n");
  }
  ___strcpy_chk(acStack_68 + local_7c," w - - 0 1",0xffffffffffffffff);
  iVar2 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return;
}



undefined8 _createFen(void)

{
  undefined8 local_18;
  
  _placeKings();
  _placePieces("PPPPPPPP");
  _placePieces("pppppppp",1);
  _placePieces("RNBQBNR");
  _placePieces("rnbqbnr",0);
  _toFen();
  return local_18;
}



undefined4 entry(void)

{
  time_t tVar1;
  
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  _createFen();
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _abs(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__abs_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004040)();
  return tVar1;
}


`
`#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t condm = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int bang = 0;

#define WAITBANG() do { \
   pthread_mutex_lock(&condm); \
   while( bang == 0 ) \
   { \
      pthread_cond_wait(&cond, &condm); \
   } \
   pthread_mutex_unlock(&condm); } while(0);\

void *t_enjoy(void *p)
{
  WAITBANG();
  printf("Enjoy\n");
  pthread_exit(0);
}

void *t_rosetta(void *p)
{
  WAITBANG();
  printf("Rosetta\n");
  pthread_exit(0);
}

void *t_code(void *p)
{
  WAITBANG();
  printf("Code\n");
  pthread_exit(0);
}

typedef void *(*threadfunc)(void *);
int main()
{
   int i;
   pthread_t a[3];
   threadfunc p[3] = {t_enjoy, t_rosetta, t_code};

   for(i=0;i<3;i++)
   {
     pthread_create(&a[i], NULL, p[i], NULL);
   }
   sleep(1);
   bang = 1;
   pthread_cond_broadcast(&cond);
   for(i=0;i<3;i++)
   {
     pthread_join(a[i], NULL);
   }
}
`,`#include "concurrent-computing-1.h"



void _t_enjoy(void)

{
  _pthread_mutex_lock((pthread_mutex_t *)&_condm);
  while (_bang == 0) {
    _pthread_cond_wait((pthread_cond_t *)&_cond,(pthread_mutex_t *)&_condm);
  }
  _pthread_mutex_unlock((pthread_mutex_t *)&_condm);
  _printf("Enjoy\n");
                    // WARNING: Subroutine does not return
  _pthread_exit((void *)0x0);
}



void _t_rosetta(void)

{
  _pthread_mutex_lock((pthread_mutex_t *)&_condm);
  while (_bang == 0) {
    _pthread_cond_wait((pthread_cond_t *)&_cond,(pthread_mutex_t *)&_condm);
  }
  _pthread_mutex_unlock((pthread_mutex_t *)&_condm);
  _printf("Rosetta\n");
                    // WARNING: Subroutine does not return
  _pthread_exit((void *)0x0);
}



void _t_code(void)

{
  _pthread_mutex_lock((pthread_mutex_t *)&_condm);
  while (_bang == 0) {
    _pthread_cond_wait((pthread_cond_t *)&_cond,(pthread_mutex_t *)&_condm);
  }
  _pthread_mutex_unlock((pthread_mutex_t *)&_condm);
  _printf("Code\n");
                    // WARNING: Subroutine does not return
  _pthread_exit((void *)0x0);
}



undefined4 entry(void)

{
  int iVar1;
  int local_58;
  code *local_50 [4];
  pthread_t ap_Stack_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_50[1] = _t_rosetta;
  local_50[0] = _t_enjoy;
  local_50[2] = _t_code;
  for (local_58 = 0; local_58 < 3; local_58 = local_58 + 1) {
    _pthread_create(ap_Stack_30 + local_58,(pthread_attr_t *)0x0,(void **)local_50[local_58],
                    (void *)0x0);
  }
  _sleep(1);
  _bang = 1;
  iVar1 = _pthread_cond_broadcast((pthread_cond_t *)&_cond);
  for (local_58 = 0; local_58 < 3; local_58 = local_58 + 1) {
    iVar1 = _pthread_join(ap_Stack_30[local_58],(void **)0x0);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cond_broadcast(pthread_cond_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cond_broadcast_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cond_wait(pthread_cond_t *param_1,pthread_mutex_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cond_wait_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_create(pthread_t *param_1,pthread_attr_t *param_2,void **param_3,void *param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_create_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _pthread_exit(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pthread_exit_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_join(pthread_t param_1,void **param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_join_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_lock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_lock_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_unlock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_unlock_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint _sleep(uint param_1)

{
  uint uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__sleep_100004050)(param_1);
  return uVar1;
}


`
`#include<stdio.h>

int main()
{
	char ch, str[100];
	int i;
	
	do{
		printf("\nEnter the string :");
		fgets(str,100,stdin);
		for(i=0;str[i]!=00;i++)
		{
			if(str[i]=='#'||str[i]==';')
			{
				str[i]=00;
				break;
			}
		}
		printf("\nThe modified string is : %s",str);
		printf("\nDo you want to repeat (y/n): ");
		scanf("%c",&ch);
		fflush(stdin);
	}while(ch=='y'||ch=='Y');
	
	return 0;
}
`,`#include "strip-comments-from-a-string.h"



undefined8 entry(void)

{
  int iVar1;
  int local_88;
  char local_81;
  char acStack_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  do {
    _printf("\nEnter the string :");
    _fgets(acStack_7c,100,*(FILE **)PTR____stdinp_100004010);
    for (local_88 = 0; acStack_7c[local_88] != '\0'; local_88 = local_88 + 1) {
      if ((acStack_7c[local_88] == '#') || (acStack_7c[local_88] == ';')) {
        acStack_7c[local_88] = '\0';
        break;
      }
    }
    _printf("\nThe modified string is : %s");
    _printf("\nDo you want to repeat (y/n): ");
    _scanf("%c");
    iVar1 = _fflush(*(FILE **)PTR____stdinp_100004010);
    if (local_81 != 'y' && local_81 != 'Y') {
      if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
        ___stack_chk_fail(iVar1);
      }
      return 0;
    }
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004020)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004030)((int)param_1);
  return iVar1;
}


`
`#include<stdio.h>

int main()
{
	int hyperCube[5][4][3][2];
	
	/*An element is set*/
	
	hyperCube[4][3][2][1] = 1;
	
	/*IMPORTANT : C ( and hence C++ and Java and everyone of the family ) arrays are zero based.
	The above element is thus actually the last element of the hypercube.*/
	
	/*Now we print out that element*/
	
	printf("\n%d",hyperCube[4][3][2][1]);
	
	/*But that's not the only way to get at that element*/
	printf("\n%d",*(*(*(*(hyperCube + 4) + 3) + 2) + 1));

	/*Yes, I know, it's beautiful*/
	*(*(*(*(hyperCube+3)+2)+1)) = 3;
	
	printf("\n%d",hyperCube[3][2][1][0]);
	
	return 0;
}
`,`#include "multi-dimensional-array-2.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("\n%d");
  _printf("\n%d");
  iVar1 = _printf("\n%d");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

int main() {
    int n = 1, count = 0, sq, cr;
    for ( ; count < 30; ++n) {
        sq = n * n;
        cr = (int)cbrt((double)sq);
        if (cr * cr * cr != sq) {
            count++;
            printf("%d\n", sq);
        }
        else {
            printf("%d is square and cube\n", sq);
        }
    }
    return 0;
}
`,`#include "square-but-not-cube.h"



undefined8 entry(ulong param_1)

{
  uint uVar1;
  int iVar2;
  double dVar3;
  int local_1c;
  int local_18;
  
  local_18 = 1;
  local_1c = 0;
  while (local_1c < 0x1e) {
    dVar3 = (double)_cbrt((double)(long)(local_18 * local_18),param_1);
    iVar2 = (int)dVar3;
    if (iVar2 * iVar2 * iVar2 == local_18 * local_18) {
      uVar1 = _printf("%d is square and cube\n");
    }
    else {
      local_1c = local_1c + 1;
      uVar1 = _printf("%d\n");
    }
    param_1 = (ulong)uVar1;
    local_18 = local_18 + 1;
  }
  return 0;
}



void _cbrt(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cbrt_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdio.h>

char *months[] = {
    "ERR", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

struct Date {
    int month, day;
    bool active;
} dates[] = {
    {5,15,true}, {5,16,true}, {5,19,true},
    {6,17,true}, {6,18,true},
    {7,14,true}, {7,16,true},
    {8,14,true}, {8,15,true}, {8,17,true}
};
#define UPPER_BOUND (sizeof(dates) / sizeof(struct Date))

void printRemaining() {
    int i, c;
    for (i = 0, c = 0; i < UPPER_BOUND; i++) {
        if (dates[i].active) {
            c++;
        }
    }
    printf("%d remaining.\n", c);
}

void printAnswer() {
    int i;
    for (i = 0; i < UPPER_BOUND; i++) {
        if (dates[i].active) {
            printf("%s, %d\n", months[dates[i].month], dates[i].day);
        }
    }
}

void firstPass() {
    // the month cannot have a unique day
    int i, j, c;
    for (i = 0; i < UPPER_BOUND; i++) {
        c = 0;

        for (j = 0; j < UPPER_BOUND; j++) {
            if (dates[j].day == dates[i].day) {
                c++;
            }
        }

        if (c == 1) {
            for (j = 0; j < UPPER_BOUND; j++) {
                if (!dates[j].active) continue;
                if (dates[j].month == dates[i].month) {
                    dates[j].active = false;
                }
            }
        }
    }
}

void secondPass() {
    // the day must now be unique
    int i, j, c;
    for (i = 0; i < UPPER_BOUND; i++) {
        if (!dates[i].active) continue;
        c = 0;

        for (j = 0; j < UPPER_BOUND; j++) {
            if (!dates[j].active) continue;
            if (dates[j].day == dates[i].day) {
                c++;
            }
        }

        if (c > 1) {
            for (j = 0; j < UPPER_BOUND; j++) {
                if (!dates[j].active) continue;
                if (dates[j].day == dates[i].day) {
                    dates[j].active = false;
                }
            }
        }
    }
}

void thirdPass() {
    // the month must now be unique
    int i, j, c;
    for (i = 0; i < UPPER_BOUND; i++) {
        if (!dates[i].active) continue;
        c = 0;

        for (j = 0; j < UPPER_BOUND; j++) {
            if (!dates[j].active) continue;
            if (dates[j].month == dates[i].month) {
                c++;
            }
        }

        if (c > 1) {
            for (j = 0; j < UPPER_BOUND; j++) {
                if (!dates[j].active) continue;
                if (dates[j].month == dates[i].month) {
                    dates[j].active = false;
                }
            }
        }
    }
}

int main() {
    printRemaining();
    // the month cannot have a unique day
    firstPass();

    printRemaining();
    // the day must now be unique
    secondPass();

    printRemaining();
    // the month must now be unique
    thirdPass();

    printAnswer();
    return 0;
}
`,`#include "cheryls-birthday.h"



int _printRemaining(void)

{
  int iVar1;
  uint local_14;
  
  for (local_14 = 0; local_14 < 10; local_14 = local_14 + 1) {
  }
  iVar1 = _printf("%d remaining.\n");
  return iVar1;
}



ulong _printAnswer(ulong param_1)

{
  uint uVar1;
  uint local_14;
  
  for (local_14 = 0; local_14 < 10; local_14 = local_14 + 1) {
    if (((&DAT_100008070)[(long)(int)local_14 * 0xc] & 1) != 0) {
      uVar1 = _printf("%s, %d\n");
      param_1 = (ulong)uVar1;
    }
  }
  return param_1;
}



void _firstPass(void)

{
  int local_c;
  uint local_8;
  uint local_4;
  
  for (local_4 = 0; local_4 < 10; local_4 = local_4 + 1) {
    local_c = 0;
    for (local_8 = 0; local_8 < 10; local_8 = local_8 + 1) {
      if (*(int *)(&DAT_10000806c + (long)(int)local_8 * 0xc) ==
          *(int *)(&DAT_10000806c + (long)(int)local_4 * 0xc)) {
        local_c = local_c + 1;
      }
    }
    if (local_c == 1) {
      for (local_8 = 0; local_8 < 10; local_8 = local_8 + 1) {
        if ((((&DAT_100008070)[(long)(int)local_8 * 0xc] & 1) != 0) &&
           (*(int *)(&_dates + (long)(int)local_8 * 0xc) ==
            *(int *)(&_dates + (long)(int)local_4 * 0xc))) {
          (&DAT_100008070)[(long)(int)local_8 * 0xc] = 0;
        }
      }
    }
  }
  return;
}



void _secondPass(void)

{
  int local_c;
  uint local_8;
  uint local_4;
  
  for (local_4 = 0; local_4 < 10; local_4 = local_4 + 1) {
    if (((&DAT_100008070)[(long)(int)local_4 * 0xc] & 1) != 0) {
      local_c = 0;
      for (local_8 = 0; local_8 < 10; local_8 = local_8 + 1) {
        if ((((&DAT_100008070)[(long)(int)local_8 * 0xc] & 1) != 0) &&
           (*(int *)(&DAT_10000806c + (long)(int)local_8 * 0xc) ==
            *(int *)(&DAT_10000806c + (long)(int)local_4 * 0xc))) {
          local_c = local_c + 1;
        }
      }
      if (1 < local_c) {
        for (local_8 = 0; local_8 < 10; local_8 = local_8 + 1) {
          if ((((&DAT_100008070)[(long)(int)local_8 * 0xc] & 1) != 0) &&
             (*(int *)(&DAT_10000806c + (long)(int)local_8 * 0xc) ==
              *(int *)(&DAT_10000806c + (long)(int)local_4 * 0xc))) {
            (&DAT_100008070)[(long)(int)local_8 * 0xc] = 0;
          }
        }
      }
    }
  }
  return;
}



void _thirdPass(void)

{
  int local_c;
  uint local_8;
  uint local_4;
  
  for (local_4 = 0; local_4 < 10; local_4 = local_4 + 1) {
    if (((&DAT_100008070)[(long)(int)local_4 * 0xc] & 1) != 0) {
      local_c = 0;
      for (local_8 = 0; local_8 < 10; local_8 = local_8 + 1) {
        if ((((&DAT_100008070)[(long)(int)local_8 * 0xc] & 1) != 0) &&
           (*(int *)(&_dates + (long)(int)local_8 * 0xc) ==
            *(int *)(&_dates + (long)(int)local_4 * 0xc))) {
          local_c = local_c + 1;
        }
      }
      if (1 < local_c) {
        for (local_8 = 0; local_8 < 10; local_8 = local_8 + 1) {
          if ((((&DAT_100008070)[(long)(int)local_8 * 0xc] & 1) != 0) &&
             (*(int *)(&_dates + (long)(int)local_8 * 0xc) ==
              *(int *)(&_dates + (long)(int)local_4 * 0xc))) {
            (&DAT_100008070)[(long)(int)local_8 * 0xc] = 0;
          }
        }
      }
    }
  }
  return;
}



undefined4 entry(void)

{
  _printRemaining();
  _firstPass();
  _printRemaining();
  _secondPass();
  _printRemaining();
  _thirdPass();
  _printAnswer();
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

#define BUF_SIZE ( 256 )

char *get_nth_line( FILE *f, int line_no )
{
    char   buf[ BUF_SIZE ];
    size_t curr_alloc = BUF_SIZE, curr_ofs = 0;
    char   *line      = malloc( BUF_SIZE );
    int    in_line    = line_no == 1;
    size_t bytes_read;

    /* Illegal to ask for a line before the first one. */
    if ( line_no < 1 )
        return NULL;

    /* Handle out-of-memory by returning NULL */
    if ( !line )
        return NULL;

    /* Scan the file looking for newlines */
    while ( line_no &&
            ( bytes_read = fread( buf, 1, BUF_SIZE, f ) ) > 0 )
    {
        int i;

        for ( i = 0 ; i < bytes_read ; i++ )
        {
            if ( in_line )
            {
                if ( curr_ofs >= curr_alloc )
                {
                    curr_alloc <<= 1;
                    line = realloc( line, curr_alloc );

                    if ( !line )    /* out of memory? */
                        return NULL;
                }
                line[ curr_ofs++ ] = buf[i];
            }

            if ( buf[i] == '\n' )
            {
                line_no--;

                if ( line_no == 1 )
                    in_line = 1;

                if ( line_no == 0 )
                    break;
            }
        }
    }

    /* Didn't find the line? */
    if ( line_no != 0 )
    {
        free( line );
        return NULL;
    }

    /* Resize allocated buffer to what's exactly needed by the string
       and the terminating NUL character.  Note that this code *keeps*
       the terminating newline as part of the string.
     */
    line = realloc( line, curr_ofs + 1 );

    if ( !line ) /* out of memory? */
        return NULL;

    /* Add the terminating NUL. */
    line[ curr_ofs ] = '\0';

    /* Return the line.  Caller is responsible for freeing it. */
    return line;
}


/* Test program.  Prints out the 7th line of input from stdin, if any */
int main( int argc, char *argv[] )
{
    char *line7 = get_nth_line( stdin, 7 );

    if ( line7 )
    {
        printf("The 7th line of input was:\n%s\n", line7 );
        free( line7 );
    } else
    {
        printf("Did not find the 7th line of input.  Reason:  ");
        if ( feof( stdin ) )
            puts("End of file reached.");
        else if ( ferror( stdin ) )
            puts("Error reading input.");
        else
            puts("Out of memory.");
    }

    return 0;
}
`,`#include "read-a-specific-line-from-a-file-2.h"



void * _get_nth_line(FILE *param_1,int param_2)

{
  bool bVar1;
  bool bVar2;
  int local_16c;
  ulong local_168;
  void *local_158;
  ulong local_150;
  size_t local_148;
  int local_13c;
  void *local_130;
  char acStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_148 = 0x100;
  local_150 = 0;
  local_158 = _malloc(0x100);
  bVar2 = param_2 == 1;
  if (param_2 < 1) {
    local_130 = (void *)0x0;
  }
  else {
    local_13c = param_2;
    if (local_158 == (void *)0x0) {
      local_130 = (void *)0x0;
    }
    else {
LAB_100003b80:
      bVar1 = false;
      if (local_13c != 0) {
        local_168 = _fread(acStack_128,1,0x100,param_1);
        bVar1 = local_168 != 0;
      }
      if (bVar1) {
        for (local_16c = 0; (ulong)(long)local_16c < local_168; local_16c = local_16c + 1) {
          if (bVar2) {
            if (local_148 <= local_150) {
              local_148 = local_148 << 1;
              local_158 = _realloc(local_158,local_148);
              if (local_158 == (void *)0x0) {
                local_130 = (void *)0x0;
                goto LAB_100003d70;
              }
            }
            *(char *)((long)local_158 + local_150) = acStack_128[local_16c];
            local_150 = local_150 + 1;
          }
          if (acStack_128[local_16c] == '\n') {
            local_13c = local_13c + -1;
            if (local_13c == 1) {
              bVar2 = true;
            }
            if (local_13c == 0) break;
          }
        }
        goto LAB_100003b80;
      }
      if (local_13c == 0) {
        local_130 = _realloc(local_158,local_150 + 1);
        if (local_130 == (void *)0x0) {
          local_130 = (void *)0x0;
        }
        else {
          *(undefined *)((long)local_130 + local_150) = 0;
        }
      }
      else {
        _free(local_158);
        local_130 = (void *)0x0;
      }
    }
  }
LAB_100003d70:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return local_130;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = (void *)_get_nth_line(*(undefined8 *)PTR____stdinp_100004010,7);
  if (pvVar2 == (void *)0x0) {
    _printf("Did not find the 7th line of input.  Reason:  ");
    iVar1 = _feof(*(FILE **)PTR____stdinp_100004010);
    if (iVar1 == 0) {
      iVar1 = _ferror(*(FILE **)PTR____stdinp_100004010);
      if (iVar1 == 0) {
        _puts("Out of memory.");
      }
      else {
        _puts("Error reading input.");
      }
    }
    else {
      _puts("End of file reached.");
    }
  }
  else {
    _printf("The 7th line of input was:\n%s\n");
    _free(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _feof(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__feof_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _ferror(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__ferror_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fread(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fread_100004028)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004050)();
  return pvVar1;
}


`
`#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

void binprint(unsigned int n, unsigned int m)
{
	char c[sizeof(n) * 8 + 1];
	int i = 0;
	while (m >>= 1)	c[i++] = n & m ? '#' : '-';
	c[i] = 0;
	puts(c);
}

int main(int c, char **v)
{
	unsigned int n, gap, left, right;
	if (c < 2 || ! (n = 1 << atoi(v[1]))) n = 16;

	for (gap = 2; gap < n; gap <<= 1)
		for (left = gap << 1; left < n; left |= left << 1)
			for (right = 1; right < gap; right++)
				binprint(left | right, n);

	return 0;
}
`,`#include "non-continuous-subsequences-2.h"



void _binprint(uint param_1,uint param_2)

{
  int iVar1;
  char cVar2;
  long lVar3;
  int local_48;
  uint local_44;
  char acStack_39 [33];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_48 = 0;
  local_44 = param_2;
  while (local_44 = local_44 >> 1, local_44 != 0) {
    cVar2 = '#';
    if ((param_1 & local_44) == 0) {
      cVar2 = '-';
    }
    lVar3 = (long)local_48;
    local_48 = local_48 + 1;
    acStack_39[lVar3] = cVar2;
  }
  acStack_39[local_48] = '\0';
  iVar1 = _puts(acStack_39);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  uint uVar1;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  if (1 < param_1) {
    uVar1 = _atoi(*(char **)(param_2 + 8));
    local_24 = 1 << (ulong)(uVar1 & 0x1f);
    if (local_24 != 0) goto LAB_100003eb0;
  }
  local_24 = 0x10;
LAB_100003eb0:
  for (local_28 = 2; local_28 < local_24; local_28 = local_28 << 1) {
    for (local_2c = local_28 << 1; local_2c < local_24; local_2c = local_2c | local_2c << 1) {
      for (local_30 = 1; local_30 < local_28; local_30 = local_30 + 1) {
        _binprint(local_2c | local_30,local_24);
      }
    }
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004018)((int)param_1);
  return iVar1;
}


`
`#define _CRT_SECURE_NO_WARNINGS    // turn off panic warnings
#define _CRT_NONSTDC_NO_WARNINGS   // enable old-gold POSIX names in MSVS

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


struct StringArray
{
    size_t sizeOfArray;
    size_t numberOfElements;
    char** elements;
};
typedef struct StringArray* StringArray;

StringArray StringArray_new(size_t size)
{
    StringArray this = calloc(1, sizeof(struct StringArray));
    if (this)
    {
        this->elements = calloc(size, sizeof(int));
        if (this->elements)
            this->sizeOfArray = size;
        else
        {
            free(this);
            this = NULL;
        }
    }
    return this;
}

void StringArray_delete(StringArray* ptr_to_this)
{
    assert(ptr_to_this != NULL);
    StringArray this = (*ptr_to_this);
    if (this)
    {
        for (size_t i = 0; i < this->sizeOfArray; i++)
            free(this->elements[i]);
        free(this->elements);
        free(this);
        this = NULL;
    }
}

void StringArray_add(StringArray this, ...)
{
    char* s;
    va_list args;
    va_start(args, this);
    while (this->numberOfElements < this->sizeOfArray && (s = va_arg(args, char*)))
        this->elements[this->numberOfElements++] = strdup(s);
    va_end(args);
}


int main(int argc, char* argv[])
{
    StringArray a = StringArray_new(10);
    StringArray_add(a, "apple", "orange", NULL);

    printf(
        "There are %d elements in an array with a capacity of %d elements:\n\n",
        a->numberOfElements, a->sizeOfArray);

    for (size_t i = 0; i < a->numberOfElements; i++)
        printf("    the element %d is the string \"%s\"\n", i, a->elements[i]);

    StringArray_delete(&a);

    return EXIT_SUCCESS;
}
`,`#include "array-length-3.h"



size_t * _StringArray_new(size_t param_1)

{
  void *pvVar1;
  size_t *local_20;
  
  local_20 = (size_t *)_calloc(1,0x18);
  if (local_20 != (size_t *)0x0) {
    pvVar1 = _calloc(param_1,4);
    local_20[2] = (size_t)pvVar1;
    if (local_20[2] == 0) {
      _free(local_20);
      local_20 = (size_t *)0x0;
    }
    else {
      *local_20 = param_1;
    }
  }
  return local_20;
}



void _StringArray_delete(undefined8 *param_1)

{
  ulong *puVar1;
  ulong local_28;
  
  if (param_1 == (undefined8 *)0x0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("StringArray_delete","array-length-3.c",0x26,"ptr_to_this != NULL");
  }
  puVar1 = (ulong *)*param_1;
  if (puVar1 != (ulong *)0x0) {
    for (local_28 = 0; local_28 < *puVar1; local_28 = local_28 + 1) {
      _free(*(void **)(puVar1[2] + local_28 * 8));
    }
    _free((void *)puVar1[2]);
    _free(puVar1);
  }
  return;
}



void _StringArray_add(ulong *param_1)

{
  bool bVar1;
  char *pcVar2;
  ulong uVar3;
  char *local_20;
  
  while( true ) {
    bVar1 = false;
    if (param_1[1] < *param_1) {
      local_20 = *(char **)register0x00000008;
      register0x00000008 = (BADSPACEBASE *)((long)register0x00000008 + 8);
      bVar1 = local_20 != (char *)0x0;
    }
    if (!bVar1) break;
    pcVar2 = _strdup(local_20);
    uVar3 = param_1[1];
    param_1[1] = uVar3 + 1;
    *(char **)(param_1[2] + uVar3 * 8) = pcVar2;
  }
  return;
}



undefined8 entry(undefined4 param_1,undefined8 param_2)

{
  ulong local_30;
  long local_28;
  undefined8 local_20;
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = param_2;
  local_18 = param_1;
  local_28 = _StringArray_new(10);
  _StringArray_add(local_28);
  _printf("There are %d elements in an array with a capacity of %d elements:\n\n");
  for (local_30 = 0; local_30 < *(ulong *)(local_28 + 8); local_30 = local_30 + 1) {
    _printf("    the element %d is the string \"%s\"\n");
  }
  _StringArray_delete(&local_28);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004020)();
  return pcVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h> /*Optional, but better if included as fabs, labs and abs functions are being used. */

int main(int argC, char* argV[])
{
	
	int i,zeroCount= 0,firstNonZero = -1;
	double* vector;
	
	if(argC == 1){
		printf("Usage : %s <Vector component coefficients seperated by single space>",argV[0]);
	}
	
	else{
		
		printf("Vector for [");
		for(i=1;i<argC;i++){
			printf("%s,",argV[i]);
		}
		printf("\b] -> ");
		
		
		vector = (double*)malloc((argC-1)*sizeof(double));
		
		for(i=1;i<=argC;i++){
			vector[i-1] = atof(argV[i]);
			if(vector[i-1]==0.0)
				zeroCount++;
			if(vector[i-1]!=0.0 && firstNonZero==-1)
				firstNonZero = i-1;
		}

		if(zeroCount == argC){
			printf("0");
		}
		
		else{
			for(i=0;i<argC;i++){
				if(i==firstNonZero && vector[i]==1)
					printf("e%d ",i+1);
				else if(i==firstNonZero && vector[i]==-1)
					printf("- e%d ",i+1);
				else if(i==firstNonZero && vector[i]<0 && fabs(vector[i])-abs(vector[i])>0.0)
					printf("- %lf e%d ",fabs(vector[i]),i+1);
				else if(i==firstNonZero && vector[i]<0 && fabs(vector[i])-abs(vector[i])==0.0)
					printf("- %ld e%d ",labs(vector[i]),i+1);
				else if(i==firstNonZero && vector[i]>0 && fabs(vector[i])-abs(vector[i])>0.0)
					printf("%lf e%d ",vector[i],i+1);
				else if(i==firstNonZero && vector[i]>0 && fabs(vector[i])-abs(vector[i])==0.0)
					printf("%ld e%d ",vector[i],i+1);
				else if(fabs(vector[i])==1.0 && i!=0)
					printf("%c e%d ",(vector[i]==-1)?'-':'+',i+1);
				else if(i!=0 && vector[i]!=0 && fabs(vector[i])-abs(vector[i])>0.0)
					printf("%c %lf e%d ",(vector[i]<0)?'-':'+',fabs(vector[i]),i+1);
				else if(i!=0 && vector[i]!=0 && fabs(vector[i])-abs(vector[i])==0.0)
					printf("%c %ld e%d ",(vector[i]<0)?'-':'+',labs(vector[i]),i+1);				
			}
		}
	}
	
	free(vector);
	
	return 0;
}
`,`#include "display-a-linear-combination.h"



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  double dVar2;
  void *local_38;
  int local_2c;
  int local_28;
  int local_24;
  
  local_28 = 0;
  local_2c = -1;
  if (param_1 == 1) {
    _printf("Usage : %s <Vector component coefficients seperated by single space>");
  }
  else {
    _printf("Vector for [");
    for (local_24 = 1; local_24 < param_1; local_24 = local_24 + 1) {
      _printf("%s,");
    }
    _printf("\b] -> ");
    local_38 = _malloc((long)(param_1 + -1) << 3);
    for (local_24 = 1; local_24 <= param_1; local_24 = local_24 + 1) {
      dVar2 = _atof(*(char **)(param_2 + (long)local_24 * 8));
      *(double *)((long)local_38 + (long)(local_24 + -1) * 8) = dVar2;
      if (*(double *)((long)local_38 + (long)(local_24 + -1) * 8) == 0.0) {
        local_28 = local_28 + 1;
      }
      if ((*(double *)((long)local_38 + (long)(local_24 + -1) * 8) != 0.0) && (local_2c == -1)) {
        local_2c = local_24 + -1;
      }
    }
    if (local_28 == param_1) {
      _printf("0");
    }
    else {
      for (local_24 = 0; local_24 < param_1; local_24 = local_24 + 1) {
        if ((local_24 == local_2c) && (*(double *)((long)local_38 + (long)local_24 * 8) == 1.0)) {
          _printf("e%d ");
        }
        else if ((local_24 == local_2c) &&
                (*(double *)((long)local_38 + (long)local_24 * 8) == -1.0)) {
          _printf("- e%d ");
        }
        else if (((local_24 != local_2c) ||
                 (0.0 <= *(double *)((long)local_38 + (long)local_24 * 8))) ||
                (dVar2 = *(double *)((long)local_38 + (long)local_24 * 8),
                iVar1 = _abs((int)*(double *)((long)local_38 + (long)local_24 * 8)),
                ABS(dVar2) - (double)iVar1 <= 0.0)) {
          if (((local_24 != local_2c) || (0.0 <= *(double *)((long)local_38 + (long)local_24 * 8)))
             || (dVar2 = *(double *)((long)local_38 + (long)local_24 * 8),
                iVar1 = _abs((int)*(double *)((long)local_38 + (long)local_24 * 8)),
                ABS(dVar2) - (double)iVar1 != 0.0)) {
            if (((local_24 != local_2c) || (*(double *)((long)local_38 + (long)local_24 * 8) <= 0.0)
                ) || (dVar2 = *(double *)((long)local_38 + (long)local_24 * 8),
                     iVar1 = _abs((int)*(double *)((long)local_38 + (long)local_24 * 8)),
                     ABS(dVar2) - (double)iVar1 <= 0.0)) {
              if (((local_24 != local_2c) ||
                  (*(double *)((long)local_38 + (long)local_24 * 8) <= 0.0)) ||
                 (dVar2 = *(double *)((long)local_38 + (long)local_24 * 8),
                 iVar1 = _abs((int)*(double *)((long)local_38 + (long)local_24 * 8)),
                 ABS(dVar2) - (double)iVar1 != 0.0)) {
                if ((ABS(*(double *)((long)local_38 + (long)local_24 * 8)) == 1.0) &&
                   (local_24 != 0)) {
                  _printf("%c e%d ");
                }
                else if ((local_24 == 0) ||
                        ((*(double *)((long)local_38 + (long)local_24 * 8) == 0.0 ||
                         (dVar2 = *(double *)((long)local_38 + (long)local_24 * 8),
                         iVar1 = _abs((int)*(double *)((long)local_38 + (long)local_24 * 8)),
                         ABS(dVar2) - (double)iVar1 <= 0.0)))) {
                  if ((local_24 != 0) &&
                     ((*(double *)((long)local_38 + (long)local_24 * 8) != 0.0 &&
                      (dVar2 = *(double *)((long)local_38 + (long)local_24 * 8),
                      iVar1 = _abs((int)*(double *)((long)local_38 + (long)local_24 * 8)),
                      ABS(dVar2) - (double)iVar1 == 0.0)))) {
                    _labs((long)*(double *)((long)local_38 + (long)local_24 * 8));
                    _printf("%c %ld e%d ");
                  }
                }
                else {
                  _printf("%c %lf e%d ");
                }
              }
              else {
                _printf("%ld e%d ");
              }
            }
            else {
              _printf("%lf e%d ");
            }
          }
          else {
            _labs((long)*(double *)((long)local_38 + (long)local_24 * 8));
            _printf("- %ld e%d ");
          }
        }
        else {
          _printf("- %lf e%d ");
        }
      }
    }
  }
  _free(local_38);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _abs(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__abs_100004000)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _atof(char *param_1)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__atof_100004008)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _labs(long param_1)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__labs_100004018)();
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void shell_sort (int *a, int n) {
    int h, i, j, t;
    for (h = n; h /= 2;) {
        for (i = h; i < n; i++) {
            t = a[i];
            for (j = i; j >= h && t < a[j - h]; j -= h) {
                a[j] = a[j - h];
            }
            a[j] = t;
        }
    }
}

int main (int ac, char **av) {
    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
    int n = sizeof a / sizeof a[0];
    int i;
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    shell_sort(a, n);
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    return 0;
}
`,`#include "sorting-algorithms-shell-sort.h"



void _shell_sort(long param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  
  local_10 = param_2;
  while (local_10 = local_10 / 2, local_14 = local_10, local_10 != 0) {
    for (; local_14 < param_2; local_14 = local_14 + 1) {
      iVar2 = *(int *)(param_1 + (long)local_14 * 4);
      local_18 = local_14;
      while( true ) {
        bVar1 = false;
        if (local_10 <= local_18) {
          bVar1 = iVar2 < *(int *)(param_1 + (long)(local_18 - local_10) * 4);
        }
        if (!bVar1) break;
        *(undefined4 *)(param_1 + (long)local_18 * 4) =
             *(undefined4 *)(param_1 + (long)(local_18 - local_10) * 4);
        local_18 = local_18 - local_10;
      }
      *(int *)(param_1 + (long)local_18 * 4) = iVar2;
    }
  }
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  int local_58;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f6c,0x28);
  for (local_58 = 0; local_58 < 10; local_58 = local_58 + 1) {
    _printf("%d%s");
  }
  uVar2 = _shell_sort(auStack_40,10);
  for (local_58 = 0; local_58 < 10; local_58 = local_58 + 1) {
    uVar1 = _printf("%d%s");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define MAT_ELEM(rows,cols,r,c) (r*cols+c)

//Improve performance by assuming output matrices do not overlap with
//input matrices. If this is C++, use the __restrict extension instead
#ifdef __cplusplus
    typedef double * const __restrict MAT_OUT_t;
#else
    typedef double * const restrict MAT_OUT_t;
#endif
typedef const double * const MAT_IN_t;

static inline void mat_mult(
    const int m,
    const int n,
    const int p,
    MAT_IN_t a,
    MAT_IN_t b,
    MAT_OUT_t c)
{
    for (int row=0; row<m; row++) {
        for (int col=0; col<p; col++) {
            c[MAT_ELEM(m,p,row,col)] = 0;
            for (int i=0; i<n; i++) {
                c[MAT_ELEM(m,p,row,col)] += a[MAT_ELEM(m,n,row,i)]*b[MAT_ELEM(n,p,i,col)];
            }
        }
    }
}

static inline void mat_show(
    const int m,
    const int p,
    MAT_IN_t a)
{
    for (int row=0; row<m;row++) {
        for (int col=0; col<p;col++) {
            printf("\t%7.3f", a[MAT_ELEM(m,p,row,col)]);
        }
        putchar('\n');
    }
}

int main(void)
{
    double a[4*4] = {1, 1,   1,   1,
                     2, 4,   8,  16,
                     3, 9,  27,  81,
                     4, 16, 64, 256};

    double b[4*3] = {    4.0,   -3.0,  4.0/3,
                     -13.0/3, 19.0/4, -7.0/3,
                       3.0/2,   -2.0,  7.0/6,
                      -1.0/6,  1.0/4, -1.0/6};

    double c[4*3] = {0};

    mat_mult(4,4,3,a,b,c);
    mat_show(4,3,c);
    return 0;
}
`,`#include "matrix-multiplication.h"



undefined8 entry(void)

{
  undefined auStack_168 [96];
  undefined auStack_108 [96];
  undefined auStack_a8 [128];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_a8,&DAT_100003eb0,0x80);
  _memcpy(auStack_108,&DAT_100003f30,0x60);
  _memset(auStack_168,0,0x60);
  FUN_100003c70(4,4,3,auStack_a8,auStack_108,auStack_168);
  FUN_100003db0(4,3,auStack_168);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void FUN_100003c70(int param_1,int param_2,int param_3,long param_4,long param_5,long param_6)

{
  undefined8 *puVar1;
  undefined8 uVar2;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  
  for (local_2c = 0; local_2c < param_1; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < param_3; local_30 = local_30 + 1) {
      *(undefined8 *)(param_6 + (long)(local_2c * param_3 + local_30) * 8) = 0;
      for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
        puVar1 = (undefined8 *)(param_6 + (long)(local_2c * param_3 + local_30) * 8);
        uVar2 = NEON_fmadd(*(undefined8 *)(param_4 + (long)(local_2c * param_2 + local_34) * 8),
                           *(undefined8 *)(param_5 + (long)(local_34 * param_3 + local_30) * 8),
                           *puVar1);
        *puVar1 = uVar2;
      }
    }
  }
  return;
}



ulong FUN_100003db0(ulong param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  int local_28;
  int local_24;
  
  iVar1 = (int)param_1;
  for (local_24 = 0; local_24 < iVar1; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < param_2; local_28 = local_28 + 1) {
      _printf("\t%7.3f");
    }
    uVar2 = _putchar(10);
    param_1 = (ulong)uVar2;
  }
  return param_1;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004018)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004028)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <limits.h>

typedef unsigned long long ull;
#define N (sizeof(ull) * CHAR_BIT)
#define B(x) (1ULL << (x))

void evolve(ull state, int rule)
{
	int i, p, q, b;

	for (p = 0; p < 10; p++) {
		for (b = 0, q = 8; q--; ) {
			ull st = state;
			b |= (st&1) << q;

			for (state = i = 0; i < N; i++)
				if (rule & B(7 & (st>>(i-1) | st<<(N+1-i))))
					state |= B(i);
		}
		printf(" %d", b);
	}
	putchar('\n');
	return;
}

int main(void)
{
	evolve(1, 30);
	return 0;
}
`,`#include "elementary-cellular-automaton-random-number-generator.h"



int _evolve(ulong param_1,int param_2)

{
  ulong uVar1;
  int iVar2;
  int local_28;
  int local_24;
  uint local_20;
  ulong local_18;
  
  local_18 = param_1;
  for (local_24 = 0; local_24 < 10; local_24 = local_24 + 1) {
    local_28 = 8;
    while (uVar1 = local_18, iVar2 = local_28 + -1, local_28 != 0) {
      local_18 = 0;
      for (local_20 = 0; local_28 = iVar2, local_20 < 0x40; local_20 = local_20 + 1) {
        if (((long)param_2 &
            1L << ((uVar1 >> ((ulong)(local_20 - 1) & 0x3f) |
                   uVar1 << (0x41U - (long)(int)local_20 & 0x3f)) & 7)) != 0) {
          local_18 = local_18 | 1L << ((ulong)local_20 & 0x3f);
        }
      }
    }
    _printf(" %d");
  }
  iVar2 = _putchar(10);
  return iVar2;
}



undefined4 entry(void)

{
  _evolve(1,0x1e);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void talk(const char *s)
{
	pid_t pid;
	int status;

	pid = fork();
	if (pid < 0) {
		perror("fork");
		exit(1);
	}

	if (pid == 0) {
		execlp("espeak", "espeak", s, (void*)0);
		perror("espeak");
		_exit(1);
	}

	waitpid(pid, &status, 0);
	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		exit(1);
}

int main()
{
	talk("This is an example of speech synthesis.");
	return 0;
}
`,`#include "speech-synthesis.h"



pid_t _talk(undefined8 param_1)

{
  pid_t pVar1;
  uint local_20;
  pid_t local_1c;
  undefined8 local_18;
  
  local_18 = param_1;
  local_1c = _fork();
  if (local_1c < 0) {
    _perror("fork");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  if (local_1c != 0) {
    pVar1 = _waitpid(local_1c,(int *)&local_20,0);
    if (((local_20 & 0x7f) == 0) && (((int)local_20 >> 8 & 0xffU) == 0)) {
      return pVar1;
    }
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  _execlp("espeak","espeak");
  _perror("espeak");
                    // WARNING: Subroutine does not return
  __exit(1);
}



undefined4 entry(void)

{
  _talk("This is an example of speech synthesis.");
  return 0;
}



void __exit(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR___exit_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _execlp(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__execlp_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _fork(void)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__fork_100004018)();
  return pVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _waitpid(pid_t param_1,int *param_2,int param_3)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__waitpid_100004028)(param_1,param_2,param_3);
  return pVar1;
}


`
`#include <stdio.h>

int main(int argc, char **argv) {

   int user1 = 0, user2 = 0;
   printf("Enter two integers.  Space delimited, please:  ");
   scanf("%d %d",&user1, &user2);
   int array[user1][user2];
   array[user1/2][user2/2] = user1 + user2;
   printf("array[%d][%d] is %d\n",user1/2,user2/2,array[user1/2][user2/2]);

   return 0;
}
`,`#include "create-a-two-dimensional-array-at-runtime-1.h"



undefined4 entry(undefined4 param_1,undefined8 param_2)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  int iVar5;
  ulong auStack_a0 [2];
  uint *local_90 [2];
  uint auStack_80 [2];
  uint *local_78;
  uint *local_70;
  ulong local_68;
  ulong local_60;
  ulong local_58;
  undefined4 local_4c;
  ulong local_48;
  ulong local_40;
  undefined *local_38;
  uint local_30;
  uint local_2c;
  undefined8 local_28;
  undefined4 local_20;
  undefined4 local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_1c = 0;
  local_78 = &local_2c;
  local_2c = 0;
  local_70 = &local_30;
  local_30 = 0;
  local_28 = param_2;
  local_20 = param_1;
  _printf("Enter two integers.  Space delimited, please:  ");
  local_90[0] = local_78;
  local_90[1] = local_70;
  iVar5 = _scanf("%d %d");
  local_60 = (ulong)local_2c;
  local_58 = (ulong)local_30;
  local_68 = local_60 * local_58 * 4 + 0xf & 0xfffffffffffffff0;
  local_38 = (undefined *)auStack_80;
  (*(code *)PTR____chkstk_darwin_100004000)(iVar5);
  uVar4 = local_58;
  lVar3 = -local_68;
  local_40 = local_60;
  local_48 = local_58;
  *(uint *)((long)auStack_80 +
           (long)((int)local_30 / 2) * 4 + (long)((int)local_2c / 2) * local_58 * 4 + lVar3 + -0x80
           + 0x80) = local_2c + local_30;
  uVar2 = (int)local_30 / 2;
  uVar1 = *(uint *)((long)auStack_80 +
                   (long)((int)local_30 / 2) * 4 +
                   (long)((int)local_2c / 2) * uVar4 * 4 + lVar3 + -0x80 + 0x80);
  *(ulong *)((long)auStack_a0 + lVar3) = (ulong)(uint)((int)local_2c / 2);
  *(ulong *)((long)auStack_a0 + lVar3 + 8) = (ulong)uVar2;
  *(ulong *)((long)local_90 + lVar3) = (ulong)uVar1;
  iVar5 = _printf("array[%d][%d] is %d\n");
  local_1c = 0;
  local_4c = 0;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar5);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define MAXBUF 256  /* limit */
#define STR_SZ 100  /* string size */


/* function prototypes */
int ascii (const unsigned char c);

int ascii_ext (const unsigned char c);

unsigned char* strip(unsigned char* str, const size_t n, int ext );


/* check a character
   return 1 for true
          0 for false
*/
int ascii (const unsigned char c)
{
  unsigned char min = 32;   /* <space> */
  unsigned char max = 126;  /* ~ tilde */

  if ( c>=min && c<=max ) return 1;

  return 0;
}


/* check if extended character
   return 1 for true
          0 for false
*/
int ascii_ext (const unsigned char c)
{
  unsigned char min_ext = 128;
  unsigned char max_ext = 255;

  if ( c>=min_ext && c<=max_ext )
       return 1;

  return 0;
}


/* fill buffer with only ASCII valid characters
   then rewrite string from buffer
   limit to n < MAX chars
*/

unsigned char* strip( unsigned char* str, const size_t n, int ext)
{

  unsigned char buffer[MAXBUF] = {'\0'};

  size_t i = 0;  // source index
  size_t j = 0;  // dest   index

  size_t max = (n<MAXBUF)? n : MAXBUF -1;  // limit size

  while (i < max )
    {
      if ( (ext && ascii_ext(str[i]) ) ||  (ascii(str[i]) ) )    // check
	{
	  buffer[j++] = str[i]; // assign
	}
      i++;
    }

  memset(str, '\0', max); // wipe string

  i = 0;               // reset count

  while( i < j)
    {
      str[i] = buffer[i]; // copy back
      i++;
    }

  str[j] = '\0';  // terminate properly

  return str;
}

/* try it out */
int main( int argc, char** argv)
{
  enum {ASCII=0, EXT=1}; /* enumeration makes easier reading */

  unsigned int seed = 134529;  // RNG seed value

  /* variables and storage */
  unsigned char badstring[STR_SZ] = {'\0'};
  unsigned char bs_2[STR_SZ]      = {'\0'};

  unsigned char* goodstring = NULL;
  unsigned char* goodstring_ext = NULL;

  size_t i = 0;

  srand(seed); /* seed RNG */

  fprintf(stdout, "Original:\t" );

  /* generate a random string */
  for (i = 0; i < STR_SZ; i++)
    {
      badstring[i] = (unsigned char) ( rand () & (unsigned char)0xFF );
      fprintf(stdout, "%c", badstring[i] );
    }
  fprintf(stdout, "\n");


   memcpy(bs_2, badstring, STR_SZ * sizeof(unsigned char) ); /* copy string */

   goodstring_ext = strip( badstring, STR_SZ, EXT); /* remove non-extended and non-ascii */

   fprintf(stdout, "\nEXT:\t%s\n" , goodstring_ext );

   goodstring = strip( bs_2, STR_SZ, ASCII); /* remove all non-ascii */

   fprintf(stdout, "\nASCII:\t%s\n" , goodstring );

return 0;
}
`,`#include "strip-control-codes-and-extended-characters-from-a-string-1.h"



undefined4 _ascii(byte param_1)

{
  undefined4 local_4;
  
  if ((param_1 < 0x20) || (0x7e < param_1)) {
    local_4 = 0;
  }
  else {
    local_4 = 1;
  }
  return local_4;
}



bool _ascii_ext(byte param_1)

{
  return 0x7f < param_1;
}



long _strip(long param_1,ulong param_2,int param_3)

{
  int iVar1;
  ulong local_160;
  ulong local_150;
  ulong local_148;
  undefined auStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _memset(auStack_128,0,0x100);
  local_148 = 0;
  local_150 = 0;
  local_160 = param_2;
  if (0xff < param_2) {
    local_160 = 0xff;
  }
  for (; local_148 < local_160; local_148 = local_148 + 1) {
    if (((param_3 != 0) && (iVar1 = _ascii_ext(*(undefined *)(param_1 + local_148)), iVar1 != 0)) ||
       (iVar1 = _ascii(*(undefined *)(param_1 + local_148)), iVar1 != 0)) {
      auStack_128[local_150] = *(undefined *)(param_1 + local_148);
      local_150 = local_150 + 1;
    }
  }
  ___memset_chk(param_1,0,local_160,0xffffffffffffffff);
  for (local_148 = 0; local_148 < local_150; local_148 = local_148 + 1) {
    *(undefined *)(param_1 + local_148) = auStack_128[local_148];
  }
  *(undefined *)(param_1 + local_150) = 0;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return param_1;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  undefined *puVar1;
  int iVar2;
  ulong local_120;
  undefined auStack_f0 [100];
  undefined auStack_8c [100];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _memset(auStack_8c,0,100);
  _memset(auStack_f0,0,100);
  _srand(0x20d81);
  _fprintf(*(FILE **)PTR____stdoutp_100004018,"Original:\t");
  for (local_120 = 0; puVar1 = PTR____stdoutp_100004018, local_120 < 100; local_120 = local_120 + 1)
  {
    iVar2 = _rand();
    auStack_8c[local_120] = (char)iVar2;
    _fprintf(*(FILE **)PTR____stdoutp_100004018,"%c");
  }
  _fprintf(*(FILE **)PTR____stdoutp_100004018,"\n");
  _memcpy(auStack_f0,auStack_8c,100);
  _strip(auStack_8c,100,1);
  _fprintf(*(FILE **)puVar1,"\nEXT:\t%s\n");
  _strip(auStack_f0,100,0);
  iVar2 = _fprintf(*(FILE **)puVar1,"\nASCII:\t%s\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004030)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004038)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004040)(param_1);
  return;
}


`
`#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct tPoint {
    int x, y;
} Point;

bool ccw(const Point *a, const Point *b, const Point *c) {
    return (b->x - a->x) * (c->y - a->y)
         > (b->y - a->y) * (c->x - a->x);
}

int comparePoints(const void *lhs, const void *rhs) {
    const Point* lp = lhs;
    const Point* rp = rhs;
    if (lp->x < rp->x)
        return -1;
    if (rp->x < lp->x)
        return 1;
    if (lp->y < rp->y)
        return -1;
    if (rp->y < lp->y)
        return 1;
    return 0;
}

void fatal(const char* message) {
    fprintf(stderr, "%s\n", message);
    exit(1);
}

void* xmalloc(size_t n) {
    void* ptr = malloc(n);
    if (ptr == NULL)
        fatal("Out of memory");
    return ptr;
}

void* xrealloc(void* p, size_t n) {
    void* ptr = realloc(p, n);
    if (ptr == NULL)
        fatal("Out of memory");
    return ptr;
}

void printPoints(const Point* points, int len) {
    printf("[");
    if (len > 0) {
        const Point* ptr = points;
        const Point* end = points + len;
        printf("(%d, %d)", ptr->x, ptr->y);
        ++ptr;
        for (; ptr < end; ++ptr)
            printf(", (%d, %d)", ptr->x, ptr->y);
    }
    printf("]");
}

Point* convexHull(Point p[], int len, int* hsize) {
    if (len == 0) {
        *hsize = 0;
        return NULL;
    }

    int i, size = 0, capacity = 4;
    Point* hull = xmalloc(capacity * sizeof(Point));

    qsort(p, len, sizeof(Point), comparePoints);

    /* lower hull */
    for (i = 0; i < len; ++i) {
        while (size >= 2 && !ccw(&hull[size - 2], &hull[size - 1], &p[i]))
            --size;
        if (size == capacity) {
            capacity *= 2;
            hull = xrealloc(hull, capacity * sizeof(Point));
        }
        assert(size >= 0 && size < capacity);
        hull[size++] = p[i];
    }

    /* upper hull */
    int t = size + 1;
    for (i = len - 1; i >= 0; i--) {
        while (size >= t && !ccw(&hull[size - 2], &hull[size - 1], &p[i]))
            --size;
        if (size == capacity) {
            capacity *= 2;
            hull = xrealloc(hull, capacity * sizeof(Point));
        }
        assert(size >= 0 && size < capacity);
        hull[size++] = p[i];
    }
    --size;
    assert(size >= 0);
    hull = xrealloc(hull, size * sizeof(Point));
    *hsize = size;
    return hull;
}

int main() {
    Point points[] = {
        {16,  3}, {12, 17}, { 0,  6}, {-4, -6}, {16,  6},
        {16, -7}, {16, -3}, {17, -4}, { 5, 19}, {19, -8},
        { 3, 16}, {12, 13}, { 3, -4}, {17,  5}, {-3, 15},
        {-3, -9}, { 0, 11}, {-9, -3}, {-4, -2}, {12, 10}
    };
    int hsize;
    Point* hull = convexHull(points, sizeof(points)/sizeof(Point), &hsize);
    printf("Convex Hull: ");
    printPoints(hull, hsize);
    printf("\n");
    free(hull);

    return 0;
}
`,`#include "convex-hull.h"



bool _ccw(int *param_1,int *param_2,int *param_3)

{
  return (param_2[1] - param_1[1]) * (*param_3 - *param_1) <
         (*param_2 - *param_1) * (param_3[1] - param_1[1]);
}



undefined4 _comparePoints(int *param_1,int *param_2)

{
  undefined4 local_4;
  
  if (*param_1 < *param_2) {
    local_4 = 0xffffffff;
  }
  else if (*param_2 < *param_1) {
    local_4 = 1;
  }
  else if (param_1[1] < param_2[1]) {
    local_4 = 0xffffffff;
  }
  else if (param_2[1] < param_1[1]) {
    local_4 = 1;
  }
  else {
    local_4 = 0;
  }
  return local_4;
}



void _fatal(void)

{
  _fprintf(*(FILE **)PTR____stderrp_100004018,"%s\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



void * _xmalloc(size_t param_1)

{
  void *pvVar1;
  
  pvVar1 = _malloc(param_1);
  if (pvVar1 == (void *)0x0) {
    _fatal("Out of memory");
  }
  return pvVar1;
}



void * _xrealloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
  pvVar1 = _realloc(param_1,param_2);
  if (pvVar1 == (void *)0x0) {
    _fatal("Out of memory");
  }
  return pvVar1;
}



int _printPoints(long param_1,int param_2)

{
  int iVar1;
  ulong local_28;
  
  _printf("[");
  if (0 < param_2) {
    _printf("(%d, %d)");
    for (local_28 = param_1 + 8; local_28 < (ulong)(param_1 + (long)param_2 * 8);
        local_28 = local_28 + 8) {
      _printf(", (%d, %d)");
    }
  }
  iVar1 = _printf("]");
  return iVar1;
}



undefined8 _convexHull(void *param_1,int param_2,int *param_3)

{
  int iVar1;
  long lVar2;
  uint local_5c;
  uint local_50;
  long local_48;
  int local_3c;
  int local_38;
  int local_34;
  undefined8 local_18;
  
  if (param_2 == 0) {
    *param_3 = 0;
    local_18 = 0;
  }
  else {
    local_38 = 0;
    local_3c = 4;
    local_48 = _xmalloc(0x20);
    _qsort(param_1,(long)param_2,8,(int *)_comparePoints);
    for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
      while( true ) {
        local_50 = 0;
        if (1 < local_38) {
          local_50 = _ccw(local_48 + (long)(local_38 + -2) * 8,local_48 + (long)(local_38 + -1) * 8,
                          (void *)((long)param_1 + (long)local_34 * 8));
          local_50 = local_50 ^ 1;
        }
        if ((local_50 & 1) == 0) break;
        local_38 = local_38 + -1;
      }
      if (local_38 == local_3c) {
        local_3c = local_3c << 1;
        local_48 = _xrealloc(local_48,(long)local_3c << 3);
      }
      if (local_38 < 0 || local_3c <= local_38) {
                    // WARNING: Subroutine does not return
        ___assert_rtn("convexHull","convex-hull.c",0x50,"size >= 0 && size < capacity");
      }
      lVar2 = (long)local_38;
      local_38 = local_38 + 1;
      *(undefined8 *)(local_48 + lVar2 * 8) = *(undefined8 *)((long)param_1 + (long)local_34 * 8);
    }
    iVar1 = local_38 + 1;
    for (local_34 = param_2 + -1; -1 < local_34; local_34 = local_34 + -1) {
      while( true ) {
        local_5c = 0;
        if (iVar1 <= local_38) {
          local_5c = _ccw(local_48 + (long)(local_38 + -2) * 8,local_48 + (long)(local_38 + -1) * 8,
                          (void *)((long)param_1 + (long)local_34 * 8));
          local_5c = local_5c ^ 1;
        }
        if ((local_5c & 1) == 0) break;
        local_38 = local_38 + -1;
      }
      if (local_38 == local_3c) {
        local_3c = local_3c << 1;
        local_48 = _xrealloc(local_48,(long)local_3c << 3);
      }
      if (local_38 < 0 || local_3c <= local_38) {
                    // WARNING: Subroutine does not return
        ___assert_rtn("convexHull","convex-hull.c",0x5d,"size >= 0 && size < capacity");
      }
      lVar2 = (long)local_38;
      local_38 = local_38 + 1;
      *(undefined8 *)(local_48 + lVar2 * 8) = *(undefined8 *)((long)param_1 + (long)local_34 * 8);
    }
    local_38 = local_38 + -1;
    if (local_38 < 0) {
                    // WARNING: Subroutine does not return
      ___assert_rtn("convexHull","convex-hull.c",0x61,"size >= 0");
    }
    local_18 = _xrealloc(local_48,(long)local_38 << 3);
    *param_3 = local_38;
  }
  return local_18;
}



undefined8 entry(void)

{
  void *pvVar1;
  undefined4 local_c0;
  undefined4 local_bc;
  undefined auStack_b8 [160];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_bc = 0;
  _memcpy(auStack_b8,&DAT_100003ef8,0xa0);
  pvVar1 = (void *)_convexHull(auStack_b8,0x14,&local_c0);
  _printf("Convex Hull: ");
  _printPoints(pvVar1,local_c0);
  _printf("\n");
  _free(pvVar1);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e54. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004040)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004058)();
  return pvVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>

int main(void)
{
  struct stat foo;
  stat("input.txt", &foo);
  printf("%ld\n", foo.st_size);
  stat("/input.txt", &foo);
  printf("%ld\n", foo.st_size);
  return 0;
}
`,`#include "file-size-2.h"



undefined4 entry(void)

{
  stat sStack_a8;
  undefined4 local_14;
  
  local_14 = 0;
  _stat("input.txt",&sStack_a8);
  _printf("%ld\n");
  _stat("/input.txt",&sStack_a8);
  _printf("%ld\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _stat(char *param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__stat_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

typedef struct node_s
{
  int value;
  struct node_s* left;
  struct node_s* right;
} *node;

node tree(int v, node l, node r)
{
  node n = malloc(sizeof(struct node_s));
  n->value = v;
  n->left  = l;
  n->right = r;
  return n;
}

void destroy_tree(node n)
{
  if (n->left)
    destroy_tree(n->left);
  if (n->right)
    destroy_tree(n->right);
  free(n);
}

void preorder(node n, void (*f)(int))
{
  f(n->value);
  if (n->left)
    preorder(n->left, f);
  if (n->right)
    preorder(n->right, f);
}

void inorder(node n, void (*f)(int))
{
  if (n->left)
    inorder(n->left, f);
  f(n->value);
  if (n->right)
    inorder(n->right, f);
}

void postorder(node n, void (*f)(int))
{
  if (n->left)
    postorder(n->left, f);
  if (n->right)
    postorder(n->right, f);
  f(n->value);
}

/* helper queue for levelorder */
typedef struct qnode_s
{
  struct qnode_s* next;
  node value;
} *qnode;

typedef struct { qnode begin, end; } queue;

void enqueue(queue* q, node n)
{
  qnode node = malloc(sizeof(struct qnode_s));
  node->value = n;
  node->next = 0;
  if (q->end)
    q->end->next = node;
  else
    q->begin = node;
  q->end = node;
}

node dequeue(queue* q)
{
  node tmp = q->begin->value;
  qnode second = q->begin->next;
  free(q->begin);
  q->begin = second;
  if (!q->begin)
    q->end = 0;
  return tmp;
}

int queue_empty(queue* q)
{
  return !q->begin;
}

void levelorder(node n, void(*f)(int))
{
  queue nodequeue = {};
  enqueue(&nodequeue, n);
  while (!queue_empty(&nodequeue))
  {
    node next = dequeue(&nodequeue);
    f(next->value);
    if (next->left)
      enqueue(&nodequeue, next->left);
    if (next->right)
      enqueue(&nodequeue, next->right);
  }
}

void print(int n)
{
  printf("%d ", n);
}

int main()
{
  node n = tree(1,
                tree(2,
                     tree(4,
                          tree(7, 0, 0),
                          0),
                     tree(5, 0, 0)),
                tree(3,
                     tree(6,
                          tree(8, 0, 0),
                          tree(9, 0, 0)),
                     0));

  printf("preorder:    ");
  preorder(n, print);
  printf("\n");

  printf("inorder:     ");
  inorder(n, print);
  printf("\n");

  printf("postorder:   ");
  postorder(n, print);
  printf("\n");

  printf("level-order: ");
  levelorder(n, print);
  printf("\n");

  destroy_tree(n);

  return 0;
}
`,`#include "tree-traversal.h"



undefined4 * _tree(undefined4 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_malloc(0x18);
  *puVar1 = param_1;
  *(undefined8 *)(puVar1 + 2) = param_2;
  *(undefined8 *)(puVar1 + 4) = param_3;
  return puVar1;
}



void _destroy_tree(void *param_1)

{
  if (*(long *)((long)param_1 + 8) != 0) {
    _destroy_tree(*(undefined8 *)((long)param_1 + 8));
  }
  if (*(long *)((long)param_1 + 0x10) != 0) {
    _destroy_tree(*(undefined8 *)((long)param_1 + 0x10));
  }
  _free(param_1);
  return;
}



void _preorder(undefined4 *param_1,code *param_2)

{
  (*param_2)(*param_1);
  if (*(long *)(param_1 + 2) != 0) {
    _preorder(*(undefined8 *)(param_1 + 2),param_2);
  }
  if (*(long *)(param_1 + 4) != 0) {
    _preorder(*(undefined8 *)(param_1 + 4),param_2);
  }
  return;
}



void _inorder(undefined4 *param_1,code *param_2)

{
  if (*(long *)(param_1 + 2) != 0) {
    _inorder(*(undefined8 *)(param_1 + 2),param_2);
  }
  (*param_2)(*param_1);
  if (*(long *)(param_1 + 4) != 0) {
    _inorder(*(undefined8 *)(param_1 + 4),param_2);
  }
  return;
}



void _postorder(undefined4 *param_1,code *param_2)

{
  if (*(long *)(param_1 + 2) != 0) {
    _postorder(*(undefined8 *)(param_1 + 2),param_2);
  }
  if (*(long *)(param_1 + 4) != 0) {
    _postorder(*(undefined8 *)(param_1 + 4),param_2);
  }
  (*param_2)(*param_1);
  return;
}



void _enqueue(undefined8 *param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x10);
  puVar1[1] = param_2;
  *puVar1 = 0;
  if (param_1[1] == 0) {
    *param_1 = puVar1;
  }
  else {
    *(undefined8 **)param_1[1] = puVar1;
  }
  param_1[1] = puVar1;
  return;
}



undefined8 _dequeue(long *param_1)

{
  undefined8 uVar1;
  long lVar2;
  
  uVar1 = *(undefined8 *)(*param_1 + 8);
  lVar2 = *(long *)*param_1;
  _free((void *)*param_1);
  *param_1 = lVar2;
  if (*param_1 == 0) {
    param_1[1] = 0;
  }
  return uVar1;
}



bool _queue_empty(long *param_1)

{
  return *param_1 == 0;
}



void _levelorder(undefined8 param_1,code *param_2)

{
  int iVar1;
  undefined4 *puVar2;
  undefined8 local_30;
  undefined8 local_28;
  code *local_20;
  undefined8 local_18;
  
  local_30 = 0;
  local_28 = 0;
  local_20 = param_2;
  local_18 = param_1;
  _enqueue(&local_30,param_1);
  while (iVar1 = _queue_empty(&local_30), iVar1 == 0) {
    puVar2 = (undefined4 *)_dequeue(&local_30);
    (*local_20)(*puVar2);
    if (*(long *)(puVar2 + 2) != 0) {
      _enqueue(&local_30,*(undefined8 *)(puVar2 + 2));
    }
    if (*(long *)(puVar2 + 4) != 0) {
      _enqueue(&local_30,*(undefined8 *)(puVar2 + 4));
    }
  }
  return;
}



int _print(void)

{
  int iVar1;
  
  iVar1 = _printf("%d ");
  return iVar1;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  
  uVar1 = _tree(7,0);
  uVar1 = _tree(4,uVar1,0);
  uVar2 = _tree(5,0);
  uVar1 = _tree(2,uVar1,uVar2);
  uVar2 = _tree(8,0);
  uVar3 = _tree(9,0);
  uVar2 = _tree(6,uVar2,uVar3);
  uVar2 = _tree(3,uVar2,0);
  uVar1 = _tree(1,uVar1,uVar2);
  _printf("preorder:    ");
  _preorder(uVar1);
  _printf("\n");
  _printf("inorder:     ");
  _inorder(uVar1,_print);
  _printf("\n");
  _printf("postorder:   ");
  _postorder(uVar1,_print);
  _printf("\n");
  _printf("level-order: ");
  _levelorder(uVar1,_print);
  _printf("\n");
  _destroy_tree(uVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

uint64_t egyptian_division(uint64_t dividend, uint64_t divisor, uint64_t *remainder) {
	// remainder is an out parameter, pass NULL if you do not need the remainder
	
	static uint64_t powers[64];
	static uint64_t doublings[64];

	int i;
	
	for(i = 0; i < 64; i++) {
		powers[i] = 1 << i;
		doublings[i] = divisor << i;
		if(doublings[i] > dividend)
			break;
	}
	
	uint64_t answer = 0;
	uint64_t accumulator = 0;

	for(i = i - 1; i >= 0; i--) {
		// If the current value of the accumulator added to the
		// doublings cell would be less than or equal to the
		// dividend then add it to the accumulator
		if(accumulator + doublings[i] <= dividend) {
			accumulator += doublings[i];
			answer += powers[i];
		}
	}
	
	if(remainder)
		*remainder = dividend - accumulator;
	return answer;
}

void go(uint64_t a, uint64_t b) {
	uint64_t x, y;
	x = egyptian_division(a, b, &y);
	printf("%llu / %llu = %llu remainder %llu\n", a, b, x, y);
	assert(a == b * x + y);
}

int main(void) {
	go(580, 32);
}
`,`#include "egyptian-division.h"



long _egyptian_division(ulong param_1,long param_2,long *param_3)

{
  long local_30;
  long local_28;
  uint local_1c;
  
  for (local_1c = 0; (int)local_1c < 0x40; local_1c = local_1c + 1) {
    *(long *)((long)(int)local_1c * 8 + 0x100008000) = (long)(1 << (ulong)(local_1c & 0x1f));
    *(long *)((long)(int)local_1c * 8 + 0x100008200) = param_2 << ((ulong)local_1c & 0x3f);
    if (param_1 < *(ulong *)((long)(int)local_1c * 8 + 0x100008200)) break;
  }
  local_28 = 0;
  local_30 = 0;
  while (local_1c = local_1c - 1, -1 < (int)local_1c) {
    if ((ulong)(local_30 + *(long *)((long)(int)local_1c * 8 + 0x100008200)) <= param_1) {
      local_30 = local_30 + *(long *)((long)(int)local_1c * 8 + 0x100008200);
      local_28 = local_28 + *(long *)((long)(int)local_1c * 8 + 0x100008000);
    }
  }
  if (param_3 != (long *)0x0) {
    *param_3 = param_1 - local_30;
  }
  return local_28;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _go(void)

{
  uint uVar1;
  long in_x0;
  long in_x1;
  long local_30;
  long local_28;
  long local_20;
  long local_18;
  
  local_20 = in_x1;
  local_18 = in_x0;
  local_28 = _egyptian_division(in_x0,in_x1,&local_30);
  uVar1 = _printf("%llu / %llu = %llu remainder %llu\n");
  if (local_18 != local_20 * local_28 + local_30) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("go","egyptian-division.c",0x2b,"a == b * x + y");
  }
  return (ulong)uVar1;
}



undefined8 entry(void)

{
  _go();
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

struct list_node {int x; struct list_node *next;};
typedef struct list_node node;

node * uniq(int *a, unsigned alen)
 {if (alen == 0) return NULL;
  node *start = malloc(sizeof(node));
  if (start == NULL) exit(EXIT_FAILURE);
  start->x = a[0];
  start->next = NULL;

  for (int i = 1 ; i < alen ; ++i)
     {node *n = start;
      for (;; n = n->next)
         {if (a[i] == n->x) break;
          if (n->next == NULL)
             {n->next = malloc(sizeof(node));
              n = n->next;
              if (n == NULL) exit(EXIT_FAILURE);
              n->x = a[i];
              n->next = NULL;
              break;}}}

  return start;}

int main(void)
   {int a[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};
    for (node *n = uniq(a, 10) ; n != NULL ; n = n->next)
        printf("%d ", n->x);
    puts("");
    return 0;}
`,`#include "remove-duplicate-elements-1.h"



int * _uniq(int *param_1,uint param_2)

{
  void *pvVar1;
  int *piVar2;
  int *local_40;
  uint local_34;
  int *local_18;
  
  if (param_2 == 0) {
    local_18 = (int *)0x0;
  }
  else {
    local_18 = (int *)_malloc(0x10);
    if (local_18 == (int *)0x0) {
                    // WARNING: Subroutine does not return
      _exit(1);
    }
    *local_18 = *param_1;
    local_18[2] = 0;
    local_18[3] = 0;
    for (local_34 = 1; local_40 = local_18, local_34 < param_2; local_34 = local_34 + 1) {
      for (; param_1[(int)local_34] != *local_40; local_40 = *(int **)(local_40 + 2)) {
        if (*(long *)(local_40 + 2) == 0) {
          pvVar1 = _malloc(0x10);
          *(void **)(local_40 + 2) = pvVar1;
          piVar2 = *(int **)(local_40 + 2);
          if (piVar2 == (int *)0x0) {
                    // WARNING: Subroutine does not return
            _exit(1);
          }
          *piVar2 = param_1[(int)local_34];
          piVar2[2] = 0;
          piVar2[3] = 0;
          break;
        }
      }
    }
  }
  return local_18;
}



undefined8 entry(void)

{
  int iVar1;
  long local_50;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f78,0x28);
  for (local_50 = _uniq(auStack_40,10); local_50 != 0; local_50 = *(long *)(local_50 + 8)) {
    _printf("%d ");
  }
  iVar1 = _puts("");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}


`
`#include <locale.h>
#include <stdbool.h>
#include <stdio.h>
#include <time.h>

bool colorful(int n) {
    // A colorful number cannot be greater than 98765432.
    if (n < 0 || n > 98765432)
        return false;
    int digit_count[10] = {};
    int digits[8] = {};
    int num_digits = 0;
    for (int m = n; m > 0; m /= 10) {
        int d = m % 10;
        if (n > 9 && (d == 0 || d == 1))
            return false;
        if (++digit_count[d] > 1)
            return false;
        digits[num_digits++] = d;
    }
    // Maximum number of products is (8 x 9) / 2.
    int products[36] = {};
    for (int i = 0, product_count = 0; i < num_digits; ++i) {
        for (int j = i, p = 1; j < num_digits; ++j) {
            p *= digits[j];
            for (int k = 0; k < product_count; ++k) {
                if (products[k] == p)
                    return false;
            }
            products[product_count++] = p;
        }
    }
    return true;
}

static int count[8];
static bool used[10];
static int largest = 0;

void count_colorful(int taken, int n, int digits) {
    if (taken == 0) {
        for (int d = 0; d < 10; ++d) {
            used[d] = true;
            count_colorful(d < 2 ? 9 : 1, d, 1);
            used[d] = false;
        }
    } else {
        if (colorful(n)) {
            ++count[digits - 1];
            if (n > largest)
                largest = n;
        }
        if (taken < 9) {
            for (int d = 2; d < 10; ++d) {
                if (!used[d]) {
                    used[d] = true;
                    count_colorful(taken + 1, n * 10 + d, digits + 1);
                    used[d] = false;
                }
            }
        }
    }
}

int main() {
    setlocale(LC_ALL, "");

    clock_t start = clock();

    printf("Colorful numbers less than 100:\n");
    for (int n = 0, count = 0; n < 100; ++n) {
        if (colorful(n))
            printf("%2d%c", n, ++count % 10 == 0 ? '\n' : ' ');
    }

    count_colorful(0, 0, 0);
    printf("\n\nLargest colorful number: %'d\n", largest);

    printf("\nCount of colorful numbers by number of digits:\n");
    int total = 0;
    for (int d = 0; d < 8; ++d) {
        printf("%d   %'d\n", d + 1, count[d]);
        total += count[d];
    }
    printf("\nTotal: %'d\n", total);

    clock_t end = clock();
    printf("\nElapsed time: %f seconds\n",
           (end - start + 0.0) / CLOCKS_PER_SEC);
    return 0;
}
`,`#include "colorful-numbers.h"



undefined _colorful(int param_1)

{
  int iVar1;
  int iVar2;
  long lVar3;
  int local_128;
  int local_124;
  int local_120;
  int local_11c;
  int local_118;
  int local_110;
  int local_10c;
  undefined local_101;
  int aiStack_100 [36];
  int local_70 [18];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  if ((param_1 < 0) || (0x5e30a78 < param_1)) {
    local_101 = 0;
  }
  else {
    _memset(local_70 + 8,0,0x28);
    local_70[2] = 0;
    local_70[3] = 0;
    local_70[0] = 0;
    local_70[1] = 0;
    local_70[6] = 0;
    local_70[7] = 0;
    local_70[4] = 0;
    local_70[5] = 0;
    local_10c = 0;
    for (local_110 = param_1; 0 < local_110; local_110 = local_110 / 10) {
      iVar2 = local_110 % 10;
      if ((9 < param_1) && ((iVar2 == 0 || (iVar2 == 1)))) {
        local_101 = 0;
        goto LAB_100003a80;
      }
      iVar1 = local_70[(long)iVar2 + 8] + 1;
      local_70[(long)iVar2 + 8] = iVar1;
      if (1 < iVar1) {
        local_101 = 0;
        goto LAB_100003a80;
      }
      lVar3 = (long)local_10c;
      local_10c = local_10c + 1;
      local_70[lVar3] = iVar2;
    }
    _memset(aiStack_100,0,0x90);
    local_11c = 0;
    for (local_118 = 0; local_118 < local_10c; local_118 = local_118 + 1) {
      local_124 = 1;
      for (local_120 = local_118; local_120 < local_10c; local_120 = local_120 + 1) {
        local_124 = local_124 * local_70[local_120];
        for (local_128 = 0; local_128 < local_11c; local_128 = local_128 + 1) {
          if (aiStack_100[local_128] == local_124) {
            local_101 = 0;
            goto LAB_100003a80;
          }
        }
        lVar3 = (long)local_11c;
        local_11c = local_11c + 1;
        aiStack_100[lVar3] = local_124;
      }
    }
    local_101 = 1;
  }
LAB_100003a80:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return local_101;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _count_colorful(int param_1,int param_2,int param_3)

{
  int *piVar1;
  ulong uVar2;
  undefined4 uVar3;
  int local_24;
  int local_20;
  
  if (param_1 == 0) {
    for (local_20 = 0; local_20 < 10; local_20 = local_20 + 1) {
      *(undefined *)((long)local_20 + 0x100008000) = 1;
      uVar3 = 9;
      if (1 < local_20) {
        uVar3 = 1;
      }
      _count_colorful(uVar3,local_20,1);
      *(undefined *)((long)local_20 + 0x100008000) = 0;
    }
  }
  else {
    uVar2 = _colorful(param_2);
    if (((uVar2 & 1) != 0) &&
       (piVar1 = (int *)((long)(param_3 + -1) * 4 + 0x10000800c), *piVar1 = *piVar1 + 1,
       _DAT_10000802c < param_2)) {
      _DAT_10000802c = param_2;
    }
    if (param_1 < 9) {
      for (local_24 = 2; local_24 < 10; local_24 = local_24 + 1) {
        if ((*(byte *)((long)local_24 + 0x100008000) & 1) == 0) {
          *(undefined *)((long)local_24 + 0x100008000) = 1;
          _count_colorful(param_1 + 1,param_2 * 10 + local_24,param_3 + 1);
          *(undefined *)((long)local_24 + 0x100008000) = 0;
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  ulong uVar1;
  int local_30;
  int local_24;
  
  _setlocale(0,"");
  _clock();
  _printf("Colorful numbers less than 100:\n");
  for (local_24 = 0; local_24 < 100; local_24 = local_24 + 1) {
    uVar1 = _colorful(local_24);
    if ((uVar1 & 1) != 0) {
      _printf("%2d%c");
    }
  }
  _count_colorful(0,0);
  _printf("\n\nLargest colorful number: %\'d\n");
  _printf("\nCount of colorful numbers by number of digits:\n");
  for (local_30 = 0; local_30 < 8; local_30 = local_30 + 1) {
    _printf("%d   %\'d\n");
  }
  _printf("\nTotal: %\'d\n");
  _clock();
  _printf("\nElapsed time: %f seconds\n");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004010)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004018)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004028)();
  return;
}


`
`#include<stdlib.h>
#include<stdio.h>
#include<time.h>

typedef struct genome{
    char base;
    struct genome *next;
}genome;

typedef struct{
    char mutation;
    int position;
}genomeChange;

typedef struct{
    int adenineCount,thymineCount,cytosineCount,guanineCount;
}baseCounts;

genome *strand;
baseCounts baseData;
int genomeLength = 100, lineLength = 50;

int numDigits(int num){
    int len = 1;

    while(num>10){
        num /= 10;
        len++;
    }
    return len;
}

void generateStrand(){

    int baseChoice = rand()%4, i;
    genome *strandIterator, *newStrand;

    baseData.adenineCount = 0;
    baseData.thymineCount = 0;
    baseData.cytosineCount = 0;
    baseData.guanineCount = 0;

    strand = (genome*)malloc(sizeof(genome));
    strand->base = baseChoice==0?'A':(baseChoice==1?'T':(baseChoice==2?'C':'G'));
    baseChoice==0?baseData.adenineCount++:(baseChoice==1?baseData.thymineCount++:(baseChoice==2?baseData.cytosineCount++:baseData.guanineCount++));
    strand->next = NULL;

    strandIterator = strand;

    for(i=1;i<genomeLength;i++){
        baseChoice = rand()%4;

        newStrand = (genome*)malloc(sizeof(genome));
        newStrand->base = baseChoice==0?'A':(baseChoice==1?'T':(baseChoice==2?'C':'G'));
        baseChoice==0?baseData.adenineCount++:(baseChoice==1?baseData.thymineCount++:(baseChoice==2?baseData.cytosineCount++:baseData.guanineCount++));
        newStrand->next = NULL;

        strandIterator->next = newStrand;
        strandIterator = newStrand;
    }
}

genomeChange generateMutation(int swapWeight, int insertionWeight, int deletionWeight){
    int mutationChoice = rand()%(swapWeight + insertionWeight + deletionWeight);

    genomeChange mutationCommand;

    mutationCommand.mutation = mutationChoice<swapWeight?'S':((mutationChoice>=swapWeight && mutationChoice<swapWeight+insertionWeight)?'I':'D');
    mutationCommand.position = rand()%genomeLength;

    return mutationCommand;
}

void printGenome(){
    int rows, width = numDigits(genomeLength), len = 0,i,j;
	lineLength = (genomeLength<lineLength)?genomeLength:lineLength;
	
	rows = genomeLength/lineLength + (genomeLength%lineLength!=0);
	
    genome* strandIterator = strand;

    printf("\n\nGenome : \n--------\n");

    for(i=0;i<rows;i++){
        printf("\n%*d%3s",width,len,":");

        for(j=0;j<lineLength && strandIterator!=NULL;j++){
                printf("%c",strandIterator->base);
                strandIterator = strandIterator->next;
        }
        len += lineLength;
    }

    while(strandIterator!=NULL){
            printf("%c",strandIterator->base);
            strandIterator = strandIterator->next;
    }

    printf("\n\nBase Counts\n-----------");

    printf("\n%*c%3s%*d",width,'A',":",width,baseData.adenineCount);
    printf("\n%*c%3s%*d",width,'T',":",width,baseData.thymineCount);
    printf("\n%*c%3s%*d",width,'C',":",width,baseData.cytosineCount);
    printf("\n%*c%3s%*d",width,'G',":",width,baseData.guanineCount);
	
	printf("\n\nTotal:%*d",width,baseData.adenineCount + baseData.thymineCount + baseData.cytosineCount + baseData.guanineCount);

    printf("\n");
}

void mutateStrand(int numMutations, int swapWeight, int insertionWeight, int deletionWeight){
    int i,j,width,baseChoice;
    genomeChange newMutation;
    genome *strandIterator, *strandFollower, *newStrand;

    for(i=0;i<numMutations;i++){
        strandIterator = strand;
        strandFollower = strand;
        newMutation = generateMutation(swapWeight,insertionWeight,deletionWeight);
        width = numDigits(genomeLength);

        for(j=0;j<newMutation.position;j++){
            strandFollower = strandIterator;
            strandIterator = strandIterator->next;
        }

        if(newMutation.mutation=='S'){
            if(strandIterator->base=='A'){
                strandIterator->base='T';
                printf("\nSwapping A at position : %*d with T",width,newMutation.position);
            }
            else if(strandIterator->base=='A'){
                strandIterator->base='T';
                printf("\nSwapping A at position : %*d with T",width,newMutation.position);
            }
            else if(strandIterator->base=='C'){
                strandIterator->base='G';
                printf("\nSwapping C at position : %*d with G",width,newMutation.position);
            }
            else{
                strandIterator->base='C';
                printf("\nSwapping G at position : %*d with C",width,newMutation.position);
            }
        }

        else if(newMutation.mutation=='I'){
            baseChoice = rand()%4;

            newStrand = (genome*)malloc(sizeof(genome));
            newStrand->base = baseChoice==0?'A':(baseChoice==1?'T':(baseChoice==2?'C':'G'));
            printf("\nInserting %c at position : %*d",newStrand->base,width,newMutation.position);
            baseChoice==0?baseData.adenineCount++:(baseChoice==1?baseData.thymineCount++:(baseChoice==2?baseData.cytosineCount++:baseData.guanineCount++));
            newStrand->next = strandIterator;
            strandFollower->next = newStrand;
            genomeLength++;
        }

        else{
            strandFollower->next = strandIterator->next;
            strandIterator->next = NULL;
            printf("\nDeleting %c at position : %*d",strandIterator->base,width,newMutation.position);
            free(strandIterator);
            genomeLength--;
        }
    }
}

int main(int argc,char* argv[])
{
    int numMutations = 10, swapWeight = 10, insertWeight = 10, deleteWeight = 10;

    if(argc==1||argc>6){
                printf("Usage : %s <Genome Length> <Optional number of mutations> <Optional Swapping weight> <Optional Insertion weight> <Optional Deletion weight>\n",argv[0]);
                return 0;
    }

    switch(argc){
        case 2: genomeLength = atoi(argv[1]);
                break;
        case 3: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                break;
        case 4: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                swapWeight   = atoi(argv[3]);
                break;
        case 5: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                swapWeight   = atoi(argv[3]);
                insertWeight = atoi(argv[4]);
                break;
        case 6: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                swapWeight   = atoi(argv[3]);
                insertWeight = atoi(argv[4]);
                deleteWeight = atoi(argv[5]);
                break;
    };

    srand(time(NULL));
    generateStrand();
	
	printf("\nOriginal:");
    printGenome();
    mutateStrand(numMutations,swapWeight,insertWeight,deleteWeight);

	printf("\n\nMutated:");
	printGenome();

    return 0;
}
`,`#include "bioinformatics-sequence-mutation.h"



int _numDigits(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 1;
  for (local_4 = param_1; 10 < local_4; local_4 = local_4 / 10) {
    local_8 = local_8 + 1;
  }
  return local_8;
}



void _generateStrand(void)

{
  int iVar1;
  undefined *puVar2;
  undefined local_34;
  undefined local_2c;
  undefined *local_20;
  int local_18;
  
  iVar1 = _rand();
  iVar1 = iVar1 % 4;
  _baseData = 0;
  DAT_10000800c = 0;
  DAT_100008010 = 0;
  DAT_100008014 = 0;
  _strand = (undefined *)_malloc(0x10);
  if (iVar1 == 0) {
    local_2c = 0x41;
  }
  else if (iVar1 == 1) {
    local_2c = 0x54;
  }
  else {
    local_2c = 0x43;
    if (iVar1 != 2) {
      local_2c = 0x47;
    }
  }
  *_strand = local_2c;
  if (iVar1 == 0) {
    _baseData = _baseData + 1;
  }
  else if (iVar1 == 1) {
    DAT_10000800c = DAT_10000800c + 1;
  }
  else if (iVar1 == 2) {
    DAT_100008010 = DAT_100008010 + 1;
  }
  else {
    DAT_100008014 = DAT_100008014 + 1;
  }
  *(undefined8 *)(_strand + 8) = 0;
  local_20 = _strand;
  for (local_18 = 1; local_18 < _genomeLength; local_18 = local_18 + 1) {
    iVar1 = _rand();
    iVar1 = iVar1 % 4;
    puVar2 = (undefined *)_malloc(0x10);
    if (iVar1 == 0) {
      local_34 = 0x41;
    }
    else if (iVar1 == 1) {
      local_34 = 0x54;
    }
    else {
      local_34 = 0x43;
      if (iVar1 != 2) {
        local_34 = 0x47;
      }
    }
    *puVar2 = local_34;
    if (iVar1 == 0) {
      _baseData = _baseData + 1;
    }
    else if (iVar1 == 1) {
      DAT_10000800c = DAT_10000800c + 1;
    }
    else if (iVar1 == 2) {
      DAT_100008010 = DAT_100008010 + 1;
    }
    else {
      DAT_100008014 = DAT_100008014 + 1;
    }
    *(undefined8 *)(puVar2 + 8) = 0;
    *(undefined **)(local_20 + 8) = puVar2;
    local_20 = puVar2;
  }
  return;
}



undefined8 _generateMutation(int param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  undefined local_2c;
  undefined4 local_18;
  
  iVar3 = _rand();
  param_3 = param_1 + param_2 + param_3;
  iVar2 = 0;
  if (param_3 != 0) {
    iVar2 = iVar3 / param_3;
  }
  iVar3 = iVar3 - iVar2 * param_3;
  if (iVar3 < param_1) {
    local_2c = 0x53;
  }
  else {
    bVar1 = false;
    if (param_1 <= iVar3) {
      bVar1 = iVar3 < param_1 + param_2;
    }
    local_2c = 0x49;
    if (!bVar1) {
      local_2c = 0x44;
    }
  }
  local_18 = CONCAT31(local_18._1_3_,local_2c);
  iVar3 = _rand();
  iVar2 = 0;
  if (_genomeLength != 0) {
    iVar2 = iVar3 / _genomeLength;
  }
  return CONCAT44(iVar3 - iVar2 * _genomeLength,local_18);
}



int _printGenome(void)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  int local_3c;
  long local_30;
  int local_24;
  int local_20;
  
  _numDigits(_genomeLength);
  if (_genomeLength < _lineLength) {
    local_3c = _genomeLength;
  }
  else {
    local_3c = _lineLength;
  }
  _lineLength = local_3c;
  iVar3 = 0;
  if (local_3c != 0) {
    iVar3 = _genomeLength / local_3c;
  }
  iVar1 = 0;
  if (local_3c != 0) {
    iVar1 = _genomeLength / local_3c;
  }
  bVar2 = _genomeLength != iVar1 * local_3c;
  local_30 = _strand;
  _printf("\n\nGenome : \n--------\n");
  for (local_20 = 0; local_20 < (int)(iVar3 + (uint)bVar2); local_20 = local_20 + 1) {
    _printf("\n%*d%3s");
    for (local_24 = 0; local_24 < _lineLength && local_30 != 0; local_24 = local_24 + 1) {
      _printf("%c");
      local_30 = *(long *)(local_30 + 8);
    }
  }
  for (; local_30 != 0; local_30 = *(long *)(local_30 + 8)) {
    _printf("%c");
  }
  _printf("\n\nBase Counts\n-----------");
  _printf("\n%*c%3s%*d");
  _printf("\n%*c%3s%*d");
  _printf("\n%*c%3s%*d");
  _printf("\n%*c%3s%*d");
  _printf("\n\nTotal:%*d");
  iVar3 = _printf("\n");
  return iVar3;
}



void _mutateStrand(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  int iVar1;
  undefined8 uVar2;
  undefined *puVar3;
  undefined local_5c;
  char *local_48;
  char *local_40;
  char local_38;
  int iStack_34;
  int local_28;
  int local_24;
  
  for (local_24 = 0; local_24 < param_1; local_24 = local_24 + 1) {
    local_40 = _strand;
    local_48 = _strand;
    uVar2 = _generateMutation(param_2,param_3,param_4);
    _numDigits(_genomeLength);
    for (local_28 = 0; iStack_34 = (int)((ulong)uVar2 >> 0x20), local_28 < iStack_34;
        local_28 = local_28 + 1) {
      local_48 = local_40;
      local_40 = *(char **)(local_40 + 8);
    }
    local_38 = (char)uVar2;
    if (local_38 == 'S') {
      if (*local_40 == 'A') {
        *local_40 = 'T';
        _printf("\nSwapping A at position : %*d with T");
      }
      else if (*local_40 == 'A') {
        *local_40 = 'T';
        _printf("\nSwapping A at position : %*d with T");
      }
      else if (*local_40 == 'C') {
        *local_40 = 'G';
        _printf("\nSwapping C at position : %*d with G");
      }
      else {
        *local_40 = 'C';
        _printf("\nSwapping G at position : %*d with C");
      }
    }
    else if (local_38 == 'I') {
      iVar1 = _rand();
      iVar1 = iVar1 % 4;
      puVar3 = (undefined *)_malloc(0x10);
      if (iVar1 == 0) {
        local_5c = 0x41;
      }
      else if (iVar1 == 1) {
        local_5c = 0x54;
      }
      else {
        local_5c = 0x43;
        if (iVar1 != 2) {
          local_5c = 0x47;
        }
      }
      *puVar3 = local_5c;
      _printf("\nInserting %c at position : %*d");
      if (iVar1 == 0) {
        _baseData = _baseData + 1;
      }
      else if (iVar1 == 1) {
        DAT_10000800c = DAT_10000800c + 1;
      }
      else if (iVar1 == 2) {
        DAT_100008010 = DAT_100008010 + 1;
      }
      else {
        DAT_100008014 = DAT_100008014 + 1;
      }
      *(char **)(puVar3 + 8) = local_40;
      *(undefined **)(local_48 + 8) = puVar3;
      _genomeLength = _genomeLength + 1;
    }
    else {
      *(undefined8 *)(local_48 + 8) = *(undefined8 *)(local_40 + 8);
      local_40[8] = '\0';
      local_40[9] = '\0';
      local_40[10] = '\0';
      local_40[0xb] = '\0';
      local_40[0xc] = '\0';
      local_40[0xd] = '\0';
      local_40[0xe] = '\0';
      local_40[0xf] = '\0';
      _printf("\nDeleting %c at position : %*d");
      _free(local_40);
      _genomeLength = _genomeLength + -1;
    }
  }
  return;
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  time_t tVar2;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  
  local_24 = 10;
  local_28 = 10;
  local_2c = 10;
  local_30 = 10;
  if ((param_1 == 1) || (6 < param_1)) {
    _printf(
           "Usage : %s <Genome Length> <Optional number of mutations> <Optional Swapping weight> <Optional Insertion weight> <Optional Deletion weight>\n"
           );
  }
  else {
    switch(param_1) {
    case 2:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      break;
    case 3:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      break;
    case 4:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      local_28 = _atoi(*(char **)(param_2 + 0x18));
      break;
    case 5:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      local_28 = _atoi(*(char **)(param_2 + 0x18));
      local_2c = _atoi(*(char **)(param_2 + 0x20));
      break;
    case 6:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      local_28 = _atoi(*(char **)(param_2 + 0x18));
      local_2c = _atoi(*(char **)(param_2 + 0x20));
      local_30 = _atoi(*(char **)(param_2 + 0x28));
    }
    tVar2 = _time((time_t *)0x0);
    _srand((uint)tVar2);
    _generateStrand();
    iVar1 = _printf("\nOriginal:");
    _printGenome(iVar1);
    _mutateStrand(local_24,local_28,local_2c,local_30);
    iVar1 = _printf("\n\nMutated:");
    _printGenome(iVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003da4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003db0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dbc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dd4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003de0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dec. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004030)();
  return tVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* declare a typedef for a function pointer */
typedef double (*Class2Func)(double);

/*A couple of functions with the above prototype */
double functionA( double v)
{
   return v*v*v;
}
double functionB(double v)
{
   return exp(log(v)/3);
}

/* A function taking a function as an argument */
double Function1( Class2Func f2, double val )
{
    return f2(val);
}

/*A function returning a function */
Class2Func WhichFunc( int idx)
{
   return (idx < 4) ? &functionA : &functionB;
}

/* A list of functions */
Class2Func funcListA[] = {&functionA, &sin, &cos, &tan };
Class2Func funcListB[] = {&functionB, &asin, &acos, &atan };

/* Composing Functions */
double InvokeComposed( Class2Func f1, Class2Func f2, double val )
{
   return f1(f2(val));
}

typedef struct sComposition {
   Class2Func f1;
   Class2Func f2;
} *Composition;

Composition Compose( Class2Func f1, Class2Func f2)
{
   Composition comp = malloc(sizeof(struct sComposition));
   comp->f1 = f1;
   comp->f2 = f2;
   return comp;
}

double CallComposed( Composition comp, double val )
{
    return comp->f1( comp->f2(val) );
}
/** * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main(int argc, char *argv[])
{
   int ix;
   Composition c;

   printf("Function1(functionA, 3.0) = %f\n", Function1(WhichFunc(0), 3.0));

   for (ix=0; ix<4; ix++) {
       c = Compose(funcListA[ix], funcListB[ix]);
       printf("Compostion %d(0.9) = %f\n", ix, CallComposed(c, 0.9));
   }

   return 0;
}
`,`#include "first-class-functions-1.h"



undefined  [16] _functionA(double param_1)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_1 * param_1;
  auVar1._8_8_ = 0;
  return auVar1;
}



void _functionB(undefined8 param_1)

{
  double dVar1;
  
  dVar1 = (double)_log(param_1);
  _exp(dVar1 / 3.0);
  return;
}



void _Function1(undefined8 param_1,code *param_2)

{
  (*param_2)(param_1);
  return;
}



code * _WhichFunc(int param_1)

{
  code *pcVar1;
  
  pcVar1 = _functionA;
  if (3 < param_1) {
    pcVar1 = _functionB;
  }
  return pcVar1;
}



void _InvokeComposed(undefined8 param_1,code *param_2,code *param_3)

{
  (*param_3)(param_1);
  (*param_2)();
  return;
}



undefined8 * _Compose(undefined8 param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x10);
  *puVar1 = param_1;
  puVar1[1] = param_2;
  return puVar1;
}



void _CallComposed(undefined8 param_1,undefined8 *param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)*param_2;
  (*(code *)param_2[1])(param_1);
  (*pcVar1)();
  return;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  int local_24;
  
  _WhichFunc(0);
  _Function1(0x4008000000000000);
  _printf("Function1(functionA, 3.0) = %f\n");
  for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
    uVar1 = _Compose((&_funcListA)[local_24],(&_funcListB)[local_24]);
    _CallComposed(0x3feccccccccccccd,uVar1);
    _printf("Compostion %d(0.9) = %f\n");
  }
  return 0;
}



void _exp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exp_100004000)();
  return;
}



void _log(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

void bead_sort(int *a, int len)
{
	int i, j, max, sum;
	unsigned char *beads;
#	define BEAD(i, j) beads[i * max + j]

	for (i = 1, max = a[0]; i < len; i++)
		if (a[i] > max) max = a[i];

	beads = calloc(1, max * len);

	/* mark the beads */
	for (i = 0; i < len; i++)
		for (j = 0; j < a[i]; j++)
			BEAD(i, j) = 1;

	for (j = 0; j < max; j++) {
		/* count how many beads are on each post */
		for (sum = i = 0; i < len; i++) {
			sum += BEAD(i, j);
			BEAD(i, j) = 0;
		}
		/* mark bottom sum beads */
		for (i = len - sum; i < len; i++) BEAD(i, j) = 1;
	}

	for (i = 0; i < len; i++) {
		for (j = 0; j < max && BEAD(i, j); j++);
		a[i] = j;
	}
	free(beads);
}

int main()
{
	int i, x[] = {5, 3, 1, 7, 4, 1, 1, 20};
	int len = sizeof(x)/sizeof(x[0]);

	bead_sort(x, len);
	for (i = 0; i < len; i++)
		printf("%d\n", x[i]);

	return 0;
}
`,`#include "sorting-algorithms-bead-sort.h"



void _bead_sort(int *param_1,int param_2)

{
  bool bVar1;
  void *pvVar2;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  local_20 = 1;
  local_28 = *param_1;
  for (; local_20 < param_2; local_20 = local_20 + 1) {
    if (local_28 < param_1[local_20]) {
      local_28 = param_1[local_20];
    }
  }
  pvVar2 = _calloc(1,(long)(local_28 * param_2));
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < param_1[local_20]; local_24 = local_24 + 1) {
      *(undefined *)((long)pvVar2 + (long)(local_20 * local_28 + local_24)) = 1;
    }
  }
  for (local_24 = 0; local_24 < local_28; local_24 = local_24 + 1) {
    local_2c = 0;
    for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
      local_2c = local_2c + (uint)*(byte *)((long)pvVar2 + (long)(local_20 * local_28 + local_24));
      *(undefined *)((long)pvVar2 + (long)(local_20 * local_28 + local_24)) = 0;
    }
    for (local_20 = param_2 - local_2c; local_20 < param_2; local_20 = local_20 + 1) {
      *(undefined *)((long)pvVar2 + (long)(local_20 * local_28 + local_24)) = 1;
    }
  }
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    local_24 = 0;
    while( true ) {
      bVar1 = false;
      if (local_24 < local_28) {
        bVar1 = *(char *)((long)pvVar2 + (long)(local_20 * local_28 + local_24)) != '\0';
      }
      if (!bVar1) break;
      local_24 = local_24 + 1;
    }
    param_1[local_20] = local_24;
  }
  _free(pvVar2);
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  int local_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_38 = 0x700000001;
  local_40 = 0x300000005;
  uStack_28 = 0x1400000001;
  local_30 = 0x100000004;
  uVar2 = _bead_sort(&local_40,8);
  for (local_48 = 0; local_48 < 8; local_48 = local_48 + 1) {
    uVar1 = _printf("%d\n");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct oid_tag {
    char* str_;
    int* numbers_;
    int length_;
} oid;

// free memory, no-op if p is null
void oid_destroy(oid* p) {
    if (p != 0) {
        free(p->str_);
        free(p->numbers_);
        free(p);
    }
}

int char_count(const char* str, char ch) {
    int count = 0;
    for (const char* p = str; *p; ++p) {
        if (*p == ch)
            ++count;
    }
    return count;
}

// construct an OID from a string
// returns 0 on memory allocation failure or parse error
oid* oid_create(const char* str) {
    oid* ptr = calloc(1, sizeof(oid));
    if (ptr == 0)
        return 0;
    ptr->str_ = strdup(str);
    if (ptr->str_ == 0) {
        oid_destroy(ptr);
        return 0;
    }
    int dots = char_count(str, '.');
    ptr->numbers_ = malloc(sizeof(int) * (dots + 1));
    if (ptr->numbers_ == 0) {
        oid_destroy(ptr);
        return 0;
    }
    ptr->length_ = dots + 1;
    const char* p = str;
    for (int i = 0; i <= dots && *p;) {
        char* eptr = 0;
        int num = strtol(p, &eptr, 10);
        if (*eptr != 0 && *eptr != '.') {
            // TODO: check for overflow/underflow
            oid_destroy(ptr);
            return 0;
        }
        ptr->numbers_[i++] = num;
        p = eptr;
        if (*p)
            ++p;
    }
    return ptr;
}

// compare two OIDs
int oid_compare(const void* p1, const void* p2) {
    const oid* o1 = *(oid* const*)p1;
    const oid* o2 = *(oid* const*)p2;
    int i1 = 0, i2 = 0;
    for (; i1 < o1->length_ && i2 < o2->length_; ++i1, ++i2) {
        if (o1->numbers_[i1] < o2->numbers_[i2])
            return -1;
        if (o1->numbers_[i1] > o2->numbers_[i2])
            return 1;
    }
    if (o1->length_ < o2->length_)
        return -1;
    if (o1->length_ > o2->length_)
        return 1;
    return 0;
}

int main() {
    const char* input[] = {
        "1.3.6.1.4.1.11.2.17.19.3.4.0.10",
        "1.3.6.1.4.1.11.2.17.5.2.0.79",
        "1.3.6.1.4.1.11.2.17.19.3.4.0.4",
        "1.3.6.1.4.1.11150.3.4.0.1",
        "1.3.6.1.4.1.11.2.17.19.3.4.0.1",
        "1.3.6.1.4.1.11150.3.4.0"
    };
    const int len = sizeof(input)/sizeof(input[0]);
    oid* oids[len];
    memset(oids, 0, sizeof(oids));
    int i;
    for (i = 0; i < len; ++i) {
        oids[i] = oid_create(input[i]);
        if (oids[i] == 0)
        {
            fprintf(stderr, "Out of memory\n");
            goto cleanup;
        }
    }
    qsort(oids, len, sizeof(oid*), oid_compare);
    for (i = 0; i < len; ++i)
        puts(oids[i]->str_);
cleanup:
    for (i = 0; i < len; ++i)
        oid_destroy(oids[i]);
    return 0;
}
`,`#include "sort-a-list-of-object-identifiers.h"



void _oid_destroy(undefined8 *param_1)

{
  if (param_1 != (undefined8 *)0x0) {
    _free((void *)*param_1);
    _free((void *)param_1[1]);
    _free(param_1);
  }
  return;
}



int _char_count(char *param_1,char param_2)

{
  char *local_18;
  int local_10;
  
  local_10 = 0;
  for (local_18 = param_1; *local_18 != '\0'; local_18 = local_18 + 1) {
    if (*local_18 == param_2) {
      local_10 = local_10 + 1;
    }
  }
  return local_10;
}



long * _oid_create(char *param_1)

{
  bool bVar1;
  char *pcVar2;
  void *pvVar3;
  long lVar4;
  long lVar5;
  char *local_48;
  int local_3c;
  char *local_38;
  int local_2c;
  long *local_28;
  char *local_20;
  
  local_20 = param_1;
  local_28 = (long *)_calloc(1,0x18);
  if (local_28 != (long *)0x0) {
    pcVar2 = _strdup(local_20);
    *local_28 = (long)pcVar2;
    if (*local_28 == 0) {
      _oid_destroy(local_28);
    }
    else {
      local_2c = _char_count(local_20,0x2e);
      pvVar3 = _malloc((long)(local_2c + 1) * 4);
      local_28[1] = (long)pvVar3;
      if (local_28[1] == 0) {
        _oid_destroy(local_28);
      }
      else {
        *(int *)(local_28 + 2) = local_2c + 1;
        local_38 = local_20;
        local_3c = 0;
        while( true ) {
          bVar1 = false;
          if (local_3c <= local_2c) {
            bVar1 = *local_38 != '\0';
          }
          if (!bVar1) {
            return local_28;
          }
          local_48 = (char *)0x0;
          lVar4 = _strtol(local_38,&local_48,10);
          if ((*local_48 != '\0') && (*local_48 != '.')) break;
          lVar5 = (long)local_3c;
          local_3c = local_3c + 1;
          *(int *)(local_28[1] + lVar5 * 4) = (int)lVar4;
          local_38 = local_48;
          if (*local_48 != '\0') {
            local_38 = local_48 + 1;
          }
        }
        _oid_destroy(local_28);
      }
    }
  }
  return (long *)0x0;
}



undefined4 _oid_compare(long *param_1,long *param_2)

{
  bool bVar1;
  long lVar2;
  long lVar3;
  int local_30;
  int local_2c;
  
  lVar2 = *param_1;
  lVar3 = *param_2;
  local_2c = 0;
  local_30 = 0;
  while( true ) {
    bVar1 = false;
    if (local_2c < *(int *)(lVar2 + 0x10)) {
      bVar1 = local_30 < *(int *)(lVar3 + 0x10);
    }
    if (!bVar1) {
      if (*(int *)(lVar2 + 0x10) < *(int *)(lVar3 + 0x10)) {
        return 0xffffffff;
      }
      if (*(int *)(lVar3 + 0x10) < *(int *)(lVar2 + 0x10)) {
        return 1;
      }
      return 0;
    }
    if (*(int *)(*(long *)(lVar2 + 8) + (long)local_2c * 4) <
        *(int *)(*(long *)(lVar3 + 8) + (long)local_30 * 4)) {
      return 0xffffffff;
    }
    if (*(int *)(*(long *)(lVar3 + 8) + (long)local_30 * 4) <
        *(int *)(*(long *)(lVar2 + 8) + (long)local_2c * 4)) break;
    local_2c = local_2c + 1;
    local_30 = local_30 + 1;
  }
  return 1;
}



undefined8 entry(void)

{
  long lVar1;
  int local_84;
  long alStack_78 [6];
  undefined8 auStack_48 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_48,&PTR_s_1_3_6_1_4_1_11_2_17_19_3_4_0_10_100004068,0x30);
  _memset(alStack_78,0,0x30);
  local_84 = 0;
  do {
    if (5 < local_84) {
      _qsort(alStack_78,6,8,(int *)_oid_compare);
      for (local_84 = 0; local_84 < 6; local_84 = local_84 + 1) {
        _puts(*(char **)alStack_78[local_84]);
      }
LAB_100003ddc:
      for (local_84 = 0; local_84 < 6; local_84 = local_84 + 1) {
        _oid_destroy(alStack_78[local_84]);
      }
      if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
        return 0;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    lVar1 = _oid_create(auStack_48[local_84]);
    alStack_78[local_84] = lVar1;
    if (alStack_78[local_84] == 0) {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"Out of memory\n");
      goto LAB_100003ddc;
    }
    local_84 = local_84 + 1;
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004040)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004058)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _strtol(char *param_1,char **param_2,int param_3)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__strtol_100004060)(param_1,param_2,param_3);
  return lVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int verbose = 0;
#define COND(a, b) int a(int *s) { return (b); }
typedef int(*condition)(int *);

/* BEGIN problem specific setup */
#define N_FLOORS 5
#define TOP (N_FLOORS - 1)
int solution[N_FLOORS] = { 0 };
int occupied[N_FLOORS] = { 0 };

enum tenants {
	baker = 0,
	cooper,
	fletcher,
	miller,
	smith,
	phantom_of_the_opera,
};

const char *names[] = {
	"baker",
	"cooper",
	"fletcher",
	"miller",
	"smith",
};

COND(c0, s[baker] != TOP);
COND(c1, s[cooper] != 0);
COND(c2, s[fletcher] != 0 && s[fletcher] != TOP);
COND(c3, s[miller] > s[cooper]);
COND(c4, abs(s[smith] - s[fletcher]) != 1);
COND(c5, abs(s[cooper] - s[fletcher]) != 1);
#define N_CONDITIONS 6

condition cond[] = { c0, c1, c2, c3, c4, c5 };

/* END of problem specific setup */

int solve(int person)
{
	int i, j;
	if (person == phantom_of_the_opera) {
		/* check condition */
		for (i = 0; i < N_CONDITIONS; i++) {
			if (cond[i](solution)) continue;

			if (verbose) {
				for (j = 0; j < N_FLOORS; j++)
					printf("%d %s\n", solution[j], names[j]);
				printf("cond %d bad\n\n", i);
			}
			return 0;
		}

		printf("Found arrangement:\n");
		for (i = 0; i < N_FLOORS; i++)
			printf("%d %s\n", solution[i], names[i]);
		return 1;
	}

	for (i = 0; i < N_FLOORS; i++) {
		if (occupied[i]) continue;
		solution[person] = i;
		occupied[i] = 1;
		if (solve(person + 1)) return 1;
		occupied[i] = 0;
	}
	return 0;
}

int main()
{
	verbose = 0;
	if (!solve(0)) printf("Nobody lives anywhere\n");
	return 0;
}
`,`#include "dinesmans-multiple-dwelling-problem.h"



bool _c0(int *param_1)

{
  return *param_1 != 4;
}



bool _c1(long param_1)

{
  return *(int *)(param_1 + 4) != 0;
}



bool _c2(long param_1)

{
  bool bVar1;
  
  bVar1 = false;
  if (*(int *)(param_1 + 8) != 0) {
    bVar1 = *(int *)(param_1 + 8) != 4;
  }
  return bVar1;
}



bool _c3(long param_1)

{
  return *(int *)(param_1 + 4) < *(int *)(param_1 + 0xc);
}



bool _c4(long param_1)

{
  int iVar1;
  
  iVar1 = _abs(*(int *)(param_1 + 0x10) - *(int *)(param_1 + 8));
  return iVar1 != 1;
}



bool _c5(long param_1)

{
  int iVar1;
  
  iVar1 = _abs(*(int *)(param_1 + 4) - *(int *)(param_1 + 8));
  return iVar1 != 1;
}



undefined4 _solve(int param_1)

{
  int iVar1;
  int local_20;
  int local_1c;
  undefined4 local_14;
  
  if (param_1 == 5) {
    for (local_1c = 0; local_1c < 6; local_1c = local_1c + 1) {
      iVar1 = (*(code *)(&_cond)[local_1c])(&_solution);
      if (iVar1 == 0) {
        if (_verbose != 0) {
          for (local_20 = 0; local_20 < 5; local_20 = local_20 + 1) {
            _printf("%d %s\n");
          }
          _printf("cond %d bad\n\n");
        }
        return 0;
      }
    }
    _printf("Found arrangement:\n");
    for (local_1c = 0; local_1c < 5; local_1c = local_1c + 1) {
      _printf("%d %s\n");
    }
    local_14 = 1;
  }
  else {
    for (local_1c = 0; local_1c < 5; local_1c = local_1c + 1) {
      if (*(int *)(&_occupied + (long)local_1c * 4) == 0) {
        *(int *)(&_solution + (long)param_1 * 4) = local_1c;
        *(undefined4 *)(&_occupied + (long)local_1c * 4) = 1;
        iVar1 = _solve(param_1 + 1);
        if (iVar1 != 0) {
          return 1;
        }
        *(undefined4 *)(&_occupied + (long)local_1c * 4) = 0;
      }
    }
    local_14 = 0;
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  
  _verbose = 0;
  iVar1 = _solve(0);
  if (iVar1 == 0) {
    _printf("Nobody lives anywhere\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _abs(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__abs_100004000)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

/* define a shuffle function. e.g. decl_shuffle(double).
 * advantage: compiler is free to optimize the swap operation without
 *            indirection with pointers, which could be much faster.
 * disadvantage: each datatype needs a separate instance of the function.
 *            for a small funciton like this, it's not very big a deal.
 */
#define decl_shuffle(type)				\
void shuffle_##type(type *list, size_t len) {		\
	int j;						\
	type tmp;					\
	while(len) {					\
		j = irand(len);				\
		if (j != len - 1) {			\
			tmp = list[j];			\
			list[j] = list[len - 1];	\
			list[len - 1] = tmp;		\
		}					\
		len--;					\
	}						\
}							\

/* random integer from 0 to n-1 */
int irand(int n)
{
	int r, rand_max = RAND_MAX - (RAND_MAX % n);
	/* reroll until r falls in a range that can be evenly
	 * distributed in n bins.  Unless n is comparable to
	 * to RAND_MAX, it's not *that* important really. */
	while ((r = rand()) >= rand_max);
	return r / (rand_max / n);
}

/* declare and define int type shuffle function from macro */
decl_shuffle(int);

int main()
{
	int i, x[20];

	for (i = 0; i < 20; i++) x[i] = i;
	for (printf("before:"), i = 0; i < 20 || !printf("\n"); i++)
		printf(" %d", x[i]);

	shuffle_int(x, 20);

	for (printf("after: "), i = 0; i < 20 || !printf("\n"); i++)
		printf(" %d", x[i]);
	return 0;
}
`,`#include "knuth-shuffle-2.h"



int _irand(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar1 = 0;
  if (param_1 != 0) {
    iVar1 = 0x7fffffff / param_1;
  }
  iVar1 = 0x7fffffff - (0x7fffffff - iVar1 * param_1);
  do {
    iVar3 = _rand();
  } while (iVar1 <= iVar3);
  iVar2 = 0;
  if (param_1 != 0) {
    iVar2 = iVar1 / param_1;
  }
  iVar1 = 0;
  if (iVar2 != 0) {
    iVar1 = iVar3 / iVar2;
  }
  return iVar1;
}



void _shuffle_int(long param_1,long param_2)

{
  undefined4 uVar1;
  int iVar2;
  undefined8 local_20;
  
  for (local_20 = param_2; local_20 != 0; local_20 = local_20 + -1) {
    iVar2 = _irand(local_20);
    if ((long)iVar2 != local_20 + -1) {
      uVar1 = *(undefined4 *)(param_1 + (long)iVar2 * 4);
      *(undefined4 *)(param_1 + (long)iVar2 * 4) = *(undefined4 *)(param_1 + (local_20 + -1) * 4);
      *(undefined4 *)(param_1 + (local_20 + -1) * 4) = uVar1;
    }
  }
  return;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  int local_70;
  int aiStack_68 [20];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_70 = 0; local_70 < 0x14; local_70 = local_70 + 1) {
    aiStack_68[local_70] = local_70;
  }
  _printf("before:");
  local_70 = 0;
  while( true ) {
    bVar1 = true;
    if (0x13 < local_70) {
      iVar2 = _printf("\n");
      bVar1 = iVar2 == 0;
    }
    if (!bVar1) break;
    _printf(" %d");
    local_70 = local_70 + 1;
  }
  _shuffle_int(aiStack_68,0x14);
  iVar2 = _printf("after: ");
  local_70 = 0;
  while( true ) {
    bVar1 = true;
    if (0x13 < local_70) {
      iVar2 = _printf("\n");
      bVar1 = iVar2 == 0;
    }
    if (!bVar1) break;
    iVar2 = _printf(" %d");
    local_70 = local_70 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}


`
`#include <stdio.h>
#include <tgmath.h>

#define VERBOSE 0
#define for3 for(int i = 0; i < 3; i++)

typedef complex double vec;
typedef struct { vec c; double r; } circ;

#define re(x) creal(x)
#define im(x) cimag(x)
#define cp(x) re(x), im(x)
#define CPLX "(%6.3f,%6.3f)"
#define CPLX3 CPLX" "CPLX" "CPLX

double cross(vec a, vec b) { return re(a) * im(b) - im(a) * re(b); }
double abs2(vec a) { return a * conj(a); }

int apollonius_in(circ aa[], int ss[], int flip, int divert)
{
	vec n[3], x[3], t[3], a, b, center;
	int s[3], iter = 0, res = 0;
	double diff = 1, diff_old = -1, axb, d, r;

	for3 {
		s[i] = ss[i] ? 1 : -1;
		x[i] = aa[i].c;
	}

	while (diff > 1e-20) {
		a = x[0] - x[2], b = x[1] - x[2];
		diff = 0;
		axb = -cross(a, b);
		d = sqrt(abs2(a) * abs2(b) * abs2(a - b));

		if (VERBOSE) {
			const char *z = 1 + "-0+";
			printf("%c%c%c|%c%c|",
				z[s[0]], z[s[1]], z[s[2]], z[flip], z[divert]);
			printf(CPLX3, cp(x[0]), cp(x[1]), cp(x[2]));
		}

		/* r and center represent an arc through points x[i].  Each step,
		   we'll deform this arc by pushing or pulling some point on it
		   towards the edge of each given circle. */
		r = fabs(d / (2 * axb));
		center = (abs2(a)*b - abs2(b)*a) / (2 * axb) * I + x[2];

 		/* maybe the "arc" is actually straight line; then we have two
		   choices in defining "push" and "pull", so try both */
		if (!axb && flip != -1 && !divert) {
			if (!d) { /* generally means circle centers overlap */
				printf("Given conditions confused me.\n");
				return 0;
			}

			if (VERBOSE) puts("\n[divert]");
			divert = 1;
			res = apollonius_in(aa, ss, -1, 1);
		}

 		/* if straight line, push dir is its norm; else it's away from center */
		for3 n[i] = axb ? aa[i].c - center : a * I * flip;
		for3 t[i] = aa[i].c + n[i] / cabs(n[i]) * aa[i].r * s[i];

		/* diff: how much tangent points have moved since last iteration */
		for3 diff += abs2(t[i] - x[i]), x[i] = t[i];

		if (VERBOSE) printf(" %g\n", diff);

 		/* keep an eye on the total diff: failing to converge means no solution */
		if (diff >= diff_old && diff_old >= 0)
			if (iter++ > 20) return res;

		diff_old = diff;
	}

	printf("found: ");
	if (axb) printf("circle "CPLX", r = %f\n", cp(center), r);
	else	 printf("line "CPLX3"\n", cp(x[0]), cp(x[1]), cp(x[2]));

	return res + 1;
}

int apollonius(circ aa[])
{
	int s[3], i, sum = 0;
	for (i = 0; i < 8; i++) {
		s[0] = i & 1, s[1] = i & 2, s[2] = i & 4;

		/* internal or external results of a zero-radius circle are the same */
		if (s[0] && !aa[0].r) continue;
		if (s[1] && !aa[1].r) continue;
		if (s[2] && !aa[2].r) continue;
		sum += apollonius_in(aa, s, 1, 0);
	}
	return sum;
}

int main()
{
	circ a[3] = {{0, 1}, {4, 1}, {2 + 4 * I, 1}};
	circ b[3] = {{-3, 2}, {0, 1}, {3, 2}};
	circ c[3] = {{-2, 1}, {0, 1}, {2 * I, 1}};
	//circ c[3] = {{0, 1}, {0, 2}, {0, 3}}; <-- a fun one

	puts("set 1"); apollonius(a);
	puts("set 2"); apollonius(b);
	puts("set 3"); apollonius(c);
}
`,`#include "problem-of-apollonius.h"



undefined  [16] _cross(undefined8 param_1,double param_2,double param_3,undefined8 param_4)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = NEON_fnmsub(param_1,param_4,param_2 * param_3);
  auVar1._8_8_ = 0;
  return auVar1;
}



// WARNING: Removing unreachable block (ram,0x000100003160)
// WARNING: Removing unreachable block (ram,0x00010000317c)

undefined  [16] _abs2(double param_1,double param_2)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_1 - param_2 * -param_2;
  auVar1._8_8_ = 0;
  return auVar1;
}



// WARNING: Removing unreachable block (ram,0x000100003890)
// WARNING: Removing unreachable block (ram,0x0001000038b0)
// WARNING: Removing unreachable block (ram,0x0001000034b4)
// WARNING: Removing unreachable block (ram,0x0001000034d4)
// WARNING: Removing unreachable block (ram,0x000100003650)
// WARNING: Removing unreachable block (ram,0x000100003670)
// WARNING: Removing unreachable block (ram,0x0001000036f0)
// WARNING: Removing unreachable block (ram,0x000100003710)

int _apollonius_in(long param_1,long param_2,int param_3,int param_4)

{
  bool bVar1;
  double *pdVar2;
  uint uVar3;
  ulong uVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  double extraout_d0;
  double extraout_d0_00;
  double extraout_d0_01;
  double dVar11;
  double dVar12;
  int iVar13;
  double local_370;
  double local_368;
  int local_26c;
  int local_258;
  int local_254;
  int local_1dc;
  double local_1c8;
  double local_1c0;
  double local_1b8;
  int local_1b0;
  int local_1ac;
  int local_178;
  int local_15c;
  int aiStack_c4 [3];
  double adStack_b8 [6];
  double local_88 [12];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_1ac = 0;
  local_1b0 = 0;
  local_1b8 = 1.0;
  local_1c0 = -1.0;
  for (local_1dc = 0; local_178 = param_4, local_1dc < 3; local_1dc = local_1dc + 1) {
    iVar13 = -1;
    if (*(int *)(param_2 + (long)local_1dc * 4) != 0) {
      iVar13 = 1;
    }
    aiStack_c4[local_1dc] = iVar13;
    pdVar2 = (double *)(param_1 + (long)local_1dc * 0x18);
    dVar5 = pdVar2[1];
    local_88[(long)local_1dc * 2] = *pdVar2;
    local_88[(long)local_1dc * 2 + 1] = dVar5;
  }
  do {
    if (local_1b8 <= 1e-20) {
      _printf("found: ");
      if (local_1c8 == 0.0) {
        uVar3 = _printf("line (%6.3f,%6.3f) (%6.3f,%6.3f) (%6.3f,%6.3f)\n");
      }
      else {
        uVar3 = _printf("circle (%6.3f,%6.3f), r = %f\n");
      }
      uVar4 = (ulong)uVar3;
      local_15c = local_1b0 + 1;
LAB_100003bcc:
      if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
        ___stack_chk_fail(uVar4);
      }
      return local_15c;
    }
    dVar11 = local_88[0] - local_88[4];
    dVar5 = local_88[1] - local_88[5];
    dVar12 = local_88[2] - local_88[4];
    dVar6 = local_88[3] - local_88[5];
    local_1b8 = 0.0;
    dVar7 = (double)_cross(dVar11,dVar5,dVar12,dVar6);
    local_1c8 = -dVar7;
    dVar7 = (double)_abs2(dVar11,dVar5);
    dVar8 = (double)_abs2(dVar12,dVar6);
    dVar9 = (double)_abs2(dVar11 - dVar12,dVar5 - dVar6);
    dVar10 = (double)_abs2(dVar11,dVar5);
    uVar4 = _abs2(dVar12,dVar6);
    dVar12 = (dVar10 * dVar12 - extraout_d0 * dVar11) / (local_1c8 * 2.0);
    dVar6 = (dVar10 * dVar6 - extraout_d0 * dVar5) / (local_1c8 * 2.0);
    dVar10 = (dVar12 * 0.0 - dVar6 * 1.0) + local_88[4];
    dVar6 = dVar12 * 1.0 + dVar6 * 0.0 + local_88[5];
    if (((local_1c8 == 0.0) && (param_3 != -1)) && (local_178 == 0)) {
      if (SQRT(dVar7 * dVar8 * dVar9) == 0.0) {
        uVar3 = _printf("Given conditions confused me.\n");
        uVar4 = (ulong)uVar3;
        local_15c = 0;
        goto LAB_100003bcc;
      }
      local_178 = 1;
      uVar4 = _apollonius_in(param_1,param_2,0xffffffff);
      local_1b0 = (int)uVar4;
    }
    for (local_254 = 0; local_254 < 3; local_254 = local_254 + 1) {
      if (local_1c8 == 0.0) {
        dVar7 = dVar11 * 0.0 - dVar5 * 1.0;
        dVar8 = dVar11 * 1.0 + dVar5 * 0.0;
        local_370 = dVar7 * (double)(long)param_3 - dVar8 * 0.0;
        local_368 = dVar7 * 0.0 + dVar8 * (double)(long)param_3;
      }
      else {
        pdVar2 = (double *)(param_1 + (long)local_254 * 0x18);
        local_370 = *pdVar2 - dVar10;
        local_368 = pdVar2[1] - dVar6;
      }
      local_88[(long)local_254 * 2 + 6] = local_370;
      local_88[(long)local_254 * 2 + 7] = local_368;
    }
    for (local_258 = 0; local_258 < 3; local_258 = local_258 + 1) {
      pdVar2 = (double *)(param_1 + (long)local_258 * 0x18);
      dVar5 = *pdVar2;
      dVar6 = pdVar2[1];
      dVar7 = local_88[(long)local_258 * 2 + 6];
      dVar8 = local_88[(long)local_258 * 2 + 7];
      uVar4 = _cabs(local_88[(long)local_258 * 2 + 6],local_88[(long)local_258 * 2 + 7]);
      dVar9 = *(double *)(param_1 + (long)local_258 * 0x18 + 0x10);
      dVar7 = (dVar7 / extraout_d0_00) * dVar9;
      dVar9 = (dVar8 / extraout_d0_00) * dVar9;
      iVar13 = aiStack_c4[local_258];
      adStack_b8[(long)local_258 * 2] = dVar5 + (dVar7 * (double)(long)iVar13 - dVar9 * 0.0);
      adStack_b8[(long)local_258 * 2 + 1] = dVar6 + dVar7 * 0.0 + dVar9 * (double)(long)iVar13;
    }
    for (local_26c = 0; local_26c < 3; local_26c = local_26c + 1) {
      uVar4 = _abs2(adStack_b8[(long)local_26c * 2] - local_88[(long)local_26c * 2],
                    adStack_b8[(long)local_26c * 2 + 1] - local_88[(long)local_26c * 2 + 1]);
      local_1b8 = local_1b8 + extraout_d0_01;
      dVar5 = adStack_b8[(long)local_26c * 2 + 1];
      local_88[(long)local_26c * 2] = adStack_b8[(long)local_26c * 2];
      local_88[(long)local_26c * 2 + 1] = dVar5;
    }
    if (((local_1c0 <= local_1b8) && (0.0 <= local_1c0)) &&
       (bVar1 = 0x14 < local_1ac, local_1ac = local_1ac + 1, bVar1)) {
      local_15c = local_1b0;
      goto LAB_100003bcc;
    }
    local_1c0 = local_1b8;
  } while( true );
}



int _apollonius(long param_1)

{
  int iVar1;
  int local_38;
  uint local_34;
  uint local_24;
  uint local_20;
  uint local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_38 = 0;
  for (local_34 = 0; (int)local_34 < 8; local_34 = local_34 + 1) {
    local_24 = local_34 & 1;
    local_20 = local_34 & 2;
    local_1c = local_34 & 4;
    if ((((local_24 == 0) || (*(double *)(param_1 + 0x10) != 0.0)) &&
        ((local_20 == 0 || (*(double *)(param_1 + 0x28) != 0.0)))) &&
       ((local_1c == 0 || (*(double *)(param_1 + 0x40) != 0.0)))) {
      iVar1 = _apollonius_in(param_1,&local_24,1,0);
      local_38 = local_38 + iVar1;
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return local_38;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  undefined8 local_100 [2];
  undefined8 local_f0;
  undefined8 local_d8;
  undefined8 local_c8;
  undefined8 local_c0;
  undefined8 local_b8 [2];
  undefined8 local_a8;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined auStack_70 [16];
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _memset(auStack_70,0,0x48);
  local_60 = 0x3ff0000000000000;
  local_58 = 0x4010000000000000;
  local_48 = 0x3ff0000000000000;
  local_40 = 0x4000000000000000;
  local_38 = 0x4010000000000000;
  local_30 = 0x3ff0000000000000;
  _memset(local_b8,0,0x48);
  local_b8[0] = 0xc008000000000000;
  local_a8 = 0x4000000000000000;
  local_90 = 0x3ff0000000000000;
  local_88 = 0x4008000000000000;
  local_78 = 0x4000000000000000;
  _memset(local_100,0,0x48);
  local_100[0] = 0xc000000000000000;
  local_f0 = 0x3ff0000000000000;
  local_d8 = 0x3ff0000000000000;
  local_c8 = 0x4000000000000000;
  local_c0 = 0x3ff0000000000000;
  _puts("set 1");
  _apollonius(auStack_70);
  _puts("set 2");
  _apollonius(local_b8);
  _puts("set 3");
  _apollonius(local_100);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___muldc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____muldc3_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void _cabs(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cabs_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004020)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}


`
`#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

bool is_prime(uint64_t n) {
    if (n < 2)
        return false;
    if (n % 2 == 0)
        return n == 2;
    if (n % 3 == 0)
        return n == 3;
    for (uint64_t p = 5; p * p <= n; p += 4) {
        if (n % p == 0)
            return false;
        p += 2;
        if (n % p == 0)
            return false;
    }
    return true;
}

int main() {
    setlocale(LC_ALL, "");
    printf(" n          M(n)             Prime?\n");
    printf("-----------------------------------\n");
    uint64_t m0 = 1, m1 = 1;
    for (uint64_t i = 0; i < 42; ++i) {
        uint64_t m =
            i > 1 ? (m1 * (2 * i + 1) + m0 * (3 * i - 3)) / (i + 2) : 1;
        printf("%2llu%'25llu  %s\n", i, m, is_prime(m) ? "true" : "false");
        m0 = m1;
        m1 = m;
    }
}
`,`#include "motzkin-numbers.h"



bool _is_prime(ulong param_1)

{
  ulong uVar1;
  ulong uVar2;
  ulong local_18;
  bool local_1;
  
  if (param_1 < 2) {
    local_1 = false;
  }
  else if (param_1 % 2 == 0) {
    local_1 = param_1 == 2;
  }
  else if (param_1 % 3 == 0) {
    local_1 = param_1 == 3;
  }
  else {
    for (local_18 = 5; local_18 * local_18 < param_1 || local_18 * local_18 - param_1 == 0;
        local_18 = local_18 + 6) {
      uVar1 = 0;
      if (local_18 != 0) {
        uVar1 = param_1 / local_18;
      }
      if (param_1 == uVar1 * local_18) {
        return false;
      }
      uVar1 = local_18 + 2;
      uVar2 = 0;
      if (uVar1 != 0) {
        uVar2 = param_1 / uVar1;
      }
      if (param_1 == uVar2 * uVar1) {
        return false;
      }
    }
    local_1 = true;
  }
  return local_1;
}



undefined4 entry(void)

{
  ulong local_40;
  ulong local_30;
  ulong local_28;
  ulong local_20;
  
  _setlocale(0,"");
  _printf(" n          M(n)             Prime?\n");
  _printf("-----------------------------------\n");
  local_20 = 1;
  local_28 = 1;
  for (local_30 = 0; local_30 < 0x2a; local_30 = local_30 + 1) {
    if (local_30 < 2) {
      local_40 = 1;
    }
    else {
      local_40 = 0;
      if (local_30 + 2 != 0) {
        local_40 = (local_28 * (local_30 * 2 + 1) + local_20 * (local_30 * 3 + -3)) / (local_30 + 2)
        ;
      }
    }
    _is_prime(local_40);
    _printf("%2llu%\'25llu  %s\n");
    local_20 = local_28;
    local_28 = local_40;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004008)();
  return;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>

// Letter lookup by frequency.  This is to reduce word insertion time.
const char *freq = "zqxjkvbpygfwmucldrhsnioate";
int char_to_idx[128];

// Trie structure of sorts
struct word {
	const char *w;
	struct word *next;
};

union node {
	union node *down[10];
	struct word *list[10];
};

int deranged(const char *s1, const char *s2)
{
	int i;
	for (i = 0; s1[i]; i++)
		if (s1[i] == s2[i]) return 0;
	return 1;
}

int count_letters(const char *s, unsigned char *c)
{
	int i, len;
	memset(c, 0, 26);
	for (len = i = 0; s[i]; i++) {
		if (s[i] < 'a' || s[i] > 'z')
			return 0;
		len++, c[char_to_idx[(unsigned char)s[i]]]++;
	}
	return len;
}

const char * insert(union node *root, const char *s, unsigned char *cnt)
{
	int i;
	union node *n;
	struct word *v, *w = 0;

	for (i = 0; i < 25; i++, root = n) {
		if (!(n = root->down[cnt[i]]))
			root->down[cnt[i]] = n = calloc(1, sizeof(union node));
	}

	w = malloc(sizeof(struct word));
	w->w = s;
	w->next = root->list[cnt[25]];
	root->list[cnt[25]] = w;

	for (v = w->next; v; v = v->next) {
		if (deranged(w->w, v->w))
			return v->w;
	}
	return 0;
}

int main(int c, char **v)
{
	int i, j = 0;
	char *words;
	struct stat st;

	int fd = open(c < 2 ? "unixdict.txt" : v[1], O_RDONLY);
	if (fstat(fd, &st) < 0) return 1;

	words = malloc(st.st_size);
	read(fd, words, st.st_size);
	close(fd);

	union node root = {{0}};
	unsigned char cnt[26];
	int best_len = 0;
	const char *b1, *b2;

	for (i = 0; freq[i]; i++)
		char_to_idx[(unsigned char)freq[i]] = i;

	/* count words, change newline to null */
	for (i = j = 0; i < st.st_size; i++) {
		if (words[i] != '\n') continue;
		words[i] = '\0';

		if (i - j > best_len) {
			count_letters(words + j, cnt);
			const char *match = insert(&root, words + j, cnt);

			if (match) {
				best_len = i - j;
				b1 = words + j;
				b2 = match;
			}
		}

		j = ++i;
	}

	if (best_len) printf("longest derangement: %s %s\n", b1, b2);

	return 0;
}
`,`#include "anagrams-deranged-anagrams.h"



undefined4 _deranged(long param_1,long param_2)

{
  int local_1c;
  
  local_1c = 0;
  while( true ) {
    if (*(char *)(param_1 + local_1c) == '\0') {
      return 1;
    }
    if (*(char *)(param_1 + local_1c) == *(char *)(param_2 + local_1c)) break;
    local_1c = local_1c + 1;
  }
  return 0;
}



int _count_letters(long param_1,long param_2)

{
  int local_30;
  int local_2c;
  
  ___memset_chk(param_2,0,0x1a,0xffffffffffffffff);
  local_2c = 0;
  local_30 = 0;
  while( true ) {
    if (*(char *)(param_1 + local_2c) == '\0') {
      return local_30;
    }
    if ((*(char *)(param_1 + local_2c) < 'a') || ('z' < *(char *)(param_1 + local_2c))) break;
    local_30 = local_30 + 1;
    *(char *)(param_2 + *(int *)(&_char_to_idx + (ulong)*(byte *)(param_1 + local_2c) * 4)) =
         *(char *)(param_2 + *(int *)(&_char_to_idx + (ulong)*(byte *)(param_1 + local_2c) * 4)) +
         '\x01';
    local_2c = local_2c + 1;
  }
  return 0;
}



undefined8 _insert(void *param_1,undefined8 param_2,long param_3)

{
  int iVar1;
  undefined8 *puVar2;
  undefined8 *local_48;
  void *local_40;
  int local_34;
  void *local_20;
  
  local_20 = param_1;
  for (local_34 = 0; local_34 < 0x19; local_34 = local_34 + 1) {
    local_40 = *(void **)((long)local_20 + (ulong)*(byte *)(param_3 + local_34) * 8);
    if (local_40 == (void *)0x0) {
      local_40 = _calloc(1,0x50);
      *(void **)((long)local_20 + (ulong)*(byte *)(param_3 + local_34) * 8) = local_40;
    }
    local_20 = local_40;
  }
  puVar2 = (undefined8 *)_malloc(0x10);
  *puVar2 = param_2;
  puVar2[1] = *(undefined8 *)((long)local_20 + (ulong)*(byte *)(param_3 + 0x19) * 8);
  *(undefined8 **)((long)local_20 + (ulong)*(byte *)(param_3 + 0x19) * 8) = puVar2;
  local_48 = (undefined8 *)puVar2[1];
  while( true ) {
    if (local_48 == (undefined8 *)0x0) {
      return 0;
    }
    iVar1 = _deranged(*puVar2,*local_48);
    if (iVar1 != 0) break;
    local_48 = (undefined8 *)local_48[1];
  }
  return *local_48;
}



undefined4 entry(int param_1,long param_2)

{
  uint uVar1;
  void *pvVar2;
  char *local_178;
  int local_154;
  undefined auStack_150 [84];
  int local_fc;
  stat sStack_f8;
  void *local_68;
  int local_60;
  int local_5c;
  long local_58;
  int local_4c;
  undefined4 local_48;
  undefined auStack_42 [26];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_48 = 0;
  local_60 = 0;
  if (param_1 < 2) {
    local_178 = "unixdict.txt";
  }
  else {
    local_178 = *(char **)(param_2 + 8);
  }
  local_58 = param_2;
  local_4c = param_1;
  local_fc = _open(local_178,0);
  uVar1 = _fstat(local_fc,&sStack_f8);
  pvVar2 = (void *)(ulong)uVar1;
  if ((int)uVar1 < 0) {
    local_48 = 1;
  }
  else {
    local_68 = _malloc(sStack_f8.st_size);
    _read(local_fc,local_68,sStack_f8.st_size);
    _close(local_fc);
    pvVar2 = _memset(auStack_150,0,0x50);
    local_154 = 0;
    for (local_5c = 0; _freq[local_5c] != '\0'; local_5c = local_5c + 1) {
      *(int *)(&_char_to_idx + (ulong)(byte)_freq[local_5c] * 4) = local_5c;
    }
    local_60 = 0;
    for (local_5c = 0; local_5c < sStack_f8.st_size; local_5c = local_5c + 1) {
      if (*(char *)((long)local_68 + (long)local_5c) == '\n') {
        *(undefined *)((long)local_68 + (long)local_5c) = 0;
        if (local_154 < local_5c - local_60) {
          _count_letters((long)local_68 + (long)local_60);
          pvVar2 = (void *)_insert(auStack_150,(long)local_68 + (long)local_60,auStack_42);
          if (pvVar2 != (void *)0x0) {
            local_154 = local_5c - local_60;
          }
        }
        local_60 = local_5c + 1;
        local_5c = local_60;
      }
    }
    if (local_154 != 0) {
      uVar1 = _printf("longest derangement: %s %s\n");
      pvVar2 = (void *)(ulong)uVar1;
    }
    local_48 = 0;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return local_48;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(pvVar2);
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004020)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004028)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004038)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004040)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _read(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__read_100004050)(param_1);
  return sVar1;
}


`
`#include<stdlib.h>
#include<math.h>
#include<stdio.h>

typedef struct
{
  int hour, minute, second;
} digitime;

double
timeToDegrees (digitime time)
{
  return (360 * time.hour / 24.0 + 360 * time.minute / (24 * 60.0) +
          360 * time.second / (24 * 3600.0));
}

digitime
timeFromDegrees (double angle)
{
  digitime d;
  double totalSeconds = 24 * 60 * 60 * angle / 360;

  d.second = (int) totalSeconds % 60;
  d.minute = ((int) totalSeconds % 3600 - d.second) / 60;
  d.hour = (int) totalSeconds / 3600;

  return d;
}

double
meanAngle (double *angles, int size)
{
  double y_part = 0, x_part = 0;
  int i;

  for (i = 0; i < size; i++)
    {
      x_part += cos (angles[i] * M_PI / 180);
      y_part += sin (angles[i] * M_PI / 180);
    }

  return atan2 (y_part / size, x_part / size) * 180 / M_PI;
}

int
main ()
{
  digitime *set, meanTime;
  int inputs, i;
  double *angleSet, angleMean;

  printf ("Enter number of inputs : ");
  scanf ("%d", &inputs);
  set = malloc (inputs * sizeof (digitime));
  angleSet = malloc (inputs * sizeof (double));
  printf ("\n\nEnter the data separated by a space between each unit : ");

  for (i = 0; i < inputs; i++)
    {
      scanf ("%d:%d:%d", &set[i].hour, &set[i].minute, &set[i].second);
      angleSet[i] = timeToDegrees (set[i]);
    }

  meanTime = timeFromDegrees (360 + meanAngle (angleSet, inputs));

  printf ("\n\nThe mean time is : %d:%d:%d", meanTime.hour, meanTime.minute,
          meanTime.second);
  return 0;
}
`,`#include "averages-mean-time-of-day.h"



undefined  [16] _timeToDegrees(undefined8 param_1,int param_2)

{
  undefined auVar1 [16];
  undefined4 local_38;
  undefined4 uStack_34;
  
  local_38 = (int)param_1;
  uStack_34 = (int)((ulong)param_1 >> 0x20);
  auVar1._0_8_ = (double)(local_38 * 0x168) / 24.0 + (double)(uStack_34 * 0x168) / 1440.0 +
                 (double)(param_2 * 0x168) / 86400.0;
  if (*(long *)PTR____stack_chk_guard_100004008 != *(long *)PTR____stack_chk_guard_100004008) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _timeFromDegrees(double param_1)

{
  undefined auVar1 [16];
  double dVar2;
  undefined4 uStack_1c;
  
  dVar2 = (param_1 * 86400.0) / 360.0;
  auVar1._4_4_ = ((int)dVar2 % 0xe10 - (int)dVar2 % 0x3c) / 0x3c;
  auVar1._0_4_ = (int)dVar2 / 0xe10;
  auVar1._12_4_ = uStack_1c;
  auVar1._8_4_ = (int)dVar2 % 0x3c;
  if (*(long *)PTR____stack_chk_guard_100004008 == *(long *)PTR____stack_chk_guard_100004008) {
    return auVar1;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined  [16] _meanAngle(long param_1,int param_2)

{
  double dVar1;
  undefined auVar2 [16];
  undefined4 local_34;
  undefined8 local_30;
  undefined8 local_28;
  
  local_28 = 0.0;
  local_30 = 0.0;
  for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
    dVar1 = (double)_cos((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_30 = local_30 + dVar1;
    dVar1 = (double)_sin((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_28 = local_28 + dVar1;
  }
  dVar1 = (double)_atan2(local_28 / (double)(long)param_2,local_30 / (double)(long)param_2);
  auVar2._0_8_ = (dVar1 * 180.0) / 3.141592653589793;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined8 entry(void)

{
  undefined8 *puVar1;
  int iVar2;
  void *pvVar3;
  void *pvVar4;
  long lVar5;
  undefined8 uVar6;
  double dVar7;
  int local_60;
  int local_5c;
  undefined4 uStack_1c;
  
  lVar5 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("Enter number of inputs : ");
  _scanf("%d");
  pvVar3 = _malloc((long)local_5c * 0xc);
  pvVar4 = _malloc((long)local_5c << 3);
  _printf("\n\nEnter the data separated by a space between each unit : ");
  for (local_60 = 0; local_60 < local_5c; local_60 = local_60 + 1) {
    _scanf("%d:%d:%d");
    puVar1 = (undefined8 *)((long)pvVar3 + (long)local_60 * 0xc);
    uVar6 = _timeToDegrees(*puVar1,CONCAT44(uStack_1c,*(undefined4 *)(puVar1 + 1)));
    *(undefined8 *)((long)pvVar4 + (long)local_60 * 8) = uVar6;
  }
  dVar7 = (double)_meanAngle(pvVar4,local_5c);
  _timeFromDegrees(dVar7 + 360.0);
  iVar2 = _printf("\n\nThe mean time is : %d:%d:%d");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar5) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004010)();
  return;
}



void _cos(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cos_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004030)((int)param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004038)();
  return;
}


`
`#include <math.h>
#include <stdio.h>

double f(double x)
{
    return x*x*x-3.0*x*x +2.0*x;
}

double secant( double xA, double xB, double(*f)(double) )
{
    double e = 1.0e-12;
    double fA, fB;
    double d;
    int i;
    int limit = 50;

    fA=(*f)(xA);
    for (i=0; i<limit; i++) {
        fB=(*f)(xB);
        d = (xB - xA) / (fB - fA) * fB;
        if (fabs(d) < e)
            break;
        xA = xB;
        fA = fB;
        xB -= d;
    }
    if (i==limit) {
        printf("Function is not converging near (%7.4f,%7.4f).\n", xA,xB);
        return -99.0;
    }
    return xB;
}

int main(int argc, char *argv[])
{
    double step = 1.0e-2;
    double e = 1.0e-12;
    double x = -1.032;		// just so we use secant method
    double xx, value;

    int s = (f(x)> 0.0);

    while (x < 3.0) {
        value = f(x);
        if (fabs(value) < e) {
            printf("Root found at x= %12.9f\n", x);
            s = (f(x+.0001)>0.0);
        }
        else if ((value > 0.0) != s) {
            xx = secant(x-step, x,&f);
            if (xx != -99.0)   // -99 meaning secand method failed
                printf("Root found at x= %12.9f\n", xx);
            else
                printf("Root found near x= %7.4f\n", x);
            s = (f(x+.0001)>0.0);
        }
        x += step;
    }
    return 0;
}
`,`#include "roots-of-a-function-1.h"



undefined  [16] _f(double param_1)

{
  undefined auVar1 [16];
  undefined8 uVar2;
  
  uVar2 = NEON_fnmsub(param_1 * param_1,param_1,param_1 * 3.0 * param_1);
  auVar1._0_8_ = NEON_fmadd(0x4000000000000000,param_1,uVar2);
  auVar1._8_8_ = 0;
  return auVar1;
}



ulong _secant(double param_1,double param_2,code *param_3)

{
  uint uVar1;
  ulong uVar2;
  double extraout_d0;
  double extraout_d0_00;
  double dVar3;
  int local_54;
  double local_40;
  double local_28;
  double local_20;
  
  uVar2 = (*param_3)(param_1);
  local_40 = extraout_d0;
  local_28 = param_2;
  local_20 = param_1;
  for (local_54 = 0; local_54 < 0x32; local_54 = local_54 + 1) {
    uVar2 = (*param_3)(local_28);
    dVar3 = ((local_28 - local_20) / (extraout_d0_00 - local_40)) * extraout_d0_00;
    if (ABS(dVar3) < 1e-12) break;
    local_20 = local_28;
    local_28 = local_28 - dVar3;
    local_40 = extraout_d0_00;
  }
  if (local_54 == 0x32) {
    uVar1 = _printf("Function is not converging near (%7.4f,%7.4f).\n");
    uVar2 = (ulong)uVar1;
  }
  return uVar2;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  double dVar3;
  double local_38;
  
  local_38 = -1.032;
  dVar3 = (double)_f(0xbff083126e978d50);
  bVar1 = 0.0 < dVar3;
  for (; local_38 < 3.0; local_38 = local_38 + 0.01) {
    dVar3 = (double)_f(local_38);
    if (1e-12 <= ABS(dVar3)) {
      if (0.0 < dVar3 != bVar1) {
        dVar3 = (double)_secant(local_38 - 0.01,local_38,_f);
        if (dVar3 == -99.0) {
          iVar2 = _printf("Root found near x= %7.4f\n");
        }
        else {
          iVar2 = _printf("Root found at x= %12.9f\n");
        }
        dVar3 = (double)_f(local_38 + 0.0001,iVar2);
        bVar1 = 0.0 < dVar3;
      }
    }
    else {
      iVar2 = _printf("Root found at x= %12.9f\n");
      dVar3 = (double)_f(local_38 + 0.0001,iVar2);
      bVar1 = 0.0 < dVar3;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

void print_headings()
{
	printf("%2s", "N");
	printf(" %10s", "Length");
	printf(" %-20s", "Entropy");
	printf(" %-40s", "Word");
	printf("\n");
}

double calculate_entropy(int ones, int zeros)
{
	double result = 0;
	
	int total = ones + zeros;
	result -= (double) ones / total * log2((double) ones / total);
	result -= (double) zeros / total * log2((double) zeros / total);
	
	if (result != result) { // NAN
		result = 0;
	}
	
	return result;
}

void print_entropy(char *word)
{
	int ones = 0;
	int zeros = 0;
	
	int i;
	for (i = 0; word[i]; i++) {
		char c = word[i];
		
		switch (c) {
			case '0':
				zeros++;
				break;
			case '1':
				ones++;
				break;
		}
	}
	
	double entropy = calculate_entropy(ones, zeros);
	printf(" %-20.18f", entropy);
}

void print_word(int n, char *word)
{
	printf("%2d", n);
	
	printf(" %10ld", strlen(word));
	
	print_entropy(word);
	
	if (n < 10) {
		printf(" %-40s", word);
	} else {
		printf(" %-40s", "...");
	}
	
	printf("\n");
}

int main(int argc, char *argv[])
{
	print_headings();
	
	char *last_word = malloc(2);
	strcpy(last_word, "1");
	
	char *current_word = malloc(2);
	strcpy(current_word, "0");
	
	print_word(1, last_word);
	int i;
	for (i = 2; i <= 37; i++) {
		print_word(i, current_word);
		
		char *next_word = malloc(strlen(current_word) + strlen(last_word) + 1);
		strcpy(next_word, current_word);
		strcat(next_word, last_word);
		
		free(last_word);
		last_word = current_word;
		current_word = next_word;
	}
	
	free(last_word);
	free(current_word);
	return 0;
}
`,`#include "fibonacci-word.h"



int _print_headings(void)

{
  int iVar1;
  
  _printf("%2s");
  _printf(" %10s");
  _printf(" %-20s");
  _printf(" %-40s");
  iVar1 = _printf("\n");
  return iVar1;
}



// WARNING: Removing unreachable block (ram,0x000100003c08)

undefined  [16] _calculate_entropy(int param_1,int param_2)

{
  int iVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  undefined auVar4 [16];
  
  iVar1 = param_1 + param_2;
  uVar2 = _log2((double)(long)param_1 / (double)(long)iVar1);
  uVar2 = NEON_fmsub((double)(long)param_1 / (double)(long)iVar1,uVar2,0);
  uVar3 = _log2((double)(long)param_2 / (double)(long)iVar1);
  auVar4._0_8_ = NEON_fmsub((double)(long)param_2 / (double)(long)iVar1,uVar3,uVar2);
  auVar4._8_8_ = 0;
  return auVar4;
}



int _print_entropy(long param_1)

{
  int iVar1;
  int local_24;
  int local_20;
  int local_1c;
  
  local_1c = 0;
  local_20 = 0;
  for (local_24 = 0; *(char *)(param_1 + local_24) != '\0'; local_24 = local_24 + 1) {
    if (*(char *)(param_1 + local_24) == '0') {
      local_20 = local_20 + 1;
    }
    else if (*(char *)(param_1 + local_24) == '1') {
      local_1c = local_1c + 1;
    }
  }
  _calculate_entropy(local_1c,local_20);
  iVar1 = _printf(" %-20.18f");
  return iVar1;
}



int _print_word(int param_1,char *param_2)

{
  int iVar1;
  
  _printf("%2d");
  _strlen(param_2);
  _printf(" %10ld");
  _print_entropy(param_2);
  if (param_1 < 10) {
    _printf(" %-40s");
  }
  else {
    _printf(" %-40s");
  }
  iVar1 = _printf("\n");
  return iVar1;
}



undefined8 entry(void)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  int local_34;
  char *local_30;
  char *local_28;
  
  _print_headings();
  local_28 = (char *)_malloc(2);
  ___strcpy_chk(local_28,"1");
  local_30 = (char *)_malloc(2);
  ___strcpy_chk(local_30,"0",0xffffffffffffffff);
  _print_word(1,local_28);
  for (local_34 = 2; local_34 < 0x26; local_34 = local_34 + 1) {
    _print_word(local_34,local_30);
    sVar1 = _strlen(local_30);
    sVar2 = _strlen(local_28);
    pcVar3 = (char *)_malloc(sVar1 + sVar2 + 1);
    ___strcpy_chk(pcVar3,local_30);
    ___strcat_chk(pcVar3,local_28,0xffffffffffffffff);
    _free(local_28);
    local_28 = local_30;
    local_30 = pcVar3;
  }
  _free(local_28);
  _free(local_30);
  return 0;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



void _log2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log2_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int list[] = {-7, 1, 5, 2, -4, 3, 0};

int eq_idx(int *a, int len, int **ret)
{
	int i, sum, s, cnt;
	/* alloc long enough: if we can afford the original list,
	 * we should be able to afford to this.  Beats a potential
         * million realloc() calls.  Even if memory is a real concern,
         * there's no garantee the result is shorter than the input anyway */
        cnt = s = sum = 0;
	*ret = malloc(sizeof(int) * len);

	for (i = 0; i < len; i++)
                sum += a[i];

	for (i = 0; i < len; i++) {
		if (s * 2 + a[i] == sum) {
			(*ret)[cnt] = i;
                        cnt++;
                }
		s += a[i];
	}

        /* uncouraged way to use realloc since it can leak memory, for example */
	*ret = realloc(*ret, cnt * sizeof(int));

	return cnt;
}

int main()
{
	int i, cnt, *idx;
	cnt = eq_idx(list, sizeof(list) / sizeof(int), &idx);

	printf("Found:");
	for (i = 0; i < cnt; i++)
                printf(" %d", idx[i]);
	printf("\n");

	return 0;
}
`,`#include "equilibrium-index.h"



int _eq_idx(long param_1,int param_2,long *param_3)

{
  void *pvVar1;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  
  local_30 = 0;
  local_34 = 0;
  local_38 = 0;
  pvVar1 = _malloc((long)param_2 * 4);
  *param_3 = (long)pvVar1;
  for (local_2c = 0; local_2c < param_2; local_2c = local_2c + 1) {
    local_30 = local_30 + *(int *)(param_1 + (long)local_2c * 4);
  }
  for (local_2c = 0; local_2c < param_2; local_2c = local_2c + 1) {
    if (*(int *)(param_1 + (long)local_2c * 4) + local_34 * 2 == local_30) {
      *(int *)(*param_3 + (long)local_38 * 4) = local_2c;
      local_38 = local_38 + 1;
    }
    local_34 = local_34 + *(int *)(param_1 + (long)local_2c * 4);
  }
  pvVar1 = _realloc((void *)*param_3,(long)local_38 << 2);
  *param_3 = (long)pvVar1;
  return local_38;
}



undefined8 entry(void)

{
  undefined local_28 [12];
  int local_1c;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_1c = _eq_idx(&_list,7,local_28);
  _printf("Found:");
  for (local_18 = 0; local_18 < local_1c; local_18 = local_18 + 1) {
    _printf(" %d");
  }
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004010)();
  return pvVar1;
}


`
`/*
 * RosettaCode example: Statistics/Normal distribution in C
 *
 * The random number generator rand() of the standard C library is obsolete
 * and should not be used in more demanding applications. There are plenty
 * libraries with advanced features (eg. GSL) with functions to calculate
 * the mean, the standard deviation, generating random numbers etc.
 * However, these features are not the core of the standard C library.
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>


#define NMAX 10000000


double mean(double* values, int n)
{
    int i;
    double s = 0;

    for ( i = 0; i < n; i++ )
        s += values[i];
    return s / n;
}


double stddev(double* values, int n)
{
    int i;
    double average = mean(values,n);
    double s = 0;

    for ( i = 0; i < n; i++ )
        s += (values[i] - average) * (values[i] - average);
    return sqrt(s / (n - 1));
}

/*
 * Normal random numbers generator - Marsaglia algorithm.
 */
double* generate(int n)
{
    int i;
    int m = n + n % 2;
    double* values = (double*)calloc(m,sizeof(double));
    double average, deviation;

    if ( values )
    {
        for ( i = 0; i < m; i += 2 )
        {
            double x,y,rsq,f;
            do {
                x = 2.0 * rand() / (double)RAND_MAX - 1.0;
                y = 2.0 * rand() / (double)RAND_MAX - 1.0;
                rsq = x * x + y * y;
            }while( rsq >= 1. || rsq == 0. );
            f = sqrt( -2.0 * log(rsq) / rsq );
            values[i]   = x * f;
            values[i+1] = y * f;
        }
    }
    return values;
}


void printHistogram(double* values, int n)
{
    const int width = 50;
    int max = 0;

    const double low   = -3.05;
    const double high  =  3.05;
    const double delta =  0.1;

    int i,j,k;
    int nbins = (int)((high - low) / delta);
    int* bins = (int*)calloc(nbins,sizeof(int));
    if ( bins != NULL )
    {
        for ( i = 0; i < n; i++ )
        {
            int j = (int)( (values[i] - low) / delta );
            if ( 0 <= j  &&  j < nbins )
                bins[j]++;
        }

        for ( j = 0; j < nbins; j++ )
            if ( max < bins[j] )
                max = bins[j];

        for ( j = 0; j < nbins; j++ )
        {
            printf("(%5.2f, %5.2f) |", low + j * delta, low + (j + 1) * delta );
            k = (int)( (double)width * (double)bins[j] / (double)max );
            while(k-- > 0) putchar('*');
            printf("  %-.1f%%", bins[j] * 100.0 / (double)n);
            putchar('\n');
        }

        free(bins);
    }
}


int main(void)
{
    double* seq;

    srand((unsigned int)time(NULL));

    if ( (seq = generate(NMAX)) != NULL )
    {
        printf("mean = %g, stddev = %g\n\n", mean(seq,NMAX), stddev(seq,NMAX));
        printHistogram(seq,NMAX);
        free(seq);

        printf("\n%s\n", "press enter");
        getchar();
        return EXIT_SUCCESS;
    }
    return EXIT_FAILURE;
}
`,`#include "statistics-normal-distribution.h"



undefined  [16] _mean(long param_1,int param_2)

{
  undefined auVar1 [16];
  undefined8 local_18;
  undefined4 local_10;
  
  local_18 = 0.0;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    local_18 = local_18 + *(double *)(param_1 + (long)local_10 * 8);
  }
  auVar1._0_8_ = local_18 / (double)(long)param_2;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _stddev(long param_1,int param_2)

{
  double dVar1;
  undefined auVar2 [16];
  undefined8 local_30;
  undefined4 local_20;
  
  dVar1 = (double)_mean(param_1,param_2);
  local_30 = 0.0;
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    local_30 = (double)NEON_fmadd(*(double *)(param_1 + (long)local_20 * 8) - dVar1,
                                  *(double *)(param_1 + (long)local_20 * 8) - dVar1,local_30);
  }
  auVar2._0_8_ = SQRT(local_30 / (double)(param_2 + -1));
  auVar2._8_8_ = 0;
  return auVar2;
}



void * _generate(int param_1)

{
  int iVar1;
  void *pvVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  int local_18;
  
  param_1 = param_1 + param_1 % 2;
  pvVar2 = _calloc((long)param_1,8);
  if (pvVar2 != (void *)0x0) {
    for (local_18 = 0; local_18 < param_1; local_18 = local_18 + 2) {
      do {
        iVar1 = _rand();
        dVar3 = ((double)iVar1 * 2.0) / 2147483647.0 - 1.0;
        iVar1 = _rand();
        dVar4 = ((double)iVar1 * 2.0) / 2147483647.0 - 1.0;
        dVar5 = (double)NEON_fmadd(dVar3,dVar3,dVar4 * dVar4);
      } while (1.0 <= dVar5 || dVar5 == 0.0);
      dVar6 = (double)_log(dVar5);
      dVar5 = SQRT((dVar6 * -2.0) / dVar5);
      *(double *)((long)pvVar2 + (long)local_18 * 8) = dVar3 * dVar5;
      *(double *)((long)pvVar2 + (long)(local_18 + 1) * 8) = dVar4 * dVar5;
    }
  }
  return pvVar2;
}



void _printHistogram(long param_1,int param_2)

{
  int *piVar1;
  void *pvVar2;
  int iVar3;
  int local_4c;
  int local_48;
  int local_44;
  int local_24;
  
  local_24 = 0;
  pvVar2 = _calloc(0x3c,4);
  if (pvVar2 != (void *)0x0) {
    for (local_44 = 0; local_44 < param_2; local_44 = local_44 + 1) {
      iVar3 = (int)((*(double *)(param_1 + (long)local_44 * 8) - -3.05) / 0.1);
      if ((-1 < iVar3) && (iVar3 < 0x3c)) {
        piVar1 = (int *)((long)pvVar2 + (long)iVar3 * 4);
        *piVar1 = *piVar1 + 1;
      }
    }
    for (local_48 = 0; local_48 < 0x3c; local_48 = local_48 + 1) {
      if (local_24 < *(int *)((long)pvVar2 + (long)local_48 * 4)) {
        local_24 = *(int *)((long)pvVar2 + (long)local_48 * 4);
      }
    }
    for (local_48 = 0; local_48 < 0x3c; local_48 = local_48 + 1) {
      NEON_fmadd((double)(long)local_48,0x3fb999999999999a,0xc008666666666666);
      NEON_fmadd((double)(local_48 + 1),0x3fb999999999999a,0xc008666666666666);
      _printf("(%5.2f, %5.2f) |");
      local_4c = (int)(((double)(long)*(int *)((long)pvVar2 + (long)local_48 * 4) * 50.0) /
                      (double)(long)local_24);
      while (0 < local_4c) {
        _putchar(0x2a);
        local_4c = local_4c + -1;
      }
      _printf("  %-.1f%%");
      _putchar(10);
    }
    _free(pvVar2);
  }
  return;
}



bool entry(void)

{
  time_t tVar1;
  void *pvVar2;
  
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  pvVar2 = (void *)_generate(10000000);
  if (pvVar2 != (void *)0x0) {
    _mean(pvVar2,10000000);
    _stddev(pvVar2,10000000);
    _printf("mean = %g, stddev = %g\n\n");
    _printHistogram(pvVar2,10000000);
    _free(pvVar2);
    _printf("\n%s\n");
    _getchar();
  }
  return pvVar2 == (void *)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004010)();
  return iVar1;
}



void _log(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004028)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004030)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004038)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004040)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef struct stream_t stream_t, *stream;
struct stream_t {
	/* get function is supposed to return a byte value (0-255),
		or -1 to signify end of input */
	int (*get)(stream);
	/* put function does output, one byte at a time */
	int (*put)(stream, int);
};

/* next two structs inherit from stream_t */
typedef struct {
	int (*get)(stream);
	int (*put)(stream, int);
	char *string;
	int pos;
} string_stream;

typedef struct {
	int (*get)(stream);
	int (*put)(stream, int);
	FILE *fp;
} file_stream;

/* methods for above streams */
int sget(stream in)
{
	int c;
	string_stream* s = (string_stream*) in;
	c = (unsigned char)(s->string[s->pos]);
	if (c == '\0') return -1;
	s->pos++;
	return c;
}

int sput(stream out, int c)
{
	string_stream* s = (string_stream*) out;
	s->string[s->pos++] = (c == -1) ? '\0' : c;
	if (c == -1) s->pos = 0;
	return 0;
}

int file_put(stream out, int c)
{
	file_stream *f = (file_stream*) out;
	return fputc(c, f->fp);
}

/* helper function */
void output(stream out, unsigned char* buf, int len)
{
	int i;
	out->put(out, 128 + len);
	for (i = 0; i < len; i++)
		out->put(out, buf[i]);
}

/* Specification: encoded stream are unsigned bytes consisting of sequences.
 * First byte of each sequence is the length, followed by a number of bytes.
 * If length <=128, the next byte is to be repeated length times;
 * If length > 128, the next (length - 128) bytes are not repeated.
 * this is to improve efficiency for long non-repeating sequences.
 * This scheme can encode arbitrary byte values efficiently.
 * c.f. Adobe PDF spec RLE stream encoding (not exactly the same)
 */
void encode(stream in, stream out)
{
	unsigned char buf[256];
	int len = 0, repeat = 0, end = 0, c;
	int (*get)(stream) = in->get;
	int (*put)(stream, int) = out->put;

	while (!end) {
		end = ((c = get(in)) == -1);
		if (!end) {
			buf[len++] = c;
			if (len <= 1) continue;
		}

		if (repeat) {
			if (buf[len - 1] != buf[len - 2])
				repeat = 0;
			if (!repeat || len == 129 || end) {
				/* write out repeating bytes */
				put(out, end ? len : len - 1);
				put(out, buf[0]);
				buf[0] = buf[len - 1];
				len = 1;
			}
		} else {
			if (buf[len - 1] == buf[len - 2]) {
				repeat = 1;
				if (len > 2) {
					output(out, buf, len - 2);
					buf[0] = buf[1] = buf[len - 1];
					len = 2;
				}
				continue;
			}
			if (len == 128 || end) {
				output(out, buf, len);
				len = 0;
				repeat = 0;
			}
		}
	}
	put(out, -1);
}

void decode(stream in, stream out)
{
	int c, i, cnt;
	while (1) {
		c = in->get(in);
		if (c == -1) return;
		if (c > 128) {
			cnt = c - 128;
			for (i = 0; i < cnt; i++)
				out->put(out, in->get(in));
		} else {
			cnt = c;
			c = in->get(in);
			for (i = 0; i < cnt; i++)
				out->put(out, c);
		}
	}
}

int main()
{
	char buf[256];
	string_stream str_in = { sget, 0,
		"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW", 0};
	string_stream str_out = { sget, sput, buf, 0 };
	file_stream file = { 0, file_put, stdout };

	/* encode from str_in to str_out */
	encode((stream)&str_in, (stream)&str_out);

	/* decode from str_out to file (stdout) */
	decode((stream)&str_out, (stream)&file);

	return 0;
}
`,`#include "run-length-encoding.h"



uint _sget(long param_1)

{
  undefined4 local_4;
  
  local_4 = (uint)*(byte *)(*(long *)(param_1 + 0x10) + (long)*(int *)(param_1 + 0x18));
  if (local_4 == 0) {
    local_4 = 0xffffffff;
  }
  else {
    *(int *)(param_1 + 0x18) = *(int *)(param_1 + 0x18) + 1;
  }
  return local_4;
}



undefined8 _sput(long param_1,int param_2)

{
  int iVar1;
  int local_1c;
  
  local_1c = param_2;
  if (param_2 == -1) {
    local_1c = 0;
  }
  iVar1 = *(int *)(param_1 + 0x18);
  *(int *)(param_1 + 0x18) = iVar1 + 1;
  *(char *)(*(long *)(param_1 + 0x10) + (long)iVar1) = (char)local_1c;
  if (param_2 == -1) {
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  return 0;
}



int _file_put(long param_1,int param_2)

{
  int iVar1;
  
  iVar1 = _fputc(param_2,*(FILE **)(param_1 + 0x10));
  return iVar1;
}



void _output(long param_1,long param_2,int param_3)

{
  undefined4 local_28;
  
  (**(code **)(param_1 + 8))(param_1,param_3 + 0x80);
  for (local_28 = 0; local_28 < param_3; local_28 = local_28 + 1) {
    (**(code **)(param_1 + 8))(param_1,*(undefined *)(param_2 + local_28));
  }
  return;
}



void _encode(undefined8 *param_1,long param_2)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  code *pcVar4;
  code *pcVar5;
  long lVar6;
  int local_16c;
  int local_13c;
  char local_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_13c = 0;
  bVar1 = false;
  bVar2 = false;
  pcVar4 = (code *)*param_1;
  pcVar5 = *(code **)(param_2 + 8);
LAB_100003a5c:
  if (bVar2) {
    (*pcVar5)(param_2,0xffffffff);
    if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
      return;
    }
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  iVar3 = (*pcVar4)(param_1);
  bVar2 = iVar3 == -1;
  if (!bVar2) goto LAB_100003aa4;
  goto LAB_100003adc;
LAB_100003aa4:
  lVar6 = (long)local_13c;
  local_13c = local_13c + 1;
  local_128[lVar6] = (char)iVar3;
  if (1 < local_13c) {
LAB_100003adc:
    if (bVar1) {
      if (local_128[local_13c + -1] != local_128[local_13c + -2]) {
        bVar1 = false;
      }
      if (((!bVar1) || (local_13c == 0x81)) || (bVar2)) {
        if (bVar2) {
          local_16c = local_13c;
        }
        else {
          local_16c = local_13c + -1;
        }
        (*pcVar5)(param_2,local_16c);
        (*pcVar5)(param_2,local_128[0]);
        local_128[0] = local_128[local_13c + -1];
        local_13c = 1;
      }
    }
    else if (local_128[local_13c + -1] == local_128[local_13c + -2]) {
      bVar1 = true;
      if (2 < local_13c) {
        _output(param_2,local_128,local_13c + -2);
        local_128[0] = local_128[local_13c + -1];
        local_13c = 2;
        local_128[1] = local_128[0];
      }
    }
    else if ((local_13c == 0x80) || (bVar2)) {
      _output(param_2,local_128,local_13c);
      local_13c = 0;
      bVar1 = false;
    }
  }
  goto LAB_100003a5c;
}



void _decode(undefined8 *param_1,long param_2)

{
  int iVar1;
  undefined4 uVar2;
  undefined8 uVar3;
  code *pcVar4;
  int local_28;
  
  while (iVar1 = (*(code *)*param_1)(param_1), iVar1 != -1) {
    if (iVar1 < 0x81) {
      uVar2 = (*(code *)*param_1)(param_1);
      for (local_28 = 0; local_28 < iVar1; local_28 = local_28 + 1) {
        (**(code **)(param_2 + 8))(param_2,uVar2);
      }
    }
    else {
      for (local_28 = 0; local_28 < iVar1 + -0x80; local_28 = local_28 + 1) {
        pcVar4 = *(code **)(param_2 + 8);
        uVar3 = (*(code *)*param_1)(param_1);
        (*pcVar4)(param_2,uVar3);
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  undefined8 local_188;
  code *local_180;
  undefined8 local_178;
  code *local_170;
  code *local_168;
  undefined *local_160;
  undefined4 local_158;
  code *local_150;
  undefined8 uStack_148;
  char *local_140;
  undefined8 uStack_138;
  undefined4 local_12c;
  undefined auStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_12c = 0;
  uStack_148 = 0;
  local_150 = _sget;
  uStack_138 = 0;
  local_140 = "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW";
  local_170 = _sget;
  local_168 = _sput;
  local_160 = auStack_128;
  local_158 = 0;
  local_188 = 0;
  local_180 = _file_put;
  local_178 = *(undefined8 *)PTR____stdoutp_100004010;
  _encode(&local_150);
  _decode(&local_170,&local_188);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fputc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fputc_100004018)(param_1);
  return iVar1;
}


`
`#include <stdio.h>


int main() {
    int arabic[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};

    // There is a bug: "XL\0" is translated into sequence 58 4C 00 00, i.e. it is 4-bytes long...
    // Should be "XL" without \0 etc.
    //
    char roman[13][3] = {"M\0", "CM\0", "D\0", "CD\0", "C\0", "XC\0", "L\0", "XL\0", "X\0", "IX\0", "V\0", "IV\0", "I\0"};
    int N;

    printf("Enter arabic number:\n");
    scanf("%d", &N);
    printf("\nRoman number:\n");

    for (int i = 0; i < 13; i++) {
        while (N >= arabic[i]) {
            printf("%s", roman[i]);
            N -= arabic[i];
        }
    }
    return 0;
}
`,`#include "roman-numerals-encode-1.h"



undefined8 entry(void)

{
  int iVar1;
  int local_80;
  int local_7c;
  undefined auStack_73 [39];
  int aiStack_4c [13];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(aiStack_4c,&DAT_100003f20,0x34);
  _memcpy(auStack_73,&DAT_100003f54,0x27);
  _printf("Enter arabic number:\n");
  _scanf("%d");
  iVar1 = _printf("\nRoman number:\n");
  for (local_80 = 0; local_80 < 0xd; local_80 = local_80 + 1) {
    for (; aiStack_4c[local_80] <= local_7c; local_7c = local_7c - aiStack_4c[local_80]) {
      iVar1 = _printf("%s");
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <inttypes.h> /* PRIu32 */
#include <stdlib.h> /* arc4random */
#include <stdio.h>  /* printf */

int
main()
{
  printf("%" PRIu32 "\n", arc4random());
  return 0;
}
`,`#include "random-number-generator-device--2.h"



undefined4 entry(void)

{
  _arc4random();
  _printf("%u\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

u_int32_t _arc4random(void)

{
  u_int32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__arc4random_100004000)();
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

double mean(double *v, int len)
{
	double sum = 0;
	int i;
	for (i = 0; i < len; i++)
		sum += v[i];
	return sum / len;
}

int main(void)
{
	double v[] = {1, 2, 2.718, 3, 3.142};
	int i, len;
	for (len = 5; len >= 0; len--) {
		printf("mean[");
		for (i = 0; i < len; i++)
			printf(i ? ", %g" : "%g", v[i]);
		printf("] = %g\n", mean(v, len));
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d6c(void);
int64_t function_100003f54(int64_t a1);
int64_t * function_100003f60(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f6c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d6c - 0x100003dec
int64_t function_100003d6c(void) {
    // 0x100003d6c
    int64_t result; // 0x100003d6c
    int32_t v1 = result; // 0x100003d74
    int32_t v2 = 0; // 0x100003d84
    while (v2 - v1 < 0 != ((v2 - v1 ^ v2) & (v2 ^ v1)) < 0) {
        // 0x100003d88
        v2++;
    }
    // 0x100003dcc
    __asm_sshll(0.0f, 0);
    return result;
}

// Address range: 0x100003dec - 0x100003f54
int64_t entry_point(void) {
    // 0x100003dec
    int64_t v1; // bp-64, 0x100003dec
    _memset(&v1, 0, 40);
    v1 = 0x3ff0000000000000;
    int32_t v2; // 0x100003f08
    for (int32_t i = 5; i > -1; i--) {
        // 0x100003e6c
        _printf("mean[");
        int32_t v3 = 0; // 0x100003e90
        if (i != 0 != (i & -i) < 0) {
            _printf(v3 == 0 ? "%g" : ", %g");
            int32_t v4 = v3 + 1; // 0x100003ee0
            int32_t v5 = v4 - i; // 0x100003e88
            v3 = v4;
            while (v5 < 0 != ((v5 ^ v4) & (v4 ^ i)) < 0) {
                // 0x100003e98
                _printf(v3 == 0 ? "%g" : ", %g");
                v4 = v3 + 1;
                v5 = v4 - i;
                v3 = v4;
            }
        }
        // 0x100003eec
        function_100003d6c();
        int128_t v6; // 0x100003dec
        v2 = _printf("] = %g\n", (float64_t)(int64_t)v6);
    }
    int64_t v7 = *(int64_t *)0x100004008; // 0x100003f28
    if (*(int64_t *)v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f40
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int64_t function_100003f54(int64_t a1) {
    // 0x100003f54
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t * function_100003f60(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f60
    return _memset(s, c, n);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <string.h>
#include <stdbool.h>

/* this should be the way we check if we can use posix/bsd strcasecmp */
#if !defined(_BSD_SOURCE) && !defined(_DEFAULT_SOURCE)
#include <ctype.h>
int strcasecmp(const char *s1, const char *s2) {
  for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)
    if(*s1 == 0)
      return 0;
  return *(unsigned char *)s1 < *(unsigned char *)s2 ? -1 : 1;
}
#else
#include <strings.h>
#endif


bool ext_is_in_list(const char *filename, const char *extlist[])
{
  size_t i;

  const char *ext = strrchr(filename, '.');
  if (ext) {
    for (i = 0; extlist[i] != NULL; ++i) {
      if (strcasecmp(ext, extlist[i]) == 0)
	return true;
    }
  }

  return false;
}


// testing
const char *fnames[] = {
    "text.txt",
    "text.TXT",
    "test.tar.gz",
    "test/test2.exe",
    "test\\test2.exe",
    "test",
    "a/b/c\\d/foo",
    "foo.c",
    "foo.C",
    "foo.C++",
    "foo.c#",
    "foo.zkl",
    "document.pdf",
    NULL
};

const char *exts[] = {
    ".txt", ".gz", ".bat", ".c",
    ".c++", ".exe", ".pdf",
    NULL
};

int  main(void)
{
  size_t i;

  for (i = 0; fnames[i]; ++i) {
    printf("%s: %s\n", fnames[i],
	   ext_is_in_list(fnames[i], exts) ? "yes" : "no");
  }

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c7c(void);
int64_t function_100003d48(void);
int32_t function_100003ed8(char * format, ...);
char * function_100003ee4(char * s, int32_t c);
int32_t function_100003ef0(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003efc; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
char * _strrchr(char * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003c7c - 0x100003d48
int64_t function_100003c7c(void) {
    // 0x100003c7c
    int64_t v1; // 0x100003c7c
    char * c = (char *)v1;
    char * c2 = (char *)v1;
    int32_t v2 = _tolower((int32_t)*c); // 0x100003c9c
    int32_t v3 = _tolower((int32_t)*c2); // 0x100003cac
    char v4 = *c;
    char v5 = v4; // 0x100003cc0
    char * v6 = c2; // 0x100003cc0
    char v7 = v4; // 0x100003cc0
    if (v2 != v3) {
      lab_0x100003d08:
        // 0x100003d38
        return v7 >= *v6 ? 1 : 0xffffffff;
    }
    while (v5 != 0) {
        // 0x100003cec
        int64_t v8; // 0x100003c7c
        int64_t v9 = v8 + 1; // 0x100003cf0
        int64_t v10; // 0x100003c7c
        int64_t v11 = v10 + 1; // 0x100003cfc
        char * c3 = (char *)v9;
        char * c4 = (char *)v11;
        int32_t v12 = _tolower((int32_t)*c3); // 0x100003c9c
        int32_t v13 = _tolower((int32_t)*c4); // 0x100003cac
        v5 = *c3;
        v10 = v11;
        v8 = v9;
        v6 = c4;
        v7 = v5;
        if (v12 != v13) {
            return v7 >= *v6 ? 1 : 0xffffffff;
        }
    }
    // 0x100003d38
    return 0;
}

// Address range: 0x100003d48 - 0x100003e1c
int64_t function_100003d48(void) {
    // 0x100003d48
    int64_t v1; // 0x100003d48
    if (_strrchr((char *)v1, 46) == NULL) {
        // 0x100003e08
        return 0;
    }
    // 0x100003d88
    if (*(int64_t *)v1 == 0) {
        // 0x100003e08
        return 0;
    }
    int64_t v2 = 0; // 0x100003d9c
    int64_t result = 1; // 0x100003dc0
    while ((int32_t)function_100003c7c() != 0) {
        // 0x100003d88
        v2++;
        result = 0;
        if (*(int64_t *)(8 * v2 + v1) == 0) {
            // break -> 0x100003e08
            break;
        }
        result = 1;
    }
    // 0x100003e08
    return result;
}

// Address range: 0x100003e1c - 0x100003ed8
int64_t entry_point(void) {
    // 0x100003e1c
    if (g1 == 0) {
        // 0x100003ec8
        return 0;
    }
    int64_t v1 = 0; // 0x100003ebc
    function_100003d48();
    int64_t v2; // 0x100003e1c
    _printf("%s: %s\n", "y?", (char *)v2);
    while (*(int64_t *)(8 * (v1 + 1) + (int64_t)&g1) != 0) {
        // 0x100003e54
        v1++;
        function_100003d48();
        _printf("%s: %s\n", "y?", (char *)v2);
    }
    // 0x100003ec8
    return 0;
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(char * format, ...) {
    // 0x100003ed8
    return _printf(format);
}

// Address range: 0x100003ee4 - 0x100003ef0
char * function_100003ee4(char * s, int32_t c) {
    // 0x100003ee4
    return _strrchr(s, c);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(int32_t c) {
    // 0x100003ef0
    return _tolower(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>

#define NELEMS(arr) (sizeof(arr) / sizeof(arr[0]))

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0

#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)

#define da_rewind(name)     _qy_ ## name ## _p = 0

#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)

typedef unsigned char uchar;
typedef uchar code;

typedef enum { FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND,
    OR, NEG, NOT, JMP, JZ, PRTC, PRTS, PRTI, HALT
} Code_t;

typedef struct Code_map {
    char    *text;
    Code_t   op;
} Code_map;

Code_map code_map[] = {
    {"fetch",  FETCH},
    {"store",  STORE},
    {"push",   PUSH },
    {"add",    ADD  },
    {"sub",    SUB  },
    {"mul",    MUL  },
    {"div",    DIV  },
    {"mod",    MOD  },
    {"lt",     LT   },
    {"gt",     GT   },
    {"le",     LE   },
    {"ge",     GE   },
    {"eq",     EQ   },
    {"ne",     NE   },
    {"and",    AND  },
    {"or",     OR   },
    {"neg",    NEG  },
    {"not",    NOT  },
    {"jmp",    JMP  },
    {"jz",     JZ   },
    {"prtc",   PRTC },
    {"prts",   PRTS },
    {"prti",   PRTI },
    {"halt",   HALT },
};

FILE *source_fp;
da_dim(object, code);

void error(const char *fmt, ... ) {
    va_list ap;
    char buf[1000];

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    va_end(ap);
    printf("error: %s\n", buf);
    exit(1);
}

/*** Virtual Machine interpreter ***/
void run_vm(const code obj[], int32_t data[], int g_size, char **string_pool) {
    int32_t *sp = &data[g_size + 1];
    const code *pc = obj;

    again:
    switch (*pc++) {
        case FETCH: *sp++ = data[*(int32_t *)pc];  pc += sizeof(int32_t); goto again;
        case STORE: data[*(int32_t *)pc] = *--sp;  pc += sizeof(int32_t); goto again;
        case PUSH:  *sp++ = *(int32_t *)pc;        pc += sizeof(int32_t); goto again;
        case ADD:   sp[-2] += sp[-1]; --sp;                             goto again;
        case SUB:   sp[-2] -= sp[-1]; --sp;                             goto again;
        case MUL:   sp[-2] *= sp[-1]; --sp;                             goto again;
        case DIV:   sp[-2] /= sp[-1]; --sp;                             goto again;
        case MOD:   sp[-2] %= sp[-1]; --sp;                             goto again;
        case LT:    sp[-2] = sp[-2] <  sp[-1]; --sp;                    goto again;
        case GT:    sp[-2] = sp[-2] >  sp[-1]; --sp;                    goto again;
        case LE:    sp[-2] = sp[-2] <= sp[-1]; --sp;                    goto again;
        case GE:    sp[-2] = sp[-2] >= sp[-1]; --sp;                    goto again;
        case EQ:    sp[-2] = sp[-2] == sp[-1]; --sp;                    goto again;
        case NE:    sp[-2] = sp[-2] != sp[-1]; --sp;                    goto again;
        case AND:   sp[-2] = sp[-2] && sp[-1]; --sp;                    goto again;
        case OR:    sp[-2] = sp[-2] || sp[-1]; --sp;                    goto again;
        case NEG:   sp[-1] = -sp[-1];                                   goto again;
        case NOT:   sp[-1] = !sp[-1];                                   goto again;
        case JMP:   pc += *(int32_t *)pc;                               goto again;
        case JZ:    pc += (*--sp == 0) ? *(int32_t *)pc : (int32_t)sizeof(int32_t); goto again;
        case PRTC:  printf("%c", sp[-1]); --sp;                         goto again;
        case PRTS:  printf("%s", string_pool[sp[-1]]); --sp;            goto again;
        case PRTI:  printf("%d", sp[-1]); --sp;                         goto again;
        case HALT:                                                      break;
        default:    error("Unknown opcode %d\n", *(pc - 1));
    }
}

char *read_line(int *len) {
    static char *text = NULL;
    static int textmax = 0;

    for (*len = 0; ; (*len)++) {
        int ch = fgetc(source_fp);
        if (ch == EOF || ch == '\n') {
            if (*len == 0)
                return NULL;
            break;
        }
        if (*len + 1 >= textmax) {
            textmax = (textmax == 0 ? 128 : textmax * 2);
            text = realloc(text, textmax);
        }
        text[*len] = ch;
    }
    text[*len] = '\0';
    return text;
}

char *rtrim(char *text, int *len) {         // remove trailing spaces
    for (; *len > 0 && isspace(text[*len - 1]); --(*len))
        ;

    text[*len] = '\0';
    return text;
}

char *translate(char *st) {
    char *p, *q;
    if (st[0] == '"')                       // skip leading " if there
        ++st;
    p = q = st;

    while ((*p++ = *q++) != '\0') {
        if (q[-1] == '\\') {
            if (q[0] == 'n') {
                p[-1] = '\n';
                ++q;
            } else if (q[0] == '\\') {
                ++q;
            }
        }
        if (q[0] == '"' && q[1] == '\0')    // skip trialing " if there
            ++q;
    }

    return st;
}

/* convert an opcode string into its byte value */
int findit(const char text[], int offset) {
    for (size_t i = 0; i < sizeof(code_map) / sizeof(code_map[0]); i++) {
        if (strcmp(code_map[i].text, text) == 0)
            return code_map[i].op;
    }
    error("Unknown instruction %s at %d\n", text, offset);
    return -1;
}

void emit_byte(int c) {
    da_append(object, (uchar)c);
}

void emit_int(int32_t n) {
    union {
        int32_t n;
        unsigned char c[sizeof(int32_t)];
    } x;

    x.n = n;

    for (size_t i = 0; i < sizeof(x.n); ++i) {
        emit_byte(x.c[i]);
    }
}

/*
Datasize: 5 Strings: 3
" is prime\n"
"Total primes found: "
"\n"
 154 jmp    (-73) 82
 164 jz     (32) 197
 175 push  0
 159 fetch [4]
 149 store [3]
 */

/* Load code into global array object, return the string pool and data size */
char **load_code(int *ds) {
    int line_len, n_strings;
    char **string_pool;
    char *text = read_line(&line_len);
    text = rtrim(text, &line_len);

    strtok(text, " ");                      // skip "Datasize:"
    *ds = atoi(strtok(NULL, " "));          // get actual data_size
    strtok(NULL, " ");                      // skip "Strings:"
    n_strings = atoi(strtok(NULL, " "));    // get number of strings

    string_pool = malloc(n_strings * sizeof(char *));
    for (int i = 0; i < n_strings; ++i) {
        text = read_line(&line_len);
        text = rtrim(text, &line_len);
        text = translate(text);
        string_pool[i] = strdup(text);
    }

    for (;;) {
        int len;

        text = read_line(&line_len);
        if (text == NULL)
            break;
        text = rtrim(text, &line_len);

        int offset = atoi(strtok(text, " "));   // get the offset
        char *instr = strtok(NULL, " ");    // get the instruction
        int opcode = findit(instr, offset);
        emit_byte(opcode);
        char *operand = strtok(NULL, " ");

        switch (opcode) {
            case JMP: case JZ:
                operand++;                  // skip the '('
                len = strlen(operand);
                operand[len - 1] = '\0';    // remove the ')'
                emit_int(atoi(operand));
                break;
            case PUSH:
                emit_int(atoi(operand));
                break;
            case FETCH: case STORE:
                operand++;                  // skip the '['
                len = strlen(operand);
                operand[len - 1] = '\0';    // remove the ']'
                emit_int(atoi(operand));
                break;
        }
    }
    return string_pool;
}

void init_io(FILE **fp, FILE *std, const char mode[], const char fn[]) {
    if (fn[0] == '\0')
        *fp = std;
    else if ((*fp = fopen(fn, mode)) == NULL)
        error(0, 0, "Can't open %s\n", fn);
}

int main(int argc, char *argv[]) {
    init_io(&source_fp, stdin,  "r",  argc > 1 ? argv[1] : "");
    int data_size;
    char **string_pool = load_code(&data_size);
    int data[1000 + data_size];
    run_vm(object, data, data_size, string_pool);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002eac(void);
int64_t function_100002f18(int32_t a1, int32_t a2, int32_t a3);
int64_t function_1000034a4(void);
int64_t function_10000360c(void);
int64_t function_1000036b4(void);
int64_t function_1000037f4(void);
int64_t function_1000038c0(void);
int64_t function_100003968(void);
int64_t function_1000039cc(void);
int64_t function_100003c50(void);
int64_t function_100003db8(void);
int64_t function_100003e24(int64_t a1);
int64_t function_100003e30(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t function_100003e3c(char * nptr);
void function_100003e48(int32_t status);
int32_t function_100003e54(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e60(char * filename, char * modes);
int32_t function_100003e6c(int32_t c);
int64_t * function_100003e78(int32_t size);
int32_t function_100003e84(char * format, ...);
int64_t * function_100003e90(int64_t * ptr, int32_t size);
int32_t function_100003e9c(char * s1, char * s2);
char * function_100003ea8(char * s);
int32_t function_100003eb4(char * s);
char * function_100003ec0(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x20000000003ecc; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008180
int32_t g3 = 0; // 0x100008188
int32_t g4 = 2; // 0x10000818c
struct _IO_FILE * g5 = (struct _IO_FILE *)0x55800000012; // 0x100008190
int64_t g6 = 0; // 0x100008198
int32_t g7 = 0; // 0x1000081a0

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t _atoi(char * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100002eac - 0x100002f18
int64_t function_100002eac(void) {
    // 0x100002eac
    int64_t v1; // 0x100002eac
    int64_t v2; // bp-1032, 0x100002eac
    int64_t v3; // 0x100002eac
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("error: %s\n", NULL);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100002f18 - 0x100003444
int64_t function_100002f18(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100002f18
    int64_t result; // 0x100002f18
    unsigned char v1 = (char)result;
    if (v1 >= 23 != v1 != 23) {
        // 0x100002f7c
        return result;
    }
    // 0x100003414
    function_100002eac();
    // UNREACHABLE
}

// Address range: 0x1000034a4 - 0x10000360c
int64_t function_1000034a4(void) {
    int32_t v1 = 0; // 0x1000034bc
    int64_t result; // 0x1000035f0
    int32_t v2; // 0x1000034a4
    while (true) {
        // 0x1000034c0
        int64_t v3; // 0x1000034a4
        *(int32_t *)v3 = v1;
        int32_t v4 = _fgetc(g5); // 0x1000034cc
        int64_t v5; // 0x1000034a4
        v2 = *(int32_t *)&v5;
        switch (v4) {
            case -1: {
            }
            case 10: {
                // 0x1000034fc
                result = 0;
                if (v2 != 0) {
                    // 0x1000035d8
                    *(char *)(g6 + (int64_t)v2) = 0;
                    result = g6;
                }
                // 0x1000035fc
                return result;
            }
        }
        int32_t v6 = v2 + 1; // 0x100003528
        int32_t v7 = *(int32_t *)((int64_t)&g1 + 416); // 0x100003530
        int32_t v8 = v6 - v7; // 0x100003534
        int64_t v9; // 0x1000034a4
        if (v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            int32_t v10 = g7; // 0x100003548
            int32_t v11 = v10 == 0 ? 128 : 2 * v10;
            g7 = v11;
            int64_t v12 = (int64_t)_realloc((int64_t *)g6, v11); // 0x100003598
            g6 = v12;
            v9 = v12;
        } else {
            // 0x100003520
            v9 = g6;
        }
        // 0x1000035a8
        *(char *)(v9 + (int64_t)v2) = (char)v4;
        v1 = *(int32_t *)&v5 + 1;
    }
    // 0x1000034fc
    result = 0;
    if (v2 != 0) {
        // 0x1000035d8
        *(char *)(g6 + (int64_t)v2) = 0;
        result = g6;
    }
    // 0x1000035fc
    return result;
}

// Address range: 0x10000360c - 0x1000036b4
int64_t function_10000360c(void) {
    // 0x10000360c
    int64_t result; // 0x10000360c
    int32_t v1 = result;
    if (v1 < 1) {
        // 0x100003690
        *(char *)(result + (int64_t)v1) = 0;
        return result;
    }
    uint32_t v2 = v1 - 1; // 0x100003650
    char v3 = *(char *)(result + (int64_t)v2); // 0x100003654
    int32_t v4 = v1; // 0x100003670
    while (_isspace((int32_t)v3) != 0) {
        // 0x10000367c
        *(int32_t *)result = v2;
        int64_t v5; // 0x10000360c
        int32_t v6 = *(int32_t *)&v5; // 0x100003628
        v4 = v6;
        if (v6 < 1) {
            // break -> 0x100003690
            break;
        }
        v2 = v6 - 1;
        v3 = *(char *)(result + (int64_t)v2);
        v4 = v6;
    }
    // 0x100003690
    *(char *)(result + (int64_t)v4) = 0;
    return result;
}

// Address range: 0x1000036b4 - 0x1000037f4
int64_t function_1000036b4(void) {
    // 0x1000036b4
    int64_t v1; // 0x1000036b4
    int64_t v2 = v1;
    int64_t result = v2 + (int64_t)((char)v2 == 34);
    char * v3 = (char *)result; // 0x1000036e8
    char v4 = *v3; // 0x100003700
    char v5 = v4; // 0x10000371c
    int64_t v6 = result; // 0x10000371c
    int64_t v7 = result; // 0x10000371c
    if (v4 == 0) {
        // 0x1000037e8
        return result;
    }
    char * v8 = v3; // 0x10000371c
    char v9; // 0x1000036b4
    char * v10; // 0x1000036b4
    char * v11; // 0x1000036b4
    while (true) {
      lab_0x100003724:;
        int64_t v12 = v7;
        char * v13 = (char *)(v12 + 1);
        v10 = v13;
        if (v5 == 92) {
            char v14 = *v13;
            v9 = v14;
            v11 = v13;
            switch (v14) {
                case 110: {
                    // 0x100003754
                    *v8 = 10;
                    v10 = (char *)(v12 + 2);
                    goto lab_0x1000037a4;
                }
                case 92: {
                    // 0x10000378c
                    v10 = (char *)(v12 + 2);
                    goto lab_0x1000037a4;
                }
                default: {
                    goto lab_0x1000037a4_2;
                }
            }
        } else {
            goto lab_0x1000037a4;
        }
    }
  lab_0x1000037e8:
    // 0x1000037e8
    return result;
  lab_0x1000037a4:
    // 0x1000037a4
    v9 = *v10;
    v11 = v10;
    goto lab_0x1000037a4_2;
  lab_0x1000037a4_2:;
    char * v15 = v11;
    char v16 = v9; // 0x1000037b4
    char * v17 = v15; // 0x1000037b4
    if (v9 == 34) {
        char * v18 = (char *)((int64_t)v15 + 1); // 0x1000037c0
        char * v19 = *v18 == 0 ? v18 : v15;
        v16 = *v19;
        v17 = v19;
    }
    // 0x1000037e4
    v6++;
    char * v20 = (char *)v6;
    *v20 = v16;
    if (v16 == 0) {
        // break -> 0x1000037e8
        goto lab_0x1000037e8;
    }
    // 0x1000037e4
    v5 = *v17;
    v7 = (int64_t)v17;
    v8 = v20;
    goto lab_0x100003724;
}

// Address range: 0x1000037f4 - 0x1000038c0
int64_t function_1000037f4(void) {
    int64_t v1 = 0; // 0x100003874
    int64_t v2 = 16 * v1; // 0x100003828
    int64_t v3 = *(int64_t *)(v2 + (int64_t)&g1); // 0x100003834
    int64_t v4; // 0x1000037f4
    while (_strcmp((char *)v3, (char *)v4) != 0) {
        // 0x100003810
        v1++;
        if (v1 >= 24) {
            // 0x100003880
            function_100002eac();
            // UNREACHABLE
        }
        v2 = 16 * v1;
        v3 = *(int64_t *)(v2 + (int64_t)&g1);
    }
    // 0x100003850
    return (int64_t)*(int32_t *)(v2 + (int64_t)&g1 + 8);
}

// Address range: 0x1000038c0 - 0x100003968
int64_t function_1000038c0(void) {
    int32_t v1 = g3; // 0x1000038dc
    int32_t v2 = v1 - g4; // 0x1000038e8
    int32_t v3 = v1; // 0x1000038f0
    int64_t v4 = g2; // 0x1000038f0
    int64_t result; // 0x1000038c0
    if (v2 < 0 == ((v2 ^ v1) & (g4 ^ v1)) < 0) {
        int32_t v5 = g4 + 32; // 0x10000390c
        g4 = v5;
        v4 = (int64_t)_realloc((int64_t *)g2, v5);
        g2 = v4;
        v3 = g3;
        result = v4;
    }
    // 0x100003934
    g3 = v3 + 1;
    int64_t v6; // 0x1000038c0
    *(char *)(v4 + (int64_t)v3) = (char)v6;
    return result;
}

// Address range: 0x100003968 - 0x1000039cc
int64_t function_100003968(void) {
    int64_t result; // 0x1000039a8
    for (int64_t i = 0; i < 4; i++) {
        // 0x10000399c
        result = function_1000038c0();
    }
    // 0x1000039c0
    return result;
}

// Address range: 0x1000039cc - 0x100003c50
int64_t function_1000039cc(void) {
    // 0x1000039cc
    function_1000034a4();
    _strtok((char *)function_10000360c(), " ");
    int64_t v1; // 0x1000039cc
    *(int32_t *)v1 = _atoi(_strtok(NULL, " "));
    _strtok(NULL, " ");
    int32_t v2 = _atoi(_strtok(NULL, " ")); // 0x100003a48
    int64_t result = (int64_t)_malloc(8 * v2); // 0x100003a58
    int32_t v3 = -v2; // 0x100003a70
    int32_t v4 = 0; // 0x100003a78
    if (v3 < 0 != (v2 & v3) < 0) {
        function_1000034a4();
        function_10000360c();
        char * v5 = _strdup((char *)function_1000036b4()); // 0x100003ab0
        *(int64_t *)(8 * (int64_t)v4 + result) = (int64_t)v5;
        v4++;
        while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
            // 0x100003a80
            function_1000034a4();
            function_10000360c();
            v5 = _strdup((char *)function_1000036b4());
            *(int64_t *)(8 * (int64_t)v4 + result) = (int64_t)v5;
            v4++;
        }
    }
    // 0x100003ad8
    if (function_1000034a4() == 0) {
        // 0x100003c40
        return result;
    }
    _atoi(_strtok((char *)function_10000360c(), " "));
    _strtok(NULL, " ");
    int64_t v6 = function_1000037f4(); // 0x100003b44
    function_1000038c0();
    char * v7 = _strtok(NULL, " "); // 0x100003b5c
    int32_t v8 = v6; // 0x100003b68
    int64_t v9; // 0x100003c00
    char * v10; // 0x100003c0c
    int64_t v11; // 0x100003bb0
    char * v12; // 0x100003bbc
    if (v8 == 1 || v8 == 0) {
        // 0x100003bfc
        v9 = (int64_t)v7 + 1;
        v10 = (char *)v9;
        *(char *)(v9 + (int64_t)(_strlen(v10) - 1)) = 0;
        _atoi(v10);
        function_100003968();
    } else {
        if (v8 == 2) {
            // 0x100003bec
            _atoi(v7);
            function_100003968();
        } else {
            if (v8 != 18 != v8 != 19) {
                // 0x100003bac
                v11 = (int64_t)v7 + 1;
                v12 = (char *)v11;
                *(char *)(v11 + (int64_t)(_strlen(v12) - 1)) = 0;
                _atoi(v12);
                function_100003968();
            }
        }
    }
    while (function_1000034a4() != 0) {
        // 0x100003afc
        _atoi(_strtok((char *)function_10000360c(), " "));
        _strtok(NULL, " ");
        v6 = function_1000037f4();
        function_1000038c0();
        v7 = _strtok(NULL, " ");
        v8 = v6;
        if (v8 == 1 || v8 == 0) {
            // 0x100003bfc
            v9 = (int64_t)v7 + 1;
            v10 = (char *)v9;
            *(char *)(v9 + (int64_t)(_strlen(v10) - 1)) = 0;
            _atoi(v10);
            function_100003968();
        } else {
            if (v8 == 2) {
                // 0x100003bec
                _atoi(v7);
                function_100003968();
            } else {
                if (v8 != 18 != v8 != 19) {
                    // 0x100003bac
                    v11 = (int64_t)v7 + 1;
                    v12 = (char *)v11;
                    *(char *)(v11 + (int64_t)(_strlen(v12) - 1)) = 0;
                    _atoi(v12);
                    function_100003968();
                }
            }
        }
    }
    // 0x100003c40
    return result;
}

// Address range: 0x100003c50 - 0x100003cf4
int64_t function_100003c50(void) {
    // 0x100003c50
    int64_t v1; // 0x100003c50
    if ((char)v1 == 0) {
        // 0x100003ce8
        int64_t result; // 0x100003c50
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, (char *)v1); // 0x100003c9c
    int64_t result2 = (int64_t)v2; // 0x100003c9c
    *(int64_t *)v1 = result2;
    if (v2 != NULL) {
        // 0x100003ce8
        return result2;
    }
    // 0x100003cbc
    function_100002eac();
    // UNREACHABLE
}

// Address range: 0x100003cf4 - 0x100003db8
int64_t entry_point(void) {
    // 0x100003cf4
    function_100003c50();
    function_1000039cc();
    return ___chkstk_darwin();
}

// Address range: 0x100003db8 - 0x100003e24
int64_t function_100003db8(void) {
    // 0x100003db8
    int64_t v1; // 0x100003db8
    int32_t v2 = *(int32_t *)(v1 - 12); // 0x100003de8
    int32_t * v3 = (int32_t *)(v1 - 76); // 0x100003dec
    *v3 = v2;
    int32_t result = v2; // 0x100003e08
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v1 - 8)) {
        // 0x100003e10
        ___stack_chk_fail(g2);
        result = *v3;
    }
    // 0x100003e14
    return result;
}

// Address range: 0x100003e24 - 0x100003e30
int64_t function_100003e24(int64_t a1) {
    // 0x100003e24
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e30 - 0x100003e3c
int64_t function_100003e30(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003e30
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003e3c - 0x100003e48
int32_t function_100003e3c(char * nptr) {
    // 0x100003e3c
    return _atoi(nptr);
}

// Address range: 0x100003e48 - 0x100003e54
void function_100003e48(int32_t status) {
    // 0x100003e48
    _exit(status);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(struct _IO_FILE * stream) {
    // 0x100003e54
    return _fgetc(stream);
}

// Address range: 0x100003e60 - 0x100003e6c
struct _IO_FILE * function_100003e60(char * filename, char * modes) {
    // 0x100003e60
    return _fopen(filename, modes);
}

// Address range: 0x100003e6c - 0x100003e78
int32_t function_100003e6c(int32_t c) {
    // 0x100003e6c
    return _isspace(c);
}

// Address range: 0x100003e78 - 0x100003e84
int64_t * function_100003e78(int32_t size) {
    // 0x100003e78
    return _malloc(size);
}

// Address range: 0x100003e84 - 0x100003e90
int32_t function_100003e84(char * format, ...) {
    // 0x100003e84
    return _printf(format);
}

// Address range: 0x100003e90 - 0x100003e9c
int64_t * function_100003e90(int64_t * ptr, int32_t size) {
    // 0x100003e90
    return _realloc(ptr, size);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(char * s1, char * s2) {
    // 0x100003e9c
    return _strcmp(s1, s2);
}

// Address range: 0x100003ea8 - 0x100003eb4
char * function_100003ea8(char * s) {
    // 0x100003ea8
    return _strdup(s);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(char * s) {
    // 0x100003eb4
    return _strlen(s);
}

// Address range: 0x100003ec0 - 0x100003ecc
char * function_100003ec0(char * s, char * delim) {
    // 0x100003ec0
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 26

`
`#include <stdio.h>

int main(int argc, char const *argv[]) {
  for (char c = 0x41; c < 0x5b; c ++) putchar(c);
  putchar('\n');
  for (char c = 0x61; c < 0x7b; c ++) putchar(c);
  putchar('\n');
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f9c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003eec - 0x100003f9c
int64_t entry_point(void) {
    int32_t v1 = 65; // 0x100003f38
    _putchar(v1);
    int32_t v2 = 0x1000000 * v1 + 0x1000000;
    v1 = v2 >> 24;
    while (v2 < 0x5b000000 != (90 - v1 & v1) < 0) {
        // 0x100003f24
        _putchar(v1);
        v2 = 0x1000000 * v1 + 0x1000000;
        v1 = v2 >> 24;
    }
    // 0x100003f40
    _putchar(10);
    int32_t v3 = 97; // 0x100003f7c
    _putchar(v3);
    int32_t v4 = 0x1000000 * v3 + 0x1000000;
    v3 = v4 >> 24;
    while (v4 < 0x7b000000 != (122 - v3 & v3) < 0) {
        // 0x100003f68
        _putchar(v3);
        v4 = 0x1000000 * v3 + 0x1000000;
        v3 = v4 >> 24;
    }
    // 0x100003f84
    _putchar(10);
    return 0;
}

// Address range: 0x100003f9c - 0x100003fa8
int32_t function_100003f9c(int32_t c) {
    // 0x100003f9c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int compareInts(const void *i1, const void *i2) {
    int a = *((int *)i1);
    int b = *((int *)i2);
    return a - b;
}

int main() {
    int i, j, nsum, vsum, vcount, values[6], numbers[4];
    srand(time(NULL));
    for (;;) {
        vsum = 0;
        for (i = 0; i < 6; ++i) {
            for (j = 0; j < 4; ++j) {
                numbers[j] = 1 + rand() % 6;
            }
            qsort(numbers, 4, sizeof(int), compareInts);
            nsum = 0;
            for (j = 1; j < 4; ++j) {
                nsum += numbers[j];
            }
            values[i] = nsum;
            vsum += values[i];
        }
        if (vsum < 75) continue;
        vcount = 0;
        for (j = 0; j < 6; ++j) {
            if (values[j] >= 15) vcount++;
        }
        if (vcount < 2) continue;
        printf("The 6 random numbers generated are:\n");
        printf("[");
        for (j = 0; j < 6; ++j) printf("%d ", values[j]);
        printf("\b]\n");
        printf("\nTheir sum is %d and %d of them are >= 15\n", vsum, vcount);
        break;
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c18(void);
int64_t function_100003efc(int64_t a1);
int32_t function_100003f08(char * format, ...);
void function_100003f14(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003f20(void);
void function_100003f2c(int32_t seed);
int32_t function_100003f38(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c18 - 0x100003c50
int64_t function_100003c18(void) {
    // 0x100003c18
    return 0;
}

// Address range: 0x100003c50 - 0x100003efc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c64
    _srand(_time(NULL));
    int64_t v2; // bp-64, 0x100003c50
    int64_t v3 = &v2;
    int64_t v4; // bp-48, 0x100003c50
    int64_t v5 = &v4;
    while (true) {
        int64_t v6 = 0;
        for (int64_t i = 0; i < 4; i++) {
            // 0x100003cbc
            *(int32_t *)(4 * i + v3) = _rand() % 6 + 1;
        }
        // 0x100003cf4
        _qsort(&v2, 4, 4, (int32_t (*)(int64_t *, int64_t *))0x100003c18);
        int64_t v7 = 1;
        int32_t v8 = *(int32_t *)(4 * v7 + v3); // 0x100003d40
        v7++;
        int32_t v9 = v8; // 0x100003d28
        while (v7 != 4) {
            // 0x100003d30
            v8 = *(int32_t *)(4 * v7 + v3) + v9;
            v7++;
            v9 = v8;
        }
        // 0x100003d5c
        *(int32_t *)(4 * v6 + v5) = v8;
        int32_t v10 = v8; // 0x100003d78
        v6++;
        int32_t v11 = v10; // 0x100003c98
        while (v6 != 6) {
            for (int64_t i = 0; i < 4; i++) {
                // 0x100003cbc
                *(int32_t *)(4 * i + v3) = _rand() % 6 + 1;
            }
            // 0x100003cf4
            _qsort(&v2, 4, 4, (int32_t (*)(int64_t *, int64_t *))0x100003c18);
            v7 = 1;
            v8 = *(int32_t *)(4 * v7 + v3);
            v7++;
            v9 = v8;
            while (v7 != 4) {
                // 0x100003d30
                v8 = *(int32_t *)(4 * v7 + v3) + v9;
                v7++;
                v9 = v8;
            }
            // 0x100003d5c
            *(int32_t *)(4 * v6 + v5) = v8;
            v10 = v8 + v11;
            v6++;
            v11 = v10;
        }
        int64_t v12 = 0; // 0x100003da0
        if (v10 < 75 == (74 - v10 & v10) < 0) {
            int32_t v13 = *(int32_t *)(4 * v12 + v5); // 0x100003dd4
            int32_t v14 = v13 < 15 == (14 - v13 & v13) < 0;
            int64_t v15 = v12 + 1;
            v12 = v15;
            int32_t v16 = v14; // 0x100003dc4
            while (v15 != 6) {
                // 0x100003dcc
                v13 = *(int32_t *)(4 * v12 + v5);
                v14 = v16 + (int32_t)(v13 < 15 == (14 - v13 & v13) < 0);
                v15 = v12 + 1;
                v12 = v15;
                v16 = v14;
            }
            if (v14 < 2 == (1 - v14 & v14) < 0) {
                // break -> 0x100003e24
                break;
            }
        }
    }
    // 0x100003e24
    _printf("The 6 random numbers generated are:\n");
    _printf("[");
    for (int32_t i = 0; i < 6; i++) {
        // 0x100003e58
        _printf("%d ", 4);
    }
    // 0x100003e90
    _printf("\b]\n");
    int32_t v17 = _printf("\nTheir sum is %d and %d of them are >= 15\n", 4, 4); // 0x100003ec0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ee8
        ___stack_chk_fail((int64_t)v17);
    }
    // 0x100003eec
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(int64_t a1) {
    // 0x100003efc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// Address range: 0x100003f14 - 0x100003f20
void function_100003f14(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f14
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(void) {
    // 0x100003f20
    return _rand();
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(int32_t seed) {
    // 0x100003f2c
    _srand(seed);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(int32_t * timer) {
    // 0x100003f38
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h> // For time

enum { empty = 0, tree = 1, fire = 2 };
const char *disp[] = {"  ", "\033[32m/\\\033[m", "\033[07;31m/\\\033[m"};
double tree_prob = 0.01, burn_prob = 0.0001;

#define for_x for (int x = 0; x < w; x++)
#define for_y for (int y = 0; y < h; y++)
#define for_yx for_y for_x
#define chance(x) (rand() < RAND_MAX * x)
void evolve(int w, int h)
{
	unsigned univ[h][w], new[h][w];
	for_yx new[y][x] = univ[y][x] = chance(tree_prob) ? tree : empty;

show:	printf("\033[H");
	for_y {
		for_x printf("%s",disp[univ[y][x]]);
		printf("\033[E");
	}
	fflush(stdout);

	for_yx {
		switch (univ[y][x]) {
		case fire:	new[y][x] = empty;
				break;
		case empty:	if (chance(tree_prob)) new[y][x] = tree;
				break;
		default:
			for (int y1 = y - 1; y1 <= y + 1; y1++) {
				if (y1 < 0 || y1 >= h) continue;
				for (int x1 = x - 1; x1 <= x + 1; x1++) {
					if (x1 < 0 || x1 >= w) continue;
					if (univ[y1][x1] != fire) continue;

					new[y][x] = fire;
					goto burn;
				}
			}

			burn:
			if (new[y][x] == tree && chance(burn_prob))
				new[y][x] = fire;
		}
	}

	for_yx { univ[y][x] = new[y][x]; }
	//usleep(100000);
	goto show;
}

int main(int c, char **v)
{
	//srand(time(0));
	int w = 0, h = 0;

	if (c > 1) w = atoi(v[1]);
	if (c > 2) h = atoi(v[2]);
	if (w <= 0) w = 30;
	if (h <= 0) h = 30;

	evolve(w, h);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000388c(int32_t a1, int32_t a2);
int64_t function_1000038dc(void);
int64_t function_100003930(void);
int32_t function_100003f48(char * nptr);
int32_t function_100003f54(struct _IO_FILE * stream);
int32_t function_100003f60(char * format, ...);
int32_t function_100003f6c(void);

// --------------------- Global Variables ---------------------

float64_t g1 = 2147483647.0; // 0x100003f78
char * g2 = "\x1b[H"; // 0x100003f9c
int64_t g3 = 0x10000000003f80; // 0x100008000
float64_t g4 = 0.01; // 0x100008018
int64_t g5 = 0x3f1a36e2eb1c432d; // 0x100008020

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int32_t _atoi(char * a1);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x10000388c - 0x1000038dc
int64_t function_10000388c(int32_t a1, int32_t a2) {
    // 0x10000388c
    return ___chkstk_darwin();
}

// Address range: 0x1000038dc - 0x100003930
int64_t function_1000038dc(void) {
    // 0x1000038dc
    int64_t v1; // 0x1000038dc
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)(v2 - 144); // 0x1000038dc
    int64_t v4; // 0x1000038dc
    *(int64_t *)(v2 - 128) = (int64_t)&v4 - v3;
    *(int64_t *)(v2 - 24) = *(int64_t *)(v2 - 136);
    int64_t v5 = (int64_t)*(int32_t *)(v2 - 8); // 0x1000038fc
    *(int64_t *)(v2 - 104) = v5;
    int64_t v6 = (int64_t)*(int32_t *)(v2 - 4); // 0x100003908
    *(int64_t *)(v2 - 120) = v6;
    *(int64_t *)(v2 - 112) = 4 * v5 * v6 + 15 & -16;
    return ___chkstk_darwin();
}

// Address range: 0x100003930 - 0x100003e7c
int64_t function_100003930(void) {
    // 0x100003930
    int64_t v1; // 0x100003930
    int64_t v2 = v1;
    int64_t v3; // 0x100003930
    int64_t v4 = (int64_t)&v3 - *(int64_t *)(v2 - 112); // 0x10000393c
    int64_t * v5 = (int64_t *)(v2 - 96); // 0x100003944
    *v5 = v4;
    *(int64_t *)(v2 - 40) = *(int64_t *)(v2 - 104);
    int32_t * v6 = (int32_t *)(v2 - 52); // 0x100003950
    *v6 = 0;
    int32_t * v7 = (int32_t *)(v2 - 8); // 0x10000395c
    int32_t v8 = *v7; // 0x10000395c
    int32_t v9 = -v8; // 0x100003960
    int32_t * v10; // 0x100003930
    int64_t * v11; // 0x100003930
    int64_t * v12; // 0x100003930
    int64_t * v13; // 0x100003930
    if (v9 < 0 == (v8 & v9) < 0) {
        // 0x100003930
        v13 = (int64_t *)(v2 - 120);
        v12 = (int64_t *)(v2 - 152);
        v11 = (int64_t *)(v2 - 128);
        v10 = (int32_t *)(v2 - 4);
    } else {
        int32_t * v14 = (int32_t *)(v2 - 56); // 0x100003970
        int32_t * v15 = (int32_t *)(v2 - 4);
        int64_t * v16 = (int64_t *)(v2 - 152);
        int64_t * v17 = (int64_t *)(v2 - 128);
        int64_t * v18 = (int64_t *)(v2 - 120);
        *v14 = 0;
        int32_t v19 = *v15; // 0x10000397c
        int32_t v20 = -v19; // 0x100003980
        int32_t v21; // 0x100003990
        int64_t v22; // 0x100003998
        int32_t v23; // 0x1000039e0
        int32_t v24; // 0x1000039e4
        int32_t v25; // 0x1000039e8
        int32_t v26; // 0x1000039f4
        int32_t v27; // 0x100003a04
        int32_t v28; // 0x10000397c
        if (v20 < 0 != (v19 & v20) < 0) {
            v21 = _rand();
            v22 = *v17;
            v23 = *v14;
            v24 = g4 * g1 < (float64_t)v21;
            *(int32_t *)(4 * (*v16 * (int64_t)*v6 + (int64_t)v23) + v22) = v24;
            v25 = *v6;
            v26 = *v14;
            *(int32_t *)(4 * (*v18 * (int64_t)v25 + (int64_t)v26) + *v5) = v24;
            v27 = *v14 + 1;
            *v14 = v27;
            v28 = *v15;
            while (v27 - v28 < 0 != ((v27 - v28 ^ v27) & (v28 ^ v27)) < 0) {
                // 0x100003990
                v21 = _rand();
                v22 = *v17;
                v23 = *v14;
                v24 = g4 * g1 < (float64_t)v21;
                *(int32_t *)(4 * (*v16 * (int64_t)*v6 + (int64_t)v23) + v22) = v24;
                v25 = *v6;
                v26 = *v14;
                *(int32_t *)(4 * (*v18 * (int64_t)v25 + (int64_t)v26) + *v5) = v24;
                v27 = *v14 + 1;
                *v14 = v27;
                v28 = *v15;
            }
        }
        int32_t v29 = *v6 + 1; // 0x100003a18
        *v6 = v29;
        int32_t v30 = *v7; // 0x10000395c
        int32_t v31 = v29 - v30; // 0x100003960
        v13 = v18;
        v12 = v16;
        v11 = v17;
        v10 = v15;
        while (v31 < 0 != ((v31 ^ v29) & (v30 ^ v29)) < 0) {
            // 0x100003970
            *v14 = 0;
            v19 = *v15;
            v20 = -v19;
            if (v20 < 0 != (v19 & v20) < 0) {
                v21 = _rand();
                v22 = *v17;
                v23 = *v14;
                v24 = g4 * g1 < (float64_t)v21;
                *(int32_t *)(4 * (*v16 * (int64_t)*v6 + (int64_t)v23) + v22) = v24;
                v25 = *v6;
                v26 = *v14;
                *(int32_t *)(4 * (*v18 * (int64_t)v25 + (int64_t)v26) + *v5) = v24;
                v27 = *v14 + 1;
                *v14 = v27;
                v28 = *v15;
                while (v27 - v28 < 0 != ((v27 - v28 ^ v27) & (v28 ^ v27)) < 0) {
                    // 0x100003990
                    v21 = _rand();
                    v22 = *v17;
                    v23 = *v14;
                    v24 = g4 * g1 < (float64_t)v21;
                    *(int32_t *)(4 * (*v16 * (int64_t)*v6 + (int64_t)v23) + v22) = v24;
                    v25 = *v6;
                    v26 = *v14;
                    *(int32_t *)(4 * (*v18 * (int64_t)v25 + (int64_t)v26) + *v5) = v24;
                    v27 = *v14 + 1;
                    *v14 = v27;
                    v28 = *v15;
                }
            }
            // 0x100003a14
            v29 = *v6 + 1;
            *v6 = v29;
            v30 = *v7;
            v31 = v29 - v30;
            v13 = v18;
            v12 = v16;
            v11 = v17;
            v10 = v15;
        }
    }
    int32_t * v32 = (int32_t *)(v2 - 60);
    int32_t * v33 = (int32_t *)(v2 - 64);
    int32_t * v34 = (int32_t *)(v2 - 68);
    int32_t * v35 = (int32_t *)(v2 - 72);
    int32_t * v36 = (int32_t *)(v2 - 76);
    int32_t * v37 = (int32_t *)(v2 - 80);
    int32_t * v38 = (int32_t *)(v2 - 84);
    int32_t * v39 = (int32_t *)(v2 - 88);
    int32_t v40; // 0x100003930
    int32_t v41; // 0x100003930
    while (true) {
        // 0x100003a28
        _printf((char *)&g2);
        *v32 = 0;
        int32_t v42 = *v7; // 0x100003a40
        int32_t v43 = -v42; // 0x100003a44
        if (v43 < 0 != (v42 & v43) < 0) {
            *v33 = 0;
            int32_t v44 = *v10; // 0x100003a60
            int32_t v45 = -v44; // 0x100003a64
            int64_t v46; // 0x100003a74
            int64_t v47; // 0x100003a78
            uint32_t v48; // 0x100003a8c
            int64_t v49; // 0x100003a9c
            int32_t v50; // 0x100003ac4
            int32_t v51; // 0x100003a60
            int32_t v52; // 0x100003a64
            if (v45 < 0 != (v44 & v45) < 0) {
                v46 = *v11;
                v47 = *v12;
                v48 = *(int32_t *)(4 * (v47 * (int64_t)*v32 + (int64_t)0) + v46);
                v49 = *(int64_t *)(8 * (int64_t)v48 + (int64_t)&g3);
                *(int64_t *)(v4 - 16) = v49;
                _printf("%s", (char *)v1);
                v50 = *v33 + 1;
                *v33 = v50;
                v51 = *v10;
                v52 = v50 - v51;
                while (v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                    // 0x100003a74
                    v46 = *v11;
                    v47 = *v12;
                    v48 = *(int32_t *)(4 * (v47 * (int64_t)*v32 + (int64_t)v50) + v46);
                    v49 = *(int64_t *)(8 * (int64_t)v48 + (int64_t)&g3);
                    *(int64_t *)(v4 - 16) = v49;
                    _printf("%s", (char *)v1);
                    v50 = *v33 + 1;
                    *v33 = v50;
                    v51 = *v10;
                    v52 = v50 - v51;
                }
            }
            // 0x100003ad0
            _printf((char *)0x100003fa3);
            int32_t v53 = *v32 + 1; // 0x100003ae4
            *v32 = v53;
            int32_t v54 = *v7; // 0x100003a40
            while (v53 - v54 < 0 != ((v53 - v54 ^ v53) & (v54 ^ v53)) < 0) {
                // 0x100003a54
                *v33 = 0;
                v44 = *v10;
                v45 = -v44;
                if (v45 < 0 != (v44 & v45) < 0) {
                    v46 = *v11;
                    v47 = *v12;
                    v48 = *(int32_t *)(4 * (v47 * (int64_t)*v32 + (int64_t)0) + v46);
                    v49 = *(int64_t *)(8 * (int64_t)v48 + (int64_t)&g3);
                    *(int64_t *)(v4 - 16) = v49;
                    _printf("%s", (char *)v1);
                    v50 = *v33 + 1;
                    *v33 = v50;
                    v51 = *v10;
                    v52 = v50 - v51;
                    while (v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                        // 0x100003a74
                        v46 = *v11;
                        v47 = *v12;
                        v48 = *(int32_t *)(4 * (v47 * (int64_t)*v32 + (int64_t)v50) + v46);
                        v49 = *(int64_t *)(8 * (int64_t)v48 + (int64_t)&g3);
                        *(int64_t *)(v4 - 16) = v49;
                        _printf("%s", (char *)v1);
                        v50 = *v33 + 1;
                        *v33 = v50;
                        v51 = *v10;
                        v52 = v50 - v51;
                    }
                }
                // 0x100003ad0
                _printf((char *)0x100003fa3);
                v53 = *v32 + 1;
                *v32 = v53;
                v54 = *v7;
            }
        }
        // 0x100003af0
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008);
        *v34 = 0;
        int32_t v55 = *v7; // 0x100003b0c
        int32_t v56 = -v55; // 0x100003b10
        if (v56 < 0 != (v55 & v56) < 0) {
            while (true) {
                // 0x100003b20
                *v35 = 0;
                int32_t v57 = *v10; // 0x100003b2c
                int32_t v58 = -v57; // 0x100003b30
                v41 = 0;
                if (v58 < 0 != (v57 & v58) < 0) {
                    while (true) {
                      lab_0x100003b40:;
                        int64_t v59 = *v11; // 0x100003b40
                        int64_t v60 = *v12; // 0x100003b44
                        int32_t v61 = *v34; // 0x100003b48
                        int32_t v62 = *(int32_t *)(4 * (v60 * (int64_t)v61 + (int64_t)v41) + v59); // 0x100003b58
                        *(int32_t *)(v2 - 156) = v62;
                        switch (v62) {
                            case 0: {
                                // 0x100003ba8
                                if (g4 * g1 < (float64_t)_rand()) {
                                    int64_t v63 = *v13; // 0x100003bd8
                                    *(int32_t *)(4 * (v63 * (int64_t)*v34 + (int64_t)*v35) + *v5) = 1;
                                }
                                goto lab_0x100003db4;
                            }
                            case 2: {
                                int64_t v64 = *v13; // 0x100003b88
                                *(int32_t *)(4 * (v64 * (int64_t)*v34 + (int64_t)*v35) + *v5) = 0;
                                goto lab_0x100003db4;
                            }
                            default: {
                                int32_t v65 = *v34 - 1; // 0x100003c00
                                *v36 = v65;
                                int32_t v66 = *v34; // 0x100003c10
                                int32_t v67 = v66 + 1; // 0x100003c14
                                int32_t v68 = v65 - v67; // 0x100003c18
                                int32_t v69 = v65; // 0x100003c20
                                v40 = v66;
                                if (v68 == 0 || v68 < 0 != ((v68 ^ v65) & (v67 ^ v65)) < 0) {
                                    int32_t v70 = v69;
                                    int32_t v71 = v70; // 0x100003c34
                                    int32_t v72; // 0x100003930
                                    int32_t v73; // 0x100003930
                                    int32_t v74; // 0x100003d08
                                    int32_t v75; // 0x100003c40
                                    int32_t v76; // 0x100003c44
                                    int32_t v77; // 0x100003c5c
                                    int32_t v78; // 0x100003c6c
                                    int32_t v79; // 0x100003c70
                                    int32_t v80; // 0x100003c74
                                    int32_t v81; // 0x100003d0c
                                    int32_t v82; // 0x100003c6c
                                    int32_t v83; // 0x100003c70
                                    int32_t v84; // 0x100003c74
                                    int32_t v85; // 0x100003c9c
                                    int32_t v86; // 0x100003ca0
                                    int64_t v87; // 0x100003cb4
                                    int64_t v88; // 0x100003cb8
                                    int32_t v89; // 0x100003cbc
                                    int32_t v90; // 0x100003ccc
                                    int64_t v91; // 0x100003ce8
                                    if (v70 >= 0) {
                                        // 0x100003c3c
                                        v75 = *v7;
                                        v76 = v70 - v75;
                                        v71 = v70;
                                        if (v76 < 0 != ((v76 ^ v70) & (v75 ^ v70)) < 0) {
                                            // 0x100003c58
                                            v77 = *v35 - 1;
                                            *v37 = v77;
                                            v78 = *v35;
                                            v79 = v78 + 1;
                                            v80 = v77 - v79;
                                            v72 = v78;
                                            v73 = v77;
                                            if (v80 == 0 || v80 < 0 != ((v80 ^ v77) & (v79 ^ v77)) < 0) {
                                                v74 = v73;
                                                if (v74 >= 0) {
                                                    // 0x100003c98
                                                    v85 = *v10;
                                                    v86 = v74 - v85;
                                                    if (v86 < 0 != ((v86 ^ v74) & (v85 ^ v74)) < 0) {
                                                        // 0x100003cb4
                                                        v87 = *v11;
                                                        v88 = *v12;
                                                        v89 = *v36;
                                                        v90 = *(int32_t *)(4 * (v88 * (int64_t)v89 + (int64_t)v74) + v87);
                                                        if (v90 == 2) {
                                                            // 0x100003ce4
                                                            v91 = *v13;
                                                            *(int32_t *)(4 * (v91 * (int64_t)*v34 + (int64_t)v72) + *v5) = 2;
                                                            v40 = *v34;
                                                            goto lab_0x100003d30;
                                                        }
                                                    }
                                                }
                                                // 0x100003d08
                                                v81 = v74 + 1;
                                                *v37 = v81;
                                                v82 = *v35;
                                                v83 = v82 + 1;
                                                v84 = v81 - v83;
                                                while (v84 == 0 || v84 < 0 != ((v84 ^ v81) & (v83 ^ v81)) < 0) {
                                                    // 0x100003c84
                                                    v74 = v81;
                                                    if (v74 >= 0) {
                                                        // 0x100003c98
                                                        v85 = *v10;
                                                        v86 = v74 - v85;
                                                        if (v86 < 0 != ((v86 ^ v74) & (v85 ^ v74)) < 0) {
                                                            // 0x100003cb4
                                                            v87 = *v11;
                                                            v88 = *v12;
                                                            v89 = *v36;
                                                            v90 = *(int32_t *)(4 * (v88 * (int64_t)v89 + (int64_t)v74) + v87);
                                                            if (v90 == 2) {
                                                                // 0x100003ce4
                                                                v91 = *v13;
                                                                *(int32_t *)(4 * (v91 * (int64_t)*v34 + (int64_t)v82) + *v5) = 2;
                                                                v40 = *v34;
                                                                goto lab_0x100003d30;
                                                            }
                                                        }
                                                    }
                                                    // 0x100003d08
                                                    v81 = v74 + 1;
                                                    *v37 = v81;
                                                    v82 = *v35;
                                                    v83 = v82 + 1;
                                                    v84 = v81 - v83;
                                                }
                                            }
                                            // 0x100003d1c
                                            v71 = *v36;
                                        }
                                    }
                                    int32_t v92 = v71 + 1; // 0x100003d20
                                    *v36 = v92;
                                    int32_t v93 = *v34; // 0x100003c10
                                    int32_t v94 = v93 + 1; // 0x100003c14
                                    int32_t v95 = v92 - v94; // 0x100003c18
                                    v40 = v93;
                                    while (v95 == 0 || v95 < 0 != ((v95 ^ v92) & (v94 ^ v92)) < 0) {
                                        // 0x100003c28
                                        v70 = v92;
                                        v71 = v70;
                                        if (v70 >= 0) {
                                            // 0x100003c3c
                                            v75 = *v7;
                                            v76 = v70 - v75;
                                            v71 = v70;
                                            if (v76 < 0 != ((v76 ^ v70) & (v75 ^ v70)) < 0) {
                                                // 0x100003c58
                                                v77 = *v35 - 1;
                                                *v37 = v77;
                                                v78 = *v35;
                                                v79 = v78 + 1;
                                                v80 = v77 - v79;
                                                v72 = v78;
                                                v73 = v77;
                                                if (v80 == 0 || v80 < 0 != ((v80 ^ v77) & (v79 ^ v77)) < 0) {
                                                    v74 = v73;
                                                    if (v74 >= 0) {
                                                        // 0x100003c98
                                                        v85 = *v10;
                                                        v86 = v74 - v85;
                                                        if (v86 < 0 != ((v86 ^ v74) & (v85 ^ v74)) < 0) {
                                                            // 0x100003cb4
                                                            v87 = *v11;
                                                            v88 = *v12;
                                                            v89 = *v36;
                                                            v90 = *(int32_t *)(4 * (v88 * (int64_t)v89 + (int64_t)v74) + v87);
                                                            if (v90 == 2) {
                                                                // 0x100003ce4
                                                                v91 = *v13;
                                                                *(int32_t *)(4 * (v91 * (int64_t)*v34 + (int64_t)v72) + *v5) = 2;
                                                                v40 = *v34;
                                                                goto lab_0x100003d30;
                                                            }
                                                        }
                                                    }
                                                    // 0x100003d08
                                                    v81 = v74 + 1;
                                                    *v37 = v81;
                                                    v82 = *v35;
                                                    v83 = v82 + 1;
                                                    v84 = v81 - v83;
                                                    while (v84 == 0 || v84 < 0 != ((v84 ^ v81) & (v83 ^ v81)) < 0) {
                                                        // 0x100003c84
                                                        v74 = v81;
                                                        if (v74 >= 0) {
                                                            // 0x100003c98
                                                            v85 = *v10;
                                                            v86 = v74 - v85;
                                                            if (v86 < 0 != ((v86 ^ v74) & (v85 ^ v74)) < 0) {
                                                                // 0x100003cb4
                                                                v87 = *v11;
                                                                v88 = *v12;
                                                                v89 = *v36;
                                                                v90 = *(int32_t *)(4 * (v88 * (int64_t)v89 + (int64_t)v74) + v87);
                                                                if (v90 == 2) {
                                                                    // 0x100003ce4
                                                                    v91 = *v13;
                                                                    *(int32_t *)(4 * (v91 * (int64_t)*v34 + (int64_t)v82) + *v5) = 2;
                                                                    v40 = *v34;
                                                                    goto lab_0x100003d30;
                                                                }
                                                            }
                                                        }
                                                        // 0x100003d08
                                                        v81 = v74 + 1;
                                                        *v37 = v81;
                                                        v82 = *v35;
                                                        v83 = v82 + 1;
                                                        v84 = v81 - v83;
                                                    }
                                                }
                                                // 0x100003d1c
                                                v71 = *v36;
                                            }
                                        }
                                        // 0x100003d1c
                                        v92 = v71 + 1;
                                        *v36 = v92;
                                        v93 = *v34;
                                        v94 = v93 + 1;
                                        v95 = v92 - v94;
                                        v40 = v93;
                                    }
                                }
                                goto lab_0x100003d30;
                            }
                        }
                    }
                }
              lab_0x100003dc8:;
                int32_t v96 = *v34 + 1; // 0x100003dcc
                *v34 = v96;
                int32_t v97 = *v7; // 0x100003b0c
                int32_t v98 = v96 - v97; // 0x100003b10
                if (v98 < 0 == ((v98 ^ v96) & (v97 ^ v96)) < 0) {
                    // break -> 0x100003dd8
                    break;
                }
            }
        }
        // 0x100003dd8
        *v38 = 0;
        int32_t v99 = *v7; // 0x100003de4
        int32_t v100 = -v99; // 0x100003de8
        if (v100 < 0 != (v99 & v100) < 0) {
            *v39 = 0;
            int32_t v101 = *v10; // 0x100003e04
            int32_t v102 = -v101; // 0x100003e08
            int32_t v103; // 0x100003e04
            int32_t v104; // 0x100003e08
            int64_t v105; // 0x100003e28
            int64_t v106; // 0x100003e38
            int32_t v107; // 0x100003e38
            int32_t v108; // 0x100003e58
            if (v102 < 0 != (v101 & v102) < 0) {
                v105 = (int64_t)*v38;
                v106 = 0;
                v107 = *(int32_t *)(*v5 + v106 + 4 * *v13 * v105);
                *(int32_t *)(v106 + *v11 + 4 * *v12 * v105) = v107;
                v108 = *v39 + 1;
                *v39 = v108;
                v103 = *v10;
                v104 = v108 - v103;
                while (v104 < 0 != ((v104 ^ v108) & (v103 ^ v108)) < 0) {
                    // 0x100003e18
                    v105 = (int64_t)*v38;
                    v106 = 4 * (int64_t)v108;
                    v107 = *(int32_t *)(*v5 + v106 + 4 * *v13 * v105);
                    *(int32_t *)(v106 + *v11 + 4 * *v12 * v105) = v107;
                    v108 = *v39 + 1;
                    *v39 = v108;
                    v103 = *v10;
                    v104 = v108 - v103;
                }
            }
            int32_t v109 = *v38 + 1; // 0x100003e6c
            *v38 = v109;
            int32_t v110 = *v7; // 0x100003de4
            while (v109 - v110 < 0 != ((v109 - v110 ^ v109) & (v110 ^ v109)) < 0) {
                // 0x100003df8
                *v39 = 0;
                v101 = *v10;
                v102 = -v101;
                if (v102 < 0 != (v101 & v102) < 0) {
                    v105 = (int64_t)*v38;
                    v106 = 0;
                    v107 = *(int32_t *)(*v5 + v106 + 4 * *v13 * v105);
                    *(int32_t *)(v106 + *v11 + 4 * *v12 * v105) = v107;
                    v108 = *v39 + 1;
                    *v39 = v108;
                    v103 = *v10;
                    v104 = v108 - v103;
                    while (v104 < 0 != ((v104 ^ v108) & (v103 ^ v108)) < 0) {
                        // 0x100003e18
                        v105 = (int64_t)*v38;
                        v106 = 4 * (int64_t)v108;
                        v107 = *(int32_t *)(*v5 + v106 + 4 * *v13 * v105);
                        *(int32_t *)(v106 + *v11 + 4 * *v12 * v105) = v107;
                        v108 = *v39 + 1;
                        *v39 = v108;
                        v103 = *v10;
                        v104 = v108 - v103;
                    }
                }
                // 0x100003e68
                v109 = *v38 + 1;
                *v38 = v109;
                v110 = *v7;
            }
        }
    }
  lab_0x100003d30:;
    int64_t v111 = *v5; // 0x100003d30
    int64_t v112 = *v13; // 0x100003d34
    int32_t v113 = *v35; // 0x100003d44
    int32_t v114 = *(int32_t *)(4 * (v112 * (int64_t)v40 + (int64_t)v113) + v111); // 0x100003d48
    if (v114 == 1) {
        // 0x100003d5c
        if (g1 * (float64_t)g5 < (float64_t)_rand()) {
            int64_t v115 = *v13; // 0x100003d8c
            *(int32_t *)(4 * (v115 * (int64_t)*v34 + (int64_t)*v35) + *v5) = 2;
        }
    }
    goto lab_0x100003db4;
  lab_0x100003db4:;
    int32_t v116 = *v35 + 1; // 0x100003db8
    *v35 = v116;
    int32_t v117 = *v10; // 0x100003b2c
    int32_t v118 = v116 - v117; // 0x100003b30
    v41 = v116;
    if (v118 < 0 == ((v118 ^ v116) & (v117 ^ v116)) < 0) {
        // break -> 0x100003dc8
        goto lab_0x100003dc8;
    }
    goto lab_0x100003b40;
}

// Address range: 0x100003e7c - 0x100003f48
int64_t entry_point(void) {
    // 0x100003e7c
    int64_t v1; // 0x100003e7c
    int32_t v2 = v1; // 0x100003e8c
    int32_t v3 = v2 - 1; // 0x100003ea0
    int32_t v4 = 0; // 0x100003ea8
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003eb0
        v4 = _atoi((char *)*(int64_t *)(v1 + 8));
    }
    int32_t v5 = v4;
    int32_t v6 = v2 - 2; // 0x100003ec8
    int32_t v7; // 0x100003e7c
    if (v6 == 0 || v6 < 0 != (1 - v2 & v2) < 0) {
        // 0x100003eec
        v7 = v5 < 1 ? 30 : v5;
    } else {
        int32_t v8 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003ee0
        int32_t v9 = v5 < 1 ? 30 : v5;
        v7 = v9;
        if (v8 >= 1) {
            function_10000388c(v9, v8);
            return 0;
        }
    }
    function_10000388c(v7, 30);
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * nptr) {
    // 0x100003f48
    return _atoi(nptr);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(struct _IO_FILE * stream) {
    // 0x100003f54
    return _fflush(stream);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(void) {
    // 0x100003f6c
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <ctype.h>
#include <string.h>

int sedol_weights[] = {1, 3, 1, 7, 3, 9};
const char *reject = "AEIOUaeiou";

int sedol_checksum(const char *sedol6)
{
  int len = strlen(sedol6);
  int sum = 0, i;

  if ( len == 7 ) {
    fprintf(stderr, "SEDOL code already checksummed? (%s)\n", sedol6);
    return sedol6[6] & 0x7f;
  }
  if ( (len > 7) || (len < 6) || ( strcspn(sedol6, reject) != 6 )) {
    fprintf(stderr, "not a SEDOL code? (%s)\n", sedol6);
    return -1;
  }
  for(i=0; i < 6; i++) {
    if ( isdigit(sedol6[i]) ) {
      sum += (sedol6[i]-'0')*sedol_weights[i];
    } else if ( isalpha(sedol6[i]) ) {
      sum += ((toupper(sedol6[i])-'A') + 10)*sedol_weights[i];
    } else {
      fprintf(stderr, "SEDOL with not alphanumeric digit\n");
      return -1;
    }
  }
  return (10 - (sum%10))%10 + '0';
}


#define MAXLINELEN 10
int main()
{
  char line[MAXLINELEN];
  int sr, len;
  while( fgets(line, MAXLINELEN, stdin) != NULL ) {
    len = strlen(line);
    if ( line[len-1] == '\n' ) line[len-1]='\0';
    sr = sedol_checksum(line);
    if ( sr > 0 )
      printf("%s%c\n", line, sr);
  }
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b80(void);
int64_t function_100003ec8(void);
char * function_100003ed4(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003ee0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003eec(int32_t c);
int32_t function_100003ef8(int32_t c);
int32_t function_100003f04(char * format, ...);
int32_t function_100003f10(char * s, char * reject);
int32_t function_100003f1c(char * s);
int32_t function_100003f28(int32_t c);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x300000001; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _isalpha(int32_t a1);
int32_t _isdigit(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strcspn(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b80 - 0x100003db0
int64_t function_100003b80(void) {
    // 0x100003b80
    int64_t v1; // 0x100003b80
    char * v2 = (char *)v1; // 0x100003b8c
    int32_t v3 = _strlen(v2); // 0x100003b94
    if (v3 == 7) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003bc0
        _fprintf((struct _IO_FILE *)v4, "SEDOL code already checksummed? (%s)\n", (char *)v1);
        // 0x100003da0
        return (int32_t)(*(char *)(v1 + 6) % 128);
    }
    int32_t v5 = v3 - 7; // 0x100003bf4
    if (v5 == 0 || v5 < 0 != (6 - v3 & v3) < 0) {
        if (v3 < 6 == (5 - v3 & v3) < 0) {
            int64_t v6 = 0; // 0x100003c30
            int32_t v7 = 0; // 0x100003c30
            int32_t v8 = 0; // 0x100003c30
            if (_strcspn(v2, (char *)0x3f34) == 6) {
                int32_t result; // 0x100003b80
                while (true) {
                    int32_t v9 = v7;
                    uint64_t v10 = v6;
                    char * c = (char *)(v10 + v1); // 0x100003c8c
                    int32_t v11 = _isdigit((int32_t)*c); // 0x100003c90
                    int32_t v12 = (int32_t)*c;
                    int32_t v13; // 0x100003b80
                    if (v11 == 0) {
                        // 0x100003cd8
                        if (_isalpha(v12) == 0) {
                            // break -> 0x100003d34
                            break;
                        }
                        int32_t v14 = _toupper((int32_t)*c); // 0x100003d04
                        int32_t v15 = *(int32_t *)(4 * v10 + (int64_t)&g1); // 0x100003d1c
                        v13 = (v14 - 55) * v15;
                    } else {
                        int32_t v16 = *(int32_t *)(4 * v10 + (int64_t)&g1); // 0x100003cc0
                        v13 = v16 * (v12 - 48);
                    }
                    int32_t v17 = v13 + v8;
                    int64_t v18 = v10 + 1;
                    v6 = v18;
                    v7 = v9 + 1;
                    v8 = v17;
                    if (v10 < 5 == (4 - v9 & (int32_t)v18) < 0) {
                        // 0x100003d70
                        result = (10 - v17 % 10) % 10 + 48;
                        return result;
                    }
                }
                int64_t v19 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d3c
                _fprintf((struct _IO_FILE *)v19, "SEDOL with not alphanumeric digit\n");
                result = -1;
              lab_0x100003da0:
                // 0x100003da0
                return result;
            }
        }
    }
    int64_t v20 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c40
    _fprintf((struct _IO_FILE *)v20, "not a SEDOL code? (%s)\n", (char *)v1);
    // 0x100003da0
    return -1;
}

// Address range: 0x100003db0 - 0x100003ec8
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003ddc
    int64_t v2; // bp-34, 0x100003db0
    if (_fgets((char *)&v2, 10, (struct _IO_FILE *)v1) != NULL) {
        int64_t v3 = &v2; // 0x100003e00
        int32_t v4 = _strlen((char *)&v2) - 1; // 0x100003e18
        if (*(char *)((int64_t)v4 + v3) == 10) {
            // 0x100003e30
            *(char *)((int64_t)v4 + v3) = 0;
        }
        // 0x100003e48
        if ((int32_t)function_100003b80() >= 1) {
            // 0x100003e68
            _printf("%s%c\n", (char *)10, (char)v1);
        }
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003ddc
        while (_fgets((char *)&v2, 10, (struct _IO_FILE *)v5) != NULL) {
            int64_t v6 = v5;
            v4 = _strlen((char *)&v2) - 1;
            if (*(char *)((int64_t)v4 + v3) == 10) {
                // 0x100003e30
                *(char *)((int64_t)v4 + v3) = 0;
            }
            // 0x100003e48
            if ((int32_t)function_100003b80() >= 1) {
                // 0x100003e68
                _printf("%s%c\n", (char *)10, (char)v6);
            }
            // 0x100003e90
            v5 = *(int64_t *)*(int64_t *)0x100004018;
        }
    }
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ea0
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003eb4
        ___stack_chk_fail();
    }
    // 0x100003eb8
    return 0;
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(void) {
    // 0x100003ec8
    return ___stack_chk_fail();
}

// Address range: 0x100003ed4 - 0x100003ee0
char * function_100003ed4(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ed4
    return _fgets(s, n, stream);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ee0
    return _fprintf(stream, format);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(int32_t c) {
    // 0x100003eec
    return _isalpha(c);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(int32_t c) {
    // 0x100003ef8
    return _isdigit(c);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(char * format, ...) {
    // 0x100003f04
    return _printf(format);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * s, char * reject) {
    // 0x100003f10
    return _strcspn(s, reject);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * s) {
    // 0x100003f1c
    return _strlen(s);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(int32_t c) {
    // 0x100003f28
    return _toupper(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#define MAX_BUF 50

int main(void)
{
  char buf[MAX_BUF];
  time_t seconds = time(NULL);
  struct tm *now = localtime(&seconds);
  const char *months[] = {"January", "February", "March", "April", "May", "June",
                          "July", "August", "September", "October", "November", "December"};

  const char *days[] = {"Sunday", "Monday", "Tuesday", "Wednesday","Thursday","Friday","Saturday"};

  (void) printf("%d-%d-%d\n", now->tm_year + 1900, now->tm_mon + 1, now->tm_mday);
  (void) printf("%s, %s %d, %d\n",days[now->tm_wday], months[now->tm_mon],
               now->tm_mday, now->tm_year + 1900);
  /* using the strftime (the result depends on the locale) */
  (void) strftime(buf, MAX_BUF, "%A, %B %e, %Y", now);
  (void) printf("%s\n", buf);
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ea4(int64_t a1);
struct tm * function_100003eb0(int32_t * timer);
int64_t * function_100003ebc(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ec8(char * format, ...);
int32_t function_100003ed4(char * s, int32_t maxsize, char * format, struct tm * tp);
int32_t function_100003ee0(int32_t * timer);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003eec; // 0x100004038

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
struct tm * _localtime(int32_t * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strftime(char * a1, int32_t a2, char * a3, struct tm * a4);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d24 - 0x100003ea4
int64_t entry_point(void) {
    int64_t v1 = _time(NULL); // bp-264, 0x100003d58
    struct tm * v2 = _localtime((int32_t *)&v1); // 0x100003d5c
    int64_t v3; // bp-192, 0x100003d24
    _memcpy(&v3, &g1, 96);
    int64_t v4; // bp-248, 0x100003d24
    _memcpy(&v4, (int64_t *)"B?", 56);
    int64_t v5; // 0x100003d24
    _printf("%d-%d-%d\n", (int64_t)"B?", 56, v5);
    _printf("%s, %s %d, %d\n", "B?", (char *)56, v5, v5);
    int64_t v6; // bp-90, 0x100003d24
    _strftime((char *)&v6, 50, "%A, %B %e, %Y", v2);
    int32_t v7 = _printf("%s\n", (char *)50); // 0x100003e68
    int64_t v8 = *(int64_t *)0x100004008; // 0x100003e74
    if (*(int64_t *)v8 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e8c
        ___stack_chk_fail((int64_t)v7);
    }
    // 0x100003e90
    return 0;
}

// Address range: 0x100003ea4 - 0x100003eb0
int64_t function_100003ea4(int64_t a1) {
    // 0x100003ea4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003eb0 - 0x100003ebc
struct tm * function_100003eb0(int32_t * timer) {
    // 0x100003eb0
    return _localtime(timer);
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t * function_100003ebc(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ebc
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(char * format, ...) {
    // 0x100003ec8
    return _printf(format);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(char * s, int32_t maxsize, char * format, struct tm * tp) {
    // 0x100003ed4
    return _strftime(s, maxsize, format, tp);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(int32_t * timer) {
    // 0x100003ee0
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>

void clear() {
	for(int n = 0;n < 10; n++) {
		printf("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\r\n\r\n\r\n");
	}
}

#define UP    "00^00\r\n00|00\r\n00000\r\n"
#define DOWN  "00000\r\n00|00\r\n00v00\r\n"
#define LEFT  "00000\r\n<--00\r\n00000\r\n"
#define RIGHT "00000\r\n00-->\r\n00000\r\n"
#define HOME  "00000\r\n00+00\r\n00000\r\n"

int main() {
	clear();
	system("stty raw");

	printf(HOME);
	printf("space to exit; wasd to move\r\n");
	char c = 1;

	while(c) {
		c = getc(stdin);
		clear();

		switch (c)
		{
			case 'a':
				printf(LEFT);
				break;
			case 'd':
				printf(RIGHT);
				break;
			case 'w':
				printf(UP);
				break;
			case 's':
				printf(DOWN);
				break;
			case ' ':
				c = 0;
				break;
			default:
				printf(HOME);
		};

		printf("space to exit; wasd key to move\r\n");
	}

	system("stty cooked");
	system("clear");
	return 1;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ce8(void);
int32_t function_100003ea4(struct _IO_FILE * stream);
int32_t function_100003eb0(char * format, ...);
int32_t function_100003ebc(char * command);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getc(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);
int32_t _system(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ce8 - 0x100003d3c
int64_t function_100003ce8(void) {
    int32_t result; // 0x100003d18
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003d10
        result = _printf("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\r\n\r\n\r\n");
    }
    // 0x100003d30
    return result;
}

// Address range: 0x100003d3c - 0x100003ea4
int64_t entry_point(void) {
    // 0x100003d3c
    function_100003ce8();
    _system("stty raw");
    _printf("00000\r\n00+00\r\n00000\r\n");
    _printf("space to exit; wasd to move\r\n");
    while (true) {
        int32_t v1 = 0x1000000 * _getc((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
        function_100003ce8();
        int32_t v2; // 0x100003d3c
        switch (v1) {
            case 0x20000000: {
                // 0x100003e6c
                _printf("space to exit; wasd key to move\r\n");
                // 0x100003e7c
                _system("stty cooked");
                _system("clear");
                return 1;
            }
            case 0x61000000: {
                // 0x100003e14
                _printf("00000\r\n<--00\r\n00000\r\n");
                v2 = 97;
                // break -> 0x100003e6c
                break;
            }
            case 0x64000000: {
                // 0x100003e24
                _printf("00000\r\n00-->\r\n00000\r\n");
                v2 = 100;
                // break -> 0x100003e6c
                break;
            }
            case 0x73000000: {
                // 0x100003e44
                _printf("00000\r\n00|00\r\n00v00\r\n");
                v2 = 115;
                // break -> 0x100003e6c
                break;
            }
            case 0x77000000: {
                // 0x100003e34
                _printf("00^00\r\n00|00\r\n00000\r\n");
                v2 = 119;
                // break -> 0x100003e6c
                break;
            }
            default: {
                // 0x100003e5c
                _printf("00000\r\n00+00\r\n00000\r\n");
                v2 = v1 >> 24;
                // break -> 0x100003e6c
                break;
            }
        }
        // 0x100003e6c
        _printf("space to exit; wasd key to move\r\n");
        if (v2 % 256 == 0) {
            // 0x100003e7c
            _system("stty cooked");
            _system("clear");
            return 1;
        }
    }
    // 0x100003e6c
    _printf("space to exit; wasd key to move\r\n");
    // 0x100003e7c
    _system("stty cooked");
    _system("clear");
    return 1;
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(struct _IO_FILE * stream) {
    // 0x100003ea4
    return _getc(stream);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * format, ...) {
    // 0x100003eb0
    return _printf(format);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * command) {
    // 0x100003ebc
    return _system(command);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

typedef uint32_t integer;

integer next_prime_digit_number(integer n) {
    if (n == 0)
        return 2;
    switch (n % 10) {
    case 2:
        return n + 1;
    case 3:
    case 5:
        return n + 2;
    default:
        return 2 + next_prime_digit_number(n/10) * 10;
    }
}

bool is_prime(integer n) {
    if (n < 2)
        return false;
    if (n % 2 == 0)
        return n == 2;
    if (n % 3 == 0)
        return n == 3;
    if (n % 5 == 0)
        return n == 5;
    static const integer wheel[] = { 4,2,4,2,4,6,2,6 };
    integer p = 7;
    for (;;) {
        for (int i = 0; i < 8; ++i) {
            if (p * p > n)
                return true;
            if (n % p == 0)
                return false;
            p += wheel[i];
        }
    }
}

int main() {
    setlocale(LC_ALL, "");
    const integer limit = 1000000000;
    integer n = 0, max = 0;
    printf("First 25 SPDS primes:\n");
    for (int i = 0; n < limit; ) {
        n = next_prime_digit_number(n);
        if (!is_prime(n))
            continue;
        if (i < 25) {
            if (i > 0)
                printf(" ");
            printf("%'u", n);
        }
        else if (i == 25)
            printf("\n");
        ++i;
        if (i == 100)
            printf("Hundredth SPDS prime: %'u\n", n);
        else if (i == 1000)
            printf("Thousandth SPDS prime: %'u\n", n);
        else if (i == 10000)
            printf("Ten thousandth SPDS prime: %'u\n", n);
        max = n;
    }
    printf("Largest SPDS prime less than %'u: %'u\n", limit, max);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a28(void);
int64_t function_100003b00(void);
int32_t function_100003ec8(char * format, ...);
char * function_100003ed4(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x200000004; // 0x100003ee0
char * g2; // 0x100003f00

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a28 - 0x100003b00
int64_t function_100003a28(void) {
    // 0x100003a28
    int64_t v1; // 0x100003a28
    uint32_t v2 = (int32_t)v1; // 0x100003a34
    if (v2 == 0) {
        // 0x100003af0
        return 2;
    }
    int64_t v3; // 0x100003a28
    switch (v2 % 10) {
        case 2: {
            // 0x100003aa8
            v3 = v1 + 1;
            // break -> 0x100003af0
            break;
        }
        case 5: {
        }
        case 3: {
            // 0x100003ab8
            v3 = v1 + 2;
            // break -> 0x100003af0
            break;
        }
        default: {
            // 0x100003ac8
            v3 = 10 * function_100003a28() + 2;
            // break -> 0x100003af0
            break;
        }
    }
    // 0x100003af0
    return v3 & 0xffffffff;
}

// Address range: 0x100003b00 - 0x100003cc8
int64_t function_100003b00(void) {
    // 0x100003b00
    int64_t v1; // 0x100003b00
    uint32_t v2 = (int32_t)v1; // 0x100003b04
    if (v2 < 2) {
        // 0x100003cb8
        return false;
    }
    if (2 * v2 / 2 == v2) {
        // 0x100003cb8
        return v2 == 2;
    }
    if (v2 % 3 == 0) {
        // 0x100003cb8
        return v2 == 3;
    }
    int32_t v3 = 7; // 0x100003bcc
    bool result; // 0x100003b00
    if (v2 % 5 == 0) {
        // 0x100003bd4
        result = v2 == 5;
        // 0x100003cb8
        return result;
    }
    while (true) {
      lab_0x100003bfc:;
        int64_t v4 = 0;
        int32_t v5 = 0; // 0x100003b00
        int32_t v6 = v3; // 0x100003c98
        while (true) {
          lab_0x100003c18:;
            uint32_t v7 = v6;
            uint32_t v8 = v7 * v7; // 0x100003c20
            result = true;
            if (v8 != v2 && v8 >= v2) {
                return result;
            }
            // 0x100003c4c
            result = false;
            if (v2 % v7 == 0) {
                return result;
            }
            int32_t v9 = v5;
            uint64_t v10 = v4;
            int32_t v11 = *(int32_t *)(4 * v10 + (int64_t)&g1); // 0x100003c90
            v6 = v11 + v7;
            v4 = v10 + 1;
            v3 = v6;
            v5 = v9 + 1;
            if (v10 < 7 == (6 - v9 & (int32_t)v4) < 0) {
                goto lab_0x100003bfc;
            } else {
                goto lab_0x100003c18;
            }
        }
    }
}

// Address range: 0x100003cc8 - 0x100003ec8
int64_t entry_point(void) {
    // 0x100003cc8
    _setlocale(0, (char *)&g2);
    _printf("First 25 SPDS primes:\n");
    int32_t v1 = 0; // 0x100003d14
    int32_t v2 = 0; // 0x100003d14
    int32_t v3; // 0x100003cc8
    while (true) {
      lab_0x100003d18:
        // 0x100003d18
        v3 = v2;
        if (v1 >= 0x3b9aca00) {
            // break (via goto) -> 0x100003e90
            goto lab_0x100003e90;
        }
        // 0x100003d30
        v1 = function_100003a28();
        int32_t v4 = v1; // 0x100003d44
        while (function_100003b00() % 2 == 0) {
            // 0x100003d18
            if (v4 >= 0x3b9aca00) {
                // break (via goto) -> 0x100003e90
                goto lab_0x100003e90;
            }
            // 0x100003d30
            v1 = function_100003a28();
            v4 = v1;
        }
        if (v3 < 25 == (24 - v3 & v3) < 0) {
            switch (v3) {
                case 25: {
                    // 0x100003e10
                    _printf("\n");
                    v2 = 26;
                    goto lab_0x100003d18;
                }
                case 99: {
                    // 0x100003df0
                    _printf("Hundredth SPDS prime: %'u\n", (int32_t)&g2);
                    v2 = 100;
                    goto lab_0x100003d18;
                }
                default: {
                    goto lab_0x100003e10_2;
                }
            }
        } else {
            if (v3 < 1) {
                // 0x100003d88
                _printf("%'u", (int32_t)&g2);
                goto lab_0x100003e10_2;
            } else {
                // 0x100003d88
                _printf(" ");
                _printf("%'u", (int32_t)&g2);
                if (v3 == 99) {
                    // 0x100003df0
                    _printf("Hundredth SPDS prime: %'u\n", (int32_t)&g2);
                    v2 = 100;
                    goto lab_0x100003d18;
                } else {
                    goto lab_0x100003e10_2;
                }
            }
        }
    }
  lab_0x100003e90:;
    // 0x100003e90
    int64_t v5; // 0x100003cc8
    _printf("Largest SPDS prime less than %'u: %'u\n", (int32_t)&g2, (int32_t)v5);
    return 0;
  lab_0x100003e10_2:
    // 0x100003e10
    v2 = v3 + 1;
    switch (v3) {
        case 999: {
            // 0x100003e24
            _printf("Thousandth SPDS prime: %'u\n", (int32_t)&g2);
            v2 = 1000;
            // break -> 0x100003e84
            break;
        }
        case 0x270f: {
            // 0x100003e5c
            _printf("Ten thousandth SPDS prime: %'u\n", (int32_t)&g2);
            v2 = 0x2710;
            // break -> 0x100003e84
            break;
        }
    }
    goto lab_0x100003d18;
  lab_0x100003e84:
    // 0x100003e84
    goto lab_0x100003d18;
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(char * format, ...) {
    // 0x100003ec8
    return _printf(format);
}

// Address range: 0x100003ed4 - 0x100003ee0
char * function_100003ed4(int32_t category, char * locale) {
    // 0x100003ed4
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <time.h>
#include <stdio.h>

int main() {
    time_t t = 0;
    printf("%s", asctime(gmtime(&t)));
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
char * function_100003f80(struct tm * tp);
struct tm * function_100003f8c(int32_t * timer);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

char * _asctime(struct tm * a1);
struct tm * _gmtime(int32_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f34 - 0x100003f80
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-32, 0x100003f50
    _asctime(_gmtime((int32_t *)&v1));
    int64_t v2; // 0x100003f34
    _printf("%s", (char *)v2);
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
char * function_100003f80(struct tm * tp) {
    // 0x100003f80
    return _asctime(tp);
}

// Address range: 0x100003f8c - 0x100003f98
struct tm * function_100003f8c(int32_t * timer) {
    // 0x100003f8c
    return _gmtime(timer);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct {
    uint16_t year;
    uint8_t month;
    uint8_t day;
} Date;

bool leap(uint16_t year) {
    return year%4==0 && (year%100!=0 || year%400==0);
}

const char *weekday(Date date) {
    static const uint8_t leapdoom[] = {4,1,7,4,2,6,4,1,5,3,7,5};
    static const uint8_t normdoom[] = {3,7,7,4,2,6,4,1,5,3,7,5};
    static const char *days[] = {
        "Sunday", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday"
    };

    unsigned c = date.year/100, r = date.year%100;
    unsigned s = r/12, t = r%12;

    unsigned c_anchor = (5 * (c%4) + 2) % 7;
    unsigned doom = (s + t + (t/4) + c_anchor) % 7;
    unsigned anchor = (leap(date.year) ? leapdoom : normdoom)[date.month-1];
    return days[(doom+date.day-anchor+7)%7];
}

int main(void) {
    const char *past = "was", *future = "will be";
    const char *months[] = { "",
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    };

    const Date dates[] = {
        {1800,1,6}, {1875,3,29}, {1915,12,7}, {1970,12,23}, {2043,5,14},
        {2077,2,12}, {2101,4,2}
    };

    int i;
    for (i=0; i < sizeof(dates)/sizeof(Date); i++) {
        printf("%s %d, %d %s on a %s.\n",
            months[dates[i].month], dates[i].day, dates[i].year,
            dates[i].year > 2021 ? future : past,
            weekday(dates[i]));
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b04(void);
int64_t function_100003ba4(int32_t a1);
int64_t function_100003e8c(int64_t a1);
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ea4(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x104060204070104; // 0x100003eb0
int64_t g2 = 0x104060204070703; // 0x100003ebc
float128_t g3 = 6.30259672903973202393650155816711604e-169L; // 0x100003ec8
int64_t g4 = 0x10000000003ee4; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b04 - 0x100003ba4
int64_t function_100003b04(void) {
    // 0x100003b04
    int64_t v1; // 0x100003b04
    uint16_t v2 = (int16_t)v1;
    if (4 * v2 / 4 != v2) {
        // 0x100003b94
        return 0;
    }
    int64_t result = 1; // 0x100003b5c
    if (v2 % 100 == 0) {
        // 0x100003b64
        result = v2 % 400 == 0;
    }
    // 0x100003b94
    return result;
}

// Address range: 0x100003ba4 - 0x100003ce0
int64_t function_100003ba4(int32_t a1) {
    uint16_t v1 = (int16_t)a1;
    uint16_t v2 = v1 % 100;
    uint16_t v3 = v2 % 12;
    uint64_t v4 = function_100003b04(); // 0x100003c70
    int64_t v5 = v4 % 2 == 0 ? (int64_t)&g2 : (int64_t)&g1; // 0x100003c90
    int32_t v6; // 0x100003ba4
    unsigned char v7 = *(char *)(v5 + (int64_t)(v6 % 256 - 1)); // 0x100003c9c
    int64_t result = *(int64_t *)((int64_t)(8 * ((((5 * ((int32_t)(v1 / 100) - (int32_t)(4 * v1 / 400)) + 2) % 7 + (int32_t)(v2 / 12 + v3 + v3 / 4)) % 7 + 7 + (uint32_t)v6 % 256 - (int32_t)v7) % 7)) + (int64_t)&g4); // 0x100003cd0
    return result;
}

// Address range: 0x100003ce0 - 0x100003e8c
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cf8
    int64_t v2; // bp-144, 0x100003ce0
    _memcpy(&v2, (int64_t *)")?", 104);
    int64_t v3 = (float64_t)g3; // bp-176, 0x100003d40
    int32_t v4; // 0x100003e3c
    for (int64_t i = 0; i < 7; i++) {
        // 0x100003d68
        function_100003ba4(*(int32_t *)(4 * i + (int64_t)&v3));
        int64_t v5; // 0x100003ce0
        v4 = _printf("%s %d, %d %s on a %s.\n", ")?", 104, v5, (char *)v5, (char *)v5);
    }
    // 0x100003e54
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e74
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003e78
    return 0;
}

// Address range: 0x100003e8c - 0x100003e98
int64_t function_100003e8c(int64_t a1) {
    // 0x100003e8c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e98
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <string.h>

int match(const char *s, const char *p, int overlap)
{
        int c = 0, l = strlen(p);

        while (*s != '\0') {
                if (strncmp(s++, p, l)) continue;
                if (!overlap) s += l - 1;
                c++;
        }
        return c;
}

int main()
{
        printf("%d\n", match("the three truths", "th", 0));
        printf("overlap:%d\n", match("abababababa", "aba", 1));
        printf("not:    %d\n", match("abababababa", "aba", 0));
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dcc(void);
int32_t function_100003f44(char * format, ...);
int32_t function_100003f50(char * s);
int32_t function_100003f5c(char * s1, char * s2, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003dcc - 0x100003e90
int64_t function_100003dcc(void) {
    // 0x100003dcc
    int64_t v1; // 0x100003dcc
    char * v2 = (char *)v1; // 0x100003ddc
    int32_t v3 = _strlen(v2); // 0x100003dec
    while (true) {
        // 0x100003dfc
        int64_t v4; // 0x100003dcc
        int64_t v5 = v4; // 0x100003dcc
        char * v6 = (char *)v5;
        while (*v6 != 0) {
            // 0x100003e14
            v5++;
            if (_strncmp(v6, v2, v3) == 0) {
                // break -> 0x100003e44
                break;
            }
            v6 = (char *)v5;
        }
        return 0;
    }
    // 0x100003e80
    uint32_t result; // 0x100003dcc
    return result;
}

// Address range: 0x100003e90 - 0x100003f44
int64_t entry_point(void) {
    // 0x100003e90
    function_100003dcc();
    _printf("%d\n", (int64_t)"th");
    function_100003dcc();
    _printf("overlap:%d\n", (int64_t)"aba");
    function_100003dcc();
    _printf("not:    %d\n", (int64_t)"aba");
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * s) {
    // 0x100003f50
    return _strlen(s);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * s1, char * s2, int32_t n) {
    // 0x100003f5c
    return _strncmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`/*
The function anynacci determines the n-arity of the sequence from the number of seed elements. 0 ended arrays are used since C does not have a way of determining the length of dynamic and function-passed integer arrays.*/

#include<stdlib.h>
#include<stdio.h>

int *
anynacci (int *seedArray, int howMany)
{
  int *result = malloc (howMany * sizeof (int));
  int i, j, initialCardinality;

  for (i = 0; seedArray[i] != 0; i++);
  initialCardinality = i;

  for (i = 0; i < initialCardinality; i++)
    result[i] = seedArray[i];

  for (i = initialCardinality; i < howMany; i++)
    {
      result[i] = 0;
      for (j = i - initialCardinality; j < i; j++)
        result[i] += result[j];
    }
  return result;
}

int
main ()
{
  int fibo[] = { 1, 1, 0 }, tribo[] = { 1, 1, 2, 0 }, tetra[] = { 1, 1, 2, 4, 0 }, luca[] = { 2, 1, 0 };
  int *fibonacci = anynacci (fibo, 10), *tribonacci = anynacci (tribo, 10), *tetranacci = anynacci (tetra, 10),
      *lucas = anynacci(luca, 10);
  int i;

  printf ("\nFibonacci\tTribonacci\tTetranacci\tLucas\n");

  for (i = 0; i < 10; i++)
    printf ("\n%d\t\t%d\t\t%d\t\t%d", fibonacci[i], tribonacci[i],
            tetranacci[i], lucas[i]);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf4(void);
int64_t function_100003f10(int64_t a1);
int64_t * function_100003f1c(int32_t size);
int32_t function_100003f28(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf4 - 0x100003d60
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t v1; // 0x100003bf4
    int32_t v2 = v1; // 0x100003c04
    int64_t * v3 = _malloc(4 * v2); // 0x100003c10
    int32_t v4 = 0; // 0x100003c1c
    while (*(int32_t *)(4 * (int64_t)v4 + v1) != 0) {
        // 0x100003c20
        v4++;
    }
    int64_t result = (int64_t)v3; // 0x100003c10
    int32_t v5 = -v4;
    int32_t v6 = 0; // 0x100003c70
    if (v5 < 0 != (v4 & v5) < 0) {
        int64_t v7 = 4 * (int64_t)v6; // 0x100003c80
        *(int32_t *)(v7 + result) = *(int32_t *)(v7 + v1);
        v6++;
        while (v6 - v4 < 0 != ((v6 - v4 ^ v6) & (v6 ^ v4)) < 0) {
            // 0x100003c78
            v7 = 4 * (int64_t)v6;
            *(int32_t *)(v7 + result) = *(int32_t *)(v7 + v1);
            v6++;
        }
    }
    int32_t v8 = v4 - v2; // 0x100003cb8
    if (v8 < 0 == ((v8 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d50
        return result;
    }
    int32_t * v9 = (int32_t *)(4 * (int64_t)v4 + result); // 0x100003cd4
    *v9 = 0;
    int32_t v10 = 0; // 0x100003ce0
    int32_t v11 = v10; // 0x100003cfc
    int32_t v12; // 0x100003bf4
    int32_t v13; // 0x100003d20
    int32_t v14; // 0x100003d30
    int32_t v15; // 0x100003cf4
    if (v5 < 0 != ((v10 ^ v5) & (v10 ^ v4)) < 0) {
        v13 = *(int32_t *)(4 * (int64_t)v11 + result);
        *v9 = v13;
        v14 = v11 + 1;
        v15 = v14 - v4;
        v12 = v13;
        v11 = v14;
        while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v4)) < 0) {
            // 0x100003d04
            v13 = *(int32_t *)(4 * (int64_t)v11 + result) + v12;
            *v9 = v13;
            v14 = v11 + 1;
            v15 = v14 - v4;
            v12 = v13;
            v11 = v14;
        }
    }
    int32_t v16 = v4 + 1; // 0x100003d44
    while (v16 - v2 < 0 != ((v16 - v2 ^ v16) & (v16 ^ v2)) < 0) {
        int32_t v17 = v16;
        v9 = (int32_t *)(4 * (int64_t)v17 + result);
        *v9 = 0;
        v10 = v17 - v4;
        v11 = v10;
        if (v5 < 0 != ((v10 ^ v5) & (v10 ^ v17)) < 0) {
            v13 = *(int32_t *)(4 * (int64_t)v11 + result);
            *v9 = v13;
            v14 = v11 + 1;
            v15 = v14 - v17;
            v12 = v13;
            v11 = v14;
            while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v17)) < 0) {
                // 0x100003d04
                v13 = *(int32_t *)(4 * (int64_t)v11 + result) + v12;
                *v9 = v13;
                v14 = v11 + 1;
                v15 = v14 - v17;
                v12 = v13;
                v11 = v14;
            }
        }
        // 0x100003d40
        v16 = v17 + 1;
    }
    // 0x100003d50
    return result;
}

// Address range: 0x100003d60 - 0x100003f10
int64_t entry_point(void) {
    // 0x100003d60
    function_100003bf4();
    function_100003bf4();
    function_100003bf4();
    function_100003bf4();
    _printf("\nFibonacci\tTribonacci\tTetranacci\tLucas\n");
    int32_t v1; // 0x100003ec4
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e68
        int64_t v2; // 0x100003d60
        v1 = _printf("\n%d\t\t%d\t\t%d\t\t%d", 10, v2, v2, v2);
    }
    int64_t v3 = *(int64_t *)0x100004008; // 0x100003ee4
    if (*(int64_t *)v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003efc
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f00
    return 0;
}

// Address range: 0x100003f10 - 0x100003f1c
int64_t function_100003f10(int64_t a1) {
    // 0x100003f10
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t * function_100003f1c(int32_t size) {
    // 0x100003f1c
    return _malloc(size);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char* command_table =
  "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy "
  "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "
  "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "
  "Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "
  "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "
  "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "
  "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up";

typedef struct command_tag {
    char* cmd;
    size_t length;
    size_t min_len;
    struct command_tag* next;
} command_t;

// str is assumed to be all uppercase
bool command_match(const command_t* command, const char* str) {
    size_t olen = strlen(str);
    return olen >= command->min_len && olen <= command->length
        && strncmp(str, command->cmd, olen) == 0;
}

// convert string to uppercase
char* uppercase(char* str, size_t n) {
    for (size_t i = 0; i < n; ++i)
        str[i] = toupper((unsigned char)str[i]);
    return str;
}

size_t get_min_length(const char* str, size_t n) {
    size_t len = 0;
    while (len < n && isupper((unsigned char)str[len]))
        ++len;
    return len;
}

void fatal(const char* message) {
    fprintf(stderr, "%s\n", message);
    exit(1);
}

void* xmalloc(size_t n) {
    void* ptr = malloc(n);
    if (ptr == NULL)
        fatal("Out of memory");
    return ptr;
}

void* xrealloc(void* p, size_t n) {
    void* ptr = realloc(p, n);
    if (ptr == NULL)
        fatal("Out of memory");
    return ptr;
}

char** split_into_words(const char* str, size_t* count) {
    size_t size = 0;
    size_t capacity = 16;
    char** words = xmalloc(capacity * sizeof(char*));
    size_t len = strlen(str);
    for (size_t begin = 0; begin < len; ) {
        size_t i = begin;
        for (; i < len && isspace((unsigned char)str[i]); ++i) {}
        begin = i;
        for (; i < len && !isspace((unsigned char)str[i]); ++i) {}
        size_t word_len = i - begin;
        if (word_len == 0)
            break;
        char* word = xmalloc(word_len + 1);
        memcpy(word, str + begin, word_len);
        word[word_len] = 0;
        begin += word_len;
        if (capacity == size) {
            capacity *= 2;
            words = xrealloc(words, capacity * sizeof(char*));
        }
        words[size++] = word;
    }
    *count = size;
    return words;
}

command_t* make_command_list(const char* table) {
    command_t* cmd = NULL;
    size_t count = 0;
    char** words = split_into_words(table, &count);
    for (size_t i = 0; i < count; ++i) {
        char* word = words[i];
        command_t* new_cmd = xmalloc(sizeof(command_t));
        size_t word_len = strlen(word);
        new_cmd->length = word_len;
        new_cmd->min_len = get_min_length(word, word_len);
        new_cmd->cmd = uppercase(word, word_len);
        new_cmd->next = cmd;
        cmd = new_cmd;
    }
    free(words);
    return cmd;
}

void free_command_list(command_t* cmd) {
    while (cmd != NULL) {
        command_t* next = cmd->next;
        free(cmd->cmd);
        free(cmd);
        cmd = next;
    }
}

const command_t* find_command(const command_t* commands, const char* word) {
    for (const command_t* cmd = commands; cmd != NULL; cmd = cmd->next) {
        if (command_match(cmd, word))
            return cmd;
    }
    return NULL;
}

void test(const command_t* commands, const char* input) {
    printf(" input: %s\n", input);
    printf("output:");
    size_t count = 0;
    char** words = split_into_words(input, &count);
    for (size_t i = 0; i < count; ++i) {
        char* word = words[i];
        uppercase(word, strlen(word));
        const command_t* cmd_ptr = find_command(commands, word);
        printf(" %s", cmd_ptr ? cmd_ptr->cmd : "*error*");
        free(word);
    }
    free(words);
    printf("\n");
}

int main() {
    command_t* commands = make_command_list(command_table);
    const char* input = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin";
    test(commands, input);
    free_command_list(commands);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003494(void);
int64_t function_100003534(void);
int64_t function_1000035a8(void);
int64_t function_100003630(void);
int64_t function_10000366c(void);
int64_t function_1000036bc(void);
int64_t function_100003714(void);
int64_t function_100003930(void);
int64_t function_100003a14(void);
int64_t function_100003a74(void);
int64_t function_100003af4(void);
int64_t function_100003c7c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003c88(int32_t status);
int32_t function_100003c94(struct _IO_FILE * stream, char * format, ...);
void function_100003ca0(int64_t * ptr);
int32_t function_100003cac(int32_t c);
int32_t function_100003cb8(int32_t c);
int64_t * function_100003cc4(int32_t size);
int32_t function_100003cd0(char * format, ...);
int64_t * function_100003cdc(int64_t * ptr, int32_t size);
int32_t function_100003ce8(char * s);
int32_t function_100003cf4(char * s1, char * s2, int32_t n);
int32_t function_100003d00(int32_t c);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _isspace(int32_t a1);
int32_t _isupper(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003494 - 0x100003534
int64_t function_100003494(void) {
    // 0x100003494
    int64_t v1; // 0x100003494
    char * v2 = (char *)v1; // 0x1000034a4
    int32_t v3 = _strlen(v2); // 0x1000034ac
    uint64_t v4 = (int64_t)v3; // 0x1000034ac
    if (*(int64_t *)(v1 + 16) > v4) {
        // 0x100003520
        return 0;
    }
    uint64_t v5 = *(int64_t *)(v1 + 8); // 0x1000034e0
    int64_t result = 0; // 0x1000034f4
    if (v5 <= v4 != v5 != v4) {
        // 0x1000034fc
        result = _strncmp(v2, v2, v3) == 0;
    }
    // 0x100003520
    return result;
}

// Address range: 0x100003534 - 0x1000035a8
int64_t function_100003534(void) {
    // 0x100003534
    int64_t result; // 0x100003534
    if (result == 0) {
        // 0x100003598
        return result;
    }
    int64_t v1 = 0; // 0x100003560
    char * c = (char *)(v1 + result); // 0x100003570
    *c = (char)_toupper((int32_t)*c);
    v1++;
    while (v1 != result) {
        // 0x100003568
        c = (char *)(v1 + result);
        *c = (char)_toupper((int32_t)*c);
        v1++;
    }
    // 0x100003598
    return result;
}

// Address range: 0x1000035a8 - 0x100003630
int64_t function_1000035a8(void) {
    // 0x1000035a8
    int64_t v1; // 0x1000035a8
    uint64_t v2 = v1;
    if (v2 == 0) {
        // 0x100003620
        return 0;
    }
    int64_t v3 = 0; // 0x1000035dc
    int64_t result = v3; // 0x100003608
    while (_isupper((int32_t)*(char *)(v3 + v1)) != 0) {
        // 0x100003610
        v3++;
        result = v3;
        if (v3 >= v2) {
            // break -> 0x100003620
            break;
        }
        result = v3;
    }
    // 0x100003620
    return result;
}

// Address range: 0x100003630 - 0x10000366c
int64_t function_100003630(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003648
    int64_t v2; // 0x100003630
    _fprintf((struct _IO_FILE *)v1, "%s\n", (char *)v2);
    _exit(1);
    return &g1;
}

// Address range: 0x10000366c - 0x1000036bc
int64_t function_10000366c(void) {
    // 0x10000366c
    int64_t v1; // 0x10000366c
    int64_t * v2 = _malloc((int32_t)v1); // 0x100003680
    if (v2 != NULL) {
        // 0x1000036ac
        return (int64_t)v2;
    }
    // 0x10000369c
    function_100003630();
    // UNREACHABLE
}

// Address range: 0x1000036bc - 0x100003714
int64_t function_1000036bc(void) {
    // 0x1000036bc
    int64_t v1; // 0x1000036bc
    int64_t * v2 = _realloc((int64_t *)v1, (int32_t)v1); // 0x1000036d8
    if (v2 != NULL) {
        // 0x100003704
        return (int64_t)v2;
    }
    // 0x1000036f4
    function_100003630();
    // UNREACHABLE
}

// Address range: 0x100003714 - 0x100003930
int64_t function_100003714(void) {
    int64_t result = function_10000366c(); // 0x10000373c
    int64_t v1; // 0x100003714
    int32_t v2 = _strlen((char *)v1); // 0x100003748
    uint64_t v3 = (int64_t)v2; // 0x100003748
    int64_t v4 = 0; // 0x100003768
    int64_t result2 = result; // 0x100003768
    int64_t v5 = 16; // 0x100003768
    int64_t v6 = 0; // 0x100003768
    if (v2 == 0) {
        // 0x100003914
        *(int64_t *)v1 = 0;
        return result;
    }
    int64_t v7; // 0x100003714
    int64_t v8; // 0x100003714
    int64_t v9; // 0x100003714
    int64_t v10; // 0x100003714
    int64_t v11; // 0x100003714
    while (true) {
      lab_0x10000377c:
        // 0x10000377c
        v7 = v6;
        v8 = v5;
        v11 = v4;
        v10 = v11;
        while (v11 < v3) {
            int64_t v12 = v11 + 1; // 0x1000037c0
            v9 = v11;
            if (_isspace((int32_t)*(char *)(v11 + v1)) == 0) {
                goto lab_0x100003828;
            }
            v11 = v12;
            v10 = v11;
        }
        goto lab_0x100003848;
    }
  lab_0x100003914_2:;
    // 0x100003914
    int64_t v13; // 0x100003714
    *(int64_t *)v1 = v13;
    return result2;
  lab_0x100003828:;
    int64_t v14 = v9;
    v10 = v14;
    if (_isspace((int32_t)*(char *)(v14 + v1)) != 0) {
        goto lab_0x100003848;
    } else {
        int64_t v15 = v14 + 1; // 0x10000383c
        v9 = v15;
        v10 = v15;
        if (v15 < v3) {
            goto lab_0x100003828;
        } else {
            goto lab_0x100003848;
        }
    }
  lab_0x100003848:
    // 0x100003848
    v4 = v10;
    int64_t v16 = v4 - v11; // 0x100003850
    v13 = v7;
    if (v16 == 0) {
        // break -> 0x100003914
        goto lab_0x100003914_2;
    }
    int64_t v17 = function_10000366c(); // 0x100003878
    ___memcpy_chk(v17, v11 + v1, v16, -1);
    *(char *)(v17 + v16) = 0;
    v5 = v8;
    int64_t v18 = result2; // 0x1000038cc
    if (v8 == v7) {
        // 0x1000038d4
        v5 = 2 * v8;
        v18 = function_1000036bc();
    }
    // 0x1000038f8
    result2 = v18;
    v6 = v7 + 1;
    *(int64_t *)(result2 + 8 * v7) = v17;
    v13 = v6;
    if (v4 >= v3) {
        // break -> 0x100003914
        goto lab_0x100003914_2;
    }
    goto lab_0x10000377c;
}

// Address range: 0x100003930 - 0x100003a14
int64_t function_100003930(void) {
    // 0x100003930
    _free((int64_t *)function_100003714());
    return 0;
}

// Address range: 0x100003a14 - 0x100003a74
int64_t function_100003a14(void) {
    // 0x100003a14
    int64_t v1; // 0x100003a14
    if (v1 == 0) {
        // 0x100003a68
        return 0;
    }
    int64_t v2; // 0x100003a14
    int64_t v3 = *(int64_t *)(v2 + 24); // 0x100003a40
    int64_t * v4 = (int64_t *)v2; // 0x100003a4c
    _free((int64_t *)*v4);
    _free(v4);
    v2 = v3;
    while (v3 != 0) {
        // 0x100003a3c
        v3 = *(int64_t *)(v2 + 24);
        v4 = (int64_t *)v2;
        _free((int64_t *)*v4);
        _free(v4);
        v2 = v3;
    }
    // 0x100003a68
    return &g1;
}

// Address range: 0x100003a74 - 0x100003af4
int64_t function_100003a74(void) {
    // 0x100003a74
    int64_t v1; // 0x100003a74
    if (v1 == 0) {
        // 0x100003ae4
        return 0;
    }
    int64_t v2; // 0x100003a74
    int64_t result = v2; // 0x100003ab4
    while (function_100003494() % 2 == 0) {
        int64_t v3 = *(int64_t *)(v2 + 24); // 0x100003ad0
        v2 = v3;
        result = 0;
        if (v3 == 0) {
            // break -> 0x100003ae4
            break;
        }
        result = v2;
    }
    // 0x100003ae4
    return result;
}

// Address range: 0x100003af4 - 0x100003c24
int64_t function_100003af4(void) {
    // 0x100003af4
    int64_t v1; // 0x100003af4
    _printf(" input: %s\n", (char *)v1);
    _printf("output:");
    _free((int64_t *)function_100003714());
    return _printf("\n");
}

// Address range: 0x100003c24 - 0x100003c7c
int64_t entry_point(void) {
    // 0x100003c24
    function_100003930();
    function_100003af4();
    function_100003a14();
    return 0;
}

// Address range: 0x100003c7c - 0x100003c88
int64_t function_100003c7c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003c7c
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003c88 - 0x100003c94
void function_100003c88(int32_t status) {
    // 0x100003c88
    _exit(status);
}

// Address range: 0x100003c94 - 0x100003ca0
int32_t function_100003c94(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003c94
    return _fprintf(stream, format);
}

// Address range: 0x100003ca0 - 0x100003cac
void function_100003ca0(int64_t * ptr) {
    // 0x100003ca0
    _free(ptr);
}

// Address range: 0x100003cac - 0x100003cb8
int32_t function_100003cac(int32_t c) {
    // 0x100003cac
    return _isspace(c);
}

// Address range: 0x100003cb8 - 0x100003cc4
int32_t function_100003cb8(int32_t c) {
    // 0x100003cb8
    return _isupper(c);
}

// Address range: 0x100003cc4 - 0x100003cd0
int64_t * function_100003cc4(int32_t size) {
    // 0x100003cc4
    return _malloc(size);
}

// Address range: 0x100003cd0 - 0x100003cdc
int32_t function_100003cd0(char * format, ...) {
    // 0x100003cd0
    return _printf(format);
}

// Address range: 0x100003cdc - 0x100003ce8
int64_t * function_100003cdc(int64_t * ptr, int32_t size) {
    // 0x100003cdc
    return _realloc(ptr, size);
}

// Address range: 0x100003ce8 - 0x100003cf4
int32_t function_100003ce8(char * s) {
    // 0x100003ce8
    return _strlen(s);
}

// Address range: 0x100003cf4 - 0x100003d00
int32_t function_100003cf4(char * s1, char * s2, int32_t n) {
    // 0x100003cf4
    return _strncmp(s1, s2, n);
}

// Address range: 0x100003d00 - 0x100003d0c
int32_t function_100003d00(int32_t c) {
    // 0x100003d00
    return _toupper(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 24

`
`#include <stdlib.h>  /* for qsort */
#include <string.h>  /* for strlen */
#include <strings.h> /* for strcasecmp */

int mycmp(const void *s1, const void *s2)
{
    const char *l = *(const char **)s1, *r = *(const char **)s2;
    size_t ll = strlen(l), lr = strlen(r);

    if (ll > lr) return -1;
    if (ll < lr) return 1;
    return strcasecmp(l, r);
}

int main()
{
    const char *strings[] = {
      "Here", "are", "some", "sample", "strings", "to", "be", "sorted" };

    qsort(strings, sizeof(strings)/sizeof(*strings), sizeof(*strings), mycmp);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e0c(void);
int64_t function_100003f40(int64_t a1);
int64_t * function_100003f4c(int64_t * dest, int64_t * src, int32_t n);
void function_100003f58(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003f64(char * s1, char * s2);
int32_t function_100003f70(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcasecmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e0c - 0x100003ebc
int64_t function_100003e0c(void) {
    // 0x100003e0c
    int64_t v1; // 0x100003e0c
    char * v2 = (char *)v1; // 0x100003e28
    char * v3 = (char *)v1; // 0x100003e34
    uint32_t v4 = _strlen(v2); // 0x100003e3c
    uint32_t v5 = _strlen(v3); // 0x100003e48
    int64_t result = v4 != v5 == v4 >= v5 ? 0xffffffff : 1; // 0x100003e60
    if (v4 >= v5 && v4 != v5 != v4 >= v5) {
        // 0x100003e98
        result = _strcasecmp(v2, v3);
    }
    // 0x100003eac
    return result;
}

// Address range: 0x100003ebc - 0x100003f40
int64_t entry_point(void) {
    // 0x100003ebc
    int64_t v1; // bp-88, 0x100003ebc
    _memcpy(&v1, (int64_t *)"|?", 64);
    _qsort(&v1, 8, 8, (int32_t (*)(int64_t *, int64_t *))0x100003e0c);
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f18
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f2c
        ___stack_chk_fail((int64_t)&g1);
    }
    // 0x100003f30
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(int64_t a1) {
    // 0x100003f40
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f4c - 0x100003f58
int64_t * function_100003f4c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f4c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f58 - 0x100003f64
void function_100003f58(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f58
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s1, char * s2) {
    // 0x100003f64
    return _strcasecmp(s1, s2);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * s) {
    // 0x100003f70
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include<stdio.h>

#define MOD 1000000000
int state[55], si = 0, sj = 0;

int subrand();

void subrand_seed(int p1)
{
	int i, j, p2 = 1;

	state[0] = p1 % MOD;
	for (i = 1, j = 21; i < 55; i++, j += 21) {
		if (j >= 55) j -= 55;
		state[j] = p2;
		if ((p2 = p1 - p2) < 0) p2 += MOD;
		p1 = state[j];
	}
	si = 0;
	sj = 24;
	for (i = 0; i < 165; i++) subrand();
}

int subrand()
{
	int x;
	if (si == sj) subrand_seed(0);

	if (!si--) si = 54;
	if (!sj--) sj = 54;
	if ((x = state[si] - state[sj]) < 0) x += MOD;

	return state[si] = x;
}

int main()
{
	subrand_seed(292929);
	int i;
	for (i = 0; i < 10; i++) printf("%d\n", subrand());

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cbc(void);
int64_t function_100003e14(void);
int32_t function_100003f98(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int32_t g2 = 0x100000c; // 0x100008004
int32_t * g3 = (int32_t *)0x200000000; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cbc - 0x100003e14
int64_t function_100003cbc(void) {
    // 0x100003cbc
    int64_t v1; // 0x100003cbc
    int32_t v2 = v1; // 0x100003cc8
    *(int32_t *)&g3 = v2 % 0x3b9aca00;
    int32_t v3 = 1; // 0x100003da8
    int32_t v4 = 1;
    int32_t v5 = 21;
    int32_t v6 = v5 - 55; // 0x100003d20
    int32_t v7 = v6 < 0 == (54 - v5 & v5) < 0 ? v6 : v5;
    *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g3) = v4;
    int32_t v8 = v2 - v4; // 0x100003d5c
    v3++;
    int32_t v9 = v4; // 0x100003d14
    while (v3 != 55) {
        // 0x100003d1c
        v4 = v8 < 0 ? v8 + 0x3b9aca00 : v8;
        v5 = v7 + 21;
        v6 = v5 - 55;
        v7 = v6 < 0 == (54 - v5 & v5) < 0 ? v6 : v5;
        *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g3) = v4;
        v8 = v9 - v4;
        v3++;
        v9 = v4;
    }
    // 0x100003dc0
    *(int32_t *)&g1 = 0;
    g2 = 24;
    int32_t v10 = 0;
    int64_t result = function_100003e14(); // 0x100003df0
    int32_t v11 = v10 + 1; // 0x100003dfc
    while (v10 < 164 != (163 - v10 & v11) < 0) {
        // 0x100003df0
        v10 = v11;
        result = function_100003e14();
        v11 = v10 + 1;
    }
    // 0x100003e08
    return result;
}

// Address range: 0x100003e14 - 0x100003f20
int64_t function_100003e14(void) {
    int32_t v1 = *(int32_t *)&g1; // 0x100003e24
    int32_t v2 = v1; // 0x100003e38
    if (v1 == g2) {
        // 0x100003e40
        function_100003cbc();
        v2 = *(int32_t *)&g1;
    }
    int32_t v3 = v2; // 0x100003e50
    int32_t v4 = g2; // 0x100003e80
    int32_t v5 = v3 == 0 ? 54 : v3 - 1;
    *(int32_t *)&g1 = v5;
    int32_t v6 = v4 == 0 ? 54 : v4 - 1;
    g2 = v6;
    int32_t * v7 = (int32_t *)(4 * (int64_t)v5 + (int64_t)&g3);
    int32_t v8 = *(int32_t *)(4 * (int64_t)v6 + (int64_t)&g3); // 0x100003ec8
    int32_t v9 = *v7 - v8; // 0x100003ecc
    uint32_t result = v9 < 0 ? v9 + 0x3b9aca00 : v9;
    *v7 = result;
    return result;
}

// Address range: 0x100003f20 - 0x100003f98
int64_t entry_point(void) {
    // 0x100003f20
    function_100003cbc();
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003f58
        function_100003e14();
        int64_t v1; // 0x100003f20
        _printf("%d\n", v1);
    }
    // 0x100003f88
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

#define N 10000000
#define CS N	/* cache size */

typedef unsigned long ulong;
ulong cache[CS] = {0};

ulong hailstone(ulong n)
{
	int x;
	if (n == 1) return 1;
	if (n < CS && cache[n]) return cache[n];

	x = 1 + hailstone((n & 1) ? 3 * n + 1 : n / 2);
	if (n < CS) cache[n] = x;
	return x;
}

int main()
{
	int i, l, max = 0, mi;
	for (i = 1; i < N; i++) {
		if ((l = hailstone(i)) > max) {
			max = l;
			mi = i;
		}
	}
	printf("max below %d: %d, length %d\n", N, mi, max);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d88(void);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d88 - 0x100003eac
int64_t function_100003d88(void) {
    // 0x100003d88
    int64_t v1; // 0x100003d88
    uint64_t v2 = v1;
    if (v2 == 1) {
        // 0x100003e9c
        return 1;
    }
    if (v2 >= 0x989680) {
        // 0x100003e9c
        return (int32_t)function_100003d88() + 1;
    }
    int64_t * v3 = (int64_t *)(8 * v2 + (int64_t)&g1);
    int64_t v4 = *v3; // 0x100003de0
    int32_t result; // 0x100003d88
    if (v4 == 0) {
        int32_t v5 = (int32_t)function_100003d88() + 1; // 0x100003e58
        *v3 = (int64_t)v5;
        result = v5;
    } else {
        // 0x100003df4
        result = v4;
    }
    // 0x100003e9c
    return result;
}

// Address range: 0x100003eac - 0x100003f7c
int64_t entry_point(void) {
    int32_t v1 = 1;
    function_100003d88();
    int32_t v2 = v1 + 1; // 0x100003f2c
    while (v1 < 0x98967f != (0x98967e - v1 & v2) < 0) {
        // 0x100003ee8
        v1 = v2;
        function_100003d88();
        v2 = v1 + 1;
    }
    // 0x100003f38
    int64_t v3; // 0x100003eac
    _printf("max below %d: %d, length %d\n", v3, v3, v3);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <locale.h>

bool *primeSieve(int limit) {
    int i, p;
    limit++;
    // True denotes composite, false denotes prime.
    bool *c = calloc(limit, sizeof(bool)); // all false by default
    c[0] = true;
    c[1] = true;
    for (i = 4; i < limit; i += 2) c[i] = true;
    p = 3; // Start from 3.
    while (true) {
        int p2 = p * p;
        if (p2 >= limit) break;
        for (i = p2; i < limit; i += 2 * p) c[i] = true;
        while (true) {
            p += 2;
            if (!c[p]) break;
        }
    }
    return c;
}

int main() {
    const int limit = 1000000;
    int i, j, n, uc = 2, p = 10, m = 63, ul = 151000;
    bool *c = primeSieve(limit);
    n = m * limit + 1;
    int *sumDivs = (int *)calloc(n, sizeof(int));
    for (i = 1; i < n; ++i) {
        for (j = i; j < n; j += i) sumDivs[j] += i;
    }
    bool *s = (bool *)calloc(n, sizeof(bool)); // all false
    for (i = 1; i < n; ++i) {
        int sum = sumDivs[i] - i; // proper divs sum
        if (sum <= n) s[sum] = true;
    }
    free(sumDivs);
    int *untouchable = (int *)malloc(ul * sizeof(int));
    untouchable[0] = 2;
    untouchable[1] = 5;
    for (n = 6; n <= limit; n += 2) {
        if (!s[n] && c[n-1] && c[n-3]) untouchable[uc++] = n;
    }
    setlocale(LC_NUMERIC, "");
    printf("List of untouchable numbers <= 2,000:\n");
    for (i = 0; i < uc; ++i) {
        j = untouchable[i];
        if (j > 2000) break;
        printf("%'6d ", j);
        if (!((i+1) % 10)) printf("\n");
    }
    printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", i);
    for (i = 0; i < uc; ++i) {
        j = untouchable[i];
        if (j > p) {
            printf("%'7d untouchable numbers were found  <= %'9d\n", i, p);
            p *= 10;
            if (p == limit) break;
        }
    }
    printf("%'7d untouchable numbers were found  <= %'d\n", uc, limit);
    free(c);
    free(s);
    free(untouchable);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038f0(void);
int64_t * function_100003eac(int32_t nmemb, int32_t size);
void function_100003eb8(int64_t * ptr);
int64_t * function_100003ec4(int32_t size);
int32_t function_100003ed0(char * format, ...);
char * function_100003edc(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003ee8

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x1000038f0 - 0x100003a50
int64_t function_1000038f0(void) {
    // 0x1000038f0
    int64_t v1; // 0x1000038f0
    int32_t v2 = v1; // 0x1000038fc
    int32_t v3 = v2 + 1; // 0x100003904
    int64_t * v4 = _calloc(v3, 1); // 0x100003914
    int64_t result = (int64_t)v4; // 0x100003914
    *(char *)v4 = 1;
    *(char *)(result + 1) = 1;
    int32_t v5 = 3 - v2; // 0x100003944
    int32_t v6 = 4; // 0x10000394c
    if (v5 < 0 != (v5 & v3) < 0) {
        *(char *)((int64_t)v6 + result) = 1;
        v6 += 2;
        while (v6 - v3 < 0 != ((v6 - v3 ^ v6) & (v6 ^ v3)) < 0) {
            // 0x100003954
            *(char *)((int64_t)v6 + result) = 1;
            v6 += 2;
        }
    }
    int32_t v7 = 8 - v2; // 0x1000039a0
    if (v7 < 0 == (v7 & v3) < 0) {
        // 0x100003a40
        return result;
    }
    int32_t v8 = 3;
    int32_t v9 = 9;
    int32_t v10 = v9 - v3; // 0x1000039c8
    int32_t v11; // 0x100003a00
    if (v10 < 0 != ((v10 ^ v9) & (v9 ^ v3)) < 0) {
        // 0x1000039d8
        v11 = v9;
        *(char *)((int64_t)v11 + result) = 1;
        v11 += 2 * v8;
        while (v11 - v3 < 0 != ((v11 - v3 ^ v11) & (v11 ^ v3)) < 0) {
            // 0x1000039d8
            *(char *)((int64_t)v11 + result) = 1;
            v11 += 2 * v8;
        }
    }
    int32_t v12 = v8 + 2; // 0x100003a14
    int32_t v13 = v12; // 0x100003a2c
    while (*(char *)((int64_t)v12 + result) % 2 != 0) {
        // 0x100003a10
        v12 = v13 + 2;
        v13 = v12;
    }
    int32_t v14 = v12 * v12; // 0x100003990
    while (v14 - v3 < 0 != ((v14 - v3 ^ v14) & (v14 ^ v3)) < 0) {
        // 0x1000039c0
        v8 = v12;
        v9 = v14;
        v10 = v9 - v3;
        if (v10 < 0 != ((v10 ^ v9) & (v9 ^ v3)) < 0) {
            // 0x1000039d8
            v11 = v9;
            *(char *)((int64_t)v11 + result) = 1;
            v11 += 2 * v8;
            while (v11 - v3 < 0 != ((v11 - v3 ^ v11) & (v11 ^ v3)) < 0) {
                // 0x1000039d8
                *(char *)((int64_t)v11 + result) = 1;
                v11 += 2 * v8;
            }
        }
        // 0x100003a10
        v12 = v8 + 2;
        v13 = v12;
        while (*(char *)((int64_t)v12 + result) % 2 != 0) {
            // 0x100003a10
            v12 = v13 + 2;
            v13 = v12;
        }
        // 0x100003988
        v14 = v12 * v12;
    }
    // 0x100003a40
    return result;
}

// Address range: 0x100003a50 - 0x100003eac
int64_t entry_point(void) {
    int64_t v1 = function_1000038f0(); // 0x100003a94
    int64_t * v2 = _calloc(0x3c14dc1, 4); // 0x100003ac0
    int64_t v3 = (int64_t)v2; // 0x100003ac0
    int32_t v4 = 1;
    int32_t v5 = v4; // 0x100003b08
    int32_t * v6; // 0x100003b20
    int32_t v7; // 0x100003b38
    if (v4 < 0x3c14dc1 != (0x3c14dc0 - v4 & v4) < 0) {
        v6 = (int32_t *)(4 * (int64_t)v5 + v3);
        *v6 = *v6 + v4;
        v7 = v5 + v4;
        v5 = v7;
        while (v7 < 0x3c14dc1 != (0x3c14dc0 - v7 & v7) < 0) {
            // 0x100003b10
            v6 = (int32_t *)(4 * (int64_t)v5 + v3);
            *v6 = *v6 + v4;
            v7 = v5 + v4;
            v5 = v7;
        }
    }
    int32_t v8 = v4 + 1; // 0x100003b4c
    while (v4 < 0x3c14dc0 != (0x3c14dbf - v4 & v8) < 0) {
        // 0x100003af8
        v4 = v8;
        v5 = v4;
        if (v4 < 0x3c14dc1 != (0x3c14dc0 - v4 & v4) < 0) {
            v6 = (int32_t *)(4 * (int64_t)v5 + v3);
            *v6 = *v6 + v4;
            v7 = v5 + v4;
            v5 = v7;
            while (v7 < 0x3c14dc1 != (0x3c14dc0 - v7 & v7) < 0) {
                // 0x100003b10
                v6 = (int32_t *)(4 * (int64_t)v5 + v3);
                *v6 = *v6 + v4;
                v7 = v5 + v4;
                v5 = v7;
            }
        }
        // 0x100003b48
        v8 = v4 + 1;
    }
    int64_t * v9 = _calloc(0x3c14dc1, 1); // 0x100003b60
    int64_t v10 = (int64_t)v9; // 0x100003b60
    int32_t v11 = 1;
    int32_t v12 = *(int32_t *)(4 * (int64_t)v11 + v3) - v11; // 0x100003b9c
    int32_t v13 = v12 - 0x3c14dc1; // 0x100003bac
    if (v13 == 0 || v13 < 0 != (0x3c14dc0 - v12 & v12) < 0) {
        // 0x100003bbc
        *(char *)((int64_t)v12 + v10) = 1;
    }
    int32_t v14 = v11 + 1; // 0x100003bdc
    while (v11 < 0x3c14dc0 != (0x3c14dbf - v11 & v14) < 0) {
        // 0x100003b8c
        v11 = v14;
        v12 = *(int32_t *)(4 * (int64_t)v11 + v3) - v11;
        v13 = v12 - 0x3c14dc1;
        if (v13 == 0 || v13 < 0 != (0x3c14dc0 - v12 & v12) < 0) {
            // 0x100003bbc
            *(char *)((int64_t)v12 + v10) = 1;
        }
        // 0x100003bd8
        v14 = v11 + 1;
    }
    // 0x100003be8
    _free(v2);
    int64_t * v15 = _malloc(0x93760); // 0x100003bf8
    int64_t v16 = (int64_t)v15; // 0x100003bf8
    *(int32_t *)v15 = 2;
    *(int32_t *)(v16 + 4) = 5;
    int32_t v17 = 2;
    int32_t v18 = 6;
    int32_t v19 = v17; // 0x100003c4c
    if (*(char *)((int64_t)v18 + v10) % 2 == 0) {
        // 0x100003c54
        v19 = v17;
        if (*(char *)(v1 + (int64_t)(v18 - 1)) % 2 != 0) {
            // 0x100003c70
            v19 = v17;
            if (*(char *)(v1 + (int64_t)(v18 - 3)) % 2 != 0) {
                // 0x100003c8c
                *(int32_t *)(4 * (int64_t)v17 + v16) = v18;
                v19 = v17 + 1;
            }
        }
    }
    int32_t v20 = v19;
    int32_t v21 = v18 + 2; // 0x100003cb4
    while (v18 == 0xf423e || v18 < 0xf423e != (0xf423d - v18 & v21) < 0) {
        // 0x100003c3c
        v17 = v20;
        v18 = v21;
        v19 = v17;
        if (*(char *)((int64_t)v18 + v10) % 2 == 0) {
            // 0x100003c54
            v19 = v17;
            if (*(char *)(v1 + (int64_t)(v18 - 1)) % 2 != 0) {
                // 0x100003c70
                v19 = v17;
                if (*(char *)(v1 + (int64_t)(v18 - 3)) % 2 != 0) {
                    // 0x100003c8c
                    *(int32_t *)(4 * (int64_t)v17 + v16) = v18;
                    v19 = v17 + 1;
                }
            }
        }
        // 0x100003cb0
        v20 = v19;
        v21 = v18 + 2;
    }
    // 0x100003cc0
    _setlocale(4, (char *)&g1);
    _printf("List of untouchable numbers <= 2,000:\n");
    int32_t v22 = -v20;
    int32_t v23 = 0; // 0x100003cf4
    int64_t v24; // 0x100003a50
    if (v22 < 0 == (v20 & v22) < 0) {
        // 0x100003d8c
        _printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", (int64_t)&g1);
        // 0x100003e5c
        _printf("%'7d untouchable numbers were found  <= %'d\n", (int64_t)&g1, v24);
        _free((int64_t *)v1);
        _free(v9);
        _free(v15);
        return 0;
    }
    int32_t v25 = *(int32_t *)(4 * (int64_t)v23 + v16); // 0x100003d04
    while (v25 == 2000 || v25 < 2000 != (1999 - v25 & v25) < 0) {
        // 0x100003d24
        _printf("%'6d ", (int64_t)&g1);
        v23++;
        if (v23 % 10 == 0) {
            // 0x100003d68
            _printf("\n");
        }
        int32_t v26 = v23 - v20; // 0x100003cec
        if (v26 < 0 == ((v26 ^ v23) & (v23 ^ v20)) < 0) {
            // break -> 0x100003dc8
            break;
        }
        v25 = *(int32_t *)(4 * (int64_t)v23 + v16);
    }
    // 0x100003dc8
    _printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", (int64_t)&g1);
    int32_t v27 = 0; // 0x100003e50
    int32_t v28 = 10;
    int32_t v29 = *(int32_t *)(4 * (int64_t)v27 + v16); // 0x100003dd0
    int32_t v30 = v29 - v28; // 0x100003de0
    int32_t v31 = v28; // 0x100003de8
    if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v28)) < 0) {
        // 0x100003df0
        _printf("%'7d untouchable numbers were found  <= %'9d\n", (int64_t)&g1, v24);
        v31 = 10 * v28;
        if (v31 == 0xf4240) {
            // break -> 0x100003e5c
            break;
        }
    }
    // 0x100003e4c
    v27++;
    while (v27 - v20 < 0 != ((v27 - v20 ^ v27) & (v27 ^ v20)) < 0) {
        // 0x100003dc8
        v28 = v31;
        v29 = *(int32_t *)(4 * (int64_t)v27 + v16);
        v30 = v29 - v28;
        v31 = v28;
        if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v28)) < 0) {
            // 0x100003df0
            _printf("%'7d untouchable numbers were found  <= %'9d\n", (int64_t)&g1, v24);
            v31 = 10 * v28;
            if (v31 == 0xf4240) {
                // break -> 0x100003e5c
                break;
            }
        }
        // 0x100003e4c
        v27++;
    }
    // 0x100003e5c
    _printf("%'7d untouchable numbers were found  <= %'d\n", (int64_t)&g1, v24);
    _free((int64_t *)v1);
    _free(v9);
    _free(v15);
    return 0;
}

// Address range: 0x100003eac - 0x100003eb8
int64_t * function_100003eac(int32_t nmemb, int32_t size) {
    // 0x100003eac
    return _calloc(nmemb, size);
}

// Address range: 0x100003eb8 - 0x100003ec4
void function_100003eb8(int64_t * ptr) {
    // 0x100003eb8
    _free(ptr);
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t * function_100003ec4(int32_t size) {
    // 0x100003ec4
    return _malloc(size);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(char * format, ...) {
    // 0x100003ed0
    return _printf(format);
}

// Address range: 0x100003edc - 0x100003ee8
char * function_100003edc(int32_t category, char * locale) {
    // 0x100003edc
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include<stdlib.h>
#include<stdio.h>

/*The stdlib header file is required for the malloc and free functions*/

int main()
{
	/*Declaring a four fold integer pointer, also called
	a pointer to a pointer to a pointer to an integer pointer*/
	
	int**** hyperCube, i,j,k;

	/*We will need i,j,k for the memory allocation*/
	
	/*First the five lines*/
	
	hyperCube = (int****)malloc(5*sizeof(int***));
	
	/*Now the four planes*/
	
	for(i=0;i<5;i++){
		hyperCube[i] = (int***)malloc(4*sizeof(int**));
		
		/*Now the 3 cubes*/
		
		for(j=0;j<4;j++){
			hyperCube[i][j] = (int**)malloc(3*sizeof(int*));
			
			/*Now the 2 hypercubes (?)*/
			
			for(k=0;k<3;k++){
				hyperCube[i][j][k] = (int*)malloc(2*sizeof(int));
			}
		}
	}
	
	/*All that looping and function calls may seem futile now,
	but imagine real applications when the dimensions of the dataset are
	not known beforehand*/
	
	/*Yes, I just copied the rest from the first program*/
	
	hyperCube[4][3][2][1] = 1;
	
	/*IMPORTANT : C ( and hence C++ and Java and everyone of the family ) arrays are zero based.
	The above element is thus actually the last element of the hypercube.*/
	
	/*Now we print out that element*/
	
	printf("\n%d",hyperCube[4][3][2][1]);
	
	/*But that's not the only way to get at that element*/
	printf("\n%d",*(*(*(*(hyperCube + 4) + 3) + 2) + 1));

	/*Yes, I know, it's beautiful*/
	*(*(*(*(hyperCube+3)+2)+1)) = 3;
	
	printf("\n%d",hyperCube[3][2][1][0]);
	
	/*Always nice to clean up after you, yes memory is cheap, but C is 45+ years old,
	and anyways, imagine you are dealing with terabytes of data, or more...*/
	
	free(hyperCube);
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
void function_100003f80(int64_t * ptr);
int64_t * function_100003f8c(int32_t size);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003db8 - 0x100003f80
int64_t entry_point(void) {
    int64_t * v1 = _malloc(40); // 0x100003dcc
    int64_t v2 = (int64_t)v1; // 0x100003dcc
    for (int64_t i = 0; i < 5; i++) {
        int64_t * v3 = _malloc(32); // 0x100003df4
        int64_t * v4 = (int64_t *)(8 * i + v2); // 0x100003e00
        *v4 = (int64_t)v3;
        for (int64_t j = 0; j < 4; j++) {
            int64_t * v5 = _malloc(24); // 0x100003e24
            int64_t v6 = 8 * j; // 0x100003e38
            *(int64_t *)(*v4 + v6) = (int64_t)v5;
            for (int64_t k = 0; k < 3; k++) {
                int64_t * v7 = _malloc(8); // 0x100003e5c
                int64_t v8 = *(int64_t *)(*v4 + v6); // 0x100003e70
                *(int64_t *)(v8 + 8 * k) = (int64_t)v7;
            }
        }
    }
    int64_t v9 = *(int64_t *)(*(int64_t *)(v2 + 32) + 24); // 0x100003ec0
    *(int32_t *)(*(int64_t *)(v9 + 16) + 4) = 1;
    int64_t v10; // 0x100003db8
    _printf("\n%d", v10);
    _printf("\n%d", v10);
    int64_t v11 = *(int64_t *)(*(int64_t *)(v2 + 24) + 16); // 0x100003f34
    *(int32_t *)*(int64_t *)(v11 + 8) = 3;
    _printf("\n%d", v10);
    _free(v1);
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
void function_100003f80(int64_t * ptr) {
    // 0x100003f80
    _free(ptr);
}

// Address range: 0x100003f8c - 0x100003f98
int64_t * function_100003f8c(int32_t size) {
    // 0x100003f8c
    return _malloc(size);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include<stdio.h>

int main()
{
  printf("\nHello world!");
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f58 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f58
    _printf("\nHello world!");
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    const char *name, *id, *dept;
    int sal;
} person;

person ppl[] = {
    {"Tyler Bennett",   "E10297", "D101", 32000},
    {"John Rappl",      "E21437", "D050", 47000},
    {"George Woltman",  "E00127", "D101", 53500},
    {"Adam Smith",      "E63535", "D202", 18000},
    {"Claire Buckman",  "E39876", "D202", 27800},
    {"David McClellan", "E04242", "D101", 41500},
    {"Rich Holcomb",    "E01234", "D202", 49500},
    {"Nathan Adams",    "E41298", "D050", 21900},
    {"Richard Potter",  "E43128", "D101", 15900},
    {"David Motsinger", "E27002", "D202", 19250},
    {"Tim Sampair",     "E03033", "D101", 27000},
    {"Kim Arlich",      "E10001", "D190", 57000},
    {"Timothy Grove",   "E16398", "D190", 29900},
};

int pcmp(const void *a, const void *b)
{
    const person *aa = a, *bb = b;
    int x = strcmp(aa->dept, bb->dept);
    if (x) return x;
    return aa->sal > bb->sal ? -1 : aa->sal < bb->sal;
}

#define N sizeof(ppl)/sizeof(person)
void top(int n)
{
    int i, rank;
    qsort(ppl, N, sizeof(person), pcmp);

    for (i = rank = 0; i < N; i++) {
        if (i && strcmp(ppl[i].dept, ppl[i - 1].dept)) {
            rank = 0;
            printf("\n");
        }

        if (rank++ < n)
            printf("%s %d: %s\n", ppl[i].dept, ppl[i].sal, ppl[i].name);
    }
}

int main()
{
    top(2);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c10(void);
int64_t function_100003cd8(void);
int32_t function_100003e58(char * format, ...);
void function_100003e64(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003e70(char * s1, char * s2);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003c10 - 0x100003cd8
int64_t function_100003c10(void) {
    // 0x100003c10
    int64_t v1; // 0x100003c10
    int64_t v2 = *(int64_t *)(v1 + 16); // 0x100003c40
    int32_t v3 = _strcmp((char *)*(int64_t *)(v1 + 16), (char *)v2); // 0x100003c44
    int32_t result = v3; // 0x100003c58
    if (v3 == 0) {
        int32_t v4 = *(int32_t *)(v1 + 24); // 0x100003c70
        int32_t v5 = *(int32_t *)(v1 + 24); // 0x100003c78
        int32_t v6 = v4 - v5; // 0x100003c7c
        result = v6 == 0 | v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0 ? (int32_t)(v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0) : -1;
    }
    // 0x100003cc8
    return result;
}

// Address range: 0x100003cd8 - 0x100003e28
int64_t function_100003cd8(void) {
    // 0x100003cd8
    int64_t v1; // 0x100003cd8
    int32_t v2 = v1; // 0x100003ce4
    _qsort((int64_t *)"|>", 13, 32, (int32_t (*)(int64_t *, int64_t *))0x100003c10);
    int32_t v3 = 0;
    int64_t v4 = 0;
    int32_t v5 = v3; // 0x100003d30
    int64_t v6 = &g1; // 0x100003d30
    int64_t v7 = 13; // 0x100003d30
    int64_t v8; // 0x100003d48
    int64_t v9; // 0x100003d4c
    int64_t v10; // 0x100003d64
    int32_t v11; // 0x100003d68
    if (v4 != 0) {
        // 0x100003d38
        v8 = 32 * v4;
        v9 = *(int64_t *)(v8 + (int64_t)"|>" + 16);
        v10 = *(int64_t *)(v8 + (int64_t)"|>" - 16);
        v11 = _strcmp((char *)v9, (char *)v10);
        v5 = v3;
        v6 = 0;
        v7 = v10;
        if (v11 != 0) {
            // 0x100003d7c
            v5 = 0;
            v6 = _printf("\n");
            v7 = v10;
        }
    }
    int64_t v12 = v7;
    int32_t v13 = v5;
    int32_t v14 = v13 - v2; // 0x100003da0
    int64_t v15 = v6; // 0x100003da8
    if (v14 < 0 != ((v14 ^ v13) & (v13 ^ v2)) < 0) {
        // 0x100003db0
        v15 = _printf("%s %d: %s\n", (char *)v12, 32, (char *)0x100003c10);
    }
    int64_t result = v15;
    int64_t v16 = v4 + 1;
    while (v16 != 13) {
        // 0x100003d24
        v3 = v13 + 1;
        v4 = v16;
        v5 = v3;
        v6 = result;
        v7 = v12;
        if (v4 != 0) {
            // 0x100003d38
            v8 = 32 * v4;
            v9 = *(int64_t *)(v8 + (int64_t)"|>" + 16);
            v10 = *(int64_t *)(v8 + (int64_t)"|>" - 16);
            v11 = _strcmp((char *)v9, (char *)v10);
            v5 = v3;
            v6 = 0;
            v7 = v10;
            if (v11 != 0) {
                // 0x100003d7c
                v5 = 0;
                v6 = _printf("\n");
                v7 = v10;
            }
        }
        // 0x100003d90
        v12 = v7;
        v13 = v5;
        v14 = v13 - v2;
        v15 = v6;
        if (v14 < 0 != ((v14 ^ v13) & (v13 ^ v2)) < 0) {
            // 0x100003db0
            v15 = _printf("%s %d: %s\n", (char *)v12, 32, (char *)0x100003c10);
        }
        // 0x100003e0c
        result = v15;
        v16 = v4 + 1;
    }
    // 0x100003e1c
    return result;
}

// Address range: 0x100003e28 - 0x100003e58
int64_t entry_point(void) {
    // 0x100003e28
    function_100003cd8();
    return 0;
}

// Address range: 0x100003e58 - 0x100003e64
int32_t function_100003e58(char * format, ...) {
    // 0x100003e58
    return _printf(format);
}

// Address range: 0x100003e64 - 0x100003e70
void function_100003e64(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e64
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003e70 - 0x100003e7c
int32_t function_100003e70(char * s1, char * s2) {
    // 0x100003e70
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>

typedef struct _PartialGrid{
        char** base;
        int xbegin, xend, ybegin, yend; // yend strictly not used
} PartialGrid;

void sierpinski_hollow(PartialGrid G){
        int len = G.xend - G.xbegin+1;
        int unit = len/3;
        for(int i = G.xbegin+unit; i <G.xbegin+2*unit;i++){
        for(int j = G.ybegin+unit; j <G.ybegin+2*unit;j++){
                G.base[j][i] = ' ';
        }}
}

void sierpinski(PartialGrid G, int iterations){
        if(iterations==0)
                return;
        if((iterations)==1){
                sierpinski_hollow(G);
                sierpinski(G,0);
        }
        sierpinski_hollow(G);
        for(int i=0;i<3;i++){
                for(int j=0;j<3;j++){
                        int length = G.xend-G.xbegin+1;
                        int unit = length/3;
                        PartialGrid q = {G.base, G.xbegin + i*unit, G.xbegin+(i+1)*unit-1,
                                G.ybegin+j*unit, G.ybegin+(j+1)*unit-1};
                        sierpinski(q, iterations-1);
                }
        }
}

int intpow(int base, int expo){
        if(expo==0){
                return 1;
        }
        return base*intpow(base,expo-1);
}

int allocate_grid(char*** g, int n, const char sep){
        int size = intpow(3,n+1);
        *g = (char**)calloc(size, sizeof(char*));
        if(*g==NULL)
                return -1;

        for(int i = 0; i < size; ++i){
                (*g)[i] = (char*)calloc(size, sizeof(char));
                if((*g)[i] == NULL)
                        return -1;
                for(int j = 0; j < size; j++){
                        (*g)[i][j] = sep;
                }
        }

        return size;
}

void print_grid(char** b, int size){
        for(int i = 0; i < size; i++){
                printf("%s\n",b[i]);
        }
}

int main(){
        int n = 3;

        char** basegrid;
        int size = allocate_grid(&basegrid, n, '#');
        if(size == -1)
                return 1; //bad alloc
        PartialGrid b = {basegrid, 0, size-1, 0, size-1};
        sierpinski(b, n);
        print_grid(basegrid, size);
        free(basegrid);

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039b8(void);
int64_t function_100003ac0(void);
int64_t function_100003c8c(void);
int64_t function_100003cf8(void);
int64_t function_100003e48(void);
int64_t * function_100003f78(int32_t nmemb, int32_t size);
void function_100003f84(int64_t * ptr);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039b8 - 0x100003ac0
int64_t function_1000039b8(void) {
    // 0x1000039b8
    int64_t result; // 0x1000039b8
    int32_t * v1 = (int32_t *)(result + 8); // 0x1000039cc
    int32_t v2 = *v1;
    int32_t v3 = (*(int32_t *)(result + 12) + 1 - v2) / 3; // 0x1000039e4
    int32_t v4 = v3 + v2; // 0x1000039f4
    int32_t v5 = 2 * v3; // 0x100003a14
    int32_t v6 = v5 + v2; // 0x100003a18
    int32_t v7 = v4 - v6; // 0x100003a1c
    if (v7 < 0 == ((v7 ^ v4) & (v6 ^ v4)) < 0) {
        // 0x100003ab8
        return result;
    }
    int32_t * v8 = (int32_t *)(result + 16); // 0x100003a30
    int32_t v9 = *v8; // 0x1000039b8
    int32_t v10 = v9 + v3; // 0x100003a38
    int32_t v11 = v9 + v5; // 0x100003a5c
    int32_t v12 = v10 - v11; // 0x100003a60
    int32_t v13 = v2; // 0x100003a68
    int64_t v14; // 0x100003a7c
    int32_t v15; // 0x100003a98
    int32_t v16; // 0x100003a4c
    int32_t v17; // 0x100003a5c
    if (v12 < 0 != ((v12 ^ v10) & (v11 ^ v10)) < 0) {
        // 0x100003a70
        v15 = v10;
        v14 = *(int64_t *)(8 * (int64_t)v15 + result);
        *(char *)(v14 + (int64_t)v4) = 32;
        v15++;
        v16 = *v8;
        v17 = v16 + v5;
        while (v15 - v17 < 0 != ((v15 - v17 ^ v15) & (v17 ^ v15)) < 0) {
            // 0x100003a70
            v14 = *(int64_t *)(8 * (int64_t)v15 + result);
            *(char *)(v14 + (int64_t)v4) = 32;
            v15++;
            v16 = *v8;
            v17 = v16 + v5;
        }
        // 0x100003a44
        v13 = *v1;
        v9 = v16;
    }
    int32_t v18 = v13; // 0x100003a08
    int32_t v19 = v4 + 1; // 0x100003aac
    int32_t v20 = v18 + v5; // 0x100003a18
    while (v19 - v20 < 0 != ((v19 - v20 ^ v19) & (v20 ^ v19)) < 0) {
        int32_t v21 = v19;
        v10 = v9 + v3;
        v11 = v9 + v5;
        v12 = v10 - v11;
        v13 = v18;
        if (v12 < 0 != ((v12 ^ v10) & (v11 ^ v10)) < 0) {
            // 0x100003a70
            v15 = v10;
            v14 = *(int64_t *)(8 * (int64_t)v15 + result);
            *(char *)(v14 + (int64_t)v21) = 32;
            v15++;
            v16 = *v8;
            v17 = v16 + v5;
            while (v15 - v17 < 0 != ((v15 - v17 ^ v15) & (v17 ^ v15)) < 0) {
                // 0x100003a70
                v14 = *(int64_t *)(8 * (int64_t)v15 + result);
                *(char *)(v14 + (int64_t)v21) = 32;
                v15++;
                v16 = *v8;
                v17 = v16 + v5;
            }
            // 0x100003a44
            v13 = *v1;
            v9 = v16;
        }
        // 0x100003aa8
        v18 = v13;
        v19 = v21 + 1;
        v20 = v18 + v5;
    }
    // 0x100003ab8
    return result;
}

// Address range: 0x100003ac0 - 0x100003c8c
int64_t function_100003ac0(void) {
    // 0x100003ac0
    int64_t v1; // 0x100003ac0
    int64_t result; // 0x100003ac0
    switch ((int32_t)v1) {
        case 1: {
            // 0x100003b04
            function_1000039b8();
            function_100003ac0();
        }
        default: {
            // 0x100003b44
            function_1000039b8();
            int32_t v2 = 0; // 0x100003c74
            int64_t v3; // 0x100003c54
            for (int32_t i = 0; i < 3; i++) {
                // 0x100003b98
                v3 = function_100003ac0();
            }
            // 0x100003c70
            v2++;
            result = v3;
            while (v2 != 3) {
                for (int32_t i = 0; i < 3; i++) {
                    // 0x100003b98
                    v3 = function_100003ac0();
                }
                // 0x100003c70
                v2++;
                result = v3;
            }
        }
        case 0: {
            // 0x100003c80
            return result;
        }
    }
}

// Address range: 0x100003c8c - 0x100003cf8
int64_t function_100003c8c(void) {
    int64_t result = 1; // 0x100003cac
    int64_t v1; // 0x100003c8c
    if ((int32_t)v1 != 0) {
        // 0x100003cc0
        result = function_100003c8c() * v1 & 0xffffffff;
    }
    // 0x100003ce8
    return result;
}

// Address range: 0x100003cf8 - 0x100003e48
int64_t function_100003cf8(void) {
    int64_t v1 = function_100003c8c(); // 0x100003d1c
    int32_t v2 = v1; // 0x100003d20
    int64_t * v3 = _calloc(v2, 8); // 0x100003d2c
    int64_t v4; // 0x100003cf8
    *(int64_t *)v4 = (int64_t)v3;
    if (v3 == NULL) {
        // 0x100003e38
        return 0xffffffff;
    }
    int32_t v5 = -v2;
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003e38
        return v1 & 0xffffffff;
    }
    char v6 = v4;
    int32_t v7 = 1 - v2;
    int32_t v8 = 0; // 0x100003e20
    int64_t * v9 = _calloc(v2, 1); // 0x100003d84
    int64_t v10 = (int64_t)v9; // 0x100003d84
    int64_t * v11 = (int64_t *)(8 * (int64_t)v8 + v10); // 0x100003d94
    *v11 = v10;
    while (v9 != NULL) {
        // 0x100003de4
        *(char *)v9 = v6;
        int32_t v12 = 1; // 0x100003ddc
        if (v7 < 0 != (v7 & v2) < 0) {
            *(char *)(*v11 + (int64_t)v12) = v6;
            int32_t v13 = v12 + 1; // 0x100003e0c
            int32_t v14 = v13 - v2; // 0x100003dd4
            v12 = v13;
            while (v14 < 0 != ((v14 ^ v13) & (v13 ^ v2)) < 0) {
                // 0x100003de4
                *(char *)(*v11 + (int64_t)v12) = v6;
                v13 = v12 + 1;
                v14 = v13 - v2;
                v12 = v13;
            }
        }
        // 0x100003e1c
        v8++;
        int32_t v15 = v8 - v2; // 0x100003d6c
        if (v15 < 0 == ((v15 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003e38
            return v1 & 0xffffffff;
        }
        v9 = _calloc(v2, 1);
        v10 = (int64_t)v9;
        v11 = (int64_t *)(8 * (int64_t)v8 + v10);
        *v11 = v10;
    }
    // 0x100003e38
    return 0xffffffff;
}

// Address range: 0x100003e48 - 0x100003ebc
int64_t function_100003e48(void) {
    // 0x100003e48
    int64_t v1; // 0x100003e48
    int32_t v2 = v1; // 0x100003e58
    int32_t v3 = -v2; // 0x100003e6c
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003eb0
        int64_t result; // 0x100003e48
        return result;
    }
    int32_t v4 = 0; // 0x100003ea4
    int32_t result2 = _printf("%s\n", (char *)v1); // 0x100003e98
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003e7c
        result2 = _printf("%s\n", (char *)v1);
        v4++;
    }
    // 0x100003eb0
    return result2;
}

// Address range: 0x100003ebc - 0x100003f78
int64_t entry_point(void) {
    int64_t result = 1; // 0x100003ef4
    if ((int32_t)function_100003cf8() != -1) {
        // 0x100003f08
        function_100003ac0();
        function_100003e48();
        int64_t v1; // 0x100003ebc
        _free((int64_t *)v1);
        result = 0;
    }
    // 0x100003f68
    return result;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t * function_100003f78(int32_t nmemb, int32_t size) {
    // 0x100003f78
    return _calloc(nmemb, size);
}

// Address range: 0x100003f84 - 0x100003f90
void function_100003f84(int64_t * ptr) {
    // 0x100003f84
    _free(ptr);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct IntArray_t {
    int *ptr;
    size_t length;
} IntArray;

IntArray make(size_t size) {
    IntArray temp;
    temp.ptr = calloc(size, sizeof(int));
    temp.length = size;
    return temp;
}

void destroy(IntArray *ia) {
    if (ia->ptr != NULL) {
        free(ia->ptr);

        ia->ptr = NULL;
        ia->length = 0;
    }
}

void zeroFill(IntArray dst) {
    memset(dst.ptr, 0, dst.length * sizeof(int));
}

int indexOf(const int n, const IntArray ia) {
    size_t i;
    for (i = 0; i < ia.length; i++) {
        if (ia.ptr[i] == n) {
            return i;
        }
    }
    return -1;
}

bool getDigits(int n, int le, IntArray digits) {
    while (n > 0) {
        int r = n % 10;
        if (r == 0 || indexOf(r, digits) >= 0) {
            return false;
        }
        le--;
        digits.ptr[le] = r;
        n /= 10;
    }
    return true;
}

int removeDigit(IntArray digits, size_t le, size_t idx) {
    static const int POWS[] = { 1, 10, 100, 1000, 10000 };
    int sum = 0;
    int pow = POWS[le - 2];
    size_t i;
    for (i = 0; i < le; i++) {
        if (i == idx) continue;
        sum += digits.ptr[i] * pow;
        pow /= 10;
    }
    return sum;
}

int main() {
    int lims[4][2] = { { 12, 97 }, { 123, 986 }, { 1234, 9875 }, { 12345, 98764 } };
    int count[5] = { 0 };
    int omitted[5][10] = { {0} };
    size_t upperBound = sizeof(lims) / sizeof(lims[0]);
    size_t i;

    for (i = 0; i < upperBound; i++) {
        IntArray nDigits = make(i + 2);
        IntArray dDigits = make(i + 2);
        int n;

        for (n = lims[i][0]; n <= lims[i][1]; n++) {
            int d;
            bool nOk;

            zeroFill(nDigits);
            nOk = getDigits(n, i + 2, nDigits);
            if (!nOk) {
                continue;
            }
            for (d = n + 1; d <= lims[i][1] + 1; d++) {
                size_t nix;
                bool dOk;

                zeroFill(dDigits);
                dOk = getDigits(d, i + 2, dDigits);
                if (!dOk) {
                    continue;
                }
                for (nix = 0; nix < nDigits.length; nix++) {
                    int digit = nDigits.ptr[nix];
                    int dix = indexOf(digit, dDigits);
                    if (dix >= 0) {
                        int rn = removeDigit(nDigits, i + 2, nix);
                        int rd = removeDigit(dDigits, i + 2, dix);
                        if ((double)n / d == (double)rn / rd) {
                            count[i]++;
                            omitted[i][digit]++;
                            if (count[i] <= 12) {
                                printf("%d/%d = %d/%d by omitting %d's\n", n, d, rn, rd, digit);
                            }
                        }
                    }
                }
            }
        }

        printf("\n");

        destroy(&nDigits);
        destroy(&dDigits);
    }

    for (i = 2; i <= 5; i++) {
        int j;

        printf("There are %d %d-digit fractions of which:\n", count[i - 2], i);

        for (j = 1; j <= 9; j++) {
            if (omitted[i - 2][j] == 0) {
                continue;
            }
            printf("%6d have %d's omitted\n", omitted[i - 2][j], j);
        }

        printf("\n");
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036b4(int64_t a1);
int64_t function_1000036f0(void);
int64_t function_100003744(int64_t a1, int64_t a2);
int64_t function_10000377c(void);
int64_t function_100003804(void);
int64_t function_1000038f0(void);
int64_t function_100003eb0(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ebc(int64_t a1);
int64_t * function_100003ec8(int32_t nmemb, int32_t size);
void function_100003ed4(int64_t * ptr);
int64_t * function_100003ee0(int64_t * s, int32_t c, int32_t n);
int32_t function_100003eec(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0xa00000001; // 0x100003ef8
float128_t g2 = 2.05833591729560202315899033371850082e-312L; // 0x100003f0c
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000036b4 - 0x1000036f0
int64_t function_1000036b4(int64_t a1) {
    // 0x1000036b4
    return (int64_t)_calloc((int32_t)a1, 4);
}

// Address range: 0x1000036f0 - 0x100003744
int64_t function_1000036f0(void) {
    int64_t result = 0; // 0x100003710
    int64_t v1; // 0x1000036f0
    if (v1 != 0) {
        int64_t * v2 = (int64_t *)v1; // 0x100003720
        _free(v2);
        *v2 = 0;
        *(int64_t *)(v1 + 8) = 0;
        result = &g3;
    }
    // 0x100003738
    return result;
}

// Address range: 0x100003744 - 0x10000377c
int64_t function_100003744(int64_t a1, int64_t a2) {
    // 0x100003744
    return ___memset_chk(a1, 0, 4 * a2, -1);
}

// Address range: 0x10000377c - 0x100003804
int64_t function_10000377c(void) {
    // 0x10000377c
    int64_t v1; // 0x10000377c
    uint64_t v2 = v1;
    int64_t v3 = 0; // 0x1000037a4
    if (v2 == 0) {
        // 0x1000037f8
        return 0xffffffff;
    }
    uint32_t result = 0;
    while (*(int32_t *)(4 * v3 + v1) != (int32_t)v1) {
        int32_t v4 = result + 1; // 0x1000037e0
        v3 = v4;
        if (v2 <= v3) {
            // 0x1000037f8
            return 0xffffffff;
        }
        result = v4;
    }
    // 0x1000037f8
    return result;
}

// Address range: 0x100003804 - 0x1000038f0
int64_t function_100003804(void) {
    // 0x100003804
    int64_t v1; // 0x100003804
    int32_t v2 = v1; // 0x100003818
    if (v2 < 1) {
        // 0x1000038dc
        return 1;
    }
    int32_t v3 = v1; // 0x10000389c
    uint32_t v4 = v2;
    uint32_t v5 = v4 % 10;
    int64_t result = 0; // 0x10000385c
    while (v5 != 0) {
        // 0x100003864
        result = 0;
        if ((int32_t)function_10000377c() >= 0) {
            // break -> 0x1000038dc
            break;
        }
        // 0x100003898
        v3--;
        *(int32_t *)(4 * (int64_t)v3 + v1) = v5;
        result = 1;
        if (v4 < 10) {
            // break -> 0x1000038dc
            break;
        }
        v4 /= 10;
        v5 = v4 % 10;
        result = 0;
    }
    // 0x1000038dc
    return result;
}

// Address range: 0x1000038f0 - 0x1000039ac
int64_t function_1000038f0(void) {
    // 0x1000038f0
    int64_t v1; // 0x1000038f0
    if (v1 == 0) {
        // 0x1000039a0
        return 0;
    }
    int32_t v2 = *(int32_t *)(4 * v1 + (int64_t)&g1 - 8); // 0x100003918
    int32_t v3 = 0;
    int64_t v4 = 0;
    int32_t v5 = v3; // 0x100003950
    int32_t v6 = v2; // 0x100003950
    int32_t v7; // 0x100003964
    if (v4 != v1) {
        // 0x10000395c
        v7 = *(int32_t *)(4 * v4 + v1);
        v5 = v7 * v2 + v3;
        v6 = v2 / 10;
    }
    int32_t result = v5;
    int64_t v8 = v4 + 1; // 0x100003994
    while (v8 != v1) {
        // 0x100003940
        v3 = result;
        int32_t v9 = v6;
        v4 = v8;
        v5 = v3;
        v6 = v9;
        if (v4 != v1) {
            // 0x10000395c
            v7 = *(int32_t *)(4 * v4 + v1);
            v5 = v7 * v9 + v3;
            v6 = v9 / 10;
        }
        // 0x100003990
        result = v5;
        v8 = v4 + 1;
    }
    // 0x1000039a0
    return result;
}

// Address range: 0x1000039ac - 0x100003eb0
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000039c8
    int64_t v2 = (float64_t)g2; // bp-80, 0x1000039e4
    int64_t v3 = 0; // bp-104, 0x1000039f0
    int64_t v4; // bp-304, 0x1000039ac
    _memset(&v4, 0, 200);
    int64_t v5 = &v4;
    int64_t v6 = 0;
    int64_t v7 = 0;
    int64_t v8 = v7 + 2; // 0x100003a34
    int64_t v9 = function_1000036b4(v8); // 0x100003a38
    int64_t v10 = function_1000036b4(v8); // 0x100003a4c
    int64_t v11 = 8 * v7 + (int64_t)&v2; // 0x100003a64
    int32_t v12 = *(int32_t *)v11; // 0x100003a64
    int32_t * v13 = (int32_t *)(v11 | 4); // 0x100003a80
    int32_t v14 = *v13; // 0x100003a80
    int32_t v15 = v12 - v14; // 0x100003a84
    float64_t v16; // 0x1000039ac
    float64_t v17 = v16; // 0x100003a8c
    float64_t v18; // 0x1000039ac
    float64_t v19 = v18; // 0x100003a8c
    int64_t v20 = v6; // 0x100003a8c
    int64_t v21 = 200; // 0x100003a8c
    int32_t v22; // 0x1000039ac
    int32_t v23; // 0x1000039ac
    int32_t v24; // 0x1000039ac
    float64_t v25; // 0x1000039ac
    float64_t v26; // 0x1000039ac
    float64_t v27; // 0x1000039ac
    float64_t v28; // 0x1000039ac
    float64_t v29; // 0x1000039ac
    float64_t v30; // 0x1000039ac
    float64_t v31; // 0x1000039ac
    float64_t v32; // 0x1000039ac
    float64_t v33; // 0x1000039ac
    float64_t v34; // 0x1000039ac
    float64_t v35; // 0x1000039ac
    float64_t v36; // 0x1000039ac
    float64_t v37; // 0x1000039ac
    float64_t v38; // 0x1000039ac
    float64_t v39; // 0x1000039ac
    float64_t v40; // 0x1000039ac
    float64_t v41; // 0x1000039ac
    float64_t v42; // 0x1000039ac
    int32_t v43; // 0x1000039ac
    int32_t v44; // 0x1000039ac
    int32_t v45; // 0x1000039ac
    int32_t v46; // 0x1000039ac
    int64_t v47; // 0x1000039ac
    int64_t v48; // 0x1000039ac
    int32_t * v49; // 0x1000039ac
    int64_t v50; // 0x1000039ac
    int32_t v51; // 0x100003af8
    int32_t v52; // 0x100003afc
    int32_t v53; // 0x100003b00
    int32_t v54; // 0x100003a84
    int32_t v55; // 0x100003af8
    int32_t v56; // 0x100003afc
    int32_t v57; // 0x100003b00
    int32_t v58; // 0x100003b7c
    int64_t v59; // 0x100003b90
    int64_t v60; // 0x100003cf8
    float64_t v61; // 0x100003c04
    float64_t v62; // 0x100003c28
    int32_t * v63; // 0x100003c74
    int32_t v64; // 0x100003c84
    float64_t v65; // 0x1000039ac
    int32_t v66; // 0x100003c88
    int64_t v67; // 0x1000039ac
    int64_t v68; // 0x1000039ac
    int64_t v69; // 0x1000039ac
    int64_t v70; // 0x1000039ac
    int64_t v71; // 0x1000039ac
    int64_t v72; // 0x1000039ac
    if (v15 == 0 || v15 < 0 != ((v15 ^ v12) & (v14 ^ v12)) < 0) {
        // 0x100003a94
        v49 = (int32_t *)(4 * v7 + (int64_t)&v3);
        v50 = 40 * v7 + v5;
        v46 = v12;
        function_100003744(v9, v6);
        if (function_100003804() % 2 == 0) {
            // 0x100003a94
            v22 = v46 + 1;
            v24 = *v13;
            v32 = v16;
            v41 = v18;
            v69 = v8;
            v72 = v9;
        } else {
            // 0x100003ae8
            v44 = v46 + 1;
            v51 = *v13;
            v52 = v51 + 1;
            v53 = v44 - v52;
            v45 = v44;
            v22 = v44;
            v24 = v51;
            v32 = v16;
            v41 = v18;
            v69 = v8;
            v72 = v9;
            if (v53 == 0 || v53 < 0 != ((v53 ^ v44) & (v52 ^ v44)) < 0) {
                function_100003744(v10, v6);
                v31 = v16;
                v40 = v18;
                v68 = v8;
                v71 = v10;
                if (function_100003804() % 2 != 0) {
                    // 0x100003b5c
                    v47 = 0;
                    v31 = v16;
                    v40 = v18;
                    v68 = v8;
                    v71 = v10;
                    if (v6 != 0) {
                        v58 = *(int32_t *)(4 * v47 + v9);
                        v59 = function_10000377c();
                        v30 = v16;
                        v39 = v18;
                        v67 = v10;
                        v70 = v6;
                        if ((int32_t)v59 >= 0) {
                            // 0x100003bac
                            function_1000038f0();
                            function_1000038f0();
                            __asm_sshll(0.0f, 0);
                            __asm_sshll(0.0f, 0);
                            v61 = v16 / v18;
                            __asm_sshll(0.0f, 0);
                            __asm_sshll(0.0f, 0);
                            v62 = v18 / v65;
                            v30 = v61;
                            v39 = v62;
                            v67 = v6;
                            v70 = v8;
                            if (v61 == v62) {
                                // 0x100003c3c
                                *v49 = *v49 + 1;
                                v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                *v63 = *v63 + 1;
                                v64 = *v49;
                                v66 = v64 - 12;
                                v30 = v61;
                                v39 = v62;
                                v67 = v6;
                                v70 = v8;
                                if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                    // 0x100003c98
                                    _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                }
                            }
                        }
                        // 0x100003cf4
                        v60 = v47 + 1;
                        v47 = v60;
                        v31 = v30;
                        v40 = v39;
                        v68 = v67;
                        v71 = v70;
                        while (v60 != v6) {
                            // 0x100003b74
                            v29 = v30;
                            v38 = v39;
                            v58 = *(int32_t *)(4 * v47 + v9);
                            v59 = function_10000377c();
                            v30 = v29;
                            v39 = v38;
                            v67 = v10;
                            v70 = v6;
                            if ((int32_t)v59 >= 0) {
                                // 0x100003bac
                                function_1000038f0();
                                function_1000038f0();
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v61 = v29 / v38;
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v62 = v38 / v65;
                                v30 = v61;
                                v39 = v62;
                                v67 = v6;
                                v70 = v8;
                                if (v61 == v62) {
                                    // 0x100003c3c
                                    *v49 = *v49 + 1;
                                    v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                    *v63 = *v63 + 1;
                                    v64 = *v49;
                                    v66 = v64 - 12;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                        // 0x100003c98
                                        _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                    }
                                }
                            }
                            // 0x100003cf4
                            v60 = v47 + 1;
                            v47 = v60;
                            v31 = v30;
                            v40 = v39;
                            v68 = v67;
                            v71 = v70;
                        }
                    }
                }
                // 0x100003d08
                v43 = v45 + 1;
                v55 = *v13;
                v56 = v55 + 1;
                v57 = v43 - v56;
                v45 = v43;
                v22 = v44;
                v24 = v55;
                v32 = v31;
                v41 = v40;
                v69 = v68;
                v72 = v71;
                while (v57 == 0 || v57 < 0 != ((v57 ^ v43) & (v56 ^ v43)) < 0) {
                    // 0x100003b10
                    v27 = v31;
                    v36 = v40;
                    function_100003744(v10, v6);
                    v31 = v27;
                    v40 = v36;
                    v68 = v8;
                    v71 = v10;
                    if (function_100003804() % 2 != 0) {
                        // 0x100003b5c
                        v47 = 0;
                        v37 = v36;
                        v28 = v27;
                        v31 = v27;
                        v40 = v36;
                        v68 = v8;
                        v71 = v10;
                        if (v6 != 0) {
                            v29 = v28;
                            v38 = v37;
                            v58 = *(int32_t *)(4 * v47 + v9);
                            v59 = function_10000377c();
                            v30 = v29;
                            v39 = v38;
                            v67 = v10;
                            v70 = v6;
                            if ((int32_t)v59 >= 0) {
                                // 0x100003bac
                                function_1000038f0();
                                function_1000038f0();
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v61 = v29 / v38;
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v62 = v38 / v65;
                                v30 = v61;
                                v39 = v62;
                                v67 = v6;
                                v70 = v8;
                                if (v61 == v62) {
                                    // 0x100003c3c
                                    *v49 = *v49 + 1;
                                    v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                    *v63 = *v63 + 1;
                                    v64 = *v49;
                                    v66 = v64 - 12;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                        // 0x100003c98
                                        _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                    }
                                }
                            }
                            // 0x100003cf4
                            v60 = v47 + 1;
                            v47 = v60;
                            v31 = v30;
                            v40 = v39;
                            v68 = v67;
                            v71 = v70;
                            while (v60 != v6) {
                                // 0x100003b74
                                v29 = v30;
                                v38 = v39;
                                v58 = *(int32_t *)(4 * v47 + v9);
                                v59 = function_10000377c();
                                v30 = v29;
                                v39 = v38;
                                v67 = v10;
                                v70 = v6;
                                if ((int32_t)v59 >= 0) {
                                    // 0x100003bac
                                    function_1000038f0();
                                    function_1000038f0();
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v61 = v29 / v38;
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v62 = v38 / v65;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v61 == v62) {
                                        // 0x100003c3c
                                        *v49 = *v49 + 1;
                                        v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                        *v63 = *v63 + 1;
                                        v64 = *v49;
                                        v66 = v64 - 12;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                            // 0x100003c98
                                            _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                        }
                                    }
                                }
                                // 0x100003cf4
                                v60 = v47 + 1;
                                v47 = v60;
                                v31 = v30;
                                v40 = v39;
                                v68 = v67;
                                v71 = v70;
                            }
                        }
                    }
                    // 0x100003d08
                    v43 = v45 + 1;
                    v55 = *v13;
                    v56 = v55 + 1;
                    v57 = v43 - v56;
                    v45 = v43;
                    v22 = v44;
                    v24 = v55;
                    v32 = v31;
                    v41 = v40;
                    v69 = v68;
                    v72 = v71;
                }
            }
        }
        // 0x100003d1c
        v42 = v41;
        v33 = v32;
        v23 = v22;
        v54 = v23 - v24;
        v17 = v33;
        v19 = v42;
        v20 = v69;
        v21 = v72;
        while (v54 == 0 || v54 < 0 != ((v54 ^ v23) & (v24 ^ v23)) < 0) {
            // 0x100003a94
            v25 = v33;
            v34 = v42;
            v46 = v23;
            function_100003744(v9, v6);
            if (function_100003804() % 2 == 0) {
                // 0x100003a94
                v22 = v46 + 1;
                v24 = *v13;
                v32 = v25;
                v41 = v34;
                v69 = v8;
                v72 = v9;
            } else {
                // 0x100003ae8
                v44 = v46 + 1;
                v51 = *v13;
                v52 = v51 + 1;
                v53 = v44 - v52;
                v45 = v44;
                v35 = v34;
                v26 = v25;
                v22 = v44;
                v24 = v51;
                v32 = v25;
                v41 = v34;
                v69 = v8;
                v72 = v9;
                if (v53 == 0 || v53 < 0 != ((v53 ^ v44) & (v52 ^ v44)) < 0) {
                    v27 = v26;
                    v36 = v35;
                    function_100003744(v10, v6);
                    v31 = v27;
                    v40 = v36;
                    v68 = v8;
                    v71 = v10;
                    if (function_100003804() % 2 != 0) {
                        // 0x100003b5c
                        v47 = 0;
                        v37 = v36;
                        v28 = v27;
                        v31 = v27;
                        v40 = v36;
                        v68 = v8;
                        v71 = v10;
                        if (v6 != 0) {
                            v29 = v28;
                            v38 = v37;
                            v58 = *(int32_t *)(4 * v47 + v9);
                            v59 = function_10000377c();
                            v30 = v29;
                            v39 = v38;
                            v67 = v10;
                            v70 = v6;
                            if ((int32_t)v59 >= 0) {
                                // 0x100003bac
                                function_1000038f0();
                                function_1000038f0();
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v61 = v29 / v38;
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v62 = v38 / v65;
                                v30 = v61;
                                v39 = v62;
                                v67 = v6;
                                v70 = v8;
                                if (v61 == v62) {
                                    // 0x100003c3c
                                    *v49 = *v49 + 1;
                                    v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                    *v63 = *v63 + 1;
                                    v64 = *v49;
                                    v66 = v64 - 12;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                        // 0x100003c98
                                        _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                    }
                                }
                            }
                            // 0x100003cf4
                            v60 = v47 + 1;
                            v47 = v60;
                            v31 = v30;
                            v40 = v39;
                            v68 = v67;
                            v71 = v70;
                            while (v60 != v6) {
                                // 0x100003b74
                                v29 = v30;
                                v38 = v39;
                                v58 = *(int32_t *)(4 * v47 + v9);
                                v59 = function_10000377c();
                                v30 = v29;
                                v39 = v38;
                                v67 = v10;
                                v70 = v6;
                                if ((int32_t)v59 >= 0) {
                                    // 0x100003bac
                                    function_1000038f0();
                                    function_1000038f0();
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v61 = v29 / v38;
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v62 = v38 / v65;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v61 == v62) {
                                        // 0x100003c3c
                                        *v49 = *v49 + 1;
                                        v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                        *v63 = *v63 + 1;
                                        v64 = *v49;
                                        v66 = v64 - 12;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                            // 0x100003c98
                                            _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                        }
                                    }
                                }
                                // 0x100003cf4
                                v60 = v47 + 1;
                                v47 = v60;
                                v31 = v30;
                                v40 = v39;
                                v68 = v67;
                                v71 = v70;
                            }
                        }
                    }
                    // 0x100003d08
                    v43 = v45 + 1;
                    v55 = *v13;
                    v56 = v55 + 1;
                    v57 = v43 - v56;
                    v45 = v43;
                    v22 = v44;
                    v24 = v55;
                    v32 = v31;
                    v41 = v40;
                    v69 = v68;
                    v72 = v71;
                    while (v57 == 0 || v57 < 0 != ((v57 ^ v43) & (v56 ^ v43)) < 0) {
                        // 0x100003b10
                        v27 = v31;
                        v36 = v40;
                        function_100003744(v10, v6);
                        v31 = v27;
                        v40 = v36;
                        v68 = v8;
                        v71 = v10;
                        if (function_100003804() % 2 != 0) {
                            // 0x100003b5c
                            v47 = 0;
                            v37 = v36;
                            v28 = v27;
                            v31 = v27;
                            v40 = v36;
                            v68 = v8;
                            v71 = v10;
                            if (v6 != 0) {
                                v29 = v28;
                                v38 = v37;
                                v58 = *(int32_t *)(4 * v47 + v9);
                                v59 = function_10000377c();
                                v30 = v29;
                                v39 = v38;
                                v67 = v10;
                                v70 = v6;
                                if ((int32_t)v59 >= 0) {
                                    // 0x100003bac
                                    function_1000038f0();
                                    function_1000038f0();
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v61 = v29 / v38;
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v62 = v38 / v65;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v61 == v62) {
                                        // 0x100003c3c
                                        *v49 = *v49 + 1;
                                        v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                        *v63 = *v63 + 1;
                                        v64 = *v49;
                                        v66 = v64 - 12;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                            // 0x100003c98
                                            _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                        }
                                    }
                                }
                                // 0x100003cf4
                                v60 = v47 + 1;
                                v47 = v60;
                                v31 = v30;
                                v40 = v39;
                                v68 = v67;
                                v71 = v70;
                                while (v60 != v6) {
                                    // 0x100003b74
                                    v29 = v30;
                                    v38 = v39;
                                    v58 = *(int32_t *)(4 * v47 + v9);
                                    v59 = function_10000377c();
                                    v30 = v29;
                                    v39 = v38;
                                    v67 = v10;
                                    v70 = v6;
                                    if ((int32_t)v59 >= 0) {
                                        // 0x100003bac
                                        function_1000038f0();
                                        function_1000038f0();
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v61 = v29 / v38;
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v62 = v38 / v65;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v61 == v62) {
                                            // 0x100003c3c
                                            *v49 = *v49 + 1;
                                            v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                            *v63 = *v63 + 1;
                                            v64 = *v49;
                                            v66 = v64 - 12;
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                            if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                                // 0x100003c98
                                                _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                                v30 = v61;
                                                v39 = v62;
                                                v67 = v6;
                                                v70 = v8;
                                            }
                                        }
                                    }
                                    // 0x100003cf4
                                    v60 = v47 + 1;
                                    v47 = v60;
                                    v31 = v30;
                                    v40 = v39;
                                    v68 = v67;
                                    v71 = v70;
                                }
                            }
                        }
                        // 0x100003d08
                        v43 = v45 + 1;
                        v55 = *v13;
                        v56 = v55 + 1;
                        v57 = v43 - v56;
                        v45 = v43;
                        v22 = v44;
                        v24 = v55;
                        v32 = v31;
                        v41 = v40;
                        v69 = v68;
                        v72 = v71;
                    }
                }
            }
            // 0x100003d1c
            v42 = v41;
            v33 = v32;
            v23 = v22;
            v54 = v23 - v24;
            v17 = v33;
            v19 = v42;
            v20 = v69;
            v21 = v72;
        }
    }
    int64_t v73 = v21;
    int64_t v74 = v20;
    _printf("\n");
    function_1000036f0();
    function_1000036f0();
    int64_t v75 = v7 + 1; // 0x100003d50
    while (v75 != 4) {
        float64_t v76 = v17;
        float64_t v77 = v19;
        v6 = v74;
        v7 = v75;
        v8 = v7 + 2;
        v9 = function_1000036b4(v8);
        v10 = function_1000036b4(v8);
        v11 = 8 * v7 + (int64_t)&v2;
        v12 = *(int32_t *)v11;
        v13 = (int32_t *)(v11 | 4);
        v14 = *v13;
        v15 = v12 - v14;
        v17 = v76;
        v19 = v77;
        v20 = v6;
        v21 = v73;
        if (v15 == 0 || v15 < 0 != ((v15 ^ v12) & (v14 ^ v12)) < 0) {
            // 0x100003a94
            v49 = (int32_t *)(4 * v7 + (int64_t)&v3);
            v50 = 40 * v7 + v5;
            v25 = v76;
            v34 = v77;
            v46 = v12;
            function_100003744(v9, v6);
            if (function_100003804() % 2 == 0) {
                // 0x100003a94
                v22 = v46 + 1;
                v24 = *v13;
                v32 = v25;
                v41 = v34;
                v69 = v8;
                v72 = v9;
            } else {
                // 0x100003ae8
                v44 = v46 + 1;
                v51 = *v13;
                v52 = v51 + 1;
                v53 = v44 - v52;
                v45 = v44;
                v35 = v34;
                v26 = v25;
                v22 = v44;
                v24 = v51;
                v32 = v25;
                v41 = v34;
                v69 = v8;
                v72 = v9;
                if (v53 == 0 || v53 < 0 != ((v53 ^ v44) & (v52 ^ v44)) < 0) {
                    v27 = v26;
                    v36 = v35;
                    function_100003744(v10, v6);
                    v31 = v27;
                    v40 = v36;
                    v68 = v8;
                    v71 = v10;
                    if (function_100003804() % 2 != 0) {
                        // 0x100003b5c
                        v47 = 0;
                        v37 = v36;
                        v28 = v27;
                        v31 = v27;
                        v40 = v36;
                        v68 = v8;
                        v71 = v10;
                        if (v6 != 0) {
                            v29 = v28;
                            v38 = v37;
                            v58 = *(int32_t *)(4 * v47 + v9);
                            v59 = function_10000377c();
                            v30 = v29;
                            v39 = v38;
                            v67 = v10;
                            v70 = v6;
                            if ((int32_t)v59 >= 0) {
                                // 0x100003bac
                                function_1000038f0();
                                function_1000038f0();
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v61 = v29 / v38;
                                __asm_sshll(0.0f, 0);
                                __asm_sshll(0.0f, 0);
                                v62 = v38 / v65;
                                v30 = v61;
                                v39 = v62;
                                v67 = v6;
                                v70 = v8;
                                if (v61 == v62) {
                                    // 0x100003c3c
                                    *v49 = *v49 + 1;
                                    v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                    *v63 = *v63 + 1;
                                    v64 = *v49;
                                    v66 = v64 - 12;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                        // 0x100003c98
                                        _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                    }
                                }
                            }
                            // 0x100003cf4
                            v60 = v47 + 1;
                            v47 = v60;
                            v31 = v30;
                            v40 = v39;
                            v68 = v67;
                            v71 = v70;
                            while (v60 != v6) {
                                // 0x100003b74
                                v29 = v30;
                                v38 = v39;
                                v58 = *(int32_t *)(4 * v47 + v9);
                                v59 = function_10000377c();
                                v30 = v29;
                                v39 = v38;
                                v67 = v10;
                                v70 = v6;
                                if ((int32_t)v59 >= 0) {
                                    // 0x100003bac
                                    function_1000038f0();
                                    function_1000038f0();
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v61 = v29 / v38;
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v62 = v38 / v65;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v61 == v62) {
                                        // 0x100003c3c
                                        *v49 = *v49 + 1;
                                        v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                        *v63 = *v63 + 1;
                                        v64 = *v49;
                                        v66 = v64 - 12;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                            // 0x100003c98
                                            _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                        }
                                    }
                                }
                                // 0x100003cf4
                                v60 = v47 + 1;
                                v47 = v60;
                                v31 = v30;
                                v40 = v39;
                                v68 = v67;
                                v71 = v70;
                            }
                        }
                    }
                    // 0x100003d08
                    v43 = v45 + 1;
                    v55 = *v13;
                    v56 = v55 + 1;
                    v57 = v43 - v56;
                    v45 = v43;
                    v22 = v44;
                    v24 = v55;
                    v32 = v31;
                    v41 = v40;
                    v69 = v68;
                    v72 = v71;
                    while (v57 == 0 || v57 < 0 != ((v57 ^ v43) & (v56 ^ v43)) < 0) {
                        // 0x100003b10
                        v27 = v31;
                        v36 = v40;
                        function_100003744(v10, v6);
                        v31 = v27;
                        v40 = v36;
                        v68 = v8;
                        v71 = v10;
                        if (function_100003804() % 2 != 0) {
                            // 0x100003b5c
                            v47 = 0;
                            v37 = v36;
                            v28 = v27;
                            v31 = v27;
                            v40 = v36;
                            v68 = v8;
                            v71 = v10;
                            if (v6 != 0) {
                                v29 = v28;
                                v38 = v37;
                                v58 = *(int32_t *)(4 * v47 + v9);
                                v59 = function_10000377c();
                                v30 = v29;
                                v39 = v38;
                                v67 = v10;
                                v70 = v6;
                                if ((int32_t)v59 >= 0) {
                                    // 0x100003bac
                                    function_1000038f0();
                                    function_1000038f0();
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v61 = v29 / v38;
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v62 = v38 / v65;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v61 == v62) {
                                        // 0x100003c3c
                                        *v49 = *v49 + 1;
                                        v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                        *v63 = *v63 + 1;
                                        v64 = *v49;
                                        v66 = v64 - 12;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                            // 0x100003c98
                                            _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                        }
                                    }
                                }
                                // 0x100003cf4
                                v60 = v47 + 1;
                                v47 = v60;
                                v31 = v30;
                                v40 = v39;
                                v68 = v67;
                                v71 = v70;
                                while (v60 != v6) {
                                    // 0x100003b74
                                    v29 = v30;
                                    v38 = v39;
                                    v58 = *(int32_t *)(4 * v47 + v9);
                                    v59 = function_10000377c();
                                    v30 = v29;
                                    v39 = v38;
                                    v67 = v10;
                                    v70 = v6;
                                    if ((int32_t)v59 >= 0) {
                                        // 0x100003bac
                                        function_1000038f0();
                                        function_1000038f0();
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v61 = v29 / v38;
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v62 = v38 / v65;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v61 == v62) {
                                            // 0x100003c3c
                                            *v49 = *v49 + 1;
                                            v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                            *v63 = *v63 + 1;
                                            v64 = *v49;
                                            v66 = v64 - 12;
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                            if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                                // 0x100003c98
                                                _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                                v30 = v61;
                                                v39 = v62;
                                                v67 = v6;
                                                v70 = v8;
                                            }
                                        }
                                    }
                                    // 0x100003cf4
                                    v60 = v47 + 1;
                                    v47 = v60;
                                    v31 = v30;
                                    v40 = v39;
                                    v68 = v67;
                                    v71 = v70;
                                }
                            }
                        }
                        // 0x100003d08
                        v43 = v45 + 1;
                        v55 = *v13;
                        v56 = v55 + 1;
                        v57 = v43 - v56;
                        v45 = v43;
                        v22 = v44;
                        v24 = v55;
                        v32 = v31;
                        v41 = v40;
                        v69 = v68;
                        v72 = v71;
                    }
                }
            }
            // 0x100003d1c
            v42 = v41;
            v33 = v32;
            v23 = v22;
            v54 = v23 - v24;
            v17 = v33;
            v19 = v42;
            v20 = v69;
            v21 = v72;
            while (v54 == 0 || v54 < 0 != ((v54 ^ v23) & (v24 ^ v23)) < 0) {
                // 0x100003a94
                v25 = v33;
                v34 = v42;
                v46 = v23;
                function_100003744(v9, v6);
                if (function_100003804() % 2 == 0) {
                    // 0x100003a94
                    v22 = v46 + 1;
                    v24 = *v13;
                    v32 = v25;
                    v41 = v34;
                    v69 = v8;
                    v72 = v9;
                } else {
                    // 0x100003ae8
                    v44 = v46 + 1;
                    v51 = *v13;
                    v52 = v51 + 1;
                    v53 = v44 - v52;
                    v45 = v44;
                    v35 = v34;
                    v26 = v25;
                    v22 = v44;
                    v24 = v51;
                    v32 = v25;
                    v41 = v34;
                    v69 = v8;
                    v72 = v9;
                    if (v53 == 0 || v53 < 0 != ((v53 ^ v44) & (v52 ^ v44)) < 0) {
                        v27 = v26;
                        v36 = v35;
                        function_100003744(v10, v6);
                        v31 = v27;
                        v40 = v36;
                        v68 = v8;
                        v71 = v10;
                        if (function_100003804() % 2 != 0) {
                            // 0x100003b5c
                            v47 = 0;
                            v37 = v36;
                            v28 = v27;
                            v31 = v27;
                            v40 = v36;
                            v68 = v8;
                            v71 = v10;
                            if (v6 != 0) {
                                v29 = v28;
                                v38 = v37;
                                v58 = *(int32_t *)(4 * v47 + v9);
                                v59 = function_10000377c();
                                v30 = v29;
                                v39 = v38;
                                v67 = v10;
                                v70 = v6;
                                if ((int32_t)v59 >= 0) {
                                    // 0x100003bac
                                    function_1000038f0();
                                    function_1000038f0();
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v61 = v29 / v38;
                                    __asm_sshll(0.0f, 0);
                                    __asm_sshll(0.0f, 0);
                                    v62 = v38 / v65;
                                    v30 = v61;
                                    v39 = v62;
                                    v67 = v6;
                                    v70 = v8;
                                    if (v61 == v62) {
                                        // 0x100003c3c
                                        *v49 = *v49 + 1;
                                        v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                        *v63 = *v63 + 1;
                                        v64 = *v49;
                                        v66 = v64 - 12;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                            // 0x100003c98
                                            _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                        }
                                    }
                                }
                                // 0x100003cf4
                                v60 = v47 + 1;
                                v47 = v60;
                                v31 = v30;
                                v40 = v39;
                                v68 = v67;
                                v71 = v70;
                                while (v60 != v6) {
                                    // 0x100003b74
                                    v29 = v30;
                                    v38 = v39;
                                    v58 = *(int32_t *)(4 * v47 + v9);
                                    v59 = function_10000377c();
                                    v30 = v29;
                                    v39 = v38;
                                    v67 = v10;
                                    v70 = v6;
                                    if ((int32_t)v59 >= 0) {
                                        // 0x100003bac
                                        function_1000038f0();
                                        function_1000038f0();
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v61 = v29 / v38;
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v62 = v38 / v65;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v61 == v62) {
                                            // 0x100003c3c
                                            *v49 = *v49 + 1;
                                            v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                            *v63 = *v63 + 1;
                                            v64 = *v49;
                                            v66 = v64 - 12;
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                            if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                                // 0x100003c98
                                                _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                                v30 = v61;
                                                v39 = v62;
                                                v67 = v6;
                                                v70 = v8;
                                            }
                                        }
                                    }
                                    // 0x100003cf4
                                    v60 = v47 + 1;
                                    v47 = v60;
                                    v31 = v30;
                                    v40 = v39;
                                    v68 = v67;
                                    v71 = v70;
                                }
                            }
                        }
                        // 0x100003d08
                        v43 = v45 + 1;
                        v55 = *v13;
                        v56 = v55 + 1;
                        v57 = v43 - v56;
                        v45 = v43;
                        v22 = v44;
                        v24 = v55;
                        v32 = v31;
                        v41 = v40;
                        v69 = v68;
                        v72 = v71;
                        while (v57 == 0 || v57 < 0 != ((v57 ^ v43) & (v56 ^ v43)) < 0) {
                            // 0x100003b10
                            v27 = v31;
                            v36 = v40;
                            function_100003744(v10, v6);
                            v31 = v27;
                            v40 = v36;
                            v68 = v8;
                            v71 = v10;
                            if (function_100003804() % 2 != 0) {
                                // 0x100003b5c
                                v47 = 0;
                                v37 = v36;
                                v28 = v27;
                                v31 = v27;
                                v40 = v36;
                                v68 = v8;
                                v71 = v10;
                                if (v6 != 0) {
                                    v29 = v28;
                                    v38 = v37;
                                    v58 = *(int32_t *)(4 * v47 + v9);
                                    v59 = function_10000377c();
                                    v30 = v29;
                                    v39 = v38;
                                    v67 = v10;
                                    v70 = v6;
                                    if ((int32_t)v59 >= 0) {
                                        // 0x100003bac
                                        function_1000038f0();
                                        function_1000038f0();
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v61 = v29 / v38;
                                        __asm_sshll(0.0f, 0);
                                        __asm_sshll(0.0f, 0);
                                        v62 = v38 / v65;
                                        v30 = v61;
                                        v39 = v62;
                                        v67 = v6;
                                        v70 = v8;
                                        if (v61 == v62) {
                                            // 0x100003c3c
                                            *v49 = *v49 + 1;
                                            v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                            *v63 = *v63 + 1;
                                            v64 = *v49;
                                            v66 = v64 - 12;
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                            if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                                // 0x100003c98
                                                _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                                v30 = v61;
                                                v39 = v62;
                                                v67 = v6;
                                                v70 = v8;
                                            }
                                        }
                                    }
                                    // 0x100003cf4
                                    v60 = v47 + 1;
                                    v47 = v60;
                                    v31 = v30;
                                    v40 = v39;
                                    v68 = v67;
                                    v71 = v70;
                                    while (v60 != v6) {
                                        // 0x100003b74
                                        v29 = v30;
                                        v38 = v39;
                                        v58 = *(int32_t *)(4 * v47 + v9);
                                        v59 = function_10000377c();
                                        v30 = v29;
                                        v39 = v38;
                                        v67 = v10;
                                        v70 = v6;
                                        if ((int32_t)v59 >= 0) {
                                            // 0x100003bac
                                            function_1000038f0();
                                            function_1000038f0();
                                            __asm_sshll(0.0f, 0);
                                            __asm_sshll(0.0f, 0);
                                            v61 = v29 / v38;
                                            __asm_sshll(0.0f, 0);
                                            __asm_sshll(0.0f, 0);
                                            v62 = v38 / v65;
                                            v30 = v61;
                                            v39 = v62;
                                            v67 = v6;
                                            v70 = v8;
                                            if (v61 == v62) {
                                                // 0x100003c3c
                                                *v49 = *v49 + 1;
                                                v63 = (int32_t *)(v50 + 4 * (int64_t)v58);
                                                *v63 = *v63 + 1;
                                                v64 = *v49;
                                                v66 = v64 - 12;
                                                v30 = v61;
                                                v39 = v62;
                                                v67 = v6;
                                                v70 = v8;
                                                if (v66 == 0 || v66 < 0 != (11 - v64 & v64) < 0) {
                                                    // 0x100003c98
                                                    _printf("%d/%d = %d/%d by omitting %d's\n", v6, v8, 0x100000000 * v59 >> 32, v48, v48);
                                                    v30 = v61;
                                                    v39 = v62;
                                                    v67 = v6;
                                                    v70 = v8;
                                                }
                                            }
                                        }
                                        // 0x100003cf4
                                        v60 = v47 + 1;
                                        v47 = v60;
                                        v31 = v30;
                                        v40 = v39;
                                        v68 = v67;
                                        v71 = v70;
                                    }
                                }
                            }
                            // 0x100003d08
                            v43 = v45 + 1;
                            v55 = *v13;
                            v56 = v55 + 1;
                            v57 = v43 - v56;
                            v45 = v43;
                            v22 = v44;
                            v24 = v55;
                            v32 = v31;
                            v41 = v40;
                            v69 = v68;
                            v72 = v71;
                        }
                    }
                }
                // 0x100003d1c
                v42 = v41;
                v33 = v32;
                v23 = v22;
                v54 = v23 - v24;
                v17 = v33;
                v19 = v42;
                v20 = v69;
                v21 = v72;
            }
        }
        // 0x100003d2c
        v73 = v21;
        v74 = v20;
        _printf("\n");
        function_1000036f0();
        function_1000036f0();
        v75 = v7 + 1;
    }
    int32_t v78; // 0x100003e60
    for (int64_t i = 2; i < 6; i++) {
        // 0x100003d7c
        _printf("There are %d %d-digit fractions of which:\n", v74, v73);
        int32_t v79 = 1;
        if (*(int32_t *)(v5 - 80 + 40 * i + 4 * (int64_t)v79) != 0) {
            // 0x100003e00
            _printf("%6d have %d's omitted\n", v74, v73);
        }
        int32_t v80 = v79 + 1; // 0x100003e4c
        while (v79 == 8 || v79 < 8 != (7 - v79 & v80) < 0) {
            // 0x100003dcc
            v79 = v80;
            if (*(int32_t *)(v5 - 80 + 40 * i + 4 * (int64_t)v79) != 0) {
                // 0x100003e00
                _printf("%6d have %d's omitted\n", v74, v73);
            }
            // 0x100003e48
            v80 = v79 + 1;
        }
        // 0x100003e58
        v78 = _printf("\n");
    }
    // 0x100003e78
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003e98
        ___stack_chk_fail((int64_t)v78);
    }
    // 0x100003e9c
    return 0;
}

// Address range: 0x100003eb0 - 0x100003ebc
int64_t function_100003eb0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003eb0
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(int64_t a1) {
    // 0x100003ebc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int32_t nmemb, int32_t size) {
    // 0x100003ec8
    return _calloc(nmemb, size);
}

// Address range: 0x100003ed4 - 0x100003ee0
void function_100003ed4(int64_t * ptr) {
    // 0x100003ed4
    _free(ptr);
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t * function_100003ee0(int64_t * s, int32_t c, int32_t n) {
    // 0x100003ee0
    return _memset(s, c, n);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(char * format, ...) {
    // 0x100003eec
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  const char string[] = "abracadabra";

  char *replaced = malloc(sizeof(string));
  strcpy(replaced, string);

  // Null terminated replacement character arrays
  const char *aRep = "ABaCD";
  const char *bRep = "E";
  const char *rRep = "rF";

  for (char *c = replaced; *c; ++c) {
    switch (*c) {
    case 'a':
      if (*aRep)
        *c = *aRep++;
      break;
    case 'b':
      if (*bRep)
        *c = *bRep++;
      break;
    case 'r':
      if (*rRep)
        *c = *rRep++;
      break;
    }
  }

  printf("%s\n", replaced);

  free(replaced);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f50(int64_t a1);
int64_t function_100003f5c(int64_t a1, int64_t a2, int64_t a3);
void function_100003f68(int64_t * ptr);
int64_t * function_100003f74(int32_t size);
int32_t function_100003f80(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1 = "E"; // 0x100003f9e
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d58 - 0x100003f50
int64_t entry_point(void) {
    char * v1 = (char *)0x6164616361726261; // bp-40, 0x100003d8c
    int64_t * v2 = _malloc(12); // 0x100003d9c
    ___strcpy_chk((int64_t)v2, (int64_t)&v1, -1);
    char * v3 = "ABaCD"; // 0x100003de0
    char * v4 = (char *)&g1; // 0x100003de0
    char * v5 = "rF"; // 0x100003de0
    char * v6 = (char *)v2; // 0x100003de0
    int64_t v7; // 0x100003f28
    while (true) {
        char * v8 = v6;
        char * v9 = v5;
        char * v10 = v4;
        char * v11 = v3;
        v3 = v11;
        v4 = v10;
        v5 = v9;
        switch (*v8) {
            case 0: {
                // 0x100003efc
                _printf("%s\n", &v1);
                _free(v2);
                v7 = *(int64_t *)*(int64_t *)0x100004008;
                if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
                    // 0x100003f3c
                    ___stack_chk_fail((int64_t)&g2);
                }
                // 0x100003f40
                return 0;
            }
            case 97: {
                char v12 = *v11; // 0x100003e44
                v3 = v11;
                v4 = v10;
                v5 = v9;
                if (v12 != 0) {
                    // 0x100003e58
                    *v8 = v12;
                    v3 = (char *)((int64_t)v11 + 1);
                    v4 = v10;
                    v5 = v9;
                }
                // break -> 0x100003eec
                break;
            }
            case 98: {
                char v13 = *v10; // 0x100003e7c
                v3 = v11;
                v4 = v10;
                v5 = v9;
                if (v13 != 0) {
                    // 0x100003e90
                    *v8 = v13;
                    v3 = v11;
                    v4 = (char *)((int64_t)v10 + 1);
                    v5 = v9;
                }
                // break -> 0x100003eec
                break;
            }
            case 114: {
                char v14 = *v9; // 0x100003eb4
                v3 = v11;
                v4 = v10;
                v5 = v9;
                if (v14 != 0) {
                    // 0x100003ec8
                    *v8 = v14;
                    v3 = v11;
                    v4 = v10;
                    v5 = (char *)((int64_t)v9 + 1);
                }
                // break -> 0x100003eec
                break;
            }
        }
        // 0x100003eec
        v6 = (char *)((int64_t)v8 + 1);
    }
    // 0x100003efc
    _printf("%s\n", &v1);
    _free(v2);
    v7 = *(int64_t *)*(int64_t *)0x100004008;
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f3c
        ___stack_chk_fail((int64_t)&g2);
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(int64_t a1) {
    // 0x100003f50
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003f5c
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f68 - 0x100003f74
void function_100003f68(int64_t * ptr) {
    // 0x100003f68
    _free(ptr);
}

// Address range: 0x100003f74 - 0x100003f80
int64_t * function_100003f74(int32_t size) {
    // 0x100003f74
    return _malloc(size);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

int main(void) {
    char dna[] = "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG"
                "CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG"
                "AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT"
                "GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"
                "CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG"
                "TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"
                "TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT"
                "CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG"
                "TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC"
                "GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT";
    int c_count = 0, t_count = 0, a_count = 0, g_count = 0, total;

    for (total = 0; dna[total]; total++) {
        if (total % 50 == 0)
            printf("\n%3d - %3d: %c", total + 1, total + 50, dna[total]);
        else if (total % 5 == 0)
            printf(" %c", dna[total]);
        else
            printf("%c", dna[total]);

        switch (dna[total]) {
            case 'C': c_count++; break;
            case 'T': t_count++; break;
            case 'A': a_count++; break;
            case 'G': g_count++; break;
        }
    }

    printf("\n\nC count: %3d\nT count: %3d\nA count: %3d\nG count: %3d\n  Total: %3d\n\n",
            c_count, t_count, a_count, g_count, total);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int64_t function_100003d2c(int64_t a1);
int64_t * function_100003d38(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003d44(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a70 - 0x100003cdc
int64_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x100003a70
    int64_t v1; // bp-533, 0x100003a70
    _memcpy(&v1, (int64_t *)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501);
    int64_t v2; // 0x100003a70
    if (*(char *)&v1 == 0) {
      lab_0x100003c58:;
        int32_t v3 = _printf("\n\nC count: %3d\nT count: %3d\nA count: %3d\nG count: %3d\n  Total: %3d\n\n", (int64_t)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501, v2, v2, v2); // 0x100003ca0
        int64_t v4 = *(int64_t *)0x100004008; // 0x100003cac
        if (*(int64_t *)v4 != *(int64_t *)*(int64_t *)0x100004008) {
            // 0x100003cc4
            ___stack_chk_fail((int64_t)v3);
        }
        // 0x100003cc8
        return 0;
    }
    int32_t v5 = 0;
    int32_t result; // 0x100003a70
    if (v5 % 50 == 0) {
        // 0x100003b04
        result = _printf("\n%3d - %3d: %c", (int64_t)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501, (char)v2);
    } else {
        if (v5 % 5 == 0) {
            // 0x100003b70
            result = _printf(" %c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
        } else {
            // 0x100003b98
            result = _printf("%c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
        }
    }
    uint64_t v6 = (int64_t)*(char *)&v1 + 0xffffffbf & 0xffffffff; // 0x100003bd4
    while (v6 >= 19 == (v6 != 19)) {
        int32_t v7 = v5 + 1; // 0x100003c4c
        char * v8 = (char *)((int64_t)v7 + (int64_t)&v1); // 0x100003acc
        if (*v8 == 0) {
            goto lab_0x100003c58;
        }
        v5 = v7;
        if (v5 % 50 == 0) {
            // 0x100003b04
            result = _printf("\n%3d - %3d: %c", (int64_t)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501, (char)v2);
        } else {
            if (v5 % 5 == 0) {
                // 0x100003b70
                result = _printf(" %c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
            } else {
                // 0x100003b98
                result = _printf("%c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
            }
        }
        // 0x100003bc4
        v6 = (int64_t)*v8 + 0xffffffbf & 0xffffffff;
    }
    // 0x100003be8
    return result;
}

// Address range: 0x100003d2c - 0x100003d38
int64_t function_100003d2c(int64_t a1) {
    // 0x100003d2c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d38 - 0x100003d44
int64_t * function_100003d38(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003d38
    return _memcpy(dest, src, n);
}

// Address range: 0x100003d44 - 0x100003d50
int32_t function_100003d44(char * format, ...) {
    // 0x100003d44
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`//SquFoF: minimalistic version without queue.
//Classical heuristic. Tested: tcc 0.9.27
#include <math.h>
#include <stdio.h>

//input maximum
#define MxN ((unsigned long long) 1 << 62)

//reduce indefinite form
#define rho(a, b, c) {        \
  t = c; c = a; a = t; t = b; \
   q = (rN + b) / a;          \
   b = q * a - b;             \
   c += q * (t - b); }

//initialize
#define rhoin(a, b, c) {      \
   rho(a, b, c)  h = b;       \
   c = (mN - h * h) / a; }

#define gcd(a, b) while (b) { \
   t = a % b; a = b; b = t; }

//multipliers
const unsigned long m[] = {1, 3, 5, 7, 11, 0};

//square form factorization
unsigned long squfof( unsigned long long N ) {
unsigned long a, b, c, u, v, w, rN, q, t, r;
unsigned long long mN, h;
int i, ix, k = 0;

   if ((N & 1)==0) return 2;

   h = floor(sqrt(N)+ 0.5);
   if (h * h == N) return h;

   while (m[k]) {
      if (k && N % m[k]==0) return m[k];
      //check overflow m * N
      if (N > MxN / m[k]) break;
      mN = N * m[k++];

      r = floor(sqrt(mN));
      h = r; //float64 fix
      if (h * h > mN) r -= 1;
      rN = r;

      //principal form
      b = r; c = 1;
      rhoin(a, b, c)

      //iteration bound
      ix = floor(sqrt(2*r)) * 4;

      //search principal cycle
      for (i = 2; i < ix; i += 2) {
         rho(a, b, c)
         //even step

         r = floor(sqrt(c)+ 0.5);
         if (r * r == c) {
            //square form found

            //inverse square root
            v = -b; w = r;
            rhoin(u, v, w)

            //search ambiguous cycle
            do { r = v;
              rho(u, v, w)
            } while (v != r);
            //symmetry point

            h = N; gcd(h, u)
            if (h != 1) return h;
         }
         rho(a, b, c)
         //odd step
      }
   }
   return 1;
}

void main(void) {
const unsigned long long data[] = {
   2501,
   12851,
   13289,
   75301,
   120787,
   967009,
   997417,
   7091569,

   5214317,
   20834839,
   23515517,
   33409583,
   44524219,

   13290059,
   223553581,
   2027651281,
   11111111111,
   100895598169,
   1002742628021,
   60012462237239,
   287129523414791,
   9007199254740931,
   11111111111111111,
   314159265358979323,
   384307168202281507,
   419244183493398773,
   658812288346769681,
   922337203685477563,
   1000000000000000127,
   1152921505680588799,
   1537228672809128917,
   4611686018427387877,
   0};

   unsigned long long N, f;
   int i = 0;

   while (1) {
      N = data[i++];
      //scanf("%llu", &N);
      if (N < 2) break;

      printf("N = %llu\n", N);

      f = squfof(N);
      if (N % f) f = 1;

      if (f == 1) printf("fail\n\n");
      else printf("f = %llu  N/f = %llu\n\n", f, N/f);
   }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003738(void);
int64_t function_100003e1c(int64_t a1);
int64_t * function_100003e28(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003e34(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 1; // 0x100003e40
int64_t g2 = 2501; // 0x100003e70

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003738 - 0x100003cd0
int64_t function_100003738(void) {
    // 0x100003738
    int64_t v1; // 0x100003738
    uint64_t v2 = v1;
    if (v2 % 2 == 0) {
        // 0x100003cc4
        return 2;
    }
    int64_t result = __asm_fcvtmu(sqrt((float64_t)v2) + 0.5); // 0x100003778
    if (result * result == v2) {
        // 0x100003cc4
        return result;
    }
    int32_t v3 = 0; // 0x1000037c8
    int64_t result2 = 1; // 0x1000037c8
    if (g1 == 0) {
      lab_0x100003cc4:
        // 0x100003cc4
        return result2;
    }
    uint64_t v4 = g1; // 0x10000383c
    if (v3 != 0) {
        // 0x1000037e4
        if (v2 % v4 == 0) {
            // break -> 0x100003cc4
            break;
        }
    }
    uint64_t v5 = 0x4000000000000000 / v4; // 0x100003844
    result2 = 1;
    while (v5 == v2 || v5 > v2) {
        uint64_t v6 = v4 * v2; // 0x10000387c
        int64_t v7 = __asm_fcvtmu(sqrt((float64_t)v6)); // 0x100003890
        uint64_t v8 = v7 * v7; // 0x1000038a8
        int64_t v9 = v7 + (int64_t)(v8 != v6 == v8 >= v6);
        int32_t v10 = 4.0 * __asm_frintm(sqrt((float64_t)(2 * v9))); // 0x1000039a0
        int32_t v11 = 2 - v10; // 0x1000039bc
        if (v11 < 0 != (v11 & v10) < 0) {
            int32_t v12 = 2; // 0x100003ca8
            int64_t v13 = 1; // 0x100003a34
            int64_t v14 = v6 - v9 * v9; // 0x100003738
            uint64_t v15 = 2 * v9 / v14; // 0x1000039fc
            int64_t v16 = v15 * v14 - v9; // 0x100003a14
            v13 += (v9 - v16) * v15;
            uint64_t v17 = __asm_fcvtmu(sqrt((float64_t)v13) + 0.5); // 0x100003a50
            int64_t v18; // 0x100003738
            int64_t v19; // 0x100003738
            int64_t v20; // 0x100003738
            int64_t v21; // 0x100003738
            int64_t v22; // 0x100003738
            int64_t v23; // 0x100003738
            int64_t v24; // 0x100003738
            int64_t v25; // 0x100003738
            uint64_t v26; // 0x100003ab8
            int64_t v27; // 0x100003ad8
            uint64_t v28; // 0x100003b64
            int64_t v29; // 0x100003b7c
            int64_t v30; // 0x100003738
            if (v17 * v17 == v13) {
                // 0x100003a78
                v26 = v9 - v16;
                v27 = v26 - v26 % v17 + v16;
                v25 = (v6 - v27 * v27) / v17;
                v23 = v27;
                v28 = (v23 + v9) / v25;
                v29 = v28 * v25 - v23;
                v24 = (v23 - v29) * v28 + v17;
                v20 = v25;
                while (v23 != v29) {
                    // 0x100003b2c
                    v25 = v24;
                    v23 = v29;
                    v28 = (v23 + v9) / v25;
                    v29 = v28 * v25 - v23;
                    v24 = (v23 - v29) * v28 + v20;
                    v20 = v25;
                }
                // 0x100003bcc
                v21 = v25;
                if (v25 != 0) {
                    v30 = v18 % v21;
                    v18 = v21;
                    v19 = v21;
                    while (v30 != 0) {
                        // 0x100003be0
                        v22 = v30;
                        v30 = v18 % v22;
                        v18 = v22;
                        v19 = v22;
                    }
                }
                // 0x100003c0c
                result2 = v19;
                if (v19 != 1) {
                    return result2;
                }
            }
            uint64_t v31 = (v16 + v9) / v13; // 0x100003c60
            int64_t v32 = v31 * v13 - v16; // 0x100003c78
            v12 += 2;
            int32_t v33 = v12 - v10; // 0x1000039bc
            v14 += (v16 - v32) * v31;
            while (v33 < 0 != ((v33 ^ v12) & (v12 ^ v10)) < 0) {
                // 0x1000039cc
                v15 = (v32 + v9) / v14;
                v16 = v15 * v14 - v32;
                v13 += (v32 - v16) * v15;
                v17 = __asm_fcvtmu(sqrt((float64_t)v13) + 0.5);
                if (v17 * v17 == v13) {
                    // 0x100003a78
                    v26 = v9 - v16;
                    v27 = v26 - v26 % v17 + v16;
                    v25 = (v6 - v27 * v27) / v17;
                    v23 = v27;
                    v28 = (v23 + v9) / v25;
                    v29 = v28 * v25 - v23;
                    v24 = (v23 - v29) * v28 + v17;
                    v20 = v25;
                    while (v23 != v29) {
                        // 0x100003b2c
                        v25 = v24;
                        v23 = v29;
                        v28 = (v23 + v9) / v25;
                        v29 = v28 * v25 - v23;
                        v24 = (v23 - v29) * v28 + v20;
                        v20 = v25;
                    }
                    // 0x100003bcc
                    v21 = v25;
                    if (v25 != 0) {
                        v30 = v18 % v21;
                        v18 = v21;
                        v19 = v21;
                        while (v30 != 0) {
                            // 0x100003be0
                            v22 = v30;
                            v30 = v18 % v22;
                            v18 = v22;
                            v19 = v22;
                        }
                    }
                    // 0x100003c0c
                    result2 = v19;
                    if (v19 != 1) {
                        return result2;
                    }
                }
                // 0x100003c30
                v31 = (v16 + v9) / v13;
                v32 = v31 * v13 - v16;
                v12 += 2;
                v33 = v12 - v10;
                v14 += (v16 - v32) * v31;
            }
        }
        // 0x1000037b0
        v3++;
        int64_t v34 = *(int64_t *)(8 * (int64_t)v3 + (int64_t)&g1); // 0x1000037bc
        result2 = 1;
        if (v34 == 0) {
            // break -> 0x100003cc4
            break;
        }
        v4 = v34;
        if (v3 != 0) {
            // 0x1000037e4
            result2 = v4;
            if (v2 % v4 == 0) {
                // break -> 0x100003cc4
                break;
            }
        }
        // 0x10000382c
        v5 = 0x4000000000000000 / v4;
        result2 = 1;
    }
    // 0x100003cc4
    return result2;
}

// Address range: 0x100003cd0 - 0x100003e1c
int64_t entry_point(void) {
    // 0x100003cd0
    int64_t v1; // bp-304, 0x100003cd0
    int64_t * v2 = _memcpy(&v1, &g2, 264); // 0x100003d00
    int32_t v3 = 1; // 0x100003d34
    int64_t v4 = (int64_t)v2; // 0x100003d34
    if (v1 >= 2) {
        _printf("N = %llu\n", (int64_t)&g2);
        uint64_t v5 = function_100003738(); // 0x100003d5c
        int32_t v6; // 0x100003cd0
        if (v5 == 1 | v1 % v5 != 0) {
            // 0x100003da8
            v6 = _printf("fail\n\n");
        } else {
            // 0x100003db8
            v6 = _printf("f = %llu  N/f = %llu\n\n", (int64_t)&g2, 264);
        }
        uint64_t v7 = *(int64_t *)(8 * (int64_t)v3 + (int64_t)&v1); // 0x100003d20
        v3++;
        while (v7 >= 2) {
            // 0x100003d40
            _printf("N = %llu\n", (int64_t)&g2);
            v5 = function_100003738();
            if (v5 == 1 | v7 % v5 != 0) {
                // 0x100003da8
                v6 = _printf("fail\n\n");
            } else {
                // 0x100003db8
                v6 = _printf("f = %llu  N/f = %llu\n\n", (int64_t)&g2, 264);
            }
            // 0x100003de4
            v7 = *(int64_t *)(8 * (int64_t)v3 + (int64_t)&v1);
            v3++;
        }
        // 0x100003d0c
        v4 = v6;
    }
    int64_t v8 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003df4
    int64_t result = v4; // 0x100003e00
    if (v8 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e08
        result = ___stack_chk_fail(v4);
    }
    // 0x100003e0c
    return result;
}

// Address range: 0x100003e1c - 0x100003e28
int64_t function_100003e1c(int64_t a1) {
    // 0x100003e1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e28 - 0x100003e34
int64_t * function_100003e28(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e28
    return _memcpy(dest, src, n);
}

// Address range: 0x100003e34 - 0x100003e40
int32_t function_100003e34(char * format, ...) {
    // 0x100003e34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int val;
} num;

int addNodes(num **array, int elems);

int main(void) {
    int numElems, i;
    num *arr = NULL;
    numElems = addNodes(&arr, 10);
    for (i = 0; i < numElems; i++) {
        printf("%d) %d\n", i+1, arr[i].val);
    }
    free(arr);
    return 0;
}

int addNodes(num **array, int elems) {
    num *temp = NULL;
    int i;
    for (i = 0; i < elems; i++) {
        temp = realloc(*array, (i+1) * sizeof **array);
        if (temp == NULL) {
            free(*array); return -1;
        } else {
            *array = temp;
        }
        (*array)[i].val = i;
        // Alternatives:
        // ((*array)+i)->val = i; // or
        // (*((*array)+i)).val = i;
    }
    return i;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ea0(void);
void function_100003f7c(int64_t * ptr);
int32_t function_100003f88(char * format, ...);
int64_t * function_100003f94(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003dfc - 0x100003ea0
int64_t entry_point(void) {
    int32_t v1 = function_100003ea0(); // 0x100003e1c
    int32_t v2 = -v1; // 0x100003e30
    int32_t v3 = 0; // 0x100003e38
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003e88
        _free(NULL);
        return 0;
    }
    int64_t v4; // 0x100003dfc
    _printf("%d) %d\n", 10, v4);
    v3++;
    while (v3 - v1 < 0 != ((v3 - v1 ^ v3) & (v3 ^ v1)) < 0) {
        // 0x100003e40
        _printf("%d) %d\n", 10, v4);
        v3++;
    }
    // 0x100003e88
    _free(NULL);
    return 0;
}

// Address range: 0x100003ea0 - 0x100003f7c
int64_t function_100003ea0(void) {
    // 0x100003ea0
    int64_t v1; // 0x100003ea0
    int32_t v2 = v1; // 0x100003eb0
    int32_t v3 = -v2; // 0x100003ec8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003f6c
        return 0;
    }
    int32_t v4 = 0;
    int64_t v5; // 0x100003ea0
    int64_t * v6 = _realloc((int64_t *)v5, 4 * v4 + 4); // 0x100003ef4
    int64_t result; // 0x100003ea0
    while (v6 != NULL) {
        int64_t v7 = (int64_t)v6; // 0x100003ef4
        *(int64_t *)v1 = v7;
        *(int32_t *)(4 * (int64_t)v4 + v7) = v4;
        int32_t v8 = v4 + 1; // 0x100003f54
        int32_t v9 = v8 - v2; // 0x100003ec8
        if (v9 < 0 == ((v9 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003ec0
            result = v8;
            return result;
        }
        v4 = v8;
        v6 = _realloc((int64_t *)v7, 4 * v4 + 4);
    }
    // 0x100003f10
    _free(NULL);
    result = 0xffffffff;
  lab_0x100003f6c:
    // 0x100003f6c
    return result;
}

// Address range: 0x100003f7c - 0x100003f88
void function_100003f7c(int64_t * ptr) {
    // 0x100003f7c
    _free(ptr);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// Address range: 0x100003f94 - 0x100003fa0
int64_t * function_100003f94(int64_t * ptr, int32_t size) {
    // 0x100003f94
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

int main()
{
        int i, j;
        double degrees[] = { 0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5,
                84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88,
                168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12,
                253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5,
                354.37, 354.38 };
        const char * names =  "North                 "
                              "North by east         "
                              "North-northeast       "
                              "Northeast by north    "
                              "Northeast             "
                              "Northeast by east     "
                              "East-northeast        "
                              "East by north         "
                              "East                  "
                              "East by south         "
                              "East-southeast        "
                              "Southeast by east     "
                              "Southeast             "
                              "Southeast by south    "
                              "South-southeast       "
                              "South by east         "
                              "South                 "
                              "South by west         "
                              "South-southwest       "
                              "Southwest by south    "
                              "Southwest             "
                              "Southwest by west     "
                              "West-southwest        "
                              "West by south         "
                              "West                  "
                              "West by north         "
                              "West-northwest        "
                              "Northwest by west     "
                              "Northwest             "
                              "Northwest by north    "
                              "North-northwest       "
                              "North by west         "
                              "North                 ";

        for (i = 0; i < 33; i++) {
                j = .5 + degrees[i] * 32 / 360;

                printf("%2d  %.22s  %6.2f\n", (j % 32) + 1, names + (j % 32) * 22,
                        degrees[i]);
        }

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b7c(int64_t a1);
int64_t * function_100003b88(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003b94(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100003bb0

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a3c - 0x100003b7c
int64_t entry_point(void) {
    // 0x100003a3c
    int64_t v1; // bp-304, 0x100003a3c
    _memcpy(&v1, &g1, 264);
    int32_t v2; // 0x100003b2c
    for (int32_t i = 0; i < 33; i++) {
        // 0x100003a9c
        int128_t v3; // 0x100003a3c
        v2 = _printf("%2d  %.22s  %6.2f\n", (int64_t)&g1, (char *)264, (float64_t)(int64_t)v3);
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b50
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003b64
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003b68
    return 0;
}

// Address range: 0x100003b7c - 0x100003b88
int64_t function_100003b7c(int64_t a1) {
    // 0x100003b7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003b88 - 0x100003b94
int64_t * function_100003b88(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003b88
    return _memcpy(dest, src, n);
}

// Address range: 0x100003b94 - 0x100003ba0
int32_t function_100003b94(char * format, ...) {
    // 0x100003b94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <string.h>

int ordered(char *s, char **end)
{
	int r = 1;
	while (*++s != '\n' && *s != '\r' && *s != '\0')
		if (s[0] < s[-1]) r = 0;

	*end = s;
	return r;
}

int main()
{
	char *buf, *word, *end, *tail;
	struct stat st;
	int longest = 0, len, fd;

	if ((fd = open("unixdict.txt", O_RDONLY)) == -1) err(1, "read error");

	fstat(fd, &st);
	if (!(buf = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)))
		err(1, "mmap");

	for (word = end = buf; end < buf + st.st_size; word = end) {
		while (*word == '\r' || *word == '\n') word++;
		if (!ordered(word, &end)) continue;
		if ((len = end - word + 1) < longest) continue;
		if (len > longest) {
			tail = buf;  /* longer words found; reset out buffer */
			longest = len;
		}
		/* use the same mmap'd region to store output.  because of MAP_PRIVATE,
		 * change will not go back to file.  mmap is copy on write, and we are using
		 * only the head space to store output, so kernel doesn't need to copy more
		 * than the words we saved--in this case, one page tops.
		 */
		memcpy(tail, word, len);
		tail += len;
		*tail = '\0';
	}
	printf(buf);

	munmap(buf, st.st_size);
	close(fd);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c14(void);
int64_t function_100003f20(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int32_t function_100003f2c(int32_t fd);
void function_100003f38(int32_t status, char * format, ...);
int32_t function_100003f44(int32_t fd, struct stat * buf);
int64_t * function_100003f50(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003f5c(int64_t * addr, int32_t len);
int32_t function_100003f68(char * file, int32_t oflag, ...);
int32_t function_100003f74(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c14 - 0x100003cdc
int64_t function_100003c14(void) {
    // 0x100003c14
    int64_t v1; // 0x100003c14
    char * v2 = (char *)v1;
    uint32_t result = 1;
    int64_t v3 = (int64_t)v2 + 1; // 0x100003c30
    char * v4 = (char *)v3; // 0x100003c34
    char v5 = *v4; // 0x100003c38
    switch (v5) {
        case 10: {
        }
        case 13: {
            // 0x100003cc4
            *(int64_t *)v1 = v3;
            return result;
        }
    }
    while (v5 != 0) {
        int32_t v6 = v5; // 0x100003c9c
        char v7 = *v2; // 0x100003ca4
        int32_t v8 = v6 - (int32_t)v7; // 0x100003ca8
        int32_t v9 = v8 < 0 == ((v8 ^ v6) & (int32_t)(v7 ^ v5)) < 0 ? result : 0;
        v2 = v4;
        result = v9;
        v3 = (int64_t)v2 + 1;
        v4 = (char *)v3;
        v5 = *v4;
        switch (v5) {
            case 10: {
            }
            case 13: {
                // 0x100003cc4
                *(int64_t *)v1 = v3;
                return result;
            }
        }
    }
    // 0x100003cc4
    *(int64_t *)v1 = v3;
    return result;
}

// Address range: 0x100003cdc - 0x100003f20
int64_t entry_point(void) {
    int32_t v1 = _open("unixdict.txt", 0); // 0x100003d04
    if (v1 == -1) {
        // 0x100003d1c
        _err(1, "read error");
    }
    // 0x100003d2c
    int64_t v2; // bp-56, 0x100003cdc
    int64_t v3 = &v2; // 0x100003cec
    int64_t v4; // bp-200, 0x100003cdc
    _fstat(v1, (struct stat *)&v4);
    int32_t v5; // 0x100003cdc
    int64_t * v6 = _mmap(NULL, v5, 3, 2, v1, 0); // 0x100003d50
    int64_t v7 = (int64_t)v6; // 0x100003d50
    int64_t * v8 = (int64_t *)(v3 + 24); // 0x100003d5c
    *v8 = v7;
    int64_t v9 = v7; // 0x100003d68
    if (v6 == NULL) {
        // 0x100003d70
        _err(1, "mmap");
        v9 = *v8;
    }
    int64_t * v10 = (int64_t *)(v3 + 8); // 0x100003d88
    *v10 = v9;
    int64_t * v11 = (int64_t *)(v3 + 16); // 0x100003d8c
    *v11 = v9;
    int64_t v12 = *v8; // 0x100003d9c
    int64_t v13 = v5; // 0x100003da0
    int64_t v14 = v12; // 0x100003db0
    if (*v10 < v12 + v13) {
        int32_t v15 = 0;
        char v16 = *(char *)v9; // 0x100003dc4
        int64_t v17; // 0x100003cdc
        int64_t v18; // 0x100003e10
        char v19; // 0x100003dc4
        if (v16 != 13 != v16 != 10) {
            v18 = v9 + 1;
            *v11 = v18;
            v19 = *(char *)v18;
            v17 = v18;
            while (v19 != 13 != v19 != 10) {
                // 0x100003e08
                v18 = v17 + 1;
                *v11 = v18;
                v19 = *(char *)v18;
                v17 = v18;
            }
        }
        int32_t v20 = v15; // 0x100003e34
        int64_t v21; // 0x100003cdc
        int64_t v22; // 0x100003cdc
        int32_t v23; // 0x100003cdc
        int64_t v24; // 0x100003e48
        int32_t v25; // 0x100003e58
        int32_t v26; // 0x100003e60
        int64_t v27; // 0x100003e90
        int64_t v28; // 0x100003ec8
        if ((int32_t)function_100003c14() != 0) {
            // 0x100003e40
            v24 = *v11;
            v25 = (int32_t)(*v10 - v24) + 1;
            v26 = v25 - v15;
            v20 = v15;
            if (v26 < 0 == ((v26 ^ v25) & (v25 ^ v15)) < 0) {
                if (v26 == 0) {
                    // 0x100003e74
                    v21 = v24;
                    v22 = v2;
                    v23 = v15;
                } else {
                    // 0x100003e8c
                    v27 = *v8;
                    v2 = v27;
                    v21 = *v11;
                    v22 = v27;
                    v23 = v25;
                }
                // 0x100003ea4
                ___memcpy_chk(v22, v21, v25, -1);
                v28 = v2 + (int64_t)v25;
                v2 = v28;
                *(char *)v28 = 0;
                v20 = v23;
            }
        }
        int64_t v29 = *v10; // 0x100003ee0
        *v11 = v29;
        int64_t v30 = *v8; // 0x100003d9c
        v14 = v30;
        while (*v10 < v30 + v13) {
            // 0x100003dbc
            v15 = v20;
            v16 = *(char *)v29;
            v17 = v29;
            if (v16 != 13 != v16 != 10) {
                v18 = v17 + 1;
                *v11 = v18;
                v19 = *(char *)v18;
                v17 = v18;
                while (v19 != 13 != v19 != 10) {
                    // 0x100003e08
                    v18 = v17 + 1;
                    *v11 = v18;
                    v19 = *(char *)v18;
                    v17 = v18;
                }
            }
            // 0x100003e1c
            v20 = v15;
            if ((int32_t)function_100003c14() != 0) {
                // 0x100003e40
                v24 = *v11;
                v25 = (int32_t)(*v10 - v24) + 1;
                v26 = v25 - v15;
                v20 = v15;
                if (v26 < 0 == ((v26 ^ v25) & (v25 ^ v15)) < 0) {
                    if (v26 == 0) {
                        // 0x100003e74
                        v21 = v24;
                        v22 = v2;
                        v23 = v15;
                    } else {
                        // 0x100003e8c
                        v27 = *v8;
                        v2 = v27;
                        v21 = *v11;
                        v22 = v27;
                        v23 = v25;
                    }
                    // 0x100003ea4
                    ___memcpy_chk(v22, v21, v25, -1);
                    v28 = v2 + (int64_t)v25;
                    v2 = v28;
                    *(char *)v28 = 0;
                    v20 = v23;
                }
            }
            // 0x100003edc
            v29 = *v10;
            *v11 = v29;
            v30 = *v8;
            v14 = v30;
        }
    }
    // 0x100003eec
    _printf((char *)v14);
    _munmap((int64_t *)*v8, v5);
    _close(v1);
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003f20
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t fd) {
    // 0x100003f2c
    return _close(fd);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t status, char * format, ...) {
    // 0x100003f38
    _err(status, format);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(int32_t fd, struct stat * buf) {
    // 0x100003f44
    return _fstat(fd, buf);
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t * function_100003f50(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003f50
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(int64_t * addr, int32_t len) {
    // 0x100003f5c
    return _munmap(addr, len);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * file, int32_t oflag, ...) {
    // 0x100003f68
    return _open(file, oflag);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint;
uint count = 0;

#define ulen sizeof(uint) * 8

/* could have defined as int solve(...), but void may have less
   chance to confuse poor optimizer */
void solve(int n)
{
	int cnt = 0;
	const uint full = -(int)(1 << (ulen - n));
	register uint bits, pos, *m, d, e;

	uint b0, b1, l[32], r[32], c[32], mm[33] = {0};
	n -= 3;
	/* require second queen to be left of the first queen, so
	   we ever only test half of the possible solutions. This
	   is why we can't handle n=1 here */
	for (b0 = 1U << (ulen - n - 3); b0; b0 <<= 1) {
		for (b1 = b0 << 2; b1; b1 <<= 1) {
			d = n;
			/* c: columns occupied by previous queens.
			   l: columns attacked by left diagonals
			   r: by right diagnoals */
			c[n] = b0 | b1;
			l[n] = (b0 << 2) | (b1 << 1);
			r[n] = (b0 >> 2) | (b1 >> 1);

			/* availabe columns on current row. m is stack */
			bits = *(m = mm + 1) = full & ~(l[n] | r[n] | c[n]);

			while (bits) {
				/* d: depth, aka row. counting backwards
				   because !d is often faster than d != n */
				while (d) {
					/* pos is right most nonzero bit */
					pos = -(int)bits & bits;

					/* mark bit used. only put current bits
					   on stack if not zero, so backtracking
					   will skip exhausted rows (because reading
					   stack variable is sloooow compared to
					   registers) */
					if ((bits &= ~pos))
						*m++ = bits | d;

					/* faster than l[d+1] = l[d]... */
					e = d--;
					l[d] = (l[e] | pos) << 1;
					r[d] = (r[e] | pos) >> 1;
					c[d] =  c[e] | pos;

					bits = full & ~(l[d] | r[d] | c[d]);

					if (!bits) break;
					if (!d) { cnt++; break; }
				}
				/* Bottom of stack m is a zero'd field acting
				   as sentinel.  When saving to stack, left
				   27 bits are the available columns, while
				   right 5 bits is the depth. Hence solution
				   is limited to size 27 board -- not that it
				   matters in foreseeable future. */
				d = (bits = *--m) & 31U;
				bits &= ~31U;
			}
		}
	}
	count = cnt * 2;
}

int main(int c, char **v)
{
	int nn;
	if (c <= 1 || (nn = atoi(v[1])) <= 0) nn = 8;

	if (nn > 27) {
		fprintf(stderr, "Value too large, abort\n");
		exit(1);
	}

	/* Can't solve size 1 board; might as well skip 2 and 3 */
	if (nn < 4) count = nn == 1;
	else	    solve(nn);

	printf("\nSolutions: %d\n", count);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ae4(void);
int64_t function_100003f30(void);
int32_t function_100003f3c(char * nptr);
void function_100003f48(int32_t status);
int32_t function_100003f54(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f60(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f6c(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _atoi(char * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ae4 - 0x100003e38
int64_t function_100003ae4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003afc
    int64_t v2; // 0x100003ae4
    int32_t v3 = v2; // 0x100003b04
    uint32_t v4 = 32 - v3;
    int32_t v5 = -1 << v4; // 0x100003b30
    int64_t v6; // bp-548, 0x100003ae4
    int64_t * v7 = _memset(&v6, 0, 132); // 0x100003b40
    int32_t v8 = v3 - 3; // 0x100003b50
    int64_t v9; // bp-416, 0x100003ae4
    int64_t v10 = &v9;
    int64_t v11 = 4 * (int64_t)v8;
    int32_t * v12 = (int32_t *)(v11 + v10);
    int64_t v13; // bp-160, 0x100003ae4
    int64_t v14 = &v13;
    int32_t * v15 = (int32_t *)(v11 + v14);
    int64_t v16; // bp-288, 0x100003ae4
    int64_t v17 = &v16;
    int32_t v18 = 0;
    uint32_t v19 = 1 << v4;
    int32_t v20 = 4 * v19; // 0x100003b88
    int32_t v21 = v18; // 0x100003ba0
    int32_t v22; // 0x100003ae4
    int64_t v23; // 0x100003ae4
    int64_t v24; // 0x100003ae4
    int64_t v25; // bp-544, 0x100003ae4
    int32_t v26; // 0x100003ae4
    int32_t v27; // 0x100003ae4
    int32_t v28; // 0x100003ae4
    int32_t v29; // 0x100003ae4
    int32_t v30; // 0x100003ae4
    int32_t v31; // 0x100003ae4
    int32_t * v32; // 0x100003ae4
    int32_t * v33; // 0x100003ae4
    int32_t * v34; // 0x100003ae4
    int32_t * v35; // 0x100003ae4
    int32_t * v36; // 0x100003ae4
    int32_t * v37; // 0x100003ae4
    int32_t v38; // 0x100003ae4
    uint32_t v39; // 0x100003ae4
    int32_t v40; // 0x100003ae4
    int32_t v41; // 0x100003bd0
    int32_t v42; // 0x100003bf0
    int32_t v43; // 0x100003c24
    int32_t v44; // 0x100003c7c
    int32_t v45; // 0x100003ae4
    uint32_t v46; // 0x100003ccc
    int64_t v47; // 0x100003ce0
    int64_t v48; // 0x100003cf4
    int32_t * v49; // 0x100003cf4
    int32_t * v50; // 0x100003d14
    int32_t v51; // 0x100003d28
    int32_t v52; // 0x100003d58
    if (v20 != 0) {
        // 0x100003ba8
        v41 = v20;
        v29 = v18;
        while (true) {
            // 0x100003ba8
            v39 = v41;
            *v12 = v39 | v19;
            v41 = 2 * v39;
            *v15 = v41 | v20;
            v42 = v39 / 2 | v19 / 4;
            *(int32_t *)(v11 + v17) = v42;
            v43 = v5 & -1 - (*v15 | v42 | *v12);
            v25 = v43;
            v28 = v29;
            v40 = v43;
            v32 = (int32_t *)&v25;
            v38 = v8;
            v26 = v29;
            if (v43 != 0) {
                while (true) {
                    // 0x100003c58
                    v27 = v26;
                    v23 = v38;
                    v33 = v32;
                    v52 = v40;
                    v34 = v33;
                    v24 = v23;
                    v30 = v27;
                    v37 = v34;
                    while (v24 != 0) {
                        // 0x100003c6c
                        v31 = v52;
                        v44 = v31 & -v31;
                        if (v44 == v31) {
                            // 0x100003c6c
                            v22 = v24;
                            v35 = v34;
                        } else {
                            // 0x100003ca8
                            v45 = v24;
                            *v34 = v44 ^ v31 | v45;
                            v22 = v45;
                            v35 = (int32_t *)((int64_t)v34 + 4);
                        }
                        // 0x100003cc8
                        v36 = v35;
                        v46 = v22 - 1;
                        v47 = 4 * v24;
                        v48 = 4 * (int64_t)v46;
                        v49 = (int32_t *)(v48 + v14);
                        *v49 = 2 * (*(int32_t *)(v47 + v14) | v44);
                        v50 = (int32_t *)(v48 + v17);
                        *v50 = (*(int32_t *)(v47 + v17) | v44) / 2;
                        v51 = *(int32_t *)(v47 + v10) | v44;
                        *(int32_t *)(v48 + v10) = v51;
                        v52 = v5 & -1 - (*v49 | v51 | *v50);
                        v30 = v27;
                        v37 = v36;
                        if (v52 == 0) {
                            // break -> 0x100003da0
                            break;
                        }
                        // 0x100003d78
                        v23 = v24 - 1;
                        v33 = v36;
                        if (v46 == 0) {
                            // 0x100003d8c
                            v30 = v27 + 1;
                            v37 = v36;
                            goto lab_0x100003da0;
                        }
                        v34 = v33;
                        v24 = v23;
                        v30 = v27;
                        v37 = v34;
                    }
                    goto lab_0x100003da0;
                }
            }
            // 0x100003b94
            v29 = v28;
            v21 = v29;
            if (v41 == 0) {
                // break -> 0x100003de4
                break;
            }
        }
    }
    int32_t v53 = v21;
    int32_t v54 = 2 * v19; // 0x100003de8
    while (v54 != 0) {
        // 0x100003b84
        v18 = v53;
        v19 = v54;
        v20 = 4 * v19;
        v21 = v18;
        if (v20 != 0) {
            // 0x100003ba8
            v41 = v20;
            v29 = v18;
            while (true) {
                // 0x100003ba8
                v39 = v41;
                *v12 = v39 | v19;
                v41 = 2 * v39;
                *v15 = v41 | v20;
                v42 = v39 / 2 | v19 / 4;
                *(int32_t *)(v11 + v17) = v42;
                v43 = v5 & -1 - (*v15 | v42 | *v12);
                v25 = v43;
                v28 = v29;
                v40 = v43;
                v32 = (int32_t *)&v25;
                v38 = v8;
                v26 = v29;
                if (v43 != 0) {
                    while (true) {
                        // 0x100003c58
                        v27 = v26;
                        v23 = v38;
                        v33 = v32;
                        v52 = v40;
                        v34 = v33;
                        v24 = v23;
                        v30 = v27;
                        v37 = v34;
                        while (v24 != 0) {
                            // 0x100003c6c
                            v31 = v52;
                            v44 = v31 & -v31;
                            if (v44 == v31) {
                                // 0x100003c6c
                                v22 = v24;
                                v35 = v34;
                            } else {
                                // 0x100003ca8
                                v45 = v24;
                                *v34 = v44 ^ v31 | v45;
                                v22 = v45;
                                v35 = (int32_t *)((int64_t)v34 + 4);
                            }
                            // 0x100003cc8
                            v36 = v35;
                            v46 = v22 - 1;
                            v47 = 4 * v24;
                            v48 = 4 * (int64_t)v46;
                            v49 = (int32_t *)(v48 + v14);
                            *v49 = 2 * (*(int32_t *)(v47 + v14) | v44);
                            v50 = (int32_t *)(v48 + v17);
                            *v50 = (*(int32_t *)(v47 + v17) | v44) / 2;
                            v51 = *(int32_t *)(v47 + v10) | v44;
                            *(int32_t *)(v48 + v10) = v51;
                            v52 = v5 & -1 - (*v49 | v51 | *v50);
                            v30 = v27;
                            v37 = v36;
                            if (v52 == 0) {
                                // break -> 0x100003da0
                                break;
                            }
                            // 0x100003d78
                            v23 = v24 - 1;
                            v33 = v36;
                            if (v46 == 0) {
                                // 0x100003d8c
                                v30 = v27 + 1;
                                v37 = v36;
                                goto lab_0x100003da0;
                            }
                            v34 = v33;
                            v24 = v23;
                            v30 = v27;
                            v37 = v34;
                        }
                        goto lab_0x100003da0;
                    }
                }
                // 0x100003b94
                v29 = v28;
                v21 = v29;
                if (v41 == 0) {
                    // break -> 0x100003de4
                    break;
                }
            }
        }
        // 0x100003de4
        v53 = v21;
        v54 = 2 * v19;
    }
    // 0x100003df4
    *(int32_t *)&g1 = 2 * v53;
    int64_t result = (int64_t)v7; // 0x100003e1c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e24
        result = ___stack_chk_fail();
    }
    // 0x100003e28
    return result;
  lab_0x100003da0:;
    int32_t * v55 = (int32_t *)((int64_t)v37 - 4); // 0x100003da8
    uint32_t v56 = *v55; // 0x100003dac
    int32_t v57 = v56 & -32; // 0x100003dc0
    v28 = v30;
    v40 = v57;
    v32 = v55;
    v38 = v56 % 32;
    v26 = v30;
    if (v57 == 0) {
        // break -> 0x100003b94
        goto lab_0x100003b94;
    }
    goto lab_0x100003c58;
}

// Address range: 0x100003e38 - 0x100003f30
int64_t entry_point(void) {
    // 0x100003e38
    int64_t v1; // 0x100003e38
    int32_t v2 = v1; // 0x100003e48
    int32_t v3 = v2 - 1; // 0x100003e54
    int32_t v4; // 0x100003e38
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0) {
        // 0x100003e84
        v4 = 8;
        goto lab_0x100003e90;
    } else {
        int32_t v5 = _atoi((char *)*(int64_t *)(v1 + 8)); // 0x100003e6c
        v4 = v5;
        if (v5 < 1) {
            // 0x100003e84
            v4 = 8;
            goto lab_0x100003e90;
        } else {
            goto lab_0x100003e90;
        }
    }
  lab_0x100003e90:;
    int32_t v6 = v4;
    int32_t v7 = v6 - 27; // 0x100003e94
    if (v7 != 0 && v7 < 0 == (26 - v6 & v6) < 0) {
        int64_t v8 = *(int64_t *)0x100004010; // 0x100003ea8
        _fprintf((struct _IO_FILE *)*(int64_t *)v8, "Value too large, abort\n");
        _exit(1);
        // UNREACHABLE
    }
    if (v6 < 4 == (3 - v6 & v6) < 0) {
        // 0x100003ef4
        function_100003ae4();
    } else {
        // 0x100003ed8
        *(int32_t *)&g1 = (int32_t)(v6 == 1);
    }
    // 0x100003f00
    _printf("\nSolutions: %d\n", v1);
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(void) {
    // 0x100003f30
    return ___stack_chk_fail();
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * nptr) {
    // 0x100003f3c
    return _atoi(nptr);
}

// Address range: 0x100003f48 - 0x100003f54
void function_100003f48(int32_t status) {
    // 0x100003f48
    _exit(status);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f54
    return _fprintf(stream, format);
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t * function_100003f60(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f60
    return _memset(s, c, n);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

struct node {
	char *s;
	struct node* prev;
};

void powerset(char **v, int n, struct node *up)
{
	struct node me;

	if (!n) {
		putchar('[');
		while (up) {
			printf(" %s", up->s);
			up = up->prev;
		}
		puts(" ]");
	} else {
		me.s = *v;
		me.prev = up;
		powerset(v + 1, n - 1, up);
		powerset(v + 1, n - 1, &me);
	}
}

int main(int argc, char **argv)
{
	powerset(argv + 1, argc - 1, 0);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e50(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(int32_t c);
int32_t function_100003f94(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e50 - 0x100003f34
int64_t function_100003e50(void) {
    // 0x100003e50
    int64_t v1; // 0x100003e50
    if ((int32_t)v1 != 0) {
        // 0x100003ed8
        function_100003e50();
        // 0x100003f28
        return function_100003e50();
    }
    // 0x100003e7c
    _putchar(91);
    if (v1 == 0) {
        // 0x100003f28
        return _puts(" ]");
    }
    _printf(" %s", (char *)v1);
    int64_t v2; // 0x100003e50
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x100003ebc
    // 0x100003e9c
    while (v3 != 0) {
        // 0x100003e9c
        _printf(" %s", (char *)v1);
        v3 += 8;
    }
    // 0x100003f28
    return _puts(" ]");
}

// Address range: 0x100003f34 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003f34
    function_100003e50();
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(int32_t c) {
    // 0x100003f88
    return _putchar(c);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * s) {
    // 0x100003f94
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

#define s(x) (1U << ((x) - 'A'))

typedef unsigned int bitset;

int consolidate(bitset *x, int len)
{
	int i, j;
	for (i = len - 2; i >= 0; i--)
		for (j = len - 1; j > i; j--)
			if (x[i] & x[j])
				x[i] |= x[j], x[j] = x[--len];
	return len;
}

void show_sets(bitset *x, int len)
{
	bitset b;
	while(len--) {
		for (b = 'A'; b <= 'Z'; b++)
			if (x[len] & s(b)) printf("%c ", b);
		putchar('\n');
	}
}

int main(void)
{
	bitset x[] = { s('A') | s('B'), s('C') | s('D'), s('B') | s('D'),
			s('F') | s('G') | s('H'), s('H') | s('I') | s('K') };

	int len = sizeof(x) / sizeof(x[0]);

	puts("Before:"); show_sets(x, len);
	puts("\nAfter:"); show_sets(x, consolidate(x, len));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc8(void);
int64_t function_100003dc4(void);
int64_t function_100003f48(int64_t a1);
int32_t function_100003f54(char * format, ...);
int32_t function_100003f60(int32_t c);
int32_t function_100003f6c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cc8 - 0x100003dc4
int64_t function_100003cc8(void) {
    // 0x100003cc8
    int64_t v1; // 0x100003cc8
    int32_t result = v1; // 0x100003cd0
    int32_t v2 = result - 2; // 0x100003cd8
    if (v2 < 0) {
        // 0x100003db8
        return result;
    }
    int32_t v3 = v2; // 0x100003dac
    int64_t v4 = v2;
    int32_t v5 = result - 1;
    int32_t v6 = v4;
    int32_t v7 = v5 - v6; // 0x100003d10
    int32_t v8 = result; // 0x100003d18
    int32_t v9; // 0x100003cc8
    int32_t v10; // 0x100003cc8
    int32_t v11; // 0x100003cc8
    int32_t v12; // 0x100003d28
    int32_t * v13; // 0x100003d34
    int32_t v14; // 0x100003d34
    int32_t v15; // 0x100003d10
    int32_t v16; // 0x100003d74
    int32_t * v17; // 0x100003d28
    if (v7 != 0 && v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0) {
        // 0x100003d20
        v17 = (int32_t *)(4 * v4 + v1);
        v11 = v5;
        v12 = *v17;
        v13 = (int32_t *)(4 * (int64_t)v11 + v1);
        v14 = *v13;
        v16 = result;
        if ((v14 & v12) != 0) {
            // 0x100003d48
            *v17 = v14 | v12;
            v16 = result - 1;
            *v13 = *(int32_t *)(v1 + (int64_t)(4 * v16));
        }
        // 0x100003d94
        v10 = v16;
        v11--;
        v15 = v11 - v6;
        v8 = v10;
        while (v15 != 0 && v15 < 0 == ((v15 ^ v11) & (v11 ^ v6)) < 0) {
            // 0x100003d20
            v9 = v10;
            v12 = *v17;
            v13 = (int32_t *)(4 * (int64_t)v11 + v1);
            v14 = *v13;
            v16 = v9;
            if ((v14 & v12) != 0) {
                // 0x100003d48
                *v17 = v14 | v12;
                v16 = v9 - 1;
                *v13 = *(int32_t *)(v1 + (int64_t)(4 * v16));
            }
            // 0x100003d94
            v10 = v16;
            v11--;
            v15 = v11 - v6;
            v8 = v10;
        }
    }
    int32_t result2 = v8;
    v3--;
    int64_t v18 = v4 - 1; // 0x100003cf0
    while (v3 >= 0) {
        int32_t v19 = result2;
        v4 = v18;
        v5 = v19 - 1;
        v6 = v4;
        v7 = v5 - v6;
        v8 = v19;
        if (v7 != 0 && v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0) {
            // 0x100003d20
            v17 = (int32_t *)(4 * v4 + v1);
            v11 = v5;
            v9 = v19;
            v12 = *v17;
            v13 = (int32_t *)(4 * (int64_t)v11 + v1);
            v14 = *v13;
            v16 = v9;
            if ((v14 & v12) != 0) {
                // 0x100003d48
                *v17 = v14 | v12;
                v16 = v9 - 1;
                *v13 = *(int32_t *)(v1 + (int64_t)(4 * v16));
            }
            // 0x100003d94
            v10 = v16;
            v11--;
            v15 = v11 - v6;
            v8 = v10;
            while (v15 != 0 && v15 < 0 == ((v15 ^ v11) & (v11 ^ v6)) < 0) {
                // 0x100003d20
                v9 = v10;
                v12 = *v17;
                v13 = (int32_t *)(4 * (int64_t)v11 + v1);
                v14 = *v13;
                v16 = v9;
                if ((v14 & v12) != 0) {
                    // 0x100003d48
                    *v17 = v14 | v12;
                    v16 = v9 - 1;
                    *v13 = *(int32_t *)(v1 + (int64_t)(4 * v16));
                }
                // 0x100003d94
                v10 = v16;
                v11--;
                v15 = v11 - v6;
                v8 = v10;
            }
        }
        // 0x100003da8
        result2 = v8;
        v3--;
        v18 = v4 - 1;
    }
    // 0x100003db8
    return result2;
}

// Address range: 0x100003dc4 - 0x100003e90
int64_t function_100003dc4(void) {
    // 0x100003dc4
    int64_t v1; // 0x100003dc4
    int32_t v2 = v1; // 0x100003dd4
    if (v2 == 0) {
        // 0x100003e84
        int64_t result; // 0x100003dc4
        return result;
    }
    int32_t v3 = v2;
    v3--;
    for (int32_t i = 65; i < 91; i++) {
        // 0x100003e18
        if ((1 << i - 65 & *(int32_t *)(4 * (int64_t)v3 + v1)) != 0) {
            // 0x100003e44
            _printf("%c ", (char)v1);
        }
    }
    int32_t result2 = _putchar(10); // 0x100003e7c
    while (v3 != 0) {
        // 0x100003e04
        v3--;
        for (int32_t i = 65; i < 91; i++) {
            // 0x100003e18
            if ((1 << i - 65 & *(int32_t *)(4 * (int64_t)v3 + v1)) != 0) {
                // 0x100003e44
                _printf("%c ", (char)v1);
            }
        }
        // 0x100003e78
        result2 = _putchar(10);
    }
    // 0x100003e84
    return result2;
}

// Address range: 0x100003e90 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003e90
    _puts("Before:");
    function_100003dc4();
    _puts("\nAfter:");
    function_100003cc8();
    int64_t v1 = function_100003dc4(); // 0x100003f10
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f20
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f34
        ___stack_chk_fail(v1);
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(int64_t a1) {
    // 0x100003f48
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t c) {
    // 0x100003f60
    return _putchar(c);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * s) {
    // 0x100003f6c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_LEN INT_MAX

int main(int argc, char **argv)
{
    int *a, n = 10, i, j, temp, sum = 0;
    float mean;

    if (argc == 2)
    {
        n = atoi(argv[1]);
        if (n >= MAX_LEN)
        {
            fprintf(stderr, "Maximum %d!\n", MAX_LEN);
            return 1;
        }
    }
    
    a = (int *)malloc(n * sizeof(int));

    printf("Random Numbers Generated are: ");
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
        printf("%2d, ", a[i]);
    }
    putchar('\n');

    for (i = 0; i < n; i++) sum = sum + a[i];

    mean = sum / (float)n;
    printf("\nMean: ");
    printf("%f\n", mean);

    free(a);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f14(char * nptr);
int32_t function_100003f20(struct _IO_FILE * stream, char * format, ...);
void function_100003f2c(int64_t * ptr);
int64_t * function_100003f38(int32_t size);
int32_t function_100003f44(char * format, ...);
int32_t function_100003f50(int32_t c);
int32_t function_100003f5c(void);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003d38 - 0x100003f14
int64_t entry_point(void) {
    int32_t v1 = 10; // 0x100003d68
    int64_t v2; // 0x100003d38
    if ((int32_t)v2 == 2) {
        // 0x100003d70
        v1 = _atoi((char *)*(int64_t *)(v2 + 8));
        if (v1 < 0x7fffffff == (0x7ffffffe - v1 & v1) < 0) {
            // 0x100003d98
            _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "Maximum %d!\n", v2);
            // 0x100003f04
            return 1;
        }
    }
    int64_t * v3 = _malloc(4 * v1); // 0x100003dd4
    _printf("Random Numbers Generated are: ");
    int32_t v4 = -v1;
    int32_t v5 = 0; // 0x100003e00
    if (v4 < 0 == (v1 & v4) < 0) {
        // 0x100003e60
        _putchar(10);
    } else {
        *(int32_t *)(4 * (int64_t)v5 + (int64_t)v3) = _rand() % 100;
        _printf("%2d, ", v2);
        v5++;
        while (v5 - v1 < 0 != ((v5 - v1 ^ v5) & (v5 ^ v1)) < 0) {
            // 0x100003e08
            *(int32_t *)(4 * (int64_t)v5 + (int64_t)v3) = _rand() % 100;
            _printf("%2d, ", v2);
            v5++;
        }
        // 0x100003e88
        _putchar(10);
        int32_t v6 = 0; // 0x100003ea8
        v6++;
        while (v6 - v1 < 0 != ((v6 - v1 ^ v6) & (v6 ^ v1)) < 0) {
            // 0x100003e88
            v6++;
        }
    }
    // 0x100003eb4
    _printf("\nMean: ");
    int128_t v7; // 0x100003d38
    _printf("%f\n", (float64_t)(int64_t)v7);
    _free(v3);
    // 0x100003f04
    return 0;
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * nptr) {
    // 0x100003f14
    return _atoi(nptr);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f20
    return _fprintf(stream, format);
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(int64_t * ptr) {
    // 0x100003f2c
    _free(ptr);
}

// Address range: 0x100003f38 - 0x100003f44
int64_t * function_100003f38(int32_t size) {
    // 0x100003f38
    return _malloc(size);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int32_t c) {
    // 0x100003f50
    return _putchar(c);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(void) {
    // 0x100003f5c
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int a, b;
  if (argc < 3) exit(1);
  b = atoi(argv[--argc]);
  if (b == 0) exit(2);
  a = atoi(argv[--argc]);
  printf("a+b = %d\n", a+b);
  printf("a-b = %d\n", a-b);
  printf("a*b = %d\n", a*b);
  printf("a/b = %d\n", a/b); /* truncates towards 0 (in C99) */
  printf("a%%b = %d\n", a%b); /* same sign as first operand (in C99) */
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f50(char * nptr);
void function_100003f5c(int32_t status);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dfc - 0x100003f50
int64_t entry_point(void) {
    // 0x100003dfc
    int64_t v1; // 0x100003dfc
    int32_t v2 = v1; // 0x100003e0c
    if (v2 < 3 != (2 - v2 & v2) < 0) {
        // 0x100003e28
        _exit(1);
        // UNREACHABLE
    }
    int32_t v3 = 8 * v2; // 0x100003e38
    if (_atoi((char *)*(int64_t *)(v1 + (int64_t)(v3 - 8))) == 0) {
        // 0x100003e60
        _exit(2);
        // UNREACHABLE
    }
    // 0x100003e68
    _atoi((char *)*(int64_t *)(v1 + (int64_t)(v3 - 16)));
    _printf("a+b = %d\n", v1);
    _printf("a-b = %d\n", v1);
    _printf("a*b = %d\n", v1);
    _printf("a/b = %d\n", v1);
    _printf("a%%b = %d\n", v1);
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * nptr) {
    // 0x100003f50
    return _atoi(nptr);
}

// Address range: 0x100003f5c - 0x100003f68
void function_100003f5c(int32_t status) {
    // 0x100003f5c
    _exit(status);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include<limits.h>
#include<stdio.h>

int fusc(int n){
        if(n==0||n==1)
                return n;
        else if(n%2==0)
                return fusc(n/2);
        else
                return fusc((n-1)/2) + fusc((n+1)/2);
}

int numLen(int n){
        int sum = 1;

        while(n>9){
                n = n/10;
                sum++;
        }

        return sum;
}

void printLargeFuscs(int limit){
        int i,f,len,maxLen = 1;

        printf("\n\nPrinting all largest Fusc numbers upto %d \nIndex-------Value",limit);

        for(i=0;i<=limit;i++){
                f = fusc(i);
                len = numLen(f);

                if(len>maxLen){
                        maxLen = len;
                        printf("\n%5d%12d",i,f);
                }
        }
}


int main()
{
        int i;

        printf("Index-------Value");
        for(i=0;i<61;i++)
                printf("\n%5d%12d",i,fusc(i));
        printLargeFuscs(INT_MAX);
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca0(void);
int64_t function_100003d74(void);
int64_t function_100003dc8(void);
int32_t function_100003f38(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca0 - 0x100003d74
int64_t function_100003ca0(void) {
    // 0x100003ca0
    int64_t v1; // 0x100003ca0
    int32_t v2 = v1; // 0x100003cac
    int64_t v3; // 0x100003ca0
    if (v2 < 2) {
        // 0x100003d64
        return v3 & 0xffffffff;
    }
    int64_t v4 = function_100003ca0();
    v3 = v4;
    if (2 * v2 / 2 != v2) {
        // 0x100003d20
        v3 = function_100003ca0() + v4;
    }
    // 0x100003d64
    return v3 & 0xffffffff;
}

// Address range: 0x100003d74 - 0x100003dc8
int64_t function_100003d74(void) {
    // 0x100003d74
    int64_t v1; // 0x100003d74
    int32_t v2 = v1; // 0x100003d78
    int32_t v3 = v2 - 9; // 0x100003d8c
    int32_t result = 1; // 0x100003d94
    if (v3 == 0 || v3 < 0 != (8 - v2 & v2) < 0) {
        // 0x100003dbc
        return 1;
    }
    int32_t v4 = v2; // 0x100003d94
    v4 /= 10;
    result++;
    while (v4 != 9 && v4 < 9 == (8 - v4 & v4) < 0) {
        // 0x100003d9c
        v4 /= 10;
        result++;
    }
    // 0x100003dbc
    return result;
}

// Address range: 0x100003dc8 - 0x100003ea0
int64_t function_100003dc8(void) {
    // 0x100003dc8
    int64_t v1; // 0x100003dc8
    int32_t v2 = v1; // 0x100003dd4
    int32_t v3 = -v2; // 0x100003e0c
    int32_t v4 = 0; // 0x100003e14
    int64_t result = _printf("\n\nPrinting all largest Fusc numbers upto %d \nIndex-------Value", v1); // 0x100003e14
    if (v2 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e94
        return result;
    }
    int32_t v5 = 1;
    function_100003ca0();
    int64_t v6 = function_100003d74(); // 0x100003e2c
    int32_t v7 = v6; // 0x100003e30
    int32_t v8 = v7 - v5; // 0x100003e3c
    int64_t result2 = v6; // 0x100003e44
    int32_t v9 = v5; // 0x100003e44
    if (v8 != 0 && v8 < 0 == ((v8 ^ v7) & (v5 ^ v7)) < 0) {
        // 0x100003e4c
        result2 = _printf("\n%5d%12d", v1, v1);
        v9 = v7;
    }
    // 0x100003e84
    v4++;
    int32_t v10 = v4 - v2; // 0x100003e0c
    while (v10 == 0 || v10 < 0 != ((v10 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003e1c
        v5 = v9;
        function_100003ca0();
        v6 = function_100003d74();
        v7 = v6;
        v8 = v7 - v5;
        result2 = v6;
        v9 = v5;
        if (v8 != 0 && v8 < 0 == ((v8 ^ v7) & (v5 ^ v7)) < 0) {
            // 0x100003e4c
            result2 = _printf("\n%5d%12d", v1, v1);
            v9 = v7;
        }
        // 0x100003e84
        v4++;
        v10 = v4 - v2;
    }
    // 0x100003e94
    return result2;
}

// Address range: 0x100003ea0 - 0x100003f38
int64_t entry_point(void) {
    // 0x100003ea0
    _printf("Index-------Value");
    for (int32_t i = 0; i < 61; i++) {
        // 0x100003ed8
        function_100003ca0();
        int64_t v1; // 0x100003ea0
        _printf("\n%5d%12d", v1, v1);
    }
    // 0x100003f20
    function_100003dc8();
    return 0;
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <string.h>
#include <stdio.h>
#include <stdlib.h>

  /* removes all chars from string */
char *strip_chars(const char *string, const char *chars)
{
  char * newstr = malloc(strlen(string) + 1);
  int counter = 0;

  for ( ; *string; string++) {
    if (!strchr(chars, *string)) {
      newstr[ counter ] = *string;
      ++ counter;
    }
  }

  newstr[counter] = 0;
  return newstr;
}

int main(void)
{
  char *new = strip_chars("She was a soul stripper. She took my heart!", "aei");
  printf("%s\n", new);

  free(new);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e14(void);
void function_100003f38(int64_t * ptr);
int64_t * function_100003f44(int32_t size);
int32_t function_100003f50(char * format, ...);
char * function_100003f5c(char * s, int32_t c);
int32_t function_100003f68(char * s);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e14 - 0x100003ed8
int64_t function_100003e14(void) {
    // 0x100003e14
    int64_t v1; // 0x100003e14
    char * v2 = (char *)v1; // 0x100003e20
    int64_t result = (int64_t)_malloc(_strlen(v2) + 1); // 0x100003e34
    char v3 = *v2; // 0x100003e48
    if (v3 == 0) {
        // 0x100003eb8
        *(char *)((int64_t)0 + result) = 0;
        return result;
    }
    int32_t v4 = 0;
    int32_t v5 = v4; // 0x100003e74
    if (_strchr((char *)v1, (int32_t)v3) == NULL) {
        // 0x100003e7c
        *(char *)((int64_t)v4 + result) = *v2;
        v5 = v4 + 1;
    }
    int32_t v6 = v5;
    char * v7 = (char *)((int64_t)v2 + 1); // 0x100003eb0
    char v8 = *v7; // 0x100003e48
    while (v8 != 0) {
        // 0x100003e5c
        v4 = v6;
        char * v9 = v7;
        v5 = v4;
        if (_strchr((char *)v1, (int32_t)v8) == NULL) {
            // 0x100003e7c
            *(char *)((int64_t)v4 + result) = *v9;
            v5 = v4 + 1;
        }
        // 0x100003ea8
        v6 = v5;
        v7 = (char *)((int64_t)v9 + 1);
        v8 = *v7;
    }
    // 0x100003eb8
    *(char *)((int64_t)v6 + result) = 0;
    return result;
}

// Address range: 0x100003ed8 - 0x100003f38
int64_t entry_point(void) {
    int64_t v1 = function_100003e14(); // 0x100003f00
    _printf("%s\n", "aei");
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int64_t * ptr) {
    // 0x100003f38
    _free(ptr);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int32_t size) {
    // 0x100003f44
    return _malloc(size);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _printf(format);
}

// Address range: 0x100003f5c - 0x100003f68
char * function_100003f5c(char * s, int32_t c) {
    // 0x100003f5c
    return _strchr(s, c);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * s) {
    // 0x100003f68
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

const int digits[] = { 0,1,2,3,4,5,6,7,8,9 };

// calculates factorial of a number
int factorial(int n) {
    return n == 0 ? 1 : n * factorial(n - 1);
}

// returns sum of squares of digits of n
unsigned int sum_square_digits(unsigned int n) {
        int i,num=n,sum=0;
        // process digits one at a time until there are none left
        while (num > 0) {
                // peal off the last digit from the number
                int digit=num % 10;
                num=(num - digit)/10;
                // add it's square to the sum
                sum=sum+digit*digit;
        }
        return sum;
}

// builds all combinations digits 0-9 of length len
// for each of these it will perform iterated digit squaring
// and for those which result in 89 add to a counter which is
// passed by pointer.
long choose_sum_and_count_89(int * got, int n_chosen, int len, int at, int max_types, int *count89)
{
        int i;
        long count = 0;
        int digitcounts[10];
        for (i=0; i < 10; i++) {
                digitcounts[i]=0;
        }
        if (n_chosen == len) {
                if (!got) return 1;

                int sum=0;
                for (i = 0; i < len; i++) {
                        int digit=digits[got[i]];
                        digitcounts[digit]++;
                        sum=sum + digit * digit;
                }
                if (sum == 0) {
                        return 1;
                }
                if ((sum != 1) && (sum != 89)) {
                        while ((sum != 1) && (sum != 89)) {
                                sum=sum_square_digits(sum);
                        }
                }
                if (sum == 89) {
                        int count_this_comb=factorial(len);
                        for (i=0; i<10; i++) {
                                count_this_comb/=factorial(digitcounts[i]);
                        }
                        (*count89)+=count_this_comb;
                }

                return 1;
        }

        for (i = at; i < max_types; i++) {
                if (got) got[n_chosen] = i;
                count += choose_sum_and_count_89(got, n_chosen + 1, len, i, max_types, count89);
        }
        return count;
}

int main(void)
{
        int chosen[10];
        int count=0;
        // build all unique 8 digit combinations which represent
        // numbers 0-99,999,999 and count those
        // whose iterated digit squaring sum to 89
        // case 0, 100,000,000 are ignored since they don't sum to 89
        choose_sum_and_count_89(chosen, 0, 8, 0, 10, &count);
        printf("%d\n",count);
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ab4(void);
int64_t function_100003b18(void);
int64_t function_100003b98(void);
int64_t function_100003f5c(int64_t a1);
int32_t function_100003f68(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000000; // 0x100003f74

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ab4 - 0x100003b18
int64_t function_100003ab4(void) {
    int64_t result = 1; // 0x100003ad0
    int64_t v1; // 0x100003ab4
    if ((int32_t)v1 != 0) {
        // 0x100003ae4
        result = function_100003ab4() * v1 & 0xffffffff;
    }
    // 0x100003b08
    return result;
}

// Address range: 0x100003b18 - 0x100003b98
int64_t function_100003b18(void) {
    // 0x100003b18
    int64_t v1; // 0x100003b18
    int32_t v2 = v1; // 0x100003b1c
    int32_t result = 0; // 0x100003b3c
    if (v2 < 1) {
        // 0x100003b8c
        return 0;
    }
    uint32_t v3 = v2; // 0x100003b3c
    uint32_t v4 = v3 % 10;
    result += v4 * v4;
    while (v3 >= 10) {
        // 0x100003b44
        v3 /= 10;
        v4 = v3 % 10;
        result += v4 * v4;
    }
    // 0x100003b8c
    return result;
}

// Address range: 0x100003b98 - 0x100003ecc
int64_t function_100003b98(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003bac
    int64_t v2; // 0x100003b98
    int32_t v3 = v2; // 0x100003bb8
    int64_t v4; // bp-64, 0x100003b98
    int64_t v5 = &v4;
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003bec
        *(int32_t *)(4 * i + v5) = 0;
    }
    int32_t v6; // 0x100003b98
    int64_t result; // 0x100003b98
    int64_t v7; // 0x100003b98
    int64_t v8; // 0x100003b98
    if (v3 == (int32_t)v2) {
        // 0x100003c28
        result = 1;
        v8 = 0;
        if (v2 == 0) {
            goto lab_0x100003e90;
        } else {
            int32_t v9 = -v3; // 0x100003c5c
            int32_t v10 = 0; // 0x100003c64
            result = 1;
            if (v9 < 0 == (v9 & v3) < 0) {
                goto lab_0x100003e90;
            } else {
                int32_t v11 = *(int32_t *)(4 * (int64_t)v10 + v2); // 0x100003c74
                int32_t v12 = *(int32_t *)(4 * (int64_t)v11 + (int64_t)&g1); // 0x100003c80
                int32_t * v13 = (int32_t *)(4 * (int64_t)v12 + v5); // 0x100003c94
                *v13 = *v13 + 1;
                int32_t v14 = v12 * v12; // 0x100003cb0
                int32_t v15 = v10 + 1; // 0x100003cc0
                int32_t v16 = v15 - v3; // 0x100003c5c
                v10 = v15;
                int32_t v17 = v14; // 0x100003c64
                while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v3)) < 0) {
                    // 0x100003c6c
                    v11 = *(int32_t *)(4 * (int64_t)v10 + v2);
                    v12 = *(int32_t *)(4 * (int64_t)v11 + (int64_t)&g1);
                    v13 = (int32_t *)(4 * (int64_t)v12 + v5);
                    *v13 = *v13 + 1;
                    v14 = v12 * v12 + v17;
                    v15 = v10 + 1;
                    v16 = v15 - v3;
                    v10 = v15;
                    v17 = v14;
                }
                // 0x100003ccc
                v6 = v14;
                result = 1;
                switch (v14) {
                    case 0: {
                        goto lab_0x100003e90;
                    }
                    case 89: {
                        goto lab_0x100003d68;
                    }
                    case 1: {
                        goto lab_0x100003d68;
                    }
                    default: {
                        if (v14 == 89) {
                            goto lab_0x100003d7c;
                        } else {
                            int64_t v18 = function_100003b18(); // 0x100003d58
                            int32_t v19 = v18;
                            v6 = v19;
                            v7 = v18;
                            while (v19 != 1 == (v19 != 89)) {
                                // 0x100003d54
                                v18 = function_100003b18();
                                v19 = v18;
                                v6 = v19;
                                v7 = v18;
                            }
                            goto lab_0x100003d68;
                        }
                    }
                }
            }
        }
    } else {
        int32_t v20 = v2; // 0x100003bc0
        int32_t v21 = v2; // 0x100003bc4
        int32_t v22 = v20 - v21; // 0x100003e0c
        result = 0;
        if (v22 < 0 != ((v22 ^ v20) & (int32_t)(v2 ^ v2)) < 0) {
            int64_t v23 = 0; // 0x100003e68
            if (v2 != 0) {
                // 0x100003e30
                *(int32_t *)((0x100000000 * v2 >> 30) + v2) = v20;
            }
            int64_t v24 = function_100003b98(); // 0x100003e60
            v23 += v24;
            int32_t v25 = v20 + 1; // 0x100003e78
            int32_t v26 = v25 - v21; // 0x100003e0c
            result = v23;
            v8 = v24;
            while (v26 < 0 != ((v26 ^ v25) & (v25 ^ v21)) < 0) {
                int32_t v27 = v25;
                if (v2 != 0) {
                    // 0x100003e30
                    *(int32_t *)((0x100000000 * v2 >> 30) + v2) = v27;
                }
                // 0x100003e44
                v24 = function_100003b98();
                v23 += v24;
                v25 = v27 + 1;
                v26 = v25 - v21;
                result = v23;
                v8 = v24;
            }
        }
        goto lab_0x100003e90;
    }
  lab_0x100003e90:
    // 0x100003e90
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003eb8
        ___stack_chk_fail(v8);
    }
    // 0x100003ebc
    return result;
  lab_0x100003d68:
    // 0x100003d68
    result = 1;
    v8 = v7;
    if (v6 == 89) {
        goto lab_0x100003d7c;
    } else {
        goto lab_0x100003e90;
    }
  lab_0x100003d7c:;
    int32_t v28 = function_100003ab4(); // 0x100003b98
    int64_t v29 = function_100003ab4(); // 0x100003db0
    int32_t v30 = v28 / (int32_t)v29; // 0x100003db8
    int32_t v31 = 1; // 0x100003dc8
    int32_t v32 = v31; // 0x100003d9c
    v28 = v30;
    while (v31 != 10) {
        // 0x100003da4
        v29 = function_100003ab4();
        v30 = v28 / (int32_t)v29;
        v31 = v32 + 1;
        v32 = v31;
        v28 = v30;
    }
    // 0x100003dd4
    int64_t v33; // 0x100003b98
    *(int32_t *)v2 = *(int32_t *)&v33 + v30;
    result = 1;
    v8 = v29;
    goto lab_0x100003e90;
}

// Address range: 0x100003ecc - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003ecc
    function_100003b98();
    int32_t v1 = _printf("%d\n", 0); // 0x100003f24
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f34
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f48
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f4c
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(int64_t a1) {
    // 0x100003f5c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include<string.h>
#include<stdio.h>

int main(int argc,char** argv)
{
    int i,len;
    char reference;

    if(argc>2){
        printf("Usage : %s <Test String>\n",argv[0]);
        return 0;
    }

    if(argc==1||strlen(argv[1])==1){
        printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argc==1?"":argv[1],argc==1?0:(int)strlen(argv[1]));
        return 0;
    }

    reference = argv[1][0];
    len = strlen(argv[1]);

    for(i=1;i<len;i++){
        if(argv[1][i]!=reference){
            printf("Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n",argv[1],len,argv[1][i],argv[1][i],i+1);
            return 0;
        }
    }

    printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argv[1],len);

    return 0;

}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003edc(char * format, ...);
int32_t function_100003ee8(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c8c - 0x100003edc
int64_t entry_point(void) {
    // 0x100003c8c
    int64_t v1; // 0x100003c8c
    int32_t v2 = v1; // 0x100003c9c
    int32_t v3 = v2 - 2; // 0x100003ca8
    if (v3 != 0 && v3 < 0 == (1 - v2 & v2) < 0) {
        // 0x100003cb8
        _printf("Usage : %s <Test String>\n", (char *)v1);
        // 0x100003ecc
        return 0;
    }
    if (v2 == 1) {
        // 0x100003d80
        _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
        // 0x100003ecc
        return 0;
    }
    int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003cf4
    int32_t v5 = _strlen((char *)*v4); // 0x100003cf8
    char * v6 = (char *)*v4;
    if (v5 == 1) {
        // 0x100003d68
        _strlen(v6);
        // 0x100003d80
        _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
        // 0x100003ecc
        return 0;
    }
    int32_t v7 = _strlen(v6); // 0x100003dc4
    int32_t v8 = 1 - v7; // 0x100003de4
    if (v8 < 0 == (v8 & v7) < 0) {
        // 0x100003e9c
        _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
        // 0x100003ecc
        return 0;
    }
    int32_t v9 = 1; // 0x100003e90
    while (*v6 == *(char *)(*v4 + (int64_t)v9)) {
        // 0x100003ddc
        v9++;
        int32_t v10 = v9 - v7; // 0x100003de4
        if (v10 < 0 == ((v10 ^ v9) & (v9 ^ v7)) < 0) {
            // 0x100003e9c
            _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
            // 0x100003ecc
            return 0;
        }
    }
    // 0x100003e18
    _printf("Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n", (char *)v1, v1, (char)v1, (int32_t)v1, v1);
    // 0x100003ecc
    return 0;
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * format, ...) {
    // 0x100003edc
    return _printf(format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * s) {
    // 0x100003ee8
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdlib.h>	/* exit() */
#include <stdio.h>	/* fputs(), printf() */
#include <string.h>

int
main()
{
	char src[] = "Hello";
	char dst[80];

	/* Use strlcpy() from <string.h>. */
	if (strlcpy(dst, src, sizeof dst) >= sizeof dst) {
		fputs("The buffer is too small!\n", stderr);
		exit(1);
	}

	memset(src, '-', 5);
	printf("src: %s\n", src);  /* src: ----- */
	printf("dst: %s\n", dst);  /* dst: Hello */

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f38(int64_t a1);
int64_t function_100003f44(int64_t * a1, int64_t * a2, int64_t a3);
void function_100003f50(int32_t status);
int32_t function_100003f5c(char * s, struct _IO_FILE * stream);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strlcpy_chk(int64_t * a1, int64_t * a2, int64_t a3);
int32_t _fputs(char * a1, struct _IO_FILE * a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e44 - 0x100003f38
int64_t entry_point(void) {
    int64_t v1 = 0x6c6c6548; // bp-116, 0x100003e74
    int64_t v2; // bp-104, 0x100003e44
    if (___strlcpy_chk(&v2, &v1, 80) >= 80) {
        int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003ea8
        _fputs("The buffer is too small!\n", (struct _IO_FILE *)v3);
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003ec0
    v1 = 0x2d2d2d2d;
    _printf("src: %s\n", &v1);
    int32_t v4 = _printf("dst: %s\n", &v1); // 0x100003f00
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f10
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f24
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003f28
    return 0;
}

// Address range: 0x100003f38 - 0x100003f44
int64_t function_100003f38(int64_t a1) {
    // 0x100003f38
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t function_100003f44(int64_t * a1, int64_t * a2, int64_t a3) {
    // 0x100003f44
    return ___strlcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f50 - 0x100003f5c
void function_100003f50(int32_t status) {
    // 0x100003f50
    _exit(status);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * s, struct _IO_FILE * stream) {
    // 0x100003f5c
    return _fputs(s, stream);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

int **m;
int **s;

void optimal_matrix_chain_order(int *dims, int n) {
    int len, i, j, k, temp, cost;
    n--;
    m = (int **)malloc(n * sizeof(int *));
    for (i = 0; i < n; ++i) {
        m[i] = (int *)calloc(n, sizeof(int));
    }

    s = (int **)malloc(n * sizeof(int *));
    for (i = 0; i < n; ++i) {
        s[i] = (int *)calloc(n, sizeof(int));
    }

    for (len = 1; len < n; ++len) {
        for (i = 0; i < n - len; ++i) {
            j = i + len;
            m[i][j] = INT_MAX;
            for (k = i; k < j; ++k) {
                temp = dims[i] * dims[k + 1] * dims[j + 1];
                cost = m[i][k] + m[k + 1][j] + temp;
                if (cost < m[i][j]) {
                    m[i][j] = cost;
                    s[i][j] = k;
                }
            }
        }
    }
}

void print_optimal_chain_order(int i, int j) {
    if (i == j)
        printf("%c", i + 65);
    else {
        printf("(");
        print_optimal_chain_order(i, s[i][j]);
        print_optimal_chain_order(s[i][j] + 1, j);
        printf(")");
    }
}

int main() {
    int i, j, n;
    int a1[4]  = {5, 6, 3, 1};
    int a2[13] = {1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2};
    int a3[12] = {1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10};
    int *dims_list[3] = {a1, a2, a3};
    int sizes[3] = {4, 13, 12};
    for (i = 0; i < 3; ++i) {
        printf("Dims  : [");
        n = sizes[i];
        for (j = 0; j < n; ++j) {
            printf("%d", dims_list[i][j]);
            if (j < n - 1) printf(", "); else printf("]\n");
        }
        optimal_matrix_chain_order(dims_list[i], n);
        printf("Order : ");
        print_optimal_chain_order(0, n - 2);
        printf("\nCost  : %d\n\n", m[0][n - 2]);
        for (j = 0; j <= n - 2; ++j) free(m[j]);
        free(m);
        for (j = 0; j <= n - 2; ++j) free(s[j]);
        free(s);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003840(void);
int64_t function_100003b08(void);
int64_t function_100003ea4(int64_t a1);
int64_t * function_100003eb0(int32_t nmemb, int32_t size);
void function_100003ebc(int64_t * ptr);
int64_t * function_100003ec8(int32_t size);
int64_t * function_100003ed4(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ee0(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x500000001; // 0x100003f30
int64_t g2 = 0x1000003e8; // 0x100003f64
int64_t g3 = 0xd00000004; // 0x100003f94
int64_t g4 = 0x100000cfeedfacf; // 0x100008000
int64_t g5 = 0x200000000; // 0x100008008
int32_t g6;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003840 - 0x100003b08
int64_t function_100003840(void) {
    // 0x100003840
    int64_t v1; // 0x100003840
    int32_t v2 = v1; // 0x100003850
    int32_t v3 = v2 - 1; // 0x100003858
    int32_t v4 = 8 * v3; // 0x100003864
    g4 = (int64_t)_malloc(v4);
    int32_t v5 = 1 - v2;
    int32_t v6 = 0; // 0x100003890
    int64_t result; // 0x100003840
    if (v5 < 0 == (v5 & v3) < 0) {
        int64_t v7 = (int64_t)_malloc(v4); // 0x1000038d4
        g5 = v7;
        result = v7;
    } else {
        int64_t * v8 = _calloc(v3, 4); // 0x1000038a0
        *(int64_t *)(g4 + 8 * (int64_t)v6) = (int64_t)v8;
        v6++;
        while (v6 - v3 < 0 != ((v6 - v3 ^ v6) & (v6 ^ v3)) < 0) {
            // 0x100003898
            v8 = _calloc(v3, 4);
            *(int64_t *)(g4 + 8 * (int64_t)v6) = (int64_t)v8;
            v6++;
        }
        // 0x100003904
        g5 = (int64_t)_malloc(v4);
        int32_t v9 = 0; // 0x10000392c
        int64_t v10 = (int64_t)_calloc(v3, 4);
        *(int64_t *)(g5 + 8 * (int64_t)v9) = v10;
        v9++;
        int32_t v11 = v9 - v3; // 0x1000038f4
        result = v10;
        while (v11 < 0 != ((v11 ^ v9) & (v9 ^ v3)) < 0) {
            // 0x100003904
            v10 = (int64_t)_calloc(v3, 4);
            *(int64_t *)(g5 + 8 * (int64_t)v9) = v10;
            v9++;
            v11 = v9 - v3;
            result = v10;
        }
    }
    int32_t v12 = 2 - v2; // 0x10000394c
    if (v12 < 0 == (v12 & v3) < 0) {
        // 0x100003afc
        return result;
    }
    int32_t v13 = 1;
    int32_t v14 = v3 - v13; // 0x100003970
    int32_t v15 = -v14; // 0x100003974
    int32_t v16; // 0x100003840
    int32_t v17; // 0x100003840
    int32_t v18; // 0x1000039c8
    int32_t v19; // 0x10000398c
    int64_t v20; // 0x1000039a0
    int64_t v21; // 0x1000039a4
    int64_t v22; // 0x1000039b0
    int32_t v23; // 0x100003adc
    int32_t v24; // 0x1000039e0
    int32_t v25; // 0x1000039f0
    int32_t v26; // 0x100003a04
    int64_t v27; // 0x100003a20
    int32_t v28; // 0x100003a28
    int64_t v29; // 0x100003a38
    int32_t v30; // 0x100003a4c
    int32_t * v31; // 0x100003a68
    int32_t v32; // 0x100003a68
    int32_t v33; // 0x100003a6c
    int32_t v34; // 0x100003ac8
    if (v15 < 0 != (v14 & v15) < 0) {
        // 0x100003984
        v18 = -v13;
        v17 = 0;
        v19 = v17 + v13;
        v20 = v17;
        v21 = 8 * v20;
        v22 = 4 * (int64_t)v19;
        *(int32_t *)(v22 + *(int64_t *)(v21 + g4)) = 0x7fffffff;
        if (v18 < 0 != ((v19 ^ v17) & (v17 ^ v18)) < 0) {
            // 0x1000039d8
            v16 = v17;
            v24 = *(int32_t *)(4 * v20 + v1);
            v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
            v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
            v27 = *(int64_t *)(g4 + v21);
            v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
            v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
            v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
            v31 = (int32_t *)(v27 + v22);
            v32 = *v31;
            v33 = v30 - v32;
            if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                // 0x100003a7c
                *v31 = v30;
                *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
            }
            // 0x100003ac4
            v34 = v16 + 1;
            while (v34 - v19 < 0 != ((v34 - v19 ^ v34) & (v34 ^ v19)) < 0) {
                // 0x1000039d8
                v16 = v34;
                v24 = *(int32_t *)(4 * v20 + v1);
                v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                v27 = *(int64_t *)(g4 + v21);
                v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                v31 = (int32_t *)(v27 + v22);
                v32 = *v31;
                v33 = v30 - v32;
                if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                    // 0x100003a7c
                    *v31 = v30;
                    *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                }
                // 0x100003ac4
                v34 = v16 + 1;
            }
        }
        // 0x100003ad8
        v23 = v17 + 1;
        while (v23 - v14 < 0 != ((v23 - v14 ^ v23) & (v23 ^ v14)) < 0) {
            // 0x100003984
            v17 = v23;
            v19 = v17 + v13;
            v20 = v17;
            v21 = 8 * v20;
            v22 = 4 * (int64_t)v19;
            *(int32_t *)(v22 + *(int64_t *)(v21 + g4)) = 0x7fffffff;
            if (v18 < 0 != ((v19 ^ v17) & (v17 ^ v18)) < 0) {
                // 0x1000039d8
                v16 = v17;
                v24 = *(int32_t *)(4 * v20 + v1);
                v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                v27 = *(int64_t *)(g4 + v21);
                v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                v31 = (int32_t *)(v27 + v22);
                v32 = *v31;
                v33 = v30 - v32;
                if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                    // 0x100003a7c
                    *v31 = v30;
                    *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                }
                // 0x100003ac4
                v34 = v16 + 1;
                while (v34 - v19 < 0 != ((v34 - v19 ^ v34) & (v34 ^ v19)) < 0) {
                    // 0x1000039d8
                    v16 = v34;
                    v24 = *(int32_t *)(4 * v20 + v1);
                    v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                    v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                    v27 = *(int64_t *)(g4 + v21);
                    v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                    v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                    v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                    v31 = (int32_t *)(v27 + v22);
                    v32 = *v31;
                    v33 = v30 - v32;
                    if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                        // 0x100003a7c
                        *v31 = v30;
                        *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                    }
                    // 0x100003ac4
                    v34 = v16 + 1;
                }
            }
            // 0x100003ad8
            v23 = v17 + 1;
        }
    }
    int32_t v35 = v13 + 1; // 0x100003af0
    while (v35 - v3 < 0 != ((v35 - v3 ^ v35) & (v35 ^ v3)) < 0) {
        // 0x100003964
        v13 = v35;
        v14 = v3 - v13;
        v15 = -v14;
        if (v15 < 0 != (v14 & v15) < 0) {
            // 0x100003984
            v18 = -v13;
            v17 = 0;
            v19 = v17 + v13;
            v20 = v17;
            v21 = 8 * v20;
            v22 = 4 * (int64_t)v19;
            *(int32_t *)(v22 + *(int64_t *)(v21 + g4)) = 0x7fffffff;
            if (v18 < 0 != ((v19 ^ v17) & (v17 ^ v18)) < 0) {
                // 0x1000039d8
                v16 = v17;
                v24 = *(int32_t *)(4 * v20 + v1);
                v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                v27 = *(int64_t *)(g4 + v21);
                v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                v31 = (int32_t *)(v27 + v22);
                v32 = *v31;
                v33 = v30 - v32;
                if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                    // 0x100003a7c
                    *v31 = v30;
                    *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                }
                // 0x100003ac4
                v34 = v16 + 1;
                while (v34 - v19 < 0 != ((v34 - v19 ^ v34) & (v34 ^ v19)) < 0) {
                    // 0x1000039d8
                    v16 = v34;
                    v24 = *(int32_t *)(4 * v20 + v1);
                    v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                    v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                    v27 = *(int64_t *)(g4 + v21);
                    v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                    v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                    v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                    v31 = (int32_t *)(v27 + v22);
                    v32 = *v31;
                    v33 = v30 - v32;
                    if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                        // 0x100003a7c
                        *v31 = v30;
                        *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                    }
                    // 0x100003ac4
                    v34 = v16 + 1;
                }
            }
            // 0x100003ad8
            v23 = v17 + 1;
            while (v23 - v14 < 0 != ((v23 - v14 ^ v23) & (v23 ^ v14)) < 0) {
                // 0x100003984
                v17 = v23;
                v19 = v17 + v13;
                v20 = v17;
                v21 = 8 * v20;
                v22 = 4 * (int64_t)v19;
                *(int32_t *)(v22 + *(int64_t *)(v21 + g4)) = 0x7fffffff;
                if (v18 < 0 != ((v19 ^ v17) & (v17 ^ v18)) < 0) {
                    // 0x1000039d8
                    v16 = v17;
                    v24 = *(int32_t *)(4 * v20 + v1);
                    v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                    v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                    v27 = *(int64_t *)(g4 + v21);
                    v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                    v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                    v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                    v31 = (int32_t *)(v27 + v22);
                    v32 = *v31;
                    v33 = v30 - v32;
                    if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                        // 0x100003a7c
                        *v31 = v30;
                        *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                    }
                    // 0x100003ac4
                    v34 = v16 + 1;
                    while (v34 - v19 < 0 != ((v34 - v19 ^ v34) & (v34 ^ v19)) < 0) {
                        // 0x1000039d8
                        v16 = v34;
                        v24 = *(int32_t *)(4 * v20 + v1);
                        v25 = *(int32_t *)(v1 + (int64_t)(4 * v16 + 4));
                        v26 = *(int32_t *)(v1 + (int64_t)(4 * v19 + 4));
                        v27 = *(int64_t *)(g4 + v21);
                        v28 = *(int32_t *)(v27 + 4 * (int64_t)v16);
                        v29 = *(int64_t *)(g4 + (int64_t)(8 * v16 + 8));
                        v30 = v28 + v25 * v24 * v26 + *(int32_t *)(v29 + v22);
                        v31 = (int32_t *)(v27 + v22);
                        v32 = *v31;
                        v33 = v30 - v32;
                        if (v33 < 0 != ((v33 ^ v30) & (v30 ^ v32)) < 0) {
                            // 0x100003a7c
                            *v31 = v30;
                            *(int32_t *)(*(int64_t *)(g5 + v21) + v22) = v16;
                        }
                        // 0x100003ac4
                        v34 = v16 + 1;
                    }
                }
                // 0x100003ad8
                v23 = v17 + 1;
            }
        }
        // 0x100003aec
        v35 = v13 + 1;
    }
    // 0x100003afc
    return result;
}

// Address range: 0x100003b08 - 0x100003bcc
int64_t function_100003b08(void) {
    // 0x100003b08
    int32_t result; // 0x100003b08
    int64_t v1; // 0x100003b08
    if ((int32_t)v1 == (int32_t)v1) {
        // 0x100003b34
        result = _printf("%c", (char)v1);
    } else {
        // 0x100003b58
        _printf("(");
        function_100003b08();
        function_100003b08();
        result = _printf(")");
    }
    // 0x100003bc0
    return result;
}

// Address range: 0x100003bcc - 0x100003ea4
int64_t entry_point(void) {
    // 0x100003bcc
    int64_t v1; // bp-100, 0x100003bcc
    _memcpy(&v1, &g1, 52);
    int64_t v2; // bp-148, 0x100003bcc
    _memcpy(&v2, &g2, 48);
    int64_t v3 = g3; // bp-192, 0x100003c58
    int64_t v4 = 0;
    int64_t v5 = &g2; // 0x100003bcc
    _printf("Dims  : [");
    int32_t v6 = *(int32_t *)(4 * v4 + (int64_t)&v3); // 0x100003c94
    int32_t v7 = -v6; // 0x100003cac
    int32_t v8; // 0x100003bcc
    int32_t v9; // 0x100003bcc
    int32_t v10; // 0x100003cf4
    int32_t v11; // 0x100003d2c
    if (v7 < 0 != (v6 & v7) < 0) {
        // 0x100003cbc
        v9 = v6 - 1;
        v8 = 0;
        _printf("%d", v5);
        v10 = v8 - v9;
        if (v10 < 0 == ((v10 ^ v8) & (v8 ^ v9)) < 0) {
            // 0x100003d14
            _printf("]\n");
        } else {
            // 0x100003d04
            _printf(", ");
        }
        // 0x100003d28
        v11 = v8 + 1;
        while (v11 - v6 < 0 != ((v11 - v6 ^ v11) & (v11 ^ v6)) < 0) {
            // 0x100003cbc
            v8 = v11;
            _printf("%d", v5);
            v10 = v8 - v9;
            if (v10 < 0 == ((v10 ^ v8) & (v8 ^ v9)) < 0) {
                // 0x100003d14
                _printf("]\n");
            } else {
                // 0x100003d04
                _printf(", ");
            }
            // 0x100003d28
            v11 = v8 + 1;
        }
    }
    // 0x100003d38
    function_100003840();
    _printf("Order : ");
    uint32_t v12 = v6 - 2; // 0x100003d5c
    int64_t v13 = v12; // 0x100003d5c
    function_100003b08();
    _printf("\nCost  : %d\n\n", v13);
    int32_t v14 = 2 - v6;
    int32_t v15 = 0; // 0x100003db8
    int64_t v16; // 0x100003bcc
    int64_t v17; // 0x100003dd0
    int32_t v18; // 0x100003de0
    int32_t v19; // 0x100003db0
    int32_t v20; // 0x100003e40
    int32_t v21; // 0x100003e10
    int64_t v22; // 0x100003bcc
    if (v14 == 0 || v14 < 0 != (v14 & v12) < 0) {
        v17 = *(int64_t *)(8 * (int64_t)v15 + g4);
        _free((int64_t *)v17);
        v18 = v15 + 1;
        v19 = v18 - v12;
        v15 = v18;
        while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v12)) < 0) {
            // 0x100003dc0
            v17 = *(int64_t *)(8 * (int64_t)v15 + g4);
            _free((int64_t *)v17);
            v18 = v15 + 1;
            v19 = v18 - v12;
            v15 = v18;
        }
        // 0x100003e20
        _free((int64_t *)g4);
        v20 = 0;
        _free((int64_t *)*(int64_t *)(8 * (int64_t)v20 + g5));
        v20++;
        v21 = v20 - v12;
        v22 = g5;
        v16 = v22;
        while (v21 == 0 || v21 < 0 != ((v21 ^ v20) & (v20 ^ v12)) < 0) {
            // 0x100003e20
            _free((int64_t *)*(int64_t *)(8 * (int64_t)v20 + v22));
            v20++;
            v21 = v20 - v12;
            v22 = g5;
            v16 = v22;
        }
    } else {
        // 0x100003dec
        _free((int64_t *)g4);
        v16 = g5;
    }
    // 0x100003e4c
    _free((int64_t *)v16);
    v4++;
    v5 = v13;
    while (v4 != 3) {
        // 0x100003c80
        _printf("Dims  : [");
        v6 = *(int32_t *)(4 * v4 + (int64_t)&v3);
        v7 = -v6;
        if (v7 < 0 != (v6 & v7) < 0) {
            // 0x100003cbc
            v9 = v6 - 1;
            v8 = 0;
            _printf("%d", v5);
            v10 = v8 - v9;
            if (v10 < 0 == ((v10 ^ v8) & (v8 ^ v9)) < 0) {
                // 0x100003d14
                _printf("]\n");
            } else {
                // 0x100003d04
                _printf(", ");
            }
            // 0x100003d28
            v11 = v8 + 1;
            while (v11 - v6 < 0 != ((v11 - v6 ^ v11) & (v11 ^ v6)) < 0) {
                // 0x100003cbc
                v8 = v11;
                _printf("%d", v5);
                v10 = v8 - v9;
                if (v10 < 0 == ((v10 ^ v8) & (v8 ^ v9)) < 0) {
                    // 0x100003d14
                    _printf("]\n");
                } else {
                    // 0x100003d04
                    _printf(", ");
                }
                // 0x100003d28
                v11 = v8 + 1;
            }
        }
        // 0x100003d38
        function_100003840();
        _printf("Order : ");
        v12 = v6 - 2;
        v13 = v12;
        function_100003b08();
        _printf("\nCost  : %d\n\n", v13);
        v14 = 2 - v6;
        v15 = 0;
        if (v14 == 0 || v14 < 0 != (v14 & v12) < 0) {
            v17 = *(int64_t *)(8 * (int64_t)v15 + g4);
            _free((int64_t *)v17);
            v18 = v15 + 1;
            v19 = v18 - v12;
            v15 = v18;
            while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v12)) < 0) {
                // 0x100003dc0
                v17 = *(int64_t *)(8 * (int64_t)v15 + g4);
                _free((int64_t *)v17);
                v18 = v15 + 1;
                v19 = v18 - v12;
                v15 = v18;
            }
            // 0x100003e20
            _free((int64_t *)g4);
            v20 = 0;
            _free((int64_t *)*(int64_t *)(8 * (int64_t)v20 + g5));
            v20++;
            v21 = v20 - v12;
            v22 = g5;
            v16 = v22;
            while (v21 == 0 || v21 < 0 != ((v21 ^ v20) & (v20 ^ v12)) < 0) {
                // 0x100003e20
                _free((int64_t *)*(int64_t *)(8 * (int64_t)v20 + v22));
                v20++;
                v21 = v20 - v12;
                v22 = g5;
                v16 = v22;
            }
        } else {
            // 0x100003dec
            _free((int64_t *)g4);
            v16 = g5;
        }
        // 0x100003e4c
        _free((int64_t *)v16);
        v4++;
        v5 = v13;
    }
    int64_t v23 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e7c
    if (v23 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e90
        ___stack_chk_fail((int64_t)&g6);
    }
    // 0x100003e94
    return 0;
}

// Address range: 0x100003ea4 - 0x100003eb0
int64_t function_100003ea4(int64_t a1) {
    // 0x100003ea4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003eb0 - 0x100003ebc
int64_t * function_100003eb0(int32_t nmemb, int32_t size) {
    // 0x100003eb0
    return _calloc(nmemb, size);
}

// Address range: 0x100003ebc - 0x100003ec8
void function_100003ebc(int64_t * ptr) {
    // 0x100003ebc
    _free(ptr);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int32_t size) {
    // 0x100003ec8
    return _malloc(size);
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t * function_100003ed4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ed4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(char * format, ...) {
    // 0x100003ee0
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include <ctype.h>

typedef unsigned char uchar;

typedef enum {
    nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While,
    nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,
    nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or
} NodeType;

typedef enum { FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND,
    OR, NEG, NOT, JMP, JZ, PRTC, PRTS, PRTI, HALT
} Code_t;

typedef uchar code;

typedef struct Tree {
    NodeType node_type;
    struct Tree *left;
    struct Tree *right;
    char *value;
} Tree;

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0

#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)

#define da_rewind(name)     _qy_ ## name ## _p = 0

#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)
#define da_len(name)        _qy_ ## name ## _p
#define da_add(name)        do {da_redim(name); _qy_ ## name ## _p++;} while (0)

FILE *source_fp, *dest_fp;
static int here;
da_dim(object, code);
da_dim(globals, const char *);
da_dim(string_pool, const char *);

// dependency: Ordered by NodeType, must remain in same order as NodeType enum
struct {
    char       *enum_text;
    NodeType   node_type;
    Code_t     opcode;
} atr[] = {
    {"Identifier"  , nd_Ident,    -1 },
    {"String"      , nd_String,   -1 },
    {"Integer"     , nd_Integer,  -1 },
    {"Sequence"    , nd_Sequence, -1 },
    {"If"          , nd_If,       -1 },
    {"Prtc"        , nd_Prtc,     -1 },
    {"Prts"        , nd_Prts,     -1 },
    {"Prti"        , nd_Prti,     -1 },
    {"While"       , nd_While,    -1 },
    {"Assign"      , nd_Assign,   -1 },
    {"Negate"      , nd_Negate,   NEG},
    {"Not"         , nd_Not,      NOT},
    {"Multiply"    , nd_Mul,      MUL},
    {"Divide"      , nd_Div,      DIV},
    {"Mod"         , nd_Mod,      MOD},
    {"Add"         , nd_Add,      ADD},
    {"Subtract"    , nd_Sub,      SUB},
    {"Less"        , nd_Lss,      LT },
    {"LessEqual"   , nd_Leq,      LE },
    {"Greater"     , nd_Gtr,      GT },
    {"GreaterEqual", nd_Geq,      GE },
    {"Equal"       , nd_Eql,      EQ },
    {"NotEqual"    , nd_Neq,      NE },
    {"And"         , nd_And,      AND},
    {"Or"          , nd_Or,       OR },
};

void error(const char *fmt, ... ) {
    va_list ap;
    char buf[1000];

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    va_end(ap);
    printf("error: %s\n", buf);
    exit(1);
}

Code_t type_to_op(NodeType type) {
    return atr[type].opcode;
}

Tree *make_node(NodeType node_type, Tree *left, Tree *right) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->left = left;
    t->right = right;
    return t;
}

Tree *make_leaf(NodeType node_type, char *value) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->value = strdup(value);
    return t;
}

/*** Code generator ***/

void emit_byte(int c) {
    da_append(object, (uchar)c);
    ++here;
}

void emit_int(int32_t n) {
    union {
        int32_t n;
        unsigned char c[sizeof(int32_t)];
    } x;

    x.n = n;

    for (size_t i = 0; i < sizeof(x.n); ++i) {
        emit_byte(x.c[i]);
    }
}

int hole() {
    int t = here;
    emit_int(0);
    return t;
}

void fix(int src, int dst) {
    *(int32_t *)(object + src) = dst-src;
}

int fetch_var_offset(const char *id) {
    for (int i = 0; i < da_len(globals); ++i) {
        if (strcmp(id, globals[i]) == 0)
            return i;
    }
    da_add(globals);
    int n = da_len(globals) - 1;
    globals[n] = strdup(id);
    return n;
}

int fetch_string_offset(const char *st) {
    for (int i = 0; i < da_len(string_pool); ++i) {
        if (strcmp(st, string_pool[i]) == 0)
            return i;
    }
    da_add(string_pool);
    int n = da_len(string_pool) - 1;
    string_pool[n] = strdup(st);
    return n;
}

void code_gen(Tree *x) {
    int p1, p2, n;

    if (x == NULL) return;
    switch (x->node_type) {
        case nd_Ident:
            emit_byte(FETCH);
            n = fetch_var_offset(x->value);
            emit_int(n);
            break;
        case nd_Integer:
            emit_byte(PUSH);
            emit_int(atoi(x->value));
            break;
        case nd_String:
            emit_byte(PUSH);
            n = fetch_string_offset(x->value);
            emit_int(n);
            break;
        case nd_Assign:
            n = fetch_var_offset(x->left->value);
            code_gen(x->right);
            emit_byte(STORE);
            emit_int(n);
            break;
        case nd_If:
            code_gen(x->left);        // if expr
            emit_byte(JZ);                  // if false, jump
            p1 = hole();                    // make room for jump dest
            code_gen(x->right->left);   // if true statements
            if (x->right->right != NULL) {
                emit_byte(JMP);
                p2 = hole();
            }
            fix(p1, here);
            if (x->right->right != NULL) {
                code_gen(x->right->right);
                fix(p2, here);
            }
            break;
        case nd_While:
            p1 = here;
            code_gen(x->left);        // while expr
            emit_byte(JZ);                  // if false, jump
            p2 = hole();                    // make room for jump dest
            code_gen(x->right);       // statements
            emit_byte(JMP);                 // back to the top
            fix(hole(), p1);                // plug the top
            fix(p2, here);                  // plug the 'if false, jump'
            break;
        case nd_Sequence:
            code_gen(x->left);
            code_gen(x->right);
            break;
        case nd_Prtc:
            code_gen(x->left);
            emit_byte(PRTC);
            break;
        case nd_Prti:
            code_gen(x->left);
            emit_byte(PRTI);
            break;
        case nd_Prts:
            code_gen(x->left);
            emit_byte(PRTS);
            break;
        case nd_Lss: case nd_Gtr: case nd_Leq: case nd_Geq: case nd_Eql: case nd_Neq:
        case nd_And: case nd_Or: case nd_Sub: case nd_Add: case nd_Div: case nd_Mul:
        case nd_Mod:
            code_gen(x->left);
            code_gen(x->right);
            emit_byte(type_to_op(x->node_type));
            break;
        case nd_Negate: case nd_Not:
            code_gen(x->left);
            emit_byte(type_to_op(x->node_type));
            break;
        default:
            error("error in code generator - found %d, expecting operator\n", x->node_type);
    }
}

void code_finish() {
    emit_byte(HALT);
}

void list_code() {
    fprintf(dest_fp, "Datasize: %d Strings: %d\n", da_len(globals), da_len(string_pool));
    for (int i = 0; i < da_len(string_pool); ++i)
        fprintf(dest_fp, "%s\n", string_pool[i]);

    code *pc = object;

    again: fprintf(dest_fp, "%5d ", (int)(pc - object));
    switch (*pc++) {
        case FETCH: fprintf(dest_fp, "fetch [%d]\n", *(int32_t *)pc);
                    pc += sizeof(int32_t);  goto again;
        case STORE: fprintf(dest_fp, "store [%d]\n", *(int32_t *)pc);
                    pc += sizeof(int32_t);  goto again;
        case PUSH : fprintf(dest_fp, "push  %d\n", *(int32_t *)pc);
                    pc += sizeof(int32_t);    goto again;
        case ADD  : fprintf(dest_fp, "add\n");      goto again;
        case SUB  : fprintf(dest_fp, "sub\n");      goto again;
        case MUL  : fprintf(dest_fp, "mul\n");      goto again;
        case DIV  : fprintf(dest_fp, "div\n");      goto again;
        case MOD  : fprintf(dest_fp, "mod\n");      goto again;
        case LT   : fprintf(dest_fp, "lt\n");       goto again;
        case GT   : fprintf(dest_fp, "gt\n");       goto again;
        case LE   : fprintf(dest_fp, "le\n");       goto again;
        case GE   : fprintf(dest_fp, "ge\n");       goto again;
        case EQ   : fprintf(dest_fp, "eq\n");       goto again;
        case NE   : fprintf(dest_fp, "ne\n");       goto again;
        case AND  : fprintf(dest_fp, "and\n");      goto again;
        case OR   : fprintf(dest_fp, "or\n");       goto again;
        case NOT  : fprintf(dest_fp, "not\n");      goto again;
        case NEG  : fprintf(dest_fp, "neg\n");      goto again;
        case JMP  : fprintf(dest_fp, "jmp    (%d) %d\n",
                        *(int32_t *)pc, (int32_t)(pc + *(int32_t *)pc - object));
                    pc += sizeof(int32_t); goto again;
        case JZ   : fprintf(dest_fp, "jz     (%d) %d\n",
                        *(int32_t *)pc, (int32_t)(pc + *(int32_t *)pc - object));
                    pc += sizeof(int32_t); goto again;
        case PRTC : fprintf(dest_fp, "prtc\n");     goto again;
        case PRTI : fprintf(dest_fp, "prti\n");     goto again;
        case PRTS : fprintf(dest_fp, "prts\n");     goto again;
        case HALT : fprintf(dest_fp, "halt\n");     break;
        default:error("listcode:Unknown opcode %d\n", *(pc - 1));
    }
}

void init_io(FILE **fp, FILE *std, const char mode[], const char fn[]) {
    if (fn[0] == '\0')
        *fp = std;
    else if ((*fp = fopen(fn, mode)) == NULL)
        error(0, 0, "Can't open %s\n", fn);
}

NodeType get_enum_value(const char name[]) {
    for (size_t i = 0; i < sizeof(atr) / sizeof(atr[0]); i++) {
        if (strcmp(atr[i].enum_text, name) == 0) {
            return atr[i].node_type;
        }
    }
    error("Unknown token %s\n", name);
    return -1;
}

char *read_line(int *len) {
    static char *text = NULL;
    static int textmax = 0;

    for (*len = 0; ; (*len)++) {
        int ch = fgetc(source_fp);
        if (ch == EOF || ch == '\n') {
            if (*len == 0)
                return NULL;
            break;
        }
        if (*len + 1 >= textmax) {
            textmax = (textmax == 0 ? 128 : textmax * 2);
            text = realloc(text, textmax);
        }
        text[*len] = ch;
    }
    text[*len] = '\0';
    return text;
}

char *rtrim(char *text, int *len) {         // remove trailing spaces
    for (; *len > 0 && isspace(text[*len - 1]); --(*len))
        ;

    text[*len] = '\0';
    return text;
}

Tree *load_ast() {
    int len;
    char *yytext = read_line(&len);
    yytext = rtrim(yytext, &len);

    // get first token
    char *tok = strtok(yytext, " ");

    if (tok[0] == ';') {
        return NULL;
    }
    NodeType node_type = get_enum_value(tok);

    // if there is extra data, get it
    char *p = tok + strlen(tok);
    if (p != &yytext[len]) {
        for (++p; isspace(*p); ++p)
            ;
        return make_leaf(node_type, p);
    }

    Tree *left  = load_ast();
    Tree *right = load_ast();
    return make_node(node_type, left, right);
}

int main(int argc, char *argv[]) {
    init_io(&source_fp, stdin,  "r",  argc > 1 ? argv[1] : "");
    init_io(&dest_fp,   stdout, "wb", argc > 2 ? argv[2] : "");

    code_gen(load_ast());
    code_finish();
    list_code();

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002970(void);
int64_t function_1000029dc(void);
int64_t function_100002a04(int32_t a1, int64_t a2, int64_t a3);
int64_t function_100002a60(void);
int64_t function_100002ab0(void);
int64_t function_100002b68(void);
int64_t function_100002bcc(int64_t a1);
int64_t function_100002bfc(void);
int64_t function_100002c2c(void);
int64_t function_100002d64(void);
int64_t function_100002e9c(void);
int64_t function_1000031ec(int64_t a1);
int64_t function_100003204(int64_t a1, int64_t a2);
int64_t function_100003748(void);
int64_t function_1000037ec(void);
int64_t function_1000038a8(void);
int64_t function_100003a10(void);
int64_t function_100003ab8(void);
int64_t function_100003ce4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t function_100003cf0(char * nptr);
int64_t * function_100003cfc(int32_t nmemb, int32_t size);
void function_100003d08(int32_t status);
int32_t function_100003d14(struct _IO_FILE * stream);
struct _IO_FILE * function_100003d20(char * filename, char * modes);
int32_t function_100003d2c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003d38(int32_t c);
int32_t function_100003d44(char * format, ...);
int64_t * function_100003d50(int64_t * ptr, int32_t size);
int32_t function_100003d5c(char * s1, char * s2);
char * function_100003d68(char * s);
int32_t function_100003d74(char * s);
char * function_100003d80(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x20000000003d8c; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008190
int32_t g3 = 0; // 0x100008198
int32_t g4 = 2; // 0x10000819c
int64_t g5 = 0x55800000012; // 0x1000081a0
int32_t g6 = 0x200085; // 0x1000081a8
int32_t g7 = 0; // 0x1000081ac
int64_t g8 = 0x4800000019; // 0x1000081b0
char g9[11] = "__PAGEZERO"; // 0x1000081b8
char g10[7] = "GEZERO"; // 0x1000081bc
struct _IO_FILE * g11 = NULL; // 0x1000081c8
int32_t g12 = 0; // 0x1000081d0
int64_t g13 = 0; // 0x1000081d8
int32_t g14 = 0; // 0x1000081e0
int32_t g15;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100002970 - 0x1000029dc
int64_t function_100002970(void) {
    // 0x100002970
    int64_t v1; // 0x100002970
    int64_t v2; // bp-1032, 0x100002970
    int64_t v3; // 0x100002970
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("error: %s\n", NULL);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x1000029dc - 0x100002a04
int64_t function_1000029dc(void) {
    // 0x1000029dc
    int64_t v1; // 0x1000029dc
    uint32_t result = *(int32_t *)((16 * v1 & 0xffffffff0) + (int64_t)&g1 + 12); // 0x1000029f8
    return result;
}

// Address range: 0x100002a04 - 0x100002a60
int64_t function_100002a04(int32_t a1, int64_t a2, int64_t a3) {
    int64_t * v1 = _calloc(32, 1); // 0x100002a24
    *(int32_t *)v1 = a1;
    int64_t result = (int64_t)v1; // 0x100002a3c
    *(int64_t *)(result + 8) = a2;
    *(int64_t *)(result + 16) = a3;
    return result;
}

// Address range: 0x100002a60 - 0x100002ab0
int64_t function_100002a60(void) {
    int64_t * v1 = _calloc(32, 1); // 0x100002a7c
    int64_t result = (int64_t)v1; // 0x100002a7c
    int64_t v2; // 0x100002a60
    *(int32_t *)v1 = (int32_t)v2;
    *(int64_t *)(result + 24) = (int64_t)_strdup((char *)v2);
    return result;
}

// Address range: 0x100002ab0 - 0x100002b68
int64_t function_100002ab0(void) {
    int32_t v1 = g3; // 0x100002acc
    int32_t v2 = v1 - g4; // 0x100002ad8
    int32_t v3 = v1; // 0x100002ae0
    int64_t v4 = g2; // 0x100002ae0
    int64_t result; // 0x100002ab0
    if (v2 < 0 == ((v2 ^ v1) & (g4 ^ v1)) < 0) {
        int32_t v5 = g4 + 32; // 0x100002afc
        g4 = v5;
        v4 = (int64_t)_realloc((int64_t *)g2, v5);
        g2 = v4;
        v3 = g3;
        result = v4;
    }
    // 0x100002b24
    g3 = v3 + 1;
    int64_t v6; // 0x100002ab0
    *(char *)(v4 + (int64_t)v3) = (char)v6;
    g12++;
    return result;
}

// Address range: 0x100002b68 - 0x100002bcc
int64_t function_100002b68(void) {
    int64_t result; // 0x100002ba8
    for (int64_t i = 0; i < 4; i++) {
        // 0x100002b9c
        result = function_100002ab0();
    }
    // 0x100002bc0
    return result;
}

// Address range: 0x100002bcc - 0x100002bfc
int64_t function_100002bcc(int64_t a1) {
    // 0x100002bcc
    function_100002b68();
    return (uint32_t)g12;
}

// Address range: 0x100002bfc - 0x100002c2c
int64_t function_100002bfc(void) {
    // 0x100002bfc
    int64_t v1; // 0x100002bfc
    int64_t result = v1;
    *(int32_t *)((0x100000000 * result >> 32) + g2) = (int32_t)v1 - (int32_t)result;
    return result;
}

// Address range: 0x100002c2c - 0x100002d64
int64_t function_100002c2c(void) {
    // 0x100002c2c
    int64_t v1; // 0x100002c2c
    char * v2 = (char *)v1; // 0x100002c38
    int32_t v3 = -g6; // 0x100002c50
    int32_t v4 = 0; // 0x100002c58
    if (v3 < 0 != (g6 & v3) < 0) {
        int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + g5); // 0x100002c70
        int32_t result = v4; // 0x100002c80
        while (_strcmp(v2, (char *)v5) != 0) {
            // 0x100002c98
            v4++;
            int32_t v6 = v4 - g6; // 0x100002c50
            if (v6 < 0 == ((v6 ^ v4) & (g6 ^ v4)) < 0) {
                goto lab_0x100002cb0;
            }
            v5 = *(int64_t *)(8 * (int64_t)v4 + g5);
            result = v4;
        }
        // 0x100002d54
        return result;
    }
  lab_0x100002cb0:;
    int32_t v7 = g6;
    int32_t v8 = v7 - g7; // 0x100002cc0
    int32_t result2 = v7; // 0x100002cc8
    if (v8 < 0 == ((v8 ^ v7) & (g7 ^ v7)) < 0) {
        int32_t v9 = g7 + 32; // 0x100002ce4
        g7 = v9;
        g5 = (int64_t)_realloc((int64_t *)g5, 8 * v9);
        result2 = g6;
    }
    // 0x100002d0c
    g6 = result2 + 1;
    char * v10 = _strdup(v2); // 0x100002d34
    *(int64_t *)(g5 + 8 * (int64_t)result2) = (int64_t)v10;
    // 0x100002d54
    return result2;
}

// Address range: 0x100002d64 - 0x100002e9c
int64_t function_100002d64(void) {
    // 0x100002d64
    int64_t v1; // 0x100002d64
    char * v2 = (char *)v1; // 0x100002d70
    int32_t v3 = *(int32_t *)&g9; // 0x100002d84
    int32_t v4 = -v3; // 0x100002d88
    int32_t v5 = 0; // 0x100002d90
    int32_t v6 = v3; // 0x100002d90
    if (v4 < 0 != (v3 & v4) < 0) {
        int64_t v7 = *(int64_t *)(8 * (int64_t)v5 + g8); // 0x100002da8
        int32_t result = v5; // 0x100002db8
        while (_strcmp(v2, (char *)v7) != 0) {
            // 0x100002dd0
            v5++;
            int32_t v8 = *(int32_t *)&g9; // 0x100002d84
            int32_t v9 = v5 - v8; // 0x100002d88
            v6 = v8;
            if (v9 < 0 == ((v9 ^ v5) & (v8 ^ v5)) < 0) {
                goto lab_0x100002de8;
            }
            v7 = *(int64_t *)(8 * (int64_t)v5 + g8);
            result = v5;
        }
        // 0x100002e8c
        return result;
    }
  lab_0x100002de8:;
    int32_t v10 = v6;
    int32_t v11 = *(int32_t *)&g10; // 0x100002df4
    int32_t v12 = v10 - v11; // 0x100002df8
    int32_t result2 = v10; // 0x100002e00
    if (v12 < 0 == ((v12 ^ v10) & (v11 ^ v10)) < 0) {
        int32_t v13 = v11 + 32; // 0x100002e1c
        *(int32_t *)&g10 = v13;
        g8 = (int64_t)_realloc((int64_t *)g8, 8 * v13);
        result2 = *(int32_t *)&g9;
    }
    // 0x100002e44
    *(int32_t *)&g9 = result2 + 1;
    char * v14 = _strdup(v2); // 0x100002e6c
    *(int64_t *)(g8 + 8 * (int64_t)result2) = (int64_t)v14;
    // 0x100002e8c
    return result2;
}

// Address range: 0x100002e9c - 0x100003188
int64_t function_100002e9c(void) {
    // 0x100002e9c
    int64_t result; // 0x100002e9c
    if (result == 0) {
        // 0x100002ee4
        return result;
    }
    uint32_t v1 = (int32_t)result;
    if (v1 >= 24 != v1 != 24) {
        // 0x100002ee4
        return result;
    }
    // 0x100003158
    function_100002970();
    // UNREACHABLE
}

// Address range: 0x1000031ec - 0x100003204
int64_t function_1000031ec(int64_t a1) {
    // 0x1000031ec
    return function_100002ab0();
}

// Address range: 0x100003204 - 0x1000036e8
int64_t function_100003204(int64_t a1, int64_t a2) {
    // 0x100003204
    _fprintf((struct _IO_FILE *)0x4f52, "Datasize: %d Strings: %d\n");
    int32_t v1 = *(int32_t *)&g9; // 0x10000325c
    int32_t v2 = -v1; // 0x100003260
    int32_t v3 = 0; // 0x100003268
    if (v2 < 0 != (v1 & v2) < 0) {
        _fprintf((struct _IO_FILE *)0x4f52, "%s\n");
        v3++;
        int32_t v4 = *(int32_t *)&g9; // 0x10000325c
        while (v3 - v4 < 0 != ((v3 - v4 ^ v3) & (v4 ^ v3)) < 0) {
            // 0x100003270
            _fprintf((struct _IO_FILE *)0x4f52, "%s\n");
            v3++;
            v4 = *(int32_t *)&g9;
        }
    }
    int32_t result = _fprintf((struct _IO_FILE *)0x4f52, "%5d "); // 0x1000032f0
    unsigned char v5 = *(char *)g2; // 0x100003300
    if (v5 >= 23 != v5 != 23) {
        // 0x10000331c
        return result;
    }
    // 0x1000036b8
    function_100002970();
    // UNREACHABLE
}

// Address range: 0x100003748 - 0x1000037ec
int64_t function_100003748(void) {
    // 0x100003748
    int64_t v1; // 0x100003748
    if ((char)v1 == 0) {
        // 0x1000037e0
        int64_t result; // 0x100003748
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, (char *)v1); // 0x100003794
    int64_t result2 = (int64_t)v2; // 0x100003794
    *(int64_t *)v1 = result2;
    if (v2 != NULL) {
        // 0x1000037e0
        return result2;
    }
    // 0x1000037b4
    function_100002970();
    // UNREACHABLE
}

// Address range: 0x1000037ec - 0x1000038a8
int64_t function_1000037ec(void) {
    int64_t v1 = 0; // 0x100003868
    int64_t v2 = 16 * v1; // 0x10000381c
    int64_t v3 = *(int64_t *)(v2 + (int64_t)&g1); // 0x100003828
    int64_t v4; // 0x1000037ec
    while (_strcmp((char *)v3, (char *)v4) != 0) {
        // 0x100003804
        v1++;
        if (v1 >= 25) {
            // 0x100003874
            function_100002970();
            // UNREACHABLE
        }
        v2 = 16 * v1;
        v3 = *(int64_t *)(v2 + (int64_t)&g1);
    }
    // 0x100003844
    return (int64_t)*(int32_t *)(v2 + (int64_t)&g1 + 8);
}

// Address range: 0x1000038a8 - 0x100003a10
int64_t function_1000038a8(void) {
    int32_t v1 = 0; // 0x1000038c0
    int64_t result; // 0x1000039f4
    int32_t v2; // 0x1000038a8
    while (true) {
        // 0x1000038c4
        int64_t v3; // 0x1000038a8
        *(int32_t *)v3 = v1;
        int32_t v4 = _fgetc(g11); // 0x1000038d0
        int64_t v5; // 0x1000038a8
        v2 = *(int32_t *)&v5;
        switch (v4) {
            case -1: {
            }
            case 10: {
                // 0x100003900
                result = 0;
                if (v2 != 0) {
                    // 0x1000039dc
                    *(char *)(g13 + (int64_t)v2) = 0;
                    result = g13;
                }
                // 0x100003a00
                return result;
            }
        }
        int32_t v6 = v2 + 1; // 0x10000392c
        int32_t v7 = *(int32_t *)((int64_t)&g1 + 480); // 0x100003934
        int32_t v8 = v6 - v7; // 0x100003938
        int64_t v9; // 0x1000038a8
        if (v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            int32_t v10 = g14; // 0x10000394c
            int32_t v11 = v10 == 0 ? 128 : 2 * v10;
            g14 = v11;
            int64_t v12 = (int64_t)_realloc((int64_t *)g13, v11); // 0x10000399c
            g13 = v12;
            v9 = v12;
        } else {
            // 0x100003924
            v9 = g13;
        }
        // 0x1000039ac
        *(char *)(v9 + (int64_t)v2) = (char)v4;
        v1 = *(int32_t *)&v5 + 1;
    }
    // 0x100003900
    result = 0;
    if (v2 != 0) {
        // 0x1000039dc
        *(char *)(g13 + (int64_t)v2) = 0;
        result = g13;
    }
    // 0x100003a00
    return result;
}

// Address range: 0x100003a10 - 0x100003ab8
int64_t function_100003a10(void) {
    // 0x100003a10
    int64_t result; // 0x100003a10
    int32_t v1 = result;
    if (v1 < 1) {
        // 0x100003a94
        *(char *)(result + (int64_t)v1) = 0;
        return result;
    }
    uint32_t v2 = v1 - 1; // 0x100003a54
    char v3 = *(char *)(result + (int64_t)v2); // 0x100003a58
    int32_t v4 = v1; // 0x100003a74
    while (_isspace((int32_t)v3) != 0) {
        // 0x100003a80
        *(int32_t *)result = v2;
        int64_t v5; // 0x100003a10
        int32_t v6 = *(int32_t *)&v5; // 0x100003a2c
        v4 = v6;
        if (v6 < 1) {
            // break -> 0x100003a94
            break;
        }
        v2 = v6 - 1;
        v3 = *(char *)(result + (int64_t)v2);
        v4 = v6;
    }
    // 0x100003a94
    *(char *)(result + (int64_t)v4) = 0;
    return result;
}

// Address range: 0x100003ab8 - 0x100003bec
int64_t function_100003ab8(void) {
    // 0x100003ab8
    function_1000038a8();
    int64_t v1 = function_100003a10(); // 0x100003adc
    char * v2 = _strtok((char *)v1, " "); // 0x100003af0
    if (*v2 == 59) {
        // 0x100003bdc
        return 0;
    }
    int64_t v3 = function_1000037ec(); // 0x100003b1c
    int64_t v4 = (int64_t)_strlen(v2) + (int64_t)v2; // 0x100003b38
    int32_t v5; // 0x100003ab8
    if (v4 == v1 + (int64_t)v5) {
        int64_t v6 = function_100003ab8(); // 0x100003bb4
        // 0x100003bdc
        return function_100002a04((int32_t)v3, v6, function_100003ab8());
    }
    char * v7 = (char *)v4; // 0x100003b6c
    while (_isspace((int32_t)*(char *)((int64_t)v7 + 1)) != 0) {
        // 0x100003b70
        v7 = (char *)((int64_t)v7 + 1);
    }
    // 0x100003bdc
    return function_100002a60();
}

// Address range: 0x100003bec - 0x100003ce4
int64_t entry_point(void) {
    // 0x100003bec
    function_100003748();
    function_100003748();
    function_100003ab8();
    function_100002e9c();
    function_1000031ec((int64_t)&g15);
    function_100003204((int64_t)&g15, (int64_t)&g15);
    return 0;
}

// Address range: 0x100003ce4 - 0x100003cf0
int64_t function_100003ce4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003ce4
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003cf0 - 0x100003cfc
int32_t function_100003cf0(char * nptr) {
    // 0x100003cf0
    return _atoi(nptr);
}

// Address range: 0x100003cfc - 0x100003d08
int64_t * function_100003cfc(int32_t nmemb, int32_t size) {
    // 0x100003cfc
    return _calloc(nmemb, size);
}

// Address range: 0x100003d08 - 0x100003d14
void function_100003d08(int32_t status) {
    // 0x100003d08
    _exit(status);
}

// Address range: 0x100003d14 - 0x100003d20
int32_t function_100003d14(struct _IO_FILE * stream) {
    // 0x100003d14
    return _fgetc(stream);
}

// Address range: 0x100003d20 - 0x100003d2c
struct _IO_FILE * function_100003d20(char * filename, char * modes) {
    // 0x100003d20
    return _fopen(filename, modes);
}

// Address range: 0x100003d2c - 0x100003d38
int32_t function_100003d2c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003d2c
    return _fprintf(stream, format);
}

// Address range: 0x100003d38 - 0x100003d44
int32_t function_100003d38(int32_t c) {
    // 0x100003d38
    return _isspace(c);
}

// Address range: 0x100003d44 - 0x100003d50
int32_t function_100003d44(char * format, ...) {
    // 0x100003d44
    return _printf(format);
}

// Address range: 0x100003d50 - 0x100003d5c
int64_t * function_100003d50(int64_t * ptr, int32_t size) {
    // 0x100003d50
    return _realloc(ptr, size);
}

// Address range: 0x100003d5c - 0x100003d68
int32_t function_100003d5c(char * s1, char * s2) {
    // 0x100003d5c
    return _strcmp(s1, s2);
}

// Address range: 0x100003d68 - 0x100003d74
char * function_100003d68(char * s) {
    // 0x100003d68
    return _strdup(s);
}

// Address range: 0x100003d74 - 0x100003d80
int32_t function_100003d74(char * s) {
    // 0x100003d74
    return _strlen(s);
}

// Address range: 0x100003d80 - 0x100003d8c
char * function_100003d80(char * s, char * delim) {
    // 0x100003d80
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 33

`
`#include <stdio.h>

void selection_sort (int *a, int n) {
    int i, j, m, t;
    for (i = 0; i < n; i++) {
        for (j = i, m = i; j < n; j++) {
            if (a[j] < a[m]) {
                m = j;
            }
        }
        t = a[i];
        a[i] = a[m];
        a[m] = t;
    }
}

int main () {
    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
    int n = sizeof a / sizeof a[0];
    int i;
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    selection_sort(a, n);
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc0(void);
int64_t function_100003f48(int64_t a1);
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f60(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4100000004; // 0x100003f6c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cc0 - 0x100003db4
int64_t function_100003cc0(void) {
    // 0x100003cc0
    int64_t result; // 0x100003cc0
    int32_t v1 = result; // 0x100003cc8
    int32_t v2 = -v1; // 0x100003cdc
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003dac
        return result;
    }
    int32_t v3 = 0;
    int32_t v4 = v3 - v1; // 0x100003d08
    int32_t v5 = v3; // 0x100003d10
    int32_t v6 = v3; // 0x100003d10
    int32_t v7 = v3; // 0x100003d10
    int32_t v8; // 0x100003cc0
    int32_t v9; // 0x100003d20
    int32_t v10; // 0x100003d2c
    int32_t v11; // 0x100003d30
    int32_t v12; // 0x100003d54
    int32_t v13; // 0x100003d08
    if (v4 < 0 != ((v4 ^ v3) & (v3 ^ v1)) < 0) {
        v9 = *(int32_t *)(4 * (int64_t)v6 + result);
        v10 = *(int32_t *)(4 * (int64_t)v5 + result);
        v11 = v9 - v10;
        v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
        v12 = v6 + 1;
        v13 = v12 - v1;
        v5 = v8;
        v6 = v12;
        v7 = v8;
        while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v1)) < 0) {
            // 0x100003d18
            v9 = *(int32_t *)(4 * (int64_t)v6 + result);
            v10 = *(int32_t *)(4 * (int64_t)v5 + result);
            v11 = v9 - v10;
            v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
            v12 = v6 + 1;
            v13 = v12 - v1;
            v5 = v8;
            v6 = v12;
            v7 = v8;
        }
    }
    int32_t * v14 = (int32_t *)(4 * (int64_t)v3 + result); // 0x100003d68
    int32_t * v15 = (int32_t *)(4 * (int64_t)v7 + result); // 0x100003d78
    *v14 = *v15;
    *v15 = *v14;
    int32_t v16 = v3 + 1; // 0x100003da0
    while (v16 - v1 < 0 != ((v16 - v1 ^ v16) & (v16 ^ v1)) < 0) {
        // 0x100003d00
        v3 = v16;
        v4 = v3 - v1;
        v5 = v3;
        v6 = v3;
        v7 = v3;
        if (v4 < 0 != ((v4 ^ v3) & (v3 ^ v1)) < 0) {
            v9 = *(int32_t *)(4 * (int64_t)v6 + result);
            v10 = *(int32_t *)(4 * (int64_t)v5 + result);
            v11 = v9 - v10;
            v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
            v12 = v6 + 1;
            v13 = v12 - v1;
            v5 = v8;
            v6 = v12;
            v7 = v8;
            while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v1)) < 0) {
                // 0x100003d18
                v9 = *(int32_t *)(4 * (int64_t)v6 + result);
                v10 = *(int32_t *)(4 * (int64_t)v5 + result);
                v11 = v9 - v10;
                v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
                v12 = v6 + 1;
                v13 = v12 - v1;
                v5 = v8;
                v6 = v12;
                v7 = v8;
            }
        }
        // 0x100003d60
        v14 = (int32_t *)(4 * (int64_t)v3 + result);
        v15 = (int32_t *)(4 * (int64_t)v7 + result);
        *v14 = *v15;
        *v15 = *v14;
        v16 = v3 + 1;
    }
    // 0x100003dac
    return result;
}

// Address range: 0x100003db4 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003db4
    int64_t v1; // bp-64, 0x100003db4
    _memcpy(&v1, &g1, 40);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e10
        _printf("%d%s", (int64_t)&g1, (char *)40);
    }
    // 0x100003e7c
    function_100003cc0();
    int32_t v2; // 0x100003efc
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003ea8
        v2 = _printf("%d%s", 10, (char *)40);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f20
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f34
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(int64_t a1) {
    // 0x100003f48
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f54
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>

struct replace_info {
    int n;
    char *text;
};

int compare(const void *a, const void *b)
{
    struct replace_info *x = (struct replace_info *) a;
    struct replace_info *y = (struct replace_info *) b;
    return x->n - y->n;
}

void generic_fizz_buzz(int max, struct replace_info *info, int info_length)
{
    int i, it;
    int found_word;

    for (i = 1; i < max; ++i) {
        found_word = 0;

        /* Assume sorted order of values in the info array */
        for (it = 0; it < info_length; ++it) {
            if (0 == i % info[it].n) {
                printf("%s", info[it].text);
                found_word = 1;
            }
        }

        if (0 == found_word)
            printf("%d", i);

        printf("\n");
    }
}

int main(void)
{
    struct replace_info info[3] = {
        {5, "Buzz"},
        {7, "Baxx"},
        {3, "Fizz"}
    };

    /* Sort information array */
    qsort(info, 3, sizeof(struct replace_info), compare);

    /* Print output for generic FizzBuzz */
    generic_fizz_buzz(20, info, 3);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d50(void);
int64_t function_100003d88(void);
int64_t function_100003f58(int64_t a1);
int64_t * function_100003f64(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f70(char * format, ...);
void function_100003f7c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

int64_t g1 = 5; // 0x100004028

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x100003d50 - 0x100003d88
int64_t function_100003d50(void) {
    // 0x100003d50
    return 0;
}

// Address range: 0x100003d88 - 0x100003ec4
int64_t function_100003d88(void) {
    // 0x100003d88
    int64_t v1; // 0x100003d88
    int32_t v2 = v1; // 0x100003d94
    int32_t v3 = 1 - v2; // 0x100003db4
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003eb8
        int64_t result; // 0x100003d88
        return result;
    }
    int32_t v4 = v1; // 0x100003d9c
    int32_t v5 = -v4; // 0x100003dd8
    int32_t v6 = 1; // 0x100003eac
    int32_t v7; // 0x100003d88
    while (true) {
      lab_0x100003dd0:
        // 0x100003dd0
        v7 = v6;
        int32_t v8 = 0; // 0x100003de0
        if (v5 < 0 == (v5 & v4) < 0) {
            // 0x100003e78
            _printf("%d", v1);
            goto lab_0x100003e98;
        } else {
            int32_t v9 = 0; // 0x100003e14
            if (v7 % *(int32_t *)(16 * (int64_t)v8 + v1) == 0) {
                // 0x100003e1c
                _printf("%s", (char *)v1);
                v9 = 1;
            }
            int32_t v10 = v9;
            int32_t v11 = v8 + 1; // 0x100003e54
            int32_t v12 = v11 - v4; // 0x100003dd8
            v8 = v11;
            while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v4)) < 0) {
                // 0x100003de8
                v9 = v10;
                if (v7 % *(int32_t *)(16 * (int64_t)v8 + v1) == 0) {
                    // 0x100003e1c
                    _printf("%s", (char *)v1);
                    v9 = 1;
                }
                // 0x100003e50
                v10 = v9;
                v11 = v8 + 1;
                v12 = v11 - v4;
                v8 = v11;
            }
            if (v10 == 0) {
                // 0x100003e78
                _printf("%d", v1);
                goto lab_0x100003e98;
            } else {
                goto lab_0x100003e98;
            }
        }
    }
  lab_0x100003dac:;
    // 0x100003eb8
    int32_t result2; // 0x100003ea0
    return result2;
  lab_0x100003e98:
    // 0x100003e98
    result2 = _printf("\n");
    v6 = v7 + 1;
    int32_t v13 = v6 - v2; // 0x100003db4
    if (v13 < 0 == ((v13 ^ v6) & (v6 ^ v2)) < 0) {
        // break -> 0x100003dac
        goto lab_0x100003dac;
    }
    goto lab_0x100003dd0;
}

// Address range: 0x100003ec4 - 0x100003f58
int64_t entry_point(void) {
    // 0x100003ec4
    int64_t v1; // bp-72, 0x100003ec4
    _memcpy(&v1, &g1, 48);
    _qsort(&v1, 3, 16, (int32_t (*)(int64_t *, int64_t *))0x100003d50);
    int64_t v2 = function_100003d88(); // 0x100003f20
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f30
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f44
        ___stack_chk_fail(v2);
    }
    // 0x100003f48
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t a1) {
    // 0x100003f58
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f64 - 0x100003f70
int64_t * function_100003f64(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f64
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// Address range: 0x100003f7c - 0x100003f88
void function_100003f7c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f7c
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include<stdarg.h>
#include<stdio.h>

long int factorial(int n){
	if(n>1)
		return n*factorial(n-1);
	return 1;
}

long int sumOfFactorials(int num,...){
	va_list vaList;
	long int sum = 0;
	
	va_start(vaList,num);
	
	while(num--)
		sum += factorial(va_arg(vaList,int));
	
	va_end(vaList);
	
	return sum;
}

int main()
{
	printf("\nSum of factorials of [1,5] : %ld",sumOfFactorials(5,1,2,3,4,5));
	printf("\nSum of factorials of [3,5] : %ld",sumOfFactorials(3,3,4,5));
	printf("\nSum of factorials of [1,3] : %ld",sumOfFactorials(3,1,2,3));
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d58(void);
int64_t function_100003dbc(void);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d58 - 0x100003dbc
int64_t function_100003d58(void) {
    // 0x100003d58
    int64_t v1; // 0x100003d58
    int32_t v2 = v1; // 0x100003d64
    int32_t v3 = v2 - 1; // 0x100003d6c
    int64_t result = 1; // 0x100003d74
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003d7c
        result = function_100003d58() * (0x100000000 * v1 >> 32);
    }
    // 0x100003dac
    return result;
}

// Address range: 0x100003dbc - 0x100003e38
int64_t function_100003dbc(void) {
    // 0x100003dbc
    int64_t v1; // 0x100003dbc
    int32_t v2 = v1; // 0x100003dc8
    int32_t v3 = v2; // 0x100003df4
    if (v2 == 0) {
        // 0x100003e28
        return 0;
    }
    int64_t result = 0; // 0x100003df4
    v3--;
    result += function_100003d58();
    while (v3 != 0) {
        // 0x100003dfc
        v3--;
        result += function_100003d58();
    }
    // 0x100003e28
    return result;
}

// Address range: 0x100003e38 - 0x100003f34
int64_t entry_point(void) {
    // 0x100003e38
    function_100003dbc();
    int64_t v1; // 0x100003e38
    int32_t v2 = v1; // 0x100003eb0
    _printf("\nSum of factorials of [1,5] : %ld", v2);
    function_100003dbc();
    _printf("\nSum of factorials of [3,5] : %ld", v2);
    function_100003dbc();
    _printf("\nSum of factorials of [1,3] : %ld", v2);
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

int max (int *a, int n, int i, int j, int k) {
    int m = i;
    if (j < n && a[j] > a[m]) {
        m = j;
    }
    if (k < n && a[k] > a[m]) {
        m = k;
    }
    return m;
}

void downheap (int *a, int n, int i) {
    while (1) {
        int j = max(a, n, i, 2 * i + 1, 2 * i + 2);
        if (j == i) {
            break;
        }
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
        i = j;
    }
}

void heapsort (int *a, int n) {
    int i;
    for (i = (n - 2) / 2; i >= 0; i--) {
        downheap(a, n, i);
    }
    for (i = 0; i < n; i++) {
        int t = a[n - i - 1];
        a[n - i - 1] = a[0];
        a[0] = t;
        downheap(a, n - i - 1, 0);
    }
}

int main () {
    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
    int n = sizeof a / sizeof a[0];
    int i;
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    heapsort(a, n);
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b30(void);
int64_t function_100003bf4(void);
int64_t function_100003cac(void);
int64_t function_100003f48(int64_t a1);
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f60(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4100000004; // 0x100003f6c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b30 - 0x100003bf4
int64_t function_100003b30(void) {
    // 0x100003b30
    int64_t v1; // 0x100003b30
    int32_t v2 = v1; // 0x100003b38
    int32_t v3 = v1; // 0x100003b3c
    int32_t v4 = v1; // 0x100003b40
    int32_t v5 = v4 - v2; // 0x100003b58
    int32_t v6 = v3; // 0x100003b60
    if (v5 < 0 != ((v5 ^ v4) & (int32_t)(v1 ^ v1)) < 0) {
        int32_t v7 = *(int32_t *)(v1 + (0x100000000 * v1 >> 30)); // 0x100003b70
        int32_t v8 = *(int32_t *)(v1 + (0x100000000 * v1 >> 30)); // 0x100003b7c
        int32_t v9 = v7 - v8; // 0x100003b80
        v6 = v9 == 0 | v9 < 0 != ((v9 ^ v7) & (v8 ^ v7)) < 0 ? v3 : v4;
    }
    int32_t v10 = v1; // 0x100003b44
    int32_t v11 = v10 - v2; // 0x100003ba4
    int32_t result = v6; // 0x100003bac
    if (v11 < 0 != ((v11 ^ v10) & (int32_t)(v1 ^ v1)) < 0) {
        int32_t v12 = *(int32_t *)(v1 + (0x100000000 * v1 >> 30)); // 0x100003bbc
        int32_t v13 = *(int32_t *)(4 * (int64_t)v6 + v1); // 0x100003bc8
        int32_t v14 = v12 - v13; // 0x100003bcc
        result = v14 == 0 | v14 < 0 != ((v14 ^ v12) & (v13 ^ v12)) < 0 ? v6 : v10;
    }
    // 0x100003be8
    return result;
}

// Address range: 0x100003bf4 - 0x100003cac
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t v1; // 0x100003bf4
    int32_t v2 = v1; // 0x100003c08
    int64_t result = function_100003b30(); // 0x100003c38
    int32_t v3 = result; // 0x100003c3c
    if (v2 == v3) {
        // 0x100003ca0
        return result;
    }
    int32_t v4 = v3;
    int32_t * v5 = (int32_t *)(4 * (int64_t)v2 + v1); // 0x100003c64
    int32_t * v6 = (int32_t *)((0x100000000 * result >> 30) + v1); // 0x100003c74
    *v5 = *v6;
    *v6 = *v5;
    int64_t result2 = function_100003b30(); // 0x100003c38
    int32_t v7 = result2; // 0x100003c3c
    while (v4 != v7) {
        int32_t v8 = v4;
        v4 = v7;
        v5 = (int32_t *)(4 * (int64_t)v8 + v1);
        v6 = (int32_t *)((0x100000000 * result2 >> 30) + v1);
        *v5 = *v6;
        *v6 = *v5;
        result2 = function_100003b30();
        v7 = result2;
    }
    // 0x100003ca0
    return result2;
}

// Address range: 0x100003cac - 0x100003db4
int64_t function_100003cac(void) {
    // 0x100003cac
    int64_t v1; // 0x100003cac
    int32_t v2 = v1; // 0x100003cbc
    int32_t v3 = v2 - 2; // 0x100003cc8
    int64_t result; // 0x100003cac
    if (v3 >= 0xffffffff) {
        int32_t v4 = v3 / 2;
        result = function_100003bf4();
        int32_t v5 = v4 - 1; // 0x100003ce4
        while (v4 >= 1) {
            // 0x100003cec
            v4 = v5;
            result = function_100003bf4();
            v5 = v4 - 1;
        }
    }
    int32_t v6 = -v2; // 0x100003d20
    if (v6 < 0 == (v6 & v2) < 0) {
        // 0x100003da8
        return result;
    }
    int32_t v7 = 0; // 0x100003d28
    int32_t * v8 = (int32_t *)(v1 + (int64_t)(4 * ((v7 ^ 0x3fffffff) + v2))); // 0x100003d44
    *v8 = (int32_t)result;
    *(int32_t *)v1 = *v8;
    int64_t result2 = function_100003bf4(); // 0x100003d90
    v7++;
    int32_t v9 = v7 - v2; // 0x100003d20
    while (v9 < 0 != ((v9 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003d30
        v8 = (int32_t *)(v1 + (int64_t)(4 * ((v7 ^ 0x3fffffff) + v2)));
        *v8 = (int32_t)result2;
        *(int32_t *)v1 = *v8;
        result2 = function_100003bf4();
        v7++;
        v9 = v7 - v2;
    }
    // 0x100003da8
    return result2;
}

// Address range: 0x100003db4 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003db4
    int64_t v1; // bp-64, 0x100003db4
    _memcpy(&v1, &g1, 40);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e10
        _printf("%d%s", (int64_t)&g1, (char *)40);
    }
    // 0x100003e7c
    function_100003cac();
    int32_t v2; // 0x100003efc
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003ea8
        v2 = _printf("%d%s", 10, (char *)40);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f20
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f34
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(int64_t a1) {
    // 0x100003f48
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f54
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdlib.h>
#include <stdio.h>

#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))

int jacobi(unsigned long a, unsigned long n) {
	if (a >= n) a %= n;
	int result = 1;
	while (a) {
		while ((a & 1) == 0) {
			a >>= 1;
			if ((n & 7) == 3 || (n & 7) == 5) result = -result;
		}
		SWAP(a, n);
		if ((a & 3) == 3 && (n & 3) == 3) result = -result;
		a %= n;
	}
	if (n == 1) return result;
	return 0;
}

void print_table(unsigned kmax, unsigned nmax) {
	printf("n\\k|");
	for (int k = 0; k <= kmax; ++k) printf("%'3u", k);
	printf("\n----");
	for (int k = 0; k <= kmax; ++k) printf("---");
	putchar('\n');
	for (int n = 1; n <= nmax; n += 2) {
		printf("%-2u |", n);
		for (int k = 0; k <= kmax; ++k)
			printf("%'3d", jacobi(k, n));
		putchar('\n');
	}
}

int main() {
	print_table(20, 21);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c20(void);
int64_t function_100003db0(void);
int32_t function_100003f68(char * format, ...);
int32_t function_100003f74(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c20 - 0x100003db0
int64_t function_100003c20(void) {
    // 0x100003c20
    int64_t v1; // 0x100003c20
    uint64_t v2 = v1;
    int64_t v3; // 0x100003c20
    if (v1 >= v2) {
        // 0x100003c44
        v3 = v1 % v2;
    }
    // 0x100003c60
    if (v3 == 0) {
        // 0x100003d7c
        int64_t v4; // 0x100003c20
        return v4 == 1 ? 1 : 0;
    }
    int32_t v5 = 1;
    int32_t v6 = v5; // 0x100003c90
    int64_t v7 = v3; // 0x100003c90
    uint64_t v8; // 0x100003c20
    uint64_t v9; // 0x100003c20
    int32_t v10; // 0x100003c20
    int32_t v11; // 0x100003c20
    int32_t v12; // 0x100003c20
    int64_t v13; // 0x100003c9c
    if (v3 % 2 == 0) {
        // 0x100003c98
        v10 = v5;
        v8 = v3;
        v11 = v10;
        switch (v9 % 8) {
            case 3: {
            }
            case 5: {
                // 0x100003cd4
                v11 = -v10;
                // break -> 0x100003ce8
                break;
            }
        }
        // 0x100003ce8
        v13 = v8 / 2;
        v12 = v11;
        v6 = v12;
        v7 = v13;
        while ((v8 & 2) == 0) {
            // 0x100003c98
            v10 = v12;
            v8 = v13;
            v11 = v10;
            switch (v9 % 8) {
                case 3: {
                }
                case 5: {
                    // 0x100003cd4
                    v11 = -v10;
                    // break -> 0x100003ce8
                    break;
                }
            }
            // 0x100003ce8
            v13 = v8 / 2;
            v12 = v11;
            v6 = v12;
            v7 = v13;
        }
    }
    int64_t v14 = v7;
    int32_t v15 = v6;
    int64_t v16; // 0x100003c20
    int32_t v17 = (v16 % 4 & v14) == 3 ? -v15 : v15;
    int64_t v18 = v16 % v14;
    while (v18 != 0) {
        // 0x100003c84
        v5 = v17;
        v9 = v14;
        int64_t v19 = v18;
        v6 = v5;
        v7 = v19;
        if (v19 % 2 == 0) {
            // 0x100003c98
            v10 = v5;
            v8 = v19;
            v11 = v10;
            switch (v9 % 8) {
                case 3: {
                }
                case 5: {
                    // 0x100003cd4
                    v11 = -v10;
                    // break -> 0x100003ce8
                    break;
                }
            }
            // 0x100003ce8
            v13 = v8 / 2;
            v12 = v11;
            v6 = v12;
            v7 = v13;
            while ((v8 & 2) == 0) {
                // 0x100003c98
                v10 = v12;
                v8 = v13;
                v11 = v10;
                switch (v9 % 8) {
                    case 3: {
                    }
                    case 5: {
                        // 0x100003cd4
                        v11 = -v10;
                        // break -> 0x100003ce8
                        break;
                    }
                }
                // 0x100003ce8
                v13 = v8 / 2;
                v12 = v11;
                v6 = v12;
                v7 = v13;
            }
        }
        // 0x100003cec
        v14 = v7;
        v15 = v6;
        v17 = (v9 % 4 & v14) == 3 ? -v15 : v15;
        v18 = v9 % v14;
    }
    // 0x100003d7c
    return v14 == 1 ? (int64_t)v17 : 0;
}

// Address range: 0x100003db0 - 0x100003f34
int64_t function_100003db0(void) {
    // 0x100003db0
    int64_t v1; // 0x100003db0
    uint32_t v2 = (int32_t)v1; // 0x100003dbc
    uint32_t v3 = (int32_t)v1; // 0x100003dc0
    _printf("n\\k|");
    int32_t v4 = 0; // 0x100003de8
    if (v2 == 0 == (v2 != 0)) {
        // 0x100003e20
        _printf("\n----");
    } else {
        _printf("%'3u", v3);
        v4++;
        while (v4 >= v2 != v4 != v2) {
            // 0x100003df0
            _printf("%'3u", v3);
            v4++;
        }
        // 0x100003e4c
        _printf("\n----");
        int32_t v5 = 0; // 0x100003e60
        _printf("---");
        while (v5 + 1 >= v2 != v5 + 1 != v2) {
            // 0x100003e4c
            v5++;
            _printf("---");
        }
    }
    int32_t result = _putchar(10); // 0x100003e90
    if (v3 <= 1 == (v3 != 1)) {
        // 0x100003f28
        return result;
    }
    int32_t v6 = 1;
    int64_t v7; // 0x100003db0
    _printf("%-2u |", (int32_t)v7);
    int64_t v8 = v7; // 0x100003ecc
    int64_t v9; // 0x100003ed8
    int32_t v10; // 0x100003f00
    if (v2 == 0 != v2 != 0) {
        // 0x100003ed4
        v9 = v6;
        v10 = 0;
        function_100003c20();
        _printf("%'3d", v9);
        v10++;
        v8 = v9;
        while (v10 >= v2 != v10 != v2) {
            // 0x100003ed4
            function_100003c20();
            _printf("%'3d", v9);
            v10++;
            v8 = v9;
        }
    }
    int32_t v11 = v6 + 2; // 0x100003f1c
    result = _putchar(10);
    while (v11 >= v3 != v11 != v3) {
        // 0x100003e98
        v6 = v11;
        _printf("%-2u |", (int32_t)v8);
        if (v2 == 0 != v2 != 0) {
            // 0x100003ed4
            v9 = v6;
            v10 = 0;
            function_100003c20();
            _printf("%'3d", v9);
            v10++;
            v8 = v9;
            while (v10 >= v2 != v10 != v2) {
                // 0x100003ed4
                function_100003c20();
                _printf("%'3d", v9);
                v10++;
                v8 = v9;
            }
        }
        // 0x100003f0c
        v11 = v6 + 2;
        result = _putchar(10);
    }
    // 0x100003f28
    return result;
}

// Address range: 0x100003f34 - 0x100003f68
int64_t entry_point(void) {
    // 0x100003f34
    function_100003db0();
    return 0;
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(int32_t c) {
    // 0x100003f74
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`// Works for clang and GCC 10+
#include<stdio.h>

int main() {
    int Δ = 1;      // if unsupported, use \u0394
    Δ++;
    printf("%d",Δ);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f40 - 0x100003f98
int64_t entry_point(void) {
    // 0x100003f40
    int64_t v1; // 0x100003f40
    _printf("%d", v1);
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <ctype.h>

int can_make_words(char **b, char *word)
{
	int i, ret = 0, c = toupper(*word);

#define SWAP(a, b) if (a != b) { char * tmp = a; a = b; b = tmp; }

	if (!c) return 1;
	if (!b[0]) return 0;

	for (i = 0; b[i] && !ret; i++) {
		if (b[i][0] != c && b[i][1] != c) continue;
		SWAP(b[i], b[0]);
		ret = can_make_words(b + 1, word + 1);
		SWAP(b[i], b[0]);
	}

	return ret;
}

int main(void)
{
	char* blocks[] = {
		"BO", "XK", "DQ", "CP", "NA",
		"GT", "RE", "TG", "QD", "FS",
		"JW", "HU", "VI", "AN", "OB",
		"ER", "FS", "LY", "PC", "ZM",
		0 };

	char *words[] = {
		"", "A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "Confuse", 0
	};

	char **w;
	for (w = words; *w; w++)
		printf("%s\t%d\n", *w, can_make_words(blocks, *w));

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c14(void);
int64_t function_100003f08(int64_t a1);
int64_t * function_100003f14(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f20(char * format, ...);
int32_t function_100003f2c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c14 - 0x100003e0c
int64_t function_100003c14(void) {
    // 0x100003c14
    int64_t v1; // 0x100003c14
    int32_t v2 = _toupper(0x1000000 * (int32_t)v1 >> 24); // 0x100003c34
    if (v2 == 0) {
        // 0x100003dfc
        return 1;
    }
    int64_t * v3 = (int64_t *)v1;
    int64_t v4 = *v3; // 0x100003c8c
    if (v4 == 0) {
        // 0x100003dfc
        return 0;
    }
    int64_t v5 = v4; // 0x100003c8c
    int64_t * v6 = v3; // 0x100003c8c
    int32_t v7 = 0; // 0x100003de4
    int64_t v8 = v2; // 0x100003c14
    int32_t v9 = 0; // 0x100003c14
    int64_t v10; // 0x100003d1c
    int64_t * v11; // 0x100003c14
    int32_t v12; // 0x100003c14
    int64_t v13; // 0x100003c14
    while (true) {
      lab_0x100003cc8:
        // 0x100003cc8
        v13 = v8;
        v11 = v6;
        v10 = v5;
        if (v2 == (int32_t)*(char *)v10) {
            goto lab_0x100003d14;
        } else {
            // 0x100003cec
            v12 = v9;
            v8 = v13;
            if (v2 == (int32_t)*(char *)(v10 + 1)) {
                goto lab_0x100003d14;
            } else {
                goto lab_0x100003de0;
            }
        }
    }
  lab_0x100003dfc:;
    // 0x100003dfc
    int32_t result; // 0x100003c14
    return result;
  lab_0x100003d14:
    if (v10 != v13) {
        // 0x100003d38
        *v11 = v13;
        *v3 = v10;
    }
    int64_t v14 = function_100003c14(); // 0x100003d7c
    int32_t v15 = v14; // 0x100003d80
    int64_t v16 = *v11; // 0x100003d8c
    v12 = v15;
    v8 = v14;
    if (v16 != v14) {
        // 0x100003da8
        *v11 = v14;
        *v3 = v16;
        v12 = v15;
        v8 = v14;
    }
    goto lab_0x100003de0;
  lab_0x100003de0:
    // 0x100003de0
    v7++;
    v6 = (int64_t *)(8 * (int64_t)v7 + v1);
    v5 = *v6;
    v9 = v12;
    result = v12;
    if (v12 == 0 != v5 != 0) {
        // break -> 0x100003dfc
        goto lab_0x100003dfc;
    }
    goto lab_0x100003cc8;
}

// Address range: 0x100003e0c - 0x100003f08
int64_t entry_point(void) {
    // 0x100003e0c
    int64_t v1; // bp-208, 0x100003e0c
    _memcpy(&v1, (int64_t *)"8?", 168);
    int64_t v2; // bp-280, 0x100003e0c
    int64_t v3 = (int64_t)_memcpy(&v2, (int64_t *)"q?", 72); // 0x100003e78
    if (v2 != 0) {
        int64_t v4 = &v2; // 0x100003ec4
        function_100003c14();
        int32_t v5 = _printf("%s\t%d\n", (char *)v2, 72); // 0x100003eb8
        v4 += 8;
        int64_t v6 = *(int64_t *)v4; // 0x100003e6c
        while (v6 != 0) {
            // 0x100003e80
            function_100003c14();
            v5 = _printf("%s\t%d\n", (char *)v6, 72);
            v4 += 8;
            v6 = *(int64_t *)v4;
        }
        // 0x100003e68
        v3 = v5;
    }
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003edc
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ef0
        ___stack_chk_fail(v3);
    }
    // 0x100003ef4
    return 0;
}

// Address range: 0x100003f08 - 0x100003f14
int64_t function_100003f08(int64_t a1) {
    // 0x100003f08
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f14 - 0x100003f20
int64_t * function_100003f14(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f14
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * format, ...) {
    // 0x100003f20
    return _printf(format);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t c) {
    // 0x100003f2c
    return _toupper(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <string.h>

#define FOR(x, y) for(x = 0; x < y; x++)
char *best_shuffle(const char *s, int *diff)
{
	int i, j = 0, max = 0, l = strlen(s), cnt[128] = {0};
	char buf[256] = {0}, *r;

	FOR(i, l) if (++cnt[(int)s[i]] > max) max = cnt[(int)s[i]];
	FOR(i, 128) while (cnt[i]--) buf[j++] = i;

	r = strdup(s);
	FOR(i, l) FOR(j, l)
		if (r[i] == buf[j]) {
			r[i] = buf[(j + max) % l] & ~128;
			buf[j] |= 128;
			break;
		}

	*diff = 0;
	FOR(i, l) *diff += r[i] == s[i];

	return r;
}

int main()
{
	int i, d;
	const char *r, *t[] = {"abracadabra", "seesaw", "elk", "grrrrrr", "up", "a", 0};
	for (i = 0; t[i]; i++) {
		r = best_shuffle(t[i], &d);
		printf("%s %s (%d)\n", t[i], r, d);
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b30(void);
int64_t function_100003f1c(int64_t a1);
void function_100003f28(int64_t * s, int32_t n);
int64_t * function_100003f34(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003f40(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f4c(char * format, ...);
char * function_100003f58(char * s);
int32_t function_100003f64(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b30 - 0x100003e2c
int64_t function_100003b30(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b48
    int64_t v2; // 0x100003b30
    char * v3 = (char *)v2; // 0x100003b50
    int32_t v4 = _strlen(v3); // 0x100003b6c
    int64_t v5; // bp-544, 0x100003b30
    _bzero(&v5, 512);
    int64_t v6; // bp-800, 0x100003b30
    _memset(&v6, 0, 256);
    int32_t v7 = -v4;
    int64_t v8 = &v5;
    int32_t v9 = 0; // 0x100003bac
    int32_t v10 = 0; // 0x100003bac
    int32_t v11 = 0; // 0x100003bac
    if (v7 < 0 != (v4 & v7) < 0) {
        char * v12 = (char *)(v2 + (int64_t)v10); // 0x100003bbc
        int32_t * v13 = (int32_t *)(4 * (int64_t)*v12 + v8); // 0x100003bc8
        int32_t v14 = *v13 + 1; // 0x100003bcc
        *v13 = v14;
        int32_t v15 = v14 - v11; // 0x100003bd8
        int32_t v16 = v11; // 0x100003be0
        if (v15 != 0 && v15 < 0 == ((v15 ^ v14) & (v14 ^ v11)) < 0) {
            // 0x100003be8
            v16 = *(int32_t *)(4 * (int64_t)*v12 + v8);
        }
        // 0x100003c08
        v11 = v16;
        v10++;
        int32_t v17 = v10 - v4; // 0x100003ba4
        v9 = v11;
        while (v17 < 0 != ((v17 ^ v10) & (v10 ^ v4)) < 0) {
            // 0x100003bb4
            v12 = (char *)(v2 + (int64_t)v10);
            v13 = (int32_t *)(4 * (int64_t)*v12 + v8);
            v14 = *v13 + 1;
            *v13 = v14;
            v15 = v14 - v11;
            v16 = v11;
            if (v15 != 0 && v15 < 0 == ((v15 ^ v14) & (v14 ^ v11)) < 0) {
                // 0x100003be8
                v16 = *(int32_t *)(4 * (int64_t)*v12 + v8);
            }
            // 0x100003c08
            v11 = v16;
            v10++;
            v17 = v10 - v4;
            v9 = v11;
        }
    }
    int32_t * v18 = (int32_t *)v2; // 0x100003b54
    int64_t v19 = &v6;
    int32_t v20 = 0;
    int32_t v21 = 0;
    int32_t * v22 = (int32_t *)(4 * (int64_t)v21 + v8); // 0x100003c44
    int32_t v23 = *v22; // 0x100003c44
    *v22 = v23 - 1;
    int32_t v24 = v20; // 0x100003c58
    int32_t v25; // 0x100003b30
    int32_t v26; // 0x100003c6c
    int32_t v27; // 0x100003c44
    if (v23 != 0) {
        // 0x100003c60
        v26 = v20 + 1;
        *(char *)((int64_t)v20 + v19) = (char)v21;
        v27 = *v22;
        *v22 = v27 - 1;
        v24 = v26;
        while (v27 != 0) {
            // 0x100003c60
            v25 = v26;
            v26 = v25 + 1;
            *(char *)((int64_t)v25 + v19) = (char)v21;
            v27 = *v22;
            *v22 = v27 - 1;
            v24 = v26;
        }
    }
    int32_t v28 = v21 + 1; // 0x100003c88
    while (v21 < 127 != (126 - v21 & v28) < 0) {
        // 0x100003c38
        v20 = v24;
        v21 = v28;
        v22 = (int32_t *)(4 * (int64_t)v21 + v8);
        v23 = *v22;
        *v22 = v23 - 1;
        v24 = v20;
        if (v23 != 0) {
            // 0x100003c60
            v26 = v20 + 1;
            *(char *)((int64_t)v20 + v19) = (char)v21;
            v27 = *v22;
            *v22 = v27 - 1;
            v24 = v26;
            while (v27 != 0) {
                // 0x100003c60
                v25 = v26;
                v26 = v25 + 1;
                *(char *)((int64_t)v25 + v19) = (char)v21;
                v27 = *v22;
                *v22 = v27 - 1;
                v24 = v26;
            }
        }
        // 0x100003c84
        v28 = v21 + 1;
    }
    int64_t result = (int64_t)_strdup(v3); // 0x100003c98
    int32_t v29 = 0; // 0x100003cb8
    if (v7 < 0 == (v4 & v7) < 0) {
        // 0x100003d7c
        *v18 = 0;
    } else {
        while (true) {
            char * v30 = (char *)((int64_t)v29 + result);
            int32_t v31 = 0;
            char * v32 = (char *)((int64_t)v31 + v19);
            while (*v30 != *v32) {
                int32_t v33 = v31 + 1; // 0x100003d5c
                int32_t v34 = v33 - v4; // 0x100003cd0
                if (v34 < 0 == ((v34 ^ v33) & (v33 ^ v4)) < 0) {
                    goto lab_0x100003d6c;
                }
                v31 = v33;
                v32 = (char *)((int64_t)v31 + v19);
            }
            unsigned char v35 = *(char *)((int64_t)((v31 + v9) % v4) + v19); // 0x100003d28
            *v30 = v35 % 128;
            *v32 = *v32 | -128;
          lab_0x100003d6c:
            // 0x100003d6c
            v29++;
            int32_t v36 = v29 - v4; // 0x100003cb0
            if (v36 < 0 == ((v36 ^ v29) & (v29 ^ v4)) < 0) {
                // break -> 0x100003da4
                break;
            }
        }
        // 0x100003da4
        *v18 = 0;
        int32_t v37 = 0; // 0x100003de0
        int64_t v38 = v37; // 0x100003da8
        char v39 = *(char *)(v2 + v38); // 0x100003db8
        int64_t v40; // 0x100003b30
        *v18 = *(int32_t *)&v40 + (int32_t)(*(char *)(v38 + result) == v39);
        v37++;
        while (v37 - v4 < 0 != ((v37 - v4 ^ v37) & (v37 ^ v4)) < 0) {
            // 0x100003da4
            v38 = v37;
            v39 = *(char *)(v2 + v38);
            *v18 = *(int32_t *)&v40 + (int32_t)(*(char *)(v38 + result) == v39);
            v37++;
        }
    }
    // 0x100003dec
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e14
        ___stack_chk_fail(result);
    }
    // 0x100003e18
    return result;
}

// Address range: 0x100003e2c - 0x100003f1c
int64_t entry_point(void) {
    // 0x100003e2c
    int64_t v1; // bp-80, 0x100003e2c
    int64_t * v2 = _memcpy(&v1, (int64_t *)"p?", 56); // 0x100003e5c
    int32_t v3 = 0; // 0x100003e7c
    int64_t v4 = (int64_t)v2; // 0x100003e7c
    if (v1 != 0) {
        function_100003b30();
        int64_t v5; // bp-92, 0x100003e2c
        int64_t v6; // 0x100003e2c
        int32_t v7 = _printf("%s %s (%d)\n", &v5, (char *)56, v6); // 0x100003ed0
        v3++;
        while (*(int64_t *)(8 * (int64_t)v3 + (int64_t)&v1) != 0) {
            // 0x100003e84
            function_100003b30();
            v7 = _printf("%s %s (%d)\n", &v5, (char *)56, v6);
            v3++;
        }
        // 0x100003e68
        v4 = v7;
    }
    int64_t v8 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ef4
    if (v8 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f08
        ___stack_chk_fail(v4);
    }
    // 0x100003f0c
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
int64_t function_100003f1c(int64_t a1) {
    // 0x100003f1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f28 - 0x100003f34
void function_100003f28(int64_t * s, int32_t n) {
    // 0x100003f28
    _bzero(s, n);
}

// Address range: 0x100003f34 - 0x100003f40
int64_t * function_100003f34(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f34
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f40
    return _memset(s, c, n);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
char * function_100003f58(char * s) {
    // 0x100003f58
    return _strdup(s);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <unistd.h>

int main() {
  unlink("input.txt");
  unlink("/input.txt");
  rmdir("docs");
  rmdir("/docs");
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f70(char * path);
int32_t function_100003f7c(char * name);

// ------- Dynamically Linked Functions Without Header --------

int32_t _rmdir(char * a1);
int32_t _unlink(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f18 - 0x100003f70
int64_t entry_point(void) {
    // 0x100003f18
    _unlink("input.txt");
    _unlink("/input.txt");
    _rmdir("docs");
    _rmdir("/docs");
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * path) {
    // 0x100003f70
    return _rmdir(path);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * name) {
    // 0x100003f7c
    return _unlink(name);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

typedef struct {
        int power;
        double * coef;
} poly_t, *poly;

#define E(x, i) (x)->coef[i]

/* passing in negative power to have a zeroed poly */
poly p_new(int power, ...)
{
        int i, zeroed = 0;
        va_list ap;

        if (power < 0) {
                power = -power;
                zeroed = 1;
        }

        poly p = malloc(sizeof(poly_t));
        p->power = power;
        p->coef = malloc(sizeof(double) * ++power);

        if (zeroed)
                for (i = 0; i < power; i++) p->coef[i] = 0;
        else {
                va_start(ap, power);
                for (i = 0; i < power; i++)
                        E(p, i) = va_arg(ap, double);
                va_end(ap);
        }

        return p;
}

void p_del(poly p)
{
        free(p->coef);
        free(p);
}

void p_print(poly p)
{
        int i;
        for (i = 0; i <= p->power; i++)
                printf("%g ", E(p, i));
        printf("\n");
}

poly p_copy(poly p)
{
        poly q = p_new(-p->power);
        memcpy(q->coef, p->coef, sizeof(double) * (1 + p->power));
        return q;
}

/* p: poly;  d: divisor;  r: remainder; returns quotient */
poly p_div(poly p, poly d, poly* r)
{
        poly q;
        int i, j;
        int power = p->power - d->power;
        double ratio;

        if (power < 0) return 0;

        q = p_new(-power);
        *r= p_copy(p);

        for (i = p->power; i >= d->power; i--) {
                E(q, i - d->power) = ratio = E(*r, i) / E(d, d->power);
                E(*r ,i) = 0;

                for (j = 0; j < d->power; j++)
                        E(*r, i - d->power + j) -= E(d, j) * ratio;
        }
        while (! E(*r, --(*r)->power));

        return q;
}

int main()
{
        poly p = p_new(3, 1., 2., 3., 4.);
        poly d = p_new(2, 1., 2., 1.);
        poly r;
        poly q = p_div(p, d, &r);

        printf("poly: "); p_print(p);
        printf("div:  "); p_print(d);
        printf("quot: "); p_print(q);
        printf("rem:  "); p_print(r);

        p_del(p);
        p_del(q);
        p_del(r);
        p_del(d);

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039e0(void);
int64_t function_100003b40(void);
int64_t function_100003b70(void);
int64_t function_100003bf4(void);
int64_t function_100003c60(void);
int64_t function_100003f54(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f60(int64_t * ptr);
int64_t * function_100003f6c(int32_t size);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039e0 - 0x100003b40
int64_t function_1000039e0(void) {
    // 0x1000039e0
    int64_t v1; // 0x1000039e0
    int32_t v2 = v1; // 0x1000039ec
    int32_t v3 = v2 < 0 ? -v2 : v2;
    int64_t * v4 = _malloc(16); // 0x100003a28
    int64_t result = (int64_t)v4; // 0x100003a28
    *(int32_t *)v4 = v3;
    int32_t v5 = v3 + 1; // 0x100003a40
    int64_t * v6 = _malloc(8 * v5); // 0x100003a58
    int64_t * v7 = (int64_t *)(result + 8); // 0x100003a60
    *v7 = (int64_t)v6;
    if (v2 < 0) {
        if (v3 > -1 == (v5 & -v3) < 0) {
            // 0x100003b30
            return result;
        }
        // 0x100003a98
        *v6 = 0;
        int32_t v8 = -v3; // 0x100003a88
        if (v8 < 0 == (v5 & v8) < 0) {
            // 0x100003b30
            return result;
        }
        int32_t v9 = 1; // 0x100003a90
        *(float64_t *)(8 * (int64_t)v9 + *v7) = 0.0;
        v9++;
        while (v9 - v5 < 0 != ((v9 - v5 ^ v9) & (v9 ^ v5)) < 0) {
            // 0x100003a98
            *(float64_t *)(8 * (int64_t)v9 + *v7) = 0.0;
            v9++;
        }
        // 0x100003b30
        return result;
    }
    if (v3 > -1 == (v5 & -v3) < 0) {
        // 0x100003b30
        return result;
    }
    // 0x100003af0
    int64_t v10; // 0x1000039e0
    *v6 = v10;
    int32_t v11 = -v3; // 0x100003ae0
    if (v11 < 0 == (v5 & v11) < 0) {
        // 0x100003b30
        return result;
    }
    int32_t v12 = 1; // 0x100003b20
    int64_t v13 = &v10; // 0x100003af8
    v13 += 8;
    int64_t v14 = *(int64_t *)v13; // 0x100003af4
    *(float64_t *)(8 * (int64_t)v12 + *v7) = (float64_t)v14;
    v12++;
    while (v12 - v5 < 0 != ((v12 - v5 ^ v12) & (v12 ^ v5)) < 0) {
        // 0x100003af0
        v13 += 8;
        v14 = *(int64_t *)v13;
        *(float64_t *)(8 * (int64_t)v12 + *v7) = (float64_t)v14;
        v12++;
    }
    // 0x100003b30
    return result;
}

// Address range: 0x100003b40 - 0x100003b70
int64_t function_100003b40(void) {
    // 0x100003b40
    int64_t v1; // 0x100003b40
    _free((int64_t *)*(int64_t *)(v1 + 8));
    _free((int64_t *)v1);
    return &g1;
}

// Address range: 0x100003b70 - 0x100003bf4
int64_t function_100003b70(void) {
    // 0x100003b70
    int64_t v1; // 0x100003b70
    int32_t v2 = v1;
    int32_t v3 = -v2; // 0x100003b94
    if (v2 != 0 && v3 < 0 == (v2 & v3) < 0) {
        // 0x100003bdc
        return _printf("\n");
    }
    int32_t v4 = 0; // 0x100003bd0
    int128_t v5; // 0x100003b70
    _printf("%g ", (float64_t)(int64_t)v5);
    v4++;
    while (v4 - v2 == 0 || v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003ba4
        _printf("%g ", (float64_t)(int64_t)v5);
        v4++;
    }
    // 0x100003bdc
    return _printf("\n");
}

// Address range: 0x100003bf4 - 0x100003c60
int64_t function_100003bf4(void) {
    int64_t result = function_1000039e0(); // 0x100003c14
    int64_t v1; // 0x100003bf4
    int64_t v2 = *(int64_t *)(v1 + 8); // 0x100003c28
    ___memcpy_chk(*(int64_t *)(result + 8), v2, 0x100000000 * v1 + 0x100000000 >> 29, -1);
    return result;
}

// Address range: 0x100003c60 - 0x100003e4c
int64_t function_100003c60(void) {
    int64_t result = function_1000039e0(); // 0x100003cb8
    int64_t v1; // 0x100003c60
    *(int64_t *)v1 = function_100003bf4();
    int64_t v2; // 0x100003c60
    int32_t v3 = *(int32_t *)&v2; // 0x100003cd4
    int64_t v4; // 0x100003c60
    int32_t v5 = *(int32_t *)&v4; // 0x100003ce8
    int32_t v6 = v3 - v5; // 0x100003cec
    int64_t * v7; // 0x100003c60
    if (v6 < 0 == ((v6 ^ v3) & (v5 ^ v3)) < 0) {
        int64_t * v8 = (int64_t *)(v1 + 8); // 0x100003d14
        int64_t * v9 = (int64_t *)(v1 + 8);
        int64_t v10 = 8 * (int64_t)v3; // 0x100003d0c
        float64_t v11 = *(float64_t *)(*v8 + 8 * (int64_t)v5); // 0x100003d20
        float64_t v12 = *(float64_t *)(v10 + *v9) / v11; // 0x100003d24
        *(float64_t *)(*(int64_t *)(result + 8) + (int64_t)(8 * v6)) = v12;
        *(float64_t *)(*v9 + v10) = 0.0;
        int32_t v13 = *(int32_t *)&v4; // 0x100003d70
        int32_t v14 = -v13; // 0x100003d74
        int32_t v15 = v13; // 0x100003d7c
        int32_t v16 = 0; // 0x100003d7c
        int32_t v17 = v13; // 0x100003d7c
        float64_t * v18; // 0x100003dc0
        int32_t v19; // 0x100003dd4
        int32_t v20; // 0x100003d70
        int32_t v21; // 0x100003d74
        if (v14 < 0 != (v13 & v14) < 0) {
            v18 = (float64_t *)(*v9 + 8 * (int64_t)(v3 - v15 + v16));
            *v18 = *v18 - v12 * *(float64_t *)(8 * (int64_t)v16 + *v8);
            v19 = v16 + 1;
            v20 = *(int32_t *)&v4;
            v21 = v19 - v20;
            v16 = v19;
            v17 = v20;
            while (v21 < 0 != ((v21 ^ v19) & (v20 ^ v19)) < 0) {
                // 0x100003d84
                v18 = (float64_t *)(*v9 + 8 * (int64_t)(v3 - v20 + v16));
                *v18 = *v18 - v12 * *(float64_t *)(8 * (int64_t)v16 + *v8);
                v19 = v16 + 1;
                v20 = *(int32_t *)&v4;
                v21 = v19 - v20;
                v16 = v19;
                v17 = v20;
            }
        }
        int32_t v22 = v17; // 0x100003ce8
        int32_t v23 = v3 - 1; // 0x100003de8
        int32_t v24 = v23 - v22; // 0x100003cec
        v7 = v9;
        while (v24 < 0 == ((v24 ^ v23) & (v22 ^ v23)) < 0) {
            int32_t v25 = v23;
            v10 = 8 * (int64_t)v25;
            v11 = *(float64_t *)(*v8 + 8 * (int64_t)v22);
            v12 = *(float64_t *)(v10 + *v9) / v11;
            *(float64_t *)(*(int64_t *)(result + 8) + (int64_t)(8 * v24)) = v12;
            *(float64_t *)(*v9 + v10) = 0.0;
            v13 = *(int32_t *)&v4;
            v14 = -v13;
            v15 = v13;
            v16 = 0;
            v17 = v13;
            if (v14 < 0 != (v13 & v14) < 0) {
                int64_t v26 = *v9; // 0x100003da0
                v18 = (float64_t *)(v26 + 8 * (int64_t)(v25 - v15 + v16));
                *v18 = *v18 - v12 * *(float64_t *)(8 * (int64_t)v16 + *v8);
                v19 = v16 + 1;
                v20 = *(int32_t *)&v4;
                v21 = v19 - v20;
                v16 = v19;
                v17 = v20;
                while (v21 < 0 != ((v21 ^ v19) & (v20 ^ v19)) < 0) {
                    // 0x100003d84
                    v26 = *v9;
                    v18 = (float64_t *)(v26 + 8 * (int64_t)(v25 - v20 + v16));
                    *v18 = *v18 - v12 * *(float64_t *)(8 * (int64_t)v16 + *v8);
                    v19 = v16 + 1;
                    v20 = *(int32_t *)&v4;
                    v21 = v19 - v20;
                    v16 = v19;
                    v17 = v20;
                }
            }
            // 0x100003de4
            v22 = v17;
            v23 = v25 - 1;
            v24 = v23 - v22;
            v7 = v9;
        }
    } else {
        // 0x100003cac
        v7 = (int64_t *)(v1 + 8);
    }
    int32_t v27 = (int32_t)v1 - 1; // 0x100003e10
    *(int32_t *)v1 = v27;
    while (*(float64_t *)(*v7 + (int64_t)(8 * v27)) == 0.0) {
        // 0x100003df8
        *(int32_t *)v1 = v27;
    }
    // 0x100003e3c
    return result;
}

// Address range: 0x100003e4c - 0x100003f54
int64_t entry_point(void) {
    // 0x100003e4c
    function_1000039e0();
    function_1000039e0();
    function_100003c60();
    _printf("poly: ");
    function_100003b70();
    _printf("div:  ");
    function_100003b70();
    _printf("quot: ");
    function_100003b70();
    _printf("rem:  ");
    function_100003b70();
    function_100003b40();
    function_100003b40();
    function_100003b40();
    function_100003b40();
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int64_t function_100003f54(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f54
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f60 - 0x100003f6c
void function_100003f60(int64_t * ptr) {
    // 0x100003f60
    _free(ptr);
}

// Address range: 0x100003f6c - 0x100003f78
int64_t * function_100003f6c(int32_t size) {
    // 0x100003f6c
    return _malloc(size);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>

void set_mode(int want_key)
{
	static struct termios old, new;
	if (!want_key) {
		tcsetattr(STDIN_FILENO, TCSANOW, &old);
		return;
	}

	tcgetattr(STDIN_FILENO, &old);
	new = old;
	new.c_lflag &= ~(ICANON);
	tcsetattr(STDIN_FILENO, TCSANOW, &new);
}

int get_key()
{
	int c = 0;
	fd_set fs;

	FD_ZERO(&fs);
	FD_SET(STDIN_FILENO, &fs);
	select(STDIN_FILENO + 1, &fs, 0, 0, 0);

	if (FD_ISSET(STDIN_FILENO, &fs)) {
		c = getchar();
		set_mode(0);
	}
	return c;
}

int main()
{
	int c = 0;
	while (c != 'n') {
		set_mode(1);

		/* flush pending input so we won't format the hardrive
		   because user accidentally typed 'y' before we even prompted */
		tcflush(STDIN_FILENO, TCIFLUSH);

		printf("Show this prompt again [Yes/No/Ignore you]? ");
		fflush(stdout);

		switch(c = tolower(get_key())) {
		case 'y':	putchar('\n');
				break;

		case 'n':	printf("\nDone\n");
				break;

		case 'i':	puts("\nI'll ignore keys for 5 seconds");
				sleep(5);
				putchar('\n');
				break;
		default:
				puts("\nAssume that was the cat.");
		}
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct termios {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char e4;
    char e5[1];
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b04(void);
int64_t function_100003b9c(void);
int64_t function_100003e90(int32_t a1, int64_t a2, int64_t a3);
int32_t function_100003e9c(struct _IO_FILE * stream);
int32_t function_100003ea8(void);
int64_t * function_100003eb4(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003ec0(int64_t * s, int32_t c, int32_t n);
int32_t function_100003ecc(char * format, ...);
int32_t function_100003ed8(int32_t c);
int32_t function_100003ee4(char * s);
int32_t function_100003ef0(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
int32_t function_100003efc(int32_t seconds);
int32_t function_100003f08(int32_t fd, int32_t queue_selector);
int32_t function_100003f14(int32_t fd, struct termios * termios_p);
int32_t function_100003f20(int32_t fd, int32_t optional_actions, struct termios * termios_p);
int32_t function_100003f2c(int32_t c);

// --------------------- Global Variables ---------------------

struct termios * g1 = NULL; // 0x100008000
struct termios * g2 = NULL; // 0x100008048
int64_t g3 = 0; // 0x100008060

// ------- Dynamically Linked Functions Without Header --------

int64_t ___darwin_check_fd_set_overflow(int32_t a1, int64_t a2, int64_t a3);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _getchar(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
int32_t _select(int32_t a1, struct _TYPEDEF_fd_set * a2, struct _TYPEDEF_fd_set * a3, struct _TYPEDEF_fd_set * a4, struct timeval * a5);
int32_t _tcflush(int32_t a1, int32_t a2);
int32_t _tcgetattr(int32_t a1, struct termios * a2);
int32_t _tcsetattr(int32_t a1, int32_t a2, struct termios * a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003b04 - 0x100003b9c
int64_t function_100003b04(void) {
    // 0x100003b04
    int32_t result; // 0x100003b04
    int64_t v1; // 0x100003b04
    if ((int32_t)v1 == 0) {
        // 0x100003b28
        result = _tcsetattr(0, 0, (struct termios *)&g1);
    } else {
        // 0x100003b40
        _tcgetattr(0, (struct termios *)&g1);
        _memcpy((int64_t *)&g2, (int64_t *)&g1, 72);
        g3 &= -257;
        result = _tcsetattr(0, 0, (struct termios *)&g2);
    }
    // 0x100003b90
    return result;
}

// Address range: 0x100003b9c - 0x100003d88
int64_t function_100003b9c(void) {
    // 0x100003b9c
    int64_t v1; // bp-80, 0x100003b9c
    int64_t v2 = &v1; // 0x100003bac
    int64_t v3 = *(int64_t *)0x100004000; // 0x100003bb4
    int64_t v4; // bp-212, 0x100003b9c
    int64_t v5 = &v4; // 0x100003bd0
    _memset(&v4, 0, 128);
    v1 = v5;
    *(int64_t *)(v2 + 48) = v5;
    if (v3 == 0) {
        goto lab_0x100003c44;
    } else {
        // 0x100003c08
        if ((int32_t)___darwin_check_fd_set_overflow(0, v5, 0) == 0) {
            goto lab_0x100003c88;
        } else {
            goto lab_0x100003c44;
        }
    }
  lab_0x100003c44:;
    int32_t * v6 = (int32_t *)v1; // 0x100003c78
    *v6 = *v6 | 1;
    goto lab_0x100003c88;
  lab_0x100003c88:
    // 0x100003c88
    _select(1, (struct _TYPEDEF_fd_set *)&v4, NULL, NULL, NULL);
    int64_t * v7 = (int64_t *)(v2 + 16); // 0x100003cb4
    *v7 = v5;
    *(int64_t *)(v2 + 32) = v5;
    if (v3 != 0) {
        // 0x100003cd0
        if ((int32_t)___darwin_check_fd_set_overflow(0, v5, 0) == 0) {
            // 0x100003d78
            return 0;
        }
    }
    int64_t result = 0; // 0x100003d5c
    if (*(int32_t *)*v7 % 2 != 0) {
        uint32_t v8 = _getchar(); // 0x100003d64
        function_100003b04();
        result = v8;
    }
    // 0x100003d78
    return result;
}

// Address range: 0x100003d88 - 0x100003e90
int64_t entry_point(void) {
    function_100003b04();
    _tcflush(0, 1);
    _printf("Show this prompt again [Yes/No/Ignore you]? ");
    _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008);
    int32_t v1 = _tolower((int32_t)function_100003b9c()); // 0x100003dec
    switch (v1) {
        case 105: {
            // 0x100003e4c
            _puts("\nI'll ignore keys for 5 seconds");
            _sleep(5);
            _putchar(10);
            // break -> 0x100003e7c
            break;
        }
        case 110: {
            // 0x100003e7c
            _printf("\nDone\n");
            // 0x100003e80
            return 0;
        }
        case 121: {
            // 0x100003e30
            _putchar(10);
            // break -> 0x100003e7c
            break;
        }
        default: {
            // 0x100003e6c
            _puts("\nAssume that was the cat.");
            // break -> 0x100003e7c
            break;
        }
    }
    while (v1 != 110) {
        // 0x100003db4
        function_100003b04();
        _tcflush(0, 1);
        _printf("Show this prompt again [Yes/No/Ignore you]? ");
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008);
        v1 = _tolower((int32_t)function_100003b9c());
        switch (v1) {
            case 105: {
                // 0x100003e4c
                _puts("\nI'll ignore keys for 5 seconds");
                _sleep(5);
                _putchar(10);
                // break -> 0x100003e7c
                break;
            }
            case 110: {
                // 0x100003e7c
                _printf("\nDone\n");
                // 0x100003e80
                return 0;
            }
            case 121: {
                // 0x100003e30
                _putchar(10);
                // break -> 0x100003e7c
                break;
            }
            default: {
                // 0x100003e6c
                _puts("\nAssume that was the cat.");
                // break -> 0x100003e7c
                break;
            }
        }
    }
    // 0x100003e80
    return 0;
}

// Address range: 0x100003e90 - 0x100003e9c
int64_t function_100003e90(int32_t a1, int64_t a2, int64_t a3) {
    // 0x100003e90
    return ___darwin_check_fd_set_overflow(a1, a2, a3);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(struct _IO_FILE * stream) {
    // 0x100003e9c
    return _fflush(stream);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(void) {
    // 0x100003ea8
    return _getchar();
}

// Address range: 0x100003eb4 - 0x100003ec0
int64_t * function_100003eb4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003eb4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ec0 - 0x100003ecc
int64_t * function_100003ec0(int64_t * s, int32_t c, int32_t n) {
    // 0x100003ec0
    return _memset(s, c, n);
}

// Address range: 0x100003ecc - 0x100003ed8
int32_t function_100003ecc(char * format, ...) {
    // 0x100003ecc
    return _printf(format);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(int32_t c) {
    // 0x100003ed8
    return _putchar(c);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(char * s) {
    // 0x100003ee4
    return _puts(s);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x100003ef0
    return _select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(int32_t seconds) {
    // 0x100003efc
    return _sleep(seconds);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(int32_t fd, int32_t queue_selector) {
    // 0x100003f08
    return _tcflush(fd, queue_selector);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(int32_t fd, struct termios * termios_p) {
    // 0x100003f14
    return _tcgetattr(fd, termios_p);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(int32_t fd, int32_t optional_actions, struct termios * termios_p) {
    // 0x100003f20
    return _tcsetattr(fd, optional_actions, termios_p);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t c) {
    // 0x100003f2c
    return _tolower(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include <stdio.h>

int pancake(int n) {
    int gap = 2, sum = 2, adj = -1;
    while (sum < n) {
        adj++;
        gap = gap * 2 - 1;
        sum += gap;
    }
    return n + adj;
}

int main() {
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 1; j < 6; j++) {
            int n = i * 5 + j;
            printf("p(%2d) = %2d  ", n, pancake(n));
        }
        printf("\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e28(void);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e28 - 0x100003ea4
int64_t function_100003e28(void) {
    // 0x100003e28
    int64_t v1; // 0x100003e28
    int32_t v2 = v1; // 0x100003e2c
    int32_t v3 = 2 - v2; // 0x100003e50
    int32_t v4 = -1; // 0x100003e58
    int32_t v5 = 2; // 0x100003e58
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e90
        return v2 - 1;
    }
    int32_t v6 = 2; // 0x100003e58
    v4++;
    v6 = 2 * v6 - 1;
    v5 += v6;
    int32_t v7 = v5 - v2; // 0x100003e50
    while (v7 < 0 != ((v7 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003e60
        v4++;
        v6 = 2 * v6 - 1;
        v5 += v6;
        v7 = v5 - v2;
    }
    // 0x100003e90
    return v4 + v2;
}

// Address range: 0x100003ea4 - 0x100003f80
int64_t entry_point(void) {
    for (int32_t i = 0; i < 4; i++) {
        for (int32_t j = 1; j < 6; j++) {
            // 0x100003ef0
            function_100003e28();
            int64_t v1; // 0x100003ea4
            _printf("p(%2d) = %2d  ", v1, v1);
        }
        // 0x100003f50
        _printf((char *)0x100003f9b);
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

const char * donuts[] = { "iced", "jam", "plain", "something completely different" };
long choose(int * got, int n_chosen, int len, int at, int max_types)
{
        int i;
        long count = 0;
        if (n_chosen == len) {
                if (!got) return 1;

                for (i = 0; i < len; i++)
                        printf("%s\t", donuts[got[i]]);
                printf("\n");
                return 1;
        }

        for (i = at; i < max_types; i++) {
                if (got) got[n_chosen] = i;
                count += choose(got, n_chosen + 1, len, i, max_types);
        }
        return count;
}

int main()
{
        int chosen[3];
        choose(chosen, 0, 2, 0, 3);

        printf("\nWere there ten donuts, we'd have had %ld choices of three\n",
                choose(0, 0, 3, 0, 10));
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d08(void);
int64_t function_100003f20(int64_t a1);
int32_t function_100003f2c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d08 - 0x100003e80
int64_t function_100003d08(void) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    int32_t v2 = v1; // 0x100003d18
    if (v2 == (int32_t)v1) {
        // 0x100003d44
        if (v1 == 0) {
            // 0x100003e70
            return 1;
        }
        int32_t v3 = -v2; // 0x100003d74
        if (v3 < 0 != (v3 & v2) < 0) {
            int32_t v4 = 0; // 0x100003db8
            _printf("%s\t", (char *)v1);
            v4++;
            while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
                // 0x100003d84
                _printf("%s\t", (char *)v1);
                v4++;
            }
        }
        // 0x100003dc4
        _printf("\n");
        // 0x100003e70
        return 1;
    }
    int32_t v5 = v1; // 0x100003d24
    int32_t v6 = v1; // 0x100003d20
    int32_t v7 = v6 - v5; // 0x100003df0
    if (v7 < 0 == ((v7 ^ v6) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003e70
        return 0;
    }
    int64_t result = 0; // 0x100003e48
    if (v1 != 0) {
        // 0x100003e14
        *(int32_t *)((0x100000000 * v1 >> 30) + v1) = v6;
    }
    // 0x100003e28
    result += function_100003d08();
    int32_t v8 = v6 + 1; // 0x100003e58
    int32_t v9 = v8 - v5; // 0x100003df0
    while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v5)) < 0) {
        int32_t v10 = v8;
        if (v1 != 0) {
            // 0x100003e14
            *(int32_t *)((0x100000000 * v1 >> 30) + v1) = v10;
        }
        // 0x100003e28
        result += function_100003d08();
        v8 = v10 + 1;
        v9 = v8 - v5;
    }
    // 0x100003e70
    return result;
}

// Address range: 0x100003e80 - 0x100003f20
int64_t entry_point(void) {
    // 0x100003e80
    function_100003d08();
    function_100003d08();
    int32_t v1 = _printf("\nWere there ten donuts, we'd have had %ld choices of three\n", 0); // 0x100003ee8
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ef8
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f0c
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f10
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int64_t a1) {
    // 0x100003f20
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <math.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int n;
    double **elems;
} SquareMatrix;

SquareMatrix init_square_matrix(int n, double elems[n][n]) {
    SquareMatrix A = {
        .n = n,
        .elems = malloc(n * sizeof(double *))
    };
    for(int i = 0; i < n; ++i) {
        A.elems[i] = malloc(n * sizeof(double));
        for(int j = 0; j < n; ++j)
            A.elems[i][j] = elems[i][j];
    }

    return A;
}

SquareMatrix copy_square_matrix(SquareMatrix src) {
    SquareMatrix dest;
    dest.n = src.n;
    dest.elems = malloc(dest.n * sizeof(double *));
    for(int i = 0; i < dest.n; ++i) {
        dest.elems[i] = malloc(dest.n * sizeof(double));
        for(int j = 0; j < dest.n; ++j)
            dest.elems[i][j] = src.elems[i][j];
    }

    return dest;
}

double det(SquareMatrix A) {
    double det = 1;

    for(int j = 0; j < A.n; ++j) {
        int i_max = j;
        for(int i = j; i < A.n; ++i)
            if(A.elems[i][j] > A.elems[i_max][j])
                i_max = i;

        if(i_max != j) {
            for(int k = 0; k < A.n; ++k) {
                double tmp = A.elems[i_max][k];
                A.elems[i_max][k] = A.elems[j][k];
                A.elems[j][k]     = tmp;
            }

            det *= -1;
        }

        if(abs(A.elems[j][j]) < 1e-12) {
            puts("Singular matrix!");
            return NAN;
        }

        for(int i = j + 1; i < A.n; ++i) {
            double mult = -A.elems[i][j] / A.elems[j][j];
            for(int k = 0; k < A.n; ++k)
                A.elems[i][k] += mult * A.elems[j][k];
        }
    }

    for(int i = 0; i < A.n; ++i)
        det *= A.elems[i][i];

    return det;
}

void deinit_square_matrix(SquareMatrix A) {
    for(int i = 0; i < A.n; ++i)
        free(A.elems[i]);
    free(A.elems);
}

double cramer_solve(SquareMatrix A, double det_A, double *b, int var) {
    SquareMatrix tmp = copy_square_matrix(A);
    for(int i = 0; i < tmp.n; ++i)
        tmp.elems[i][var] = b[i];

    double det_tmp = det(tmp);
    deinit_square_matrix(tmp);

    return det_tmp / det_A;
}

int main(int argc, char **argv) {
#define N 4
    double elems[N][N] = {
        { 2, -1,  5,  1},
        { 3,  2,  2, -6},
        { 1,  3,  3, -1},
        { 5, -2, -3,  3}
    };
    SquareMatrix A = init_square_matrix(N, elems);

    SquareMatrix tmp = copy_square_matrix(A);
    int det_A = det(tmp);
    deinit_square_matrix(tmp);

    double b[] = {-3, -32, -47, 49};

    for(int i = 0; i < N; ++i)
        printf("%7.3lf\n", cramer_solve(A, det_A, b, i));

    deinit_square_matrix(A);
    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036f8(void);
int64_t function_1000037f0(void);
int64_t function_1000038d8(void);
int64_t function_100003c04(void);
int64_t function_100003c70(void);
int64_t function_100003e7c(int64_t a1);
int32_t function_100003e88(int32_t x);
void function_100003e94(int64_t * ptr);
int64_t * function_100003ea0(int32_t size);
int64_t * function_100003eac(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003eb8(char * format, ...);
int32_t function_100003ec4(char * s);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0e-12; // 0x100003ed8
int64_t g2 = 0x4000000000000000; // 0x100003ee0
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _abs(int32_t a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000036f8 - 0x1000037f0
int64_t function_1000036f8(void) {
    // 0x1000036f8
    int64_t v1; // 0x1000036f8
    int32_t v2 = v1; // 0x100003704
    int32_t v3 = 8 * v2; // 0x100003724
    int64_t * v4 = _malloc(v3); // 0x100003724
    int32_t v5 = -v2;
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x1000037dc
        return 0x100000000 * v1 >> 32;
    }
    int32_t v6 = 1 - v2;
    int32_t v7 = 0; // 0x1000037d0
    int64_t * v8 = _malloc(v3); // 0x100003754
    int64_t v9 = v7; // 0x10000375c
    int64_t * v10 = (int64_t *)(8 * v9 + (int64_t)v4); // 0x100003760
    *v10 = (int64_t)v8;
    int64_t v11 = (8 * v1 & 0x7fffffff8) * v9 + v1; // 0x100003794
    *v8 = *(int64_t *)v11;
    int32_t v12 = 1; // 0x10000377c
    int64_t v13; // 0x10000379c
    int32_t v14; // 0x1000037bc
    int32_t v15; // 0x100003774
    if (v6 < 0 != (v6 & v2) < 0) {
        v13 = 8 * (int64_t)v12;
        *(int64_t *)(v13 + *v10) = *(int64_t *)(v11 + v13);
        v14 = v12 + 1;
        v15 = v14 - v2;
        v12 = v14;
        while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
            // 0x100003784
            v13 = 8 * (int64_t)v12;
            *(int64_t *)(v13 + *v10) = *(int64_t *)(v11 + v13);
            v14 = v12 + 1;
            v15 = v14 - v2;
            v12 = v14;
        }
    }
    // 0x1000037cc
    v7++;
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003784
        v8 = _malloc(v3);
        v9 = v7;
        v10 = (int64_t *)(8 * v9 + (int64_t)v4);
        *v10 = (int64_t)v8;
        v11 = (8 * v1 & 0x7fffffff8) * v9 + v1;
        *v8 = *(int64_t *)v11;
        v12 = 1;
        if (v6 < 0 != (v6 & v2) < 0) {
            v13 = 8 * (int64_t)v12;
            *(int64_t *)(v13 + *v10) = *(int64_t *)(v11 + v13);
            v14 = v12 + 1;
            v15 = v14 - v2;
            v12 = v14;
            while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
                // 0x100003784
                v13 = 8 * (int64_t)v12;
                *(int64_t *)(v13 + *v10) = *(int64_t *)(v11 + v13);
                v14 = v12 + 1;
                v15 = v14 - v2;
                v12 = v14;
            }
        }
        // 0x1000037cc
        v7++;
    }
    // 0x1000037dc
    return 0x100000000 * v1 >> 32;
}

// Address range: 0x1000037f0 - 0x1000038d8
int64_t function_1000037f0(void) {
    // 0x1000037f0
    int64_t v1; // 0x1000037f0
    int32_t v2 = v1; // 0x100003804
    int32_t v3 = 8 * v2; // 0x100003814
    int64_t * v4 = _malloc(v3); // 0x100003814
    int32_t v5 = -v2;
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x1000038c4
        return 0x100000000 * v1 >> 32;
    }
    int32_t v6 = 1 - v2;
    int32_t v7 = 0; // 0x1000038b8
    int64_t * v8 = _malloc(v3); // 0x100003844
    int64_t v9 = 8 * (int64_t)v7; // 0x100003850
    int64_t * v10 = (int64_t *)(v9 + (int64_t)v4); // 0x100003850
    *v10 = (int64_t)v8;
    int64_t * v11 = (int64_t *)(v9 + v1); // 0x10000387c
    *v8 = *(int64_t *)*v11;
    int32_t v12 = 1; // 0x10000386c
    int64_t v13; // 0x100003884
    int32_t v14; // 0x1000038a4
    int32_t v15; // 0x100003864
    if (v6 < 0 != (v6 & v2) < 0) {
        v13 = 8 * (int64_t)v12;
        *(int64_t *)(v13 + *v10) = *(int64_t *)(v13 + *v11);
        v14 = v12 + 1;
        v15 = v14 - v2;
        v12 = v14;
        while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
            // 0x100003874
            v13 = 8 * (int64_t)v12;
            *(int64_t *)(v13 + *v10) = *(int64_t *)(v13 + *v11);
            v14 = v12 + 1;
            v15 = v14 - v2;
            v12 = v14;
        }
    }
    // 0x1000038b4
    v7++;
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003874
        v8 = _malloc(v3);
        v9 = 8 * (int64_t)v7;
        v10 = (int64_t *)(v9 + (int64_t)v4);
        *v10 = (int64_t)v8;
        v11 = (int64_t *)(v9 + v1);
        *v8 = *(int64_t *)*v11;
        v12 = 1;
        if (v6 < 0 != (v6 & v2) < 0) {
            v13 = 8 * (int64_t)v12;
            *(int64_t *)(v13 + *v10) = *(int64_t *)(v13 + *v11);
            v14 = v12 + 1;
            v15 = v14 - v2;
            v12 = v14;
            while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
                // 0x100003874
                v13 = 8 * (int64_t)v12;
                *(int64_t *)(v13 + *v10) = *(int64_t *)(v13 + *v11);
                v14 = v12 + 1;
                v15 = v14 - v2;
                v12 = v14;
            }
        }
        // 0x1000038b4
        v7++;
    }
    // 0x1000038c4
    return 0x100000000 * v1 >> 32;
}

// Address range: 0x1000038d8 - 0x100003c04
int64_t function_1000038d8(void) {
    // 0x1000038d8
    int64_t v1; // 0x1000038d8
    int32_t v2 = v1; // 0x1000038e4
    int32_t v3 = -v2;
    int32_t v4 = 0; // 0x10000390c
    int64_t result; // 0x1000038d8
    if (v3 < 0 == (v3 & v2) < 0) {
      lab_0x100003b9c:;
        int32_t v5 = 0;
        int32_t v6 = v5 - v2; // 0x100003ba4
        int32_t v7 = v5 + 1; // 0x100003bac
        while (v6 < 0 != ((v6 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003b9c
            v5 = v7;
            v6 = v5 - v2;
            v7 = v5 + 1;
        }
        // 0x100003bf4
        return result;
    }
    while (true) {
      lab_0x100003928:;
        int32_t v8 = v4;
        int32_t v9 = v8 - v2; // 0x100003930
        int64_t v10 = 8 * (int64_t)v8;
        int32_t v11 = v8; // 0x100003938
        int32_t v12 = v8; // 0x100003938
        if (v9 < 0 != ((v9 ^ v8) & (v8 ^ v2)) < 0) {
            int64_t v13 = *(int64_t *)(8 * (int64_t)v11 + v1); // 0x100003948
            float64_t v14 = *(float64_t *)(v13 + v10); // 0x100003950
            int64_t v15 = *(int64_t *)(8 * (int64_t)v12 + v1); // 0x10000395c
            float64_t v16 = *(float64_t *)(v15 + v10); // 0x100003964
            bool v17 = false; // 0x100003968
            bool v18 = true; // 0x100003968
            bool v19 = false; // 0x100003968
            if (v14 != v16) {
                v17 = v14 > v16;
                v18 = false;
                v19 = v14 >= v16 == v14 <= v16;
            }
            int32_t v20 = v18 | v17 != v19 ? v12 : v11;
            int32_t v21 = v11 + 1; // 0x10000398c
            int32_t v22 = v21 - v2; // 0x100003930
            v11 = v21;
            v12 = v20;
            while (v22 < 0 != ((v22 ^ v21) & (v21 ^ v2)) < 0) {
                // 0x100003940
                v13 = *(int64_t *)(8 * (int64_t)v11 + v1);
                v14 = *(float64_t *)(v13 + v10);
                v15 = *(int64_t *)(8 * (int64_t)v12 + v1);
                v16 = *(float64_t *)(v15 + v10);
                v17 = false;
                v18 = true;
                v19 = false;
                if (v14 != v16) {
                    v17 = v14 > v16;
                    v18 = false;
                    v19 = v14 >= v16 == v14 <= v16;
                }
                // 0x100003988
                v20 = v18 | v17 != v19 ? v12 : v11;
                v21 = v11 + 1;
                v22 = v21 - v2;
                v11 = v21;
                v12 = v20;
            }
            if (v20 != v8) {
                int64_t * v23 = (int64_t *)(v10 + v1); // 0x1000039f0
                int32_t v24 = 0; // 0x100003a30
                int64_t v25 = 8 * (int64_t)v24; // 0x1000039e0
                int64_t * v26 = (int64_t *)(v25 + *(int64_t *)(8 * (int64_t)v20 + v1));
                *v26 = *(int64_t *)(*v23 + v25);
                *(int64_t *)(*v23 + v25) = *v26;
                v24++;
                while (v24 - v2 < 0 != ((v24 - v2 ^ v24) & (v24 ^ v2)) < 0) {
                    // 0x1000039d0
                    v25 = 8 * (int64_t)v24;
                    v26 = (int64_t *)(v25 + *(int64_t *)(8 * (int64_t)v20 + v1));
                    *v26 = *(int64_t *)(*v23 + v25);
                    *(int64_t *)(*v23 + v25) = *v26;
                    v24++;
                }
            }
        }
        int64_t * v27 = (int64_t *)(v10 + v1); // 0x100003a58
        int32_t v28 = _abs((int32_t)*(float64_t *)(*v27 + v10)); // 0x100003a68
        if (g1 < (float64_t)v28) {
            // break -> 0x100003a88
            break;
        }
        // 0x100003ab4
        v4 = v8 + 1;
        int32_t v29 = v4 - v2;
        int32_t v30 = v4; // 0x100003ac4
        if (v29 < 0 != ((v29 ^ v4) & (v4 ^ v2)) < 0) {
            while (true) {
              lab_0x100003b20:;
                int64_t * v31 = (int64_t *)(8 * (int64_t)v30 + v1); // 0x100003ad4
                int64_t v32 = *v31; // 0x100003ad4
                int64_t v33 = *v27; // 0x100003aec
                float64_t v34 = -*(float64_t *)(v32 + v10) / *(float64_t *)(v33 + v10); // 0x100003af8
                int32_t v35 = 0; // 0x100003b60
                int64_t v36 = 8 * (int64_t)v35; // 0x100003b34
                float64_t * v37 = (float64_t *)(v36 + v32); // 0x100003b4c
                *v37 = v34 * *(float64_t *)(v36 + v33) + *v37;
                v35++;
                while (v35 - v2 < 0 != ((v35 - v2 ^ v35) & (v35 ^ v2)) < 0) {
                    // 0x100003b20
                    v36 = 8 * (int64_t)v35;
                    v37 = (float64_t *)(v36 + *v31);
                    *v37 = v34 * *(float64_t *)(v36 + *v27) + *v37;
                    v35++;
                }
                int32_t v38 = v30 + 1;
                int32_t v39 = v38 - v2; // 0x100003abc
                v30 = v38;
                if (v39 < 0 == ((v39 ^ v38) & (v38 ^ v2)) < 0) {
                    goto lab_0x100003928;
                } else {
                    goto lab_0x100003b20;
                }
            }
        }
        // 0x1000038fc
        result = v28;
        goto lab_0x100003b9c;
    }
    // 0x100003bf4
    return _puts("Singular matrix!");
}

// Address range: 0x100003c04 - 0x100003c70
int64_t function_100003c04(void) {
    // 0x100003c04
    int64_t v1; // 0x100003c04
    int32_t v2 = v1; // 0x100003c10
    int32_t v3 = -v2; // 0x100003c28
    int32_t v4 = 0; // 0x100003c30
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003c5c
        _free((int64_t *)v1);
        return &g3;
    }
    _free((int64_t *)*(int64_t *)(8 * (int64_t)v4 + v1));
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003c38
        _free((int64_t *)*(int64_t *)(8 * (int64_t)v4 + v1));
        v4++;
    }
    // 0x100003c5c
    _free((int64_t *)v1);
    return &g3;
}

// Address range: 0x100003c70 - 0x100003d2c
int64_t function_100003c70(void) {
    int32_t v1 = function_1000037f0(); // 0x100003c9c
    int32_t v2 = -v1; // 0x100003cb4
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003cf8
        function_1000038d8();
        return function_100003c04();
    }
    // 0x100003cc4
    int64_t v3; // 0x100003c70
    int64_t v4 = 0x100000000 * v3 >> 29; // 0x100003ce0
    int32_t v5 = 0; // 0x100003cec
    int64_t v6 = 8 * (int64_t)v5; // 0x100003ccc
    *(int64_t *)(*(int64_t *)(v6 + v3) + v4) = *(int64_t *)(v6 + v3);
    v5++;
    while (v5 - v1 < 0 != ((v5 - v1 ^ v5) & (v5 ^ v1)) < 0) {
        // 0x100003cc4
        v6 = 8 * (int64_t)v5;
        *(int64_t *)(*(int64_t *)(v6 + v3) + v4) = *(int64_t *)(v6 + v3);
        v5++;
    }
    // 0x100003cf8
    function_1000038d8();
    return function_100003c04();
}

// Address range: 0x100003d2c - 0x100003e7c
int64_t entry_point(void) {
    // 0x100003d2c
    int64_t v1; // bp-168, 0x100003d2c
    _memcpy(&v1, &g2, 128);
    function_1000036f8();
    function_1000037f0();
    function_1000038d8();
    function_100003c04();
    for (int32_t i = 0; i < 4; i++) {
        int128_t v2 = __asm_sshll(0.0f, 0); // 0x100003df4
        function_100003c70();
        _printf("%7.3lf\n", (float64_t)(int64_t)v2);
    }
    int64_t v3 = function_100003c04(); // 0x100003e40
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e50
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e64
        ___stack_chk_fail(v3);
    }
    // 0x100003e68
    return 0;
}

// Address range: 0x100003e7c - 0x100003e88
int64_t function_100003e7c(int64_t a1) {
    // 0x100003e7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(int32_t x) {
    // 0x100003e88
    return _abs(x);
}

// Address range: 0x100003e94 - 0x100003ea0
void function_100003e94(int64_t * ptr) {
    // 0x100003e94
    _free(ptr);
}

// Address range: 0x100003ea0 - 0x100003eac
int64_t * function_100003ea0(int32_t size) {
    // 0x100003ea0
    return _malloc(size);
}

// Address range: 0x100003eac - 0x100003eb8
int64_t * function_100003eac(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003eac
    return _memcpy(dest, src, n);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(char * format, ...) {
    // 0x100003eb8
    return _printf(format);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(char * s) {
    // 0x100003ec4
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <wchar.h>

const char *sa = "abcdef";
const char *su = "as⃝df̅"; /* Should be in your native locale encoding. Mine is UTF-8 */

int is_comb(wchar_t c)
{
	if (c >= 0x300 && c <= 0x36f) return 1;
	if (c >= 0x1dc0 && c <= 0x1dff) return 1;
	if (c >= 0x20d0 && c <= 0x20ff) return 1;
	if (c >= 0xfe20 && c <= 0xfe2f) return 1;
	return 0;
}

wchar_t* mb_to_wchar(const char *s)
{
	wchar_t *u;
	size_t len = mbstowcs(0, s, 0) + 1;
	if (!len) return 0;

	u = malloc(sizeof(wchar_t) * len);
	mbstowcs(u, s, len);
	return u;
}

wchar_t* ws_reverse(const wchar_t* u)
{
	size_t len, i, j;
	wchar_t *out;
	for (len = 0; u[len]; len++);
	out = malloc(sizeof(wchar_t) * (len + 1));
	out[len] = 0;
	j = 0;
	while (len) {
		for (i = len - 1; i && is_comb(u[i]); i--);
		wcsncpy(out + j, u + i, len - i);
		j += len - i;
		len = i;
	}
	return out;
}

char *mb_reverse(const char *in)
{
	size_t len;
	char *out;
	wchar_t *u = mb_to_wchar(in);
	wchar_t *r = ws_reverse(u);
	len = wcstombs(0, r, 0) + 1;
	out = malloc(len);
	wcstombs(out, r, len);
	free(u);
	free(r);
	return out;
}

int main(void)
{
	setlocale(LC_CTYPE, "");

	printf("%s => %s\n", sa, mb_reverse(sa));
	printf("%s => %s\n", su, mb_reverse(su));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b3c(void);
int64_t function_100003c40(void);
int64_t function_100003cc4(void);
int64_t function_100003e18(void);
void function_100003f30(int64_t * ptr);
int64_t * function_100003f3c(int32_t size);
int32_t function_100003f48(int16_t * pwcs, char * s, int32_t n);
int32_t function_100003f54(char * format, ...);
char * function_100003f60(int32_t category, char * locale);
int16_t * function_100003f6c(int16_t * dest, int16_t * src, int32_t n);
int32_t function_100003f78(char * s, int16_t * pwcs, int32_t n);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f95

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _mbstowcs(int16_t * a1, char * a2, int32_t a3);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);
int16_t * _wcsncpy(int16_t * a1, int16_t * a2, int32_t a3);
int32_t _wcstombs(char * a1, int16_t * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003b3c - 0x100003c40
int64_t function_100003b3c(void) {
    // 0x100003b3c
    int64_t v1; // 0x100003b3c
    int32_t v2 = v1; // 0x100003b40
    if (v2 < 768 == (767 - v2 & v2) < 0) {
        int32_t v3 = v2 - 879; // 0x100003b5c
        if (v3 == 0 || v3 < 0 != (878 - v2 & v2) < 0) {
            // 0x100003c34
            return 1;
        }
    }
    if (v2 < 0x1dc0 == (0x1dbf - v2 & v2) < 0) {
        int32_t v4 = v2 - 0x1dff; // 0x100003b98
        if (v4 == 0 || v4 < 0 != (0x1dfe - v2 & v2) < 0) {
            // 0x100003c34
            return 1;
        }
    }
    if (v2 < 0x20d0 == (0x20cf - v2 & v2) < 0) {
        int32_t v5 = v2 - 0x20ff; // 0x100003bd4
        if (v5 == 0 || v5 < 0 != (0x20fe - v2 & v2) < 0) {
            // 0x100003c34
            return 1;
        }
    }
    if (v2 < 0xfe20 == (0xfe1f - v2 & v2) < 0) {
        int32_t v6 = v2 - 0xfe2f; // 0x100003c10
        if (v6 == 0 || v6 < 0 != (0xfe2e - v2 & v2) < 0) {
            // 0x100003c34
            return 1;
        }
    }
    // 0x100003c34
    return 0;
}

// Address range: 0x100003c40 - 0x100003cc4
int64_t function_100003c40(void) {
    // 0x100003c40
    int64_t v1; // 0x100003c40
    char * v2 = (char *)v1; // 0x100003c4c
    int32_t v3 = _mbstowcs(NULL, v2, 0) + 1; // 0x100003c60
    int64_t result = 0; // 0x100003c74
    if (v3 != 0) {
        int64_t * v4 = _malloc(4 * v3); // 0x100003c90
        _mbstowcs((int16_t *)v4, v2, v3);
        result = (int64_t)v4;
    }
    // 0x100003cb4
    return result;
}

// Address range: 0x100003cc4 - 0x100003e18
int64_t function_100003cc4(void) {
    int64_t v1 = 0;
    int64_t v2 = 4 * v1; // 0x100003ce4
    int64_t v3 = v1 + 1; // 0x100003cf0
    int64_t v4; // 0x100003cc4
    while (*(int32_t *)(v2 + v4) != 0) {
        // 0x100003cdc
        v1 = v3;
        v2 = 4 * v1;
        v3 = v1 + 1;
    }
    int64_t result = (int64_t)_malloc(4 * (int32_t)v1 + 4); // 0x100003d1c
    *(int32_t *)(v2 + result) = 0;
    int64_t v5 = 0; // 0x100003d48
    if (v1 == 0) {
        // 0x100003e08
        return result;
    }
    int64_t v6 = v1 - 1;
    bool v7 = true; // 0x100003d74
    int64_t v8; // 0x100003cc4
    while (v6 != 0) {
        // 0x100003d9c
        v8 = v6;
        v7 = false;
        if ((int32_t)function_100003b3c() == 0) {
            // break -> 0x100003dbc
            break;
        }
        v6 = v8 - 1;
        v7 = true;
    }
    int64_t v9 = v1 - v6; // 0x100003ddc
    _wcsncpy((int16_t *)(4 * v5 + result), (int16_t *)(4 * v6 + v4), (int32_t)v9);
    v5 += v9;
    while (!v7) {
        int64_t v10 = v6;
        v6 = v10 - 1;
        v7 = true;
        while (v6 != 0) {
            // 0x100003d9c
            v8 = v6;
            v7 = false;
            if ((int32_t)function_100003b3c() == 0) {
                // break -> 0x100003dbc
                break;
            }
            v6 = v8 - 1;
            v7 = true;
        }
        // 0x100003dbc
        v9 = v10 - v6;
        _wcsncpy((int16_t *)(4 * v5 + result), (int16_t *)(4 * v6 + v4), (int32_t)v9);
        v5 += v9;
    }
    // 0x100003e08
    return result;
}

// Address range: 0x100003e18 - 0x100003e94
int64_t function_100003e18(void) {
    int64_t v1 = function_100003c40(); // 0x100003e2c
    int64_t v2 = function_100003cc4(); // 0x100003e38
    int16_t * v3 = (int16_t *)v2; // 0x100003e4c
    int32_t v4 = _wcstombs(NULL, v3, 0) + 1; // 0x100003e50
    int64_t * v5 = _malloc(v4); // 0x100003e5c
    _wcstombs((char *)v5, v3, v4);
    _free((int64_t *)v1);
    _free((int64_t *)v2);
    return (int64_t)v5;
}

// Address range: 0x100003e94 - 0x100003f30
int64_t entry_point(void) {
    // 0x100003e94
    _setlocale(2, (char *)&g1);
    function_100003e18();
    int64_t v1; // 0x100003e94
    char * v2 = (char *)v1; // 0x100003eec
    _printf("%s => %s\n", (char *)&g1, v2);
    function_100003e18();
    _printf("%s => %s\n", (char *)&g1, v2);
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
void function_100003f30(int64_t * ptr) {
    // 0x100003f30
    _free(ptr);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int32_t size) {
    // 0x100003f3c
    return _malloc(size);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int16_t * pwcs, char * s, int32_t n) {
    // 0x100003f48
    return _mbstowcs(pwcs, s, n);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// Address range: 0x100003f60 - 0x100003f6c
char * function_100003f60(int32_t category, char * locale) {
    // 0x100003f60
    return _setlocale(category, locale);
}

// Address range: 0x100003f6c - 0x100003f78
int16_t * function_100003f6c(int16_t * dest, int16_t * src, int32_t n) {
    // 0x100003f6c
    return _wcsncpy(dest, src, n);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * s, int16_t * pwcs, int32_t n) {
    // 0x100003f78
    return _wcstombs(s, pwcs, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <sys/stat.h>
#include <stdio.h>
#include <time.h>
#include <utime.h>

const char *filename = "input.txt";

int main() {
  struct stat foo;
  time_t mtime;
  struct utimbuf new_times;

  if (stat(filename, &foo) < 0) {
    perror(filename);
    return 1;
  }
  mtime = foo.st_mtime; /* seconds since the epoch */

  new_times.actime = foo.st_atime; /* keep atime unchanged */
  new_times.modtime = time(NULL);    /* set mtime to current time */
  if (utime(filename, &new_times) < 0) {
    perror(filename);
    return 1;
  }

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct utimbuf {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
void function_100003f6c(char * s);
int32_t function_100003f78(char * file, struct stat * buf);
int32_t function_100003f84(int32_t * timer);
int32_t function_100003f90(char * file, struct utimbuf * file_times);

// --------------------- Global Variables ---------------------

char * g1 = "\x9c?"; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

void _perror(char * a1);
int32_t _stat(char * a1, struct stat * a2);
int32_t _time(int32_t * a1);
int32_t _utime(char * a1, struct utimbuf * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003eb0 - 0x100003f6c
int64_t entry_point(void) {
    // 0x100003eb0
    int64_t v1; // bp-168, 0x100003eb0
    if (_stat(g1, (struct stat *)&v1) < 0) {
        // 0x100003ee0
        _perror(g1);
        // 0x100003f5c
        return 1;
    }
    // 0x100003ef8
    _time(NULL);
    int64_t v2; // bp-192, 0x100003eb0
    int32_t v3 = _utime(g1, (struct utimbuf *)&v2); // 0x100003f28
    int64_t result = 0; // 0x100003f34
    if (v3 < 0) {
        // 0x100003f3c
        _perror(g1);
        result = 1;
    }
    // 0x100003f5c
    return result;
}

// Address range: 0x100003f6c - 0x100003f78
void function_100003f6c(char * s) {
    // 0x100003f6c
    _perror(s);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * file, struct stat * buf) {
    // 0x100003f78
    return _stat(file, buf);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(int32_t * timer) {
    // 0x100003f84
    return _time(timer);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * file, struct utimbuf * file_times) {
    // 0x100003f90
    return _utime(file, file_times);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`// Input file: input.txt
// Output file: output.txt
#include <stdio.h>
int main()
{
   freopen("input.txt", "rt", stdin);
   freopen("output.txt", "wt", stdout);
   int a, b;
   scanf("%d%d", &a, &b);
   printf("%d\n", a + b);
   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
struct _IO_FILE * function_100003f60(char * filename, char * modes, struct _IO_FILE * stream);
int32_t function_100003f6c(char * format, ...);
int32_t function_100003f78(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

struct _IO_FILE * _freopen(char * a1, char * a2, struct _IO_FILE * a3);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003eb4 - 0x100003f60
int64_t entry_point(void) {
    // 0x100003eb4
    _freopen("input.txt", "rt", (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ef4
    _freopen("output.txt", "wt", (struct _IO_FILE *)v1);
    _scanf("%d%d", (int64_t *)"wt", (int64_t *)v1);
    _printf("%d\n", (int64_t)"wt");
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
struct _IO_FILE * function_100003f60(char * filename, char * modes, struct _IO_FILE * stream) {
    // 0x100003f60
    return _freopen(filename, modes, stream);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
//~ Take a number n and return a function that takes a number i
#define ACCUMULATOR(name,n) __typeof__(n) name (__typeof__(n) i) { \
    static __typeof__(n) _n=n; LOGIC; }
//~ have it return n incremented by the accumulation of i
#define LOGIC return _n+=i
ACCUMULATOR(x,1.0)
ACCUMULATOR(y,3)
ACCUMULATOR(z,'a')
#undef LOGIC
int main (void) {
    printf ("%f\n", x(5));   /* 6.000000 */
    printf ("%f\n", x(2.3)); /* 8.300000 */
    printf ("%i\n", y(5.0)); /* 8 */
    printf ("%i\n", y(3.3)); /* 11 */
    printf ("%c\n", z(5));   /* f */
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e44(void);
int64_t function_100003e68(void);
int64_t function_100003e8c(void);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t * g1 = (float64_t *)0x3ff0000000000000; // 0x100008000
int32_t g2 = 3; // 0x100008008
int64_t g3; // 0x10000800c

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e44 - 0x100003e68
int64_t function_100003e44(void) {
    // 0x100003e44
    float64_t v1; // 0x100003e44
    *(float64_t *)&g1 = v1 + (float64_t)(int64_t)g1;
    int64_t result; // 0x100003e44
    return result;
}

// Address range: 0x100003e68 - 0x100003e8c
int64_t function_100003e68(void) {
    // 0x100003e68
    int64_t v1; // 0x100003e68
    int32_t result = g2 + (int32_t)v1; // 0x100003e7c
    g2 = result;
    return result;
}

// Address range: 0x100003e8c - 0x100003eb0
int64_t function_100003e8c(void) {
    // 0x100003e8c
    int64_t v1; // 0x100003e8c
    uint32_t result = *(int32_t *)((int64_t)&g1 + 12) + (int32_t)v1; // 0x100003ea0
    *(int32_t *)&g3 = result;
    return result;
}

// Address range: 0x100003eb0 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003eb0
    function_100003e44();
    int128_t v1; // 0x100003eb0
    _printf("%f\n", (float64_t)(int64_t)v1);
    function_100003e44();
    _printf("%f\n", (float64_t)(int64_t)v1);
    function_100003e68();
    int64_t v2; // 0x100003eb0
    _printf("%i\n", v2);
    function_100003e68();
    _printf("%i\n", v2);
    function_100003e8c();
    _printf("%c\n", (char)v2);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <time.h>

int main() {
    int i, j, ms = 250;
    const char *a = "|/-\\";
    time_t start, now;
    struct timespec delay;
    delay.tv_sec = 0;
    delay.tv_nsec = ms * 1000000L;
    printf("\033[?25l");  // hide the cursor
    time(&start);
    while(1) {
        for (i = 0; i < 4; i++) {
            printf("\033[2J");          // clear terminal
            printf("\033[0;0H");        // place cursor at top left corner
            for (j = 0; j < 80; j++) {  // 80 character terminal width, say
                printf("%c", a[i]);
            }
            fflush(stdout);
            nanosleep(&delay, NULL);
        }
        // stop after 20 seconds, say
        time(&now);
        if (difftime(now, start) >= 20) break;
    }
    printf("\033[?25h"); // restore the cursor
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct timespec {
    int64_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f48(int32_t time1, int32_t time0);
int32_t function_100003f54(struct _IO_FILE * stream);
int32_t function_100003f60(struct timespec * requested_time, struct timespec * remaining);
int32_t function_100003f6c(char * format, ...);
int32_t function_100003f78(int32_t * timer);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[?25l"; // 0x100003f89
char * g2 = "\x1b[2J"; // 0x100003f90
char * g3 = "\x1b[0;0H"; // 0x100003f95

// ------- Dynamically Linked Functions Without Header --------

float64_t _difftime(int32_t a1, int32_t a2);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _nanosleep(struct timespec * a1, struct timespec * a2);
int32_t _printf(char * a1, ...);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003df0 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003df0
    float64_t v1; // 0x100003df0
    float64_t v2 = v1;
    int64_t v3 = 0; // bp-72, 0x100003e14
    _printf((char *)&g1);
    int32_t v4; // bp-48, 0x100003df0
    _time(&v4);
    int32_t v5 = 0; // 0x100003ef0
    _printf((char *)&g2);
    _printf((char *)&g3);
    for (int32_t i = 0; i < 80; i++) {
        // 0x100003e94
        int64_t v6; // 0x100003df0
        _printf("%c", (char)v6);
    }
    // 0x100003ecc
    _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
    _nanosleep((struct timespec *)&v3, NULL);
    v5++;
    int64_t v7 = 0; // 0x100003e58
    while (v5 != 4) {
        // 0x100003e60
        _printf((char *)&g2);
        _printf((char *)&g3);
        for (int32_t i = 0; i < 80; i++) {
            // 0x100003e94
            _printf("%c", (char)v7);
        }
        // 0x100003ecc
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
        _nanosleep((struct timespec *)&v3, NULL);
        v5++;
        v7 = 0;
    }
    // 0x100003efc
    int32_t v8; // bp-56, 0x100003df0
    _time(&v8);
    _difftime(v8, v4);
    while (v2 != 20.0) {
        // 0x100003e44
        if (v2 > 20.0 == v2 >= 20.0 == v2 <= 20.0) {
            // break -> 0x100003f2c
            break;
        }
        v5 = 0;
        _printf((char *)&g2);
        _printf((char *)&g3);
        for (int32_t i = 0; i < 80; i++) {
            // 0x100003e94
            _printf("%c", (char)(int64_t)v4);
        }
        // 0x100003ecc
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
        _nanosleep((struct timespec *)&v3, NULL);
        v5++;
        v7 = 0;
        while (v5 != 4) {
            // 0x100003e60
            _printf((char *)&g2);
            _printf((char *)&g3);
            for (int32_t i = 0; i < 80; i++) {
                // 0x100003e94
                _printf("%c", (char)v7);
            }
            // 0x100003ecc
            _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
            _nanosleep((struct timespec *)&v3, NULL);
            v5++;
            v7 = 0;
        }
        // 0x100003efc
        _time(&v8);
        _difftime(v8, v4);
    }
    // 0x100003f2c
    _printf((char *)0x100003f9f);
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
float64_t function_100003f48(int32_t time1, int32_t time0) {
    // 0x100003f48
    return _difftime(time1, time0);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(struct _IO_FILE * stream) {
    // 0x100003f54
    return _fflush(stream);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(struct timespec * requested_time, struct timespec * remaining) {
    // 0x100003f60
    return _nanosleep(requested_time, remaining);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int32_t * timer) {
    // 0x100003f78
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

typedef struct genome{
    char* strand;
    int length;
    struct genome* next;
}genome;

genome* genomeData;
int totalLength = 0, Adenine = 0, Cytosine = 0, Guanine = 0, Thymine = 0;

int numDigits(int num){
    int len = 1;

    while(num>10){
        num = num/10;
        len++;
    }

    return len;
}

void buildGenome(char str[100]){
    int len = strlen(str),i;
    genome *genomeIterator, *newGenome;

    totalLength += len;

    for(i=0;i<len;i++){
        switch(str[i]){
            case 'A': Adenine++;
                break;
            case 'T': Thymine++;
                break;
            case 'C': Cytosine++;
                break;
            case 'G': Guanine++;
                break;
        };
    }

    if(genomeData==NULL){
        genomeData = (genome*)malloc(sizeof(genome));

        genomeData->strand = (char*)malloc(len*sizeof(char));
        strcpy(genomeData->strand,str);
        genomeData->length = len;

        genomeData->next = NULL;
    }

    else{
        genomeIterator = genomeData;

        while(genomeIterator->next!=NULL)
            genomeIterator = genomeIterator->next;

        newGenome = (genome*)malloc(sizeof(genome));

        newGenome->strand = (char*)malloc(len*sizeof(char));
        strcpy(newGenome->strand,str);
        newGenome->length = len;

        newGenome->next = NULL;
        genomeIterator->next = newGenome;
    }
}

void printGenome(){
    genome* genomeIterator = genomeData;

    int width = numDigits(totalLength), len = 0;

    printf("Sequence:\n");

    while(genomeIterator!=NULL){
        printf("\n%*d%3s%3s",width+1,len,":",genomeIterator->strand);
        len += genomeIterator->length;

        genomeIterator = genomeIterator->next;
    }

    printf("\n\nBase Count\n----------\n\n");

    printf("%3c%3s%*d\n",'A',":",width+1,Adenine);
    printf("%3c%3s%*d\n",'T',":",width+1,Thymine);
    printf("%3c%3s%*d\n",'C',":",width+1,Cytosine);
    printf("%3c%3s%*d\n",'G',":",width+1,Guanine);
    printf("\n%3s%*d\n","Total:",width+1,Adenine + Thymine + Cytosine + Guanine);

    free(genomeData);
}

int main(int argc,char** argv)
{
    char str[100];
    int counter = 0, len;

    if(argc!=2){
        printf("Usage : %s <Gene file name>\n",argv[0]);
        return 0;
    }

    FILE *fp = fopen(argv[1],"r");

    while(fscanf(fp,"%s",str)!=EOF)
        buildGenome(str);
    fclose(fp);

    printGenome();

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038a8(void);
int64_t function_1000038fc(void);
int64_t function_100003b60(void);
int64_t function_100003ebc(int64_t a1);
int64_t function_100003ec8(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003ed4(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ee0(char * filename, char * modes);
void function_100003eec(int64_t * ptr);
int32_t function_100003ef8(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f04(int32_t size);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(char * s);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200085; // 0x100008018
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038a8 - 0x1000038fc
int64_t function_1000038a8(void) {
    // 0x1000038a8
    int64_t v1; // 0x1000038a8
    int32_t v2 = v1; // 0x1000038ac
    int32_t v3 = v2 - 10; // 0x1000038c0
    int32_t result = 1; // 0x1000038c8
    if (v3 == 0 || v3 < 0 != (9 - v2 & v2) < 0) {
        // 0x1000038f0
        return 1;
    }
    int32_t v4 = v2; // 0x1000038c8
    v4 /= 10;
    result++;
    while (v4 != 10 && v4 < 10 == (9 - v4 & v4) < 0) {
        // 0x1000038d0
        v4 /= 10;
        result++;
    }
    // 0x1000038f0
    return result;
}

// Address range: 0x1000038fc - 0x100003b10
int64_t function_1000038fc(void) {
    // 0x1000038fc
    int64_t v1; // 0x1000038fc
    int32_t result = _strlen((char *)v1); // 0x100003910
    *(int32_t *)&g1 = *(int32_t *)&g1 + result;
    int32_t v2 = -result; // 0x100003940
    int32_t v3 = 0; // 0x100003948
    if (v2 < 0 != (result & v2) < 0) {
        uint64_t v4 = (int64_t)*(char *)(v1 + (int64_t)v3) + 0xffffffbf & 0xffffffff; // 0x100003960
        while (v4 >= 19 == (v4 != 19)) {
            // 0x100003938
            v3++;
            int32_t v5 = v3 - result; // 0x100003940
            if (v5 < 0 == ((v5 ^ v3) & (v3 ^ result)) < 0) {
                goto lab_0x1000039f4;
            }
            v4 = (int64_t)*(char *)(v1 + (int64_t)v3) + 0xffffffbf & 0xffffffff;
        }
        // 0x100003974
        return result;
    }
  lab_0x1000039f4:;
    int64_t v6 = g2; // 0x100003a08
    if (g2 == 0) {
        // 0x100003a10
        g2 = (int64_t)_malloc(24);
        *(int64_t *)g2 = (int64_t)_malloc(result);
        int64_t result2 = ___strcpy_chk(*(int64_t *)g2, v1, -1); // 0x100003a50
        *(int32_t *)(g2 + 8) = result;
        *(int64_t *)(g2 + 16) = 0;
        // 0x100003974
        return result2;
    }
    int64_t * v7 = (int64_t *)(v6 + 16);
    int64_t v8 = *v7; // 0x100003a88
    while (v8 != 0) {
        // 0x100003a84
        v7 = (int64_t *)(v8 + 16);
        v8 = *v7;
    }
    int64_t * v9 = _malloc(24); // 0x100003ab0
    int64_t v10 = (int64_t)v9; // 0x100003ab0
    int64_t v11 = (int64_t)_malloc(result); // 0x100003ac0
    *v9 = v11;
    int64_t result3 = ___strcpy_chk(v11, v1, -1); // 0x100003adc
    *(int32_t *)(v10 + 8) = result;
    *(int64_t *)(v10 + 16) = 0;
    *v7 = v10;
    // 0x100003974
    return result3;
}

// Address range: 0x100003b60 - 0x100003db4
int64_t function_100003b60(void) {
    // 0x100003b60
    function_1000038a8();
    _printf("Sequence:\n");
    int64_t v1; // 0x100003b60
    if (g2 != 0) {
        int64_t v2 = g2; // 0x100003c10
        _printf("\n%*d%3s%3s", v1, v1, (char *)v1, (char *)v1);
        v2 += 16;
        while (v2 != 0) {
            // 0x100003bb4
            _printf("\n%*d%3s%3s", v1, v1, (char *)v1, (char *)v1);
            v2 += 16;
        }
    }
    // 0x100003c1c
    _printf("\n\nBase Count\n----------\n\n");
    char v3 = v1; // 0x100003c74
    char * v4 = (char *)v1; // 0x100003c74
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("\n%3s%*d\n", (char *)v1, v1, v1);
    _free((int64_t *)g2);
    return &g3;
}

// Address range: 0x100003db4 - 0x100003ebc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc8
    int64_t v2; // 0x100003db4
    int64_t v3; // 0x100003db4
    if ((int32_t)v3 == 2) {
        struct _IO_FILE * v4 = _fopen((char *)*(int64_t *)(v3 + 8), (char *)0x100003f92); // 0x100003e28
        char ** v5 = (char **)v3; // 0x100003e4c
        if (_fscanf(v4, "%s", v5) != -1) {
            function_1000038fc();
            while (_fscanf(v4, "%s", v5) != -1) {
                // 0x100003e60
                function_1000038fc();
            }
        }
        // 0x100003e6c
        _fclose(v4);
        v2 = function_100003b60();
    } else {
        // 0x100003df4
        v2 = _printf("Usage : %s <Gene file name>\n", (char *)v3);
    }
    // 0x100003e80
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ea8
        ___stack_chk_fail(v2);
    }
    // 0x100003eac
    return 0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(int64_t a1) {
    // 0x100003ebc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ec8
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(struct _IO_FILE * stream) {
    // 0x100003ed4
    return _fclose(stream);
}

// Address range: 0x100003ee0 - 0x100003eec
struct _IO_FILE * function_100003ee0(char * filename, char * modes) {
    // 0x100003ee0
    return _fopen(filename, modes);
}

// Address range: 0x100003eec - 0x100003ef8
void function_100003eec(int64_t * ptr) {
    // 0x100003eec
    _free(ptr);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ef8
    return _fscanf(stream, format);
}

// Address range: 0x100003f04 - 0x100003f10
int64_t * function_100003f04(int32_t size) {
    // 0x100003f04
    return _malloc(size);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * s) {
    // 0x100003f1c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdlib.h>
#include <time.h>
#include <stdio.h>

int main() {
    int a[10][10], i, j;

    srand(time(NULL));
    for (i = 0; i < 10; i++)
        for (j = 0; j < 10; j++)
            a[i][j] = rand() % 20 + 1;

    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            printf(" %d", a[i][j]);
            if (a[i][j] == 20)
                break;
        }
        if (a[i][j] == 20)
            break;
        printf("\n");
    }
    printf("\n");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f64(int64_t a1);
int32_t function_100003f70(char * format, ...);
int32_t function_100003f7c(void);
void function_100003f88(int32_t seed);
int32_t function_100003f94(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d54 - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d6c
    _srand(_time(NULL));
    int64_t v2; // bp-440, 0x100003d54
    int64_t v3 = &v2;
    int64_t v4 = 0;
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003dbc
        *(int32_t *)(40 * v4 + v3 + 4 * i) = _rand() % 20 + 1;
    }
    // 0x100003e08
    v4++;
    while (v4 != 10) {
        for (int64_t i = 0; i < 10; i++) {
            // 0x100003dbc
            *(int32_t *)(40 * v4 + v3 + 4 * i) = _rand() % 20 + 1;
        }
        // 0x100003e08
        v4++;
    }
    int32_t v5 = 0;
    int64_t v6 = 40 * (int64_t)v5 + v3;
    int32_t v7 = 0;
    int64_t v8; // 0x100003d54
    _printf(" %d", v8);
    if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
        // break (via goto) -> 0x100003f20
        goto lab_0x100003f20;
    }
    int32_t v9 = v7 + 1; // 0x100003ec4
    while (v7 < 9 != (8 - v7 & v9) < 0) {
        // 0x100003e50
        v7 = v9;
        _printf(" %d", v8);
        if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
            // break (via goto) -> 0x100003f20
            goto lab_0x100003f20;
        }
        // 0x100003ec0
        v9 = v7 + 1;
    }
    while (*(int32_t *)(4 * (int64_t)v9 + v6) != 20) {
        // 0x100003f00
        _printf((char *)0x100003fa4);
        int32_t v10 = v5 + 1; // 0x100003f14
        if (v5 < 9 == (8 - v5 & v10) < 0) {
            // break -> 0x100003f20
            break;
        }
        v5 = v10;
        v6 = 40 * (int64_t)v5 + v3;
        v7 = 0;
        _printf(" %d", v8);
        if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
            // break (via goto) -> 0x100003f20
            goto lab_0x100003f20;
        }
        // 0x100003ec0
        v9 = v7 + 1;
        while (v7 < 9 != (8 - v7 & v9) < 0) {
            // 0x100003e50
            v7 = v9;
            _printf(" %d", v8);
            if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
                // break (via goto) -> 0x100003f20
                goto lab_0x100003f20;
            }
            // 0x100003ec0
            v9 = v7 + 1;
        }
    }
  lab_0x100003f20:;
    int32_t v11 = _printf("\n"); // 0x100003f28
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f4c
        ___stack_chk_fail((int64_t)v11);
    }
    // 0x100003f50
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(int64_t a1) {
    // 0x100003f64
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(void) {
    // 0x100003f7c
    return _rand();
}

// Address range: 0x100003f88 - 0x100003f94
void function_100003f88(int32_t seed) {
    // 0x100003f88
    _srand(seed);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(int32_t * timer) {
    // 0x100003f94
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

#define MAX 15

int count_divisors(int n) {
    int i, count = 0;
    for (i = 1; i * i <= n; ++i) {
        if (!(n % i)) {
            if (i == n / i)
                count++;
            else
                count += 2;
        }
    }
    return count;
}

int main() {
    int i, k, n, seq[MAX];
    for (i = 0; i < MAX; ++i) seq[i] = 0;
    printf("The first %d terms of the sequence are:\n", MAX);
    for (i = 1, n = 0; n <  MAX; ++i) {
        k = count_divisors(i);
        if (k <= MAX && seq[k - 1] == 0) {
            seq[k - 1] = i;
            ++n;
        }
    }
    for (i = 0; i < MAX; ++i) printf("%d ", seq[i]);
    printf("\n");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cf0(void);
int64_t function_100003f58(int64_t a1);
int32_t function_100003f64(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cf0 - 0x100003db0
int64_t function_100003cf0(void) {
    // 0x100003cf0
    int64_t v1; // 0x100003cf0
    int32_t v2 = v1; // 0x100003cf4
    int32_t v3 = 1 - v2; // 0x100003d18
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003da4
        return 0;
    }
    int32_t v4 = 0;
    int32_t v5 = 1;
    int32_t v6 = v4; // 0x100003d44
    int32_t v7; // 0x100003cf0
    if (v2 % v5 == 0) {
        // 0x100003d4c
        v7 = v5 == v2 / v5 ? 1 : 2;
        v6 = v7 + v4;
    }
    int32_t result = v6;
    int32_t v8 = v5 + 1; // 0x100003d98
    int32_t v9 = v8 * v8; // 0x100003d10
    int32_t v10 = v9 - v2; // 0x100003d18
    while (v10 == 0 || v10 < 0 != ((v10 ^ v9) & (v9 ^ v2)) < 0) {
        // 0x100003d28
        v4 = result;
        v5 = v8;
        v6 = v4;
        if (v2 % v5 == 0) {
            // 0x100003d4c
            v7 = v5 == v2 / v5 ? 1 : 2;
            v6 = v7 + v4;
        }
        // 0x100003d94
        result = v6;
        v8 = v5 + 1;
        v9 = v8 * v8;
        v10 = v9 - v2;
    }
    // 0x100003da4
    return result;
}

// Address range: 0x100003db0 - 0x100003f58
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc4
    int64_t v2; // bp-84, 0x100003db0
    int64_t v3 = &v2;
    for (int64_t i = 0; i < 15; i++) {
        // 0x100003dec
        *(int32_t *)(4 * i + v3) = 0;
    }
    // 0x100003e10
    int64_t v4; // 0x100003db0
    _printf("The first %d terms of the sequence are:\n", v4);
    int32_t v5 = 1;
    int32_t v6 = 0;
    int64_t v7 = function_100003cf0(); // 0x100003e50
    int32_t v8 = v7; // 0x100003e54
    int32_t v9 = v8 - 15; // 0x100003e5c
    int32_t v10 = v6; // 0x100003e64
    int32_t * v11; // 0x100003e78
    if (v9 == 0 || v9 < 0 != (14 - v8 & v8) < 0) {
        // 0x100003e6c
        v11 = (int32_t *)((4 * v7 + 0xfffffffc & 0xfffffffc) + v3);
        v10 = v6;
        if (*v11 == 0) {
            // 0x100003e8c
            *v11 = v5;
            v10 = v6 + 1;
        }
    }
    int32_t v12 = v5 + 1; // 0x100003e44
    int32_t v13 = 0; // 0x100003e44
    while (v10 < 15 != (14 - v10 & v10) < 0) {
        // 0x100003e4c
        v5 = v12;
        v6 = v10;
        v7 = function_100003cf0();
        v8 = v7;
        v9 = v8 - 15;
        v10 = v6;
        if (v9 == 0 || v9 < 0 != (14 - v8 & v8) < 0) {
            // 0x100003e6c
            v11 = (int32_t *)((4 * v7 + 0xfffffffc & 0xfffffffc) + v3);
            v10 = v6;
            if (*v11 == 0) {
                // 0x100003e8c
                *v11 = v5;
                v10 = v6 + 1;
            }
        }
        // 0x100003eb4
        v12 = v5 + 1;
        v13 = 0;
    }
    _printf("%d ", v4);
    int32_t v14 = v13 + 1; // 0x100003f0c
    v13 = v14;
    while (v14 != 15) {
        // 0x100003ee0
        _printf("%d ", v4);
        v14 = v13 + 1;
        v13 = v14;
    }
    int32_t v15 = _printf((char *)0x100003f9d); // 0x100003f20
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f44
        ___stack_chk_fail((int64_t)v15);
    }
    // 0x100003f48
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t a1) {
    // 0x100003f58
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

#define NUM_DOORS 100

int main(int argc, char *argv[])
{
  int is_open[NUM_DOORS] = { 0 } ;
  int * doorptr, * doorlimit = is_open + NUM_DOORS ;
  int pass ;

  /* do the N passes, go backwards because the order is not important */
  for ( pass= NUM_DOORS ; ( pass ) ; -- pass ) {
    for ( doorptr= is_open + ( pass-1 ); ( doorptr < doorlimit ) ; doorptr += pass ) {
      ( * doorptr ) ^= 1 ;
    }
  }

  /* output results */
  for ( doorptr= is_open ; ( doorptr != doorlimit ) ; ++ doorptr ) {
    printf("door #%lld is %s\n", ( doorptr - is_open ) + 1, ( * doorptr ) ? "open" : "closed" ) ;
  }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f64(void);
void function_100003f70(int64_t * s, int32_t n);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
void _bzero(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dbc - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dd4
    int64_t v2; // bp-432, 0x100003dbc
    int64_t v3 = &v2;
    _bzero(&v2, 400);
    uint64_t v4 = v3 + 400; // 0x100003dfc
    int64_t v5 = 100;
    int64_t v6 = v5 - 1;
    int64_t v7 = 4 * v6 + v3; // 0x100003e30
    int32_t * v8; // 0x100003dbc
    if (v4 > v7) {
        for (int64_t i = v7; i < v4; i += 4 * v5) {
            // 0x100003e54
            v8 = (int32_t *)i;
            *v8 = *v8 ^ 1;
        }
    }
    while (v6 != 0) {
        // 0x100003e24
        v5 = v6;
        v6 = v5 - 1;
        v7 = 4 * v6 + v3;
        if (v4 > v7) {
            for (int64_t i = v7; i < v4; i += 4 * v5) {
                // 0x100003e54
                v8 = (int32_t *)i;
                *v8 = *v8 ^ 1;
            }
        }
    }
    int64_t v9 = v3; // 0x100003f18
    int64_t v10; // 0x100003dbc
    _printf("door #%lld is %s\n", 400, (char *)v10);
    while (v4 != v9 + 4) {
        // 0x100003eb4
        v9 += 4;
        _printf("door #%lld is %s\n", 400, (char *)v10);
    }
    // 0x100003f24
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f4c
        ___stack_chk_fail();
    }
    // 0x100003f50
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(void) {
    // 0x100003f64
    return ___stack_chk_fail();
}

// Address range: 0x100003f70 - 0x100003f7c
void function_100003f70(int64_t * s, int32_t n) {
    // 0x100003f70
    _bzero(s, n);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <wctype.h>
#include <string.h>
#include <locale.h>

typedef struct wstr {
	wchar_t *s;
	int n, alloc;
} wstr;

#define w_del(w) { free(w->s); free(w); }
#define forchars(i, c, w) for(i = 0, c = w->s[0]; i < w->n && c; c = w->s[++i])
wstr *w_new()
{
	wstr *w = malloc(sizeof(wstr));
	w->alloc = 1;
	w->n = 0;
	w->s = malloc(sizeof(wchar_t));
	w->s[0] = 0;
	return w;
}

void w_append(wstr *w, wchar_t c)
{
	int n = w->n + 1;
	if (n >= w->alloc) {
		w->alloc *= 2;
		w->s = realloc(w->s, w->alloc * sizeof(wchar_t));
	}
	w->s[w->n++] = c;
	w->s[w->n] = 0;
}

wstr *w_make(wchar_t *s)
{
	int i, len = wcslen(s);
	wstr *w = w_new();
	for (i = 0; i < len; i++) w_append(w, s[i]);
	return w;
}

typedef void (*wtrans_func)(wstr *, wstr *);
void w_transform(wstr *in, wtrans_func f)
{
	wstr t, *out = w_new();
	f(in, out);
	t = *in; *in = *out; *out = t;
	w_del(out);
}
#define transfunc(x) void w_##x(wstr *in, wstr *out)

transfunc(nocase) {
	int i;
	wchar_t c;
	forchars(i, c, in) w_append(out, towlower(c));
}

transfunc(despace) {
	int i, gotspace = 0;
	wchar_t c;
	forchars(i, c, in) {
		if (!iswspace(c)) {
			if (gotspace && out->n)
				w_append(out, L' ');
			w_append(out, c);
			gotspace = 0;
		} else	gotspace = 1;
	}
}

static const wchar_t *const tbl_accent[] = { /* copied from Raku code */
	L"Þ", L"TH", L"þ", L"th", L"Ð", L"TH", L"ð", L"th", L"À", L"A",
	L"Á", L"A", L"Â", L"A", L"Ã", L"A", L"Ä", L"A", L"Å", L"A", L"à",
	L"a", L"á", L"a", L"â", L"a", L"ã", L"a", L"ä", L"a", L"å", L"a",
	L"Ç", L"C", L"ç", L"c", L"È", L"E", L"É", L"E", L"Ê", L"E", L"Ë",
	L"E", L"è", L"e", L"é", L"e", L"ê", L"e", L"ë", L"e", L"Ì",
	L"I", L"Í", L"I", L"Î", L"I", L"Ï", L"I", L"ì", L"i", L"í",
	L"i", L"î", L"i", L"ï", L"i", L"Ò", L"O", L"Ó", L"O", L"Ô",
	L"O", L"Õ", L"O", L"Ö", L"O", L"Ø", L"O", L"ò", L"o", L"ó", L"o",
	L"ô", L"o", L"õ", L"o", L"ö", L"o", L"ø", L"o", L"Ñ", L"N", L"ñ", L"n",
	L"Ù", L"U", L"Ú", L"U", L"Û", L"U", L"Ü", L"U", L"ù", L"u", L"ú", L"u",
	L"û", L"u", L"ü", L"u", L"Ý", L"Y", L"ÿ", L"y", L"ý", L"y" };

static const wchar_t *const tbl_ligature[] = {
	L"Æ", L"AE", L"æ", L"ae", L"ß", L"ss",
	L"ﬄ", L"ffl", L"ﬃ", L"ffi", L"ﬁ", L"fi", L"ﬀ", L"ff", L"ﬂ", L"fl",
	L"ſ", L"s", L"ʒ", L"z", L"ﬆ", L"st", /* ... come on ... */
};

void w_char_repl(wstr *in, wstr *out, const wchar_t *const *tbl, int len)
{
	int i, j, k;
	wchar_t c;
	forchars(i, c, in) {
		for (j = k = 0; j < len; j += 2) {
			if (c != tbl[j][0]) continue;
			for (k = 0; tbl[j + 1][k]; k++)
				w_append(out, tbl[j + 1][k]);
			break;
		}
		if (!k) w_append(out, c);
	}
}

transfunc(noaccent) {
	w_char_repl(in, out, tbl_accent, sizeof(tbl_accent)/sizeof(wchar_t*));
}

transfunc(noligature) {
	w_char_repl(in, out, tbl_ligature, sizeof(tbl_ligature)/sizeof(wchar_t*));
}

static const wchar_t *const tbl_article[] = {
	L"the", L"a", L"of", L"to", L"is", L"it" };
#define N_ARTICLES sizeof(tbl_article)/sizeof(tbl_article[0])
transfunc(noarticle) {
	int i, j, n;
	wchar_t c, c0 = 0;
	forchars(i, c, in) {
		if (!c0 || (iswalnum(c) && !iswalnum(c0))) { /* word boundary */
			for (j = N_ARTICLES - 1; j >= 0; j--) {
				n = wcslen(tbl_article[j]);
				if (wcsncasecmp(in->s + i, tbl_article[j], n))
					continue;
				if (iswalnum(in->s[i + n])) continue;
				i += n;
				break;
			}
			if (j < 0) w_append(out, c);
		} else
			w_append(out, c);
		c0 = c;
	}
}

enum { wi_space = 0, wi_case, wi_accent, wi_lig, wi_article, wi_numeric };
#define WS_NOSPACE	(1 << wi_space)
#define WS_NOCASE	(1 << wi_case)
#define WS_ACCENT	(1 << wi_accent)
#define WS_LIGATURE	(1 << wi_lig)
#define WS_NOARTICLE	(1 << wi_article)
#define WS_NUMERIC	(1 << wi_numeric)
const wtrans_func trans_funcs[] = {
	w_despace, w_nocase, w_noaccent, w_noligature, w_noarticle, 0
};
const char *const flagnames[] = {
	"collapse spaces",
	"case insensitive",
	"disregard accent",
	"decompose ligatures",
	"discard common words",
	"numeric",
};

typedef struct { wchar_t* s; wstr *w; } kw_t;
int w_numcmp(const void *a, const void *b)
{
	wchar_t *pa = ((const kw_t*)a)->w->s, *pb = ((const kw_t*)b)->w->s;
	int sa, sb, ea, eb;
	while (*pa && *pb) {
		if (iswdigit(*pa) && iswdigit(*pb)) {
			/* skip leading zeros */
			sa = sb = 0;
			while (pa[sa] == L'0') sa++;
			while (pb[sb] == L'0') sb++;
			/* find end of numbers */
			ea = sa; eb = sb;
			while (iswdigit(pa[ea])) ea++;
			while (iswdigit(pb[eb])) eb++;
			if (eb - sb > ea - sa) return -1;
			if (eb - sb < ea - sa) return 1;
			while (sb < eb) {
				if (pa[sa] > pb[sb]) return 1;
				if (pa[sa] < pb[sb]) return -1;
				sa++; sb++;
			}

			pa += ea; pb += eb;
		}
		else if (iswdigit(*pa)) return 1;
		else if (iswdigit(*pb)) return -1;
		else {
			if (*pa > *pb) return 1;
			if (*pa < *pb) return -1;
			pa++; pb++;
		}
	}
	return (!*pa && !*pb) ? 0 : *pa ?  1 : -1;
}

int w_cmp(const void *a, const void *b)
{
	return wcscmp(((const kw_t*)a)->w->s, ((const kw_t*)b)->w->s);
}

void natural_sort(wchar_t **strings, int len, int flags)
{
	int i, j;
	kw_t *kws = malloc(sizeof(kw_t) * len);

	for (i = 0; i < len; i++) {
		kws[i].s = strings[i];
		kws[i].w = w_make(strings[i]);
		for (j = 0; j < wi_numeric; j++)
			if (flags & (1 << j) && trans_funcs[j])
				w_transform(kws[i].w, trans_funcs[j]);
	}

	qsort(kws, len, sizeof(kw_t), (flags & WS_NUMERIC) ? w_numcmp : w_cmp);
	for (i = 0; i < len; i++) {
		w_del(kws[i].w);
		strings[i] = kws[i].s;
	}
	free(kws);
}

const wchar_t *const test[] = {
	L" 0000098 nina", L"100 niño", L"99 Ninja", L"100 NINA",
	L" The work is so diﬃcult to do it took ſome 100 aeons.  ",
	L"The work is so difficult it took some 100 aeons.",
	L"  The work is so diﬃcult   it took ſome 99 æons.  ",
};
#define N_STRINGS sizeof(test)/sizeof(*test)

void test_sort(int flags)
{
	int i, j;
	const wchar_t *str[N_STRINGS];
	memcpy(str, test, sizeof(test));

	printf("Sort flags: (");
	for (i = 0, j = flags; j; i++, j >>= 1)
		if ((j & 1))
			printf("%s%s", flagnames[i], j > 1 ? ", ":")\n");

	natural_sort((wchar_t **)str, N_STRINGS, flags);

	for (i = 0; i < N_STRINGS; i++)
		printf("%ls\n", str[i]);
	printf("\n");
}

int main()
{
	setlocale(LC_CTYPE, "");

	test_sort(WS_NOSPACE);
	test_sort(WS_NOCASE);
	test_sort(WS_NUMERIC);
	test_sort(WS_NOARTICLE|WS_NOSPACE);
	test_sort(WS_NOCASE|WS_NOSPACE|WS_ACCENT);
	test_sort(WS_LIGATURE|WS_NOCASE|WS_NOSPACE|WS_NUMERIC|WS_ACCENT|WS_NOARTICLE);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000027c4(void);
int64_t function_10000281c(void);
int64_t function_1000028d8(void);
int64_t function_100002958(int64_t result, int64_t a2);
int64_t function_100002984(int64_t a1);
int64_t function_1000029cc(void);
int64_t function_100002a88(void);
int64_t function_100002ba0(void);
int64_t function_100002d30(void);
int64_t function_100002d68(void);
int64_t function_100002da0(void);
int64_t function_100002f94(void);
int64_t function_1000033a4(void);
int64_t function_1000033e0(void);
int64_t function_1000035dc(void);
int64_t function_1000037d0(int64_t a1);
void function_1000037dc(int64_t * ptr);
int32_t function_1000037e8(int32_t wc);
int32_t function_1000037f4(int32_t wc);
int32_t function_100003800(int32_t wc);
int64_t * function_10000380c(int32_t size);
int64_t * function_100003818(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003824(char * format, ...);
void function_100003830(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int64_t * function_10000383c(int64_t * ptr, int32_t size);
char * function_100003848(int32_t category, char * locale);
int32_t function_100003854(int32_t wc);
int32_t function_100003860(int16_t * s1, int16_t * s2);
int32_t function_10000386c(int16_t * s);
int32_t function_100003878(int16_t * s1, int16_t * s2, int32_t n);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000002a88; // 0x100004510
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int32_t _iswalnum(int32_t a1);
int32_t _iswdigit(int32_t a1);
int32_t _iswspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int64_t * _realloc(int64_t * a1, int32_t a2);
char * _setlocale(int32_t a1, char * a2);
int32_t _towlower(int32_t a1);
int32_t _wcscmp(int16_t * a1, int16_t * a2);
int32_t _wcslen(int16_t * a1);
int32_t _wcsncasecmp(int16_t * a1, int16_t * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000027c4 - 0x10000281c
int64_t function_1000027c4(void) {
    int64_t * v1 = _malloc(16); // 0x1000027d4
    int64_t result = (int64_t)v1; // 0x1000027d4
    *(int32_t *)(result + 12) = 1;
    *(int32_t *)(result + 8) = 0;
    int64_t * v2 = _malloc(4); // 0x1000027f4
    *v1 = (int64_t)v2;
    *(int32_t *)v2 = 0;
    return result;
}

// Address range: 0x10000281c - 0x1000028d8
int64_t function_10000281c(void) {
    // 0x10000281c
    int64_t v1; // 0x10000281c
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100002834
    int32_t v3 = *v2; // 0x100002834
    int32_t v4 = v3 + 1;
    int32_t * v5 = (int32_t *)(v1 + 12); // 0x100002848
    int32_t v6 = *v5; // 0x100002848
    int32_t v7 = v4 - v6; // 0x10000284c
    int32_t v8 = v4; // 0x100002854
    int32_t v9 = v3; // 0x100002854
    int64_t result; // 0x10000281c
    if (v7 < 0 == ((v7 ^ v4) & (v4 ^ v6)) < 0) {
        // 0x10000285c
        *v5 = 2 * v6;
        int64_t * v10 = (int64_t *)v1; // 0x100002880
        int64_t v11 = (int64_t)_realloc(v10, 8 * v6); // 0x100002880
        *v10 = v11;
        v9 = *v2;
        v8 = v9 + 1;
        result = v11;
    }
    // 0x100002890
    *v2 = v8;
    *(int32_t *)(4 * (int64_t)v9 + result) = (int32_t)v1;
    *(int32_t *)(4 * (int64_t)*v2 + result) = 0;
    return result;
}

// Address range: 0x1000028d8 - 0x100002958
int64_t function_1000028d8(void) {
    // 0x1000028d8
    int64_t v1; // 0x1000028d8
    int32_t v2 = _wcslen((int16_t *)v1); // 0x1000028ec
    int64_t result = function_1000027c4(); // 0x1000028f8
    int32_t v3 = -v2; // 0x100002910
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100002948
        return result;
    }
    int32_t v4 = 0; // 0x100002918
    function_10000281c();
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100002920
        function_10000281c();
        v4++;
    }
    // 0x100002948
    return result;
}

// Address range: 0x100002958 - 0x100002984
int64_t function_100002958(int64_t result, int64_t a2) {
    // 0x100002958
    function_1000027c4();
    return result;
}

// Address range: 0x100002984 - 0x1000029cc
int64_t function_100002984(int64_t a1) {
    // 0x100002984
    int64_t v1; // 0x100002984
    float128_t * v2 = (float128_t *)*(int64_t *)(v1 - 8); // 0x100002988
    float128_t * v3 = (float128_t *)a1; // 0x100002998
    *v2 = *v3;
    *v3 = *v2;
    int64_t * v4 = (int64_t *)a1; // 0x1000029b0
    _free((int64_t *)*v4);
    _free(v4);
    return &g2;
}

// Address range: 0x1000029cc - 0x100002a88
int64_t function_1000029cc(void) {
    // 0x1000029cc
    int64_t v1; // 0x1000029cc
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002a00
    int32_t v4 = *v3; // 0x100002a00
    int32_t v5 = -v4; // 0x100002a04
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002a7c
        int64_t result; // 0x1000029cc
        return result;
    }
    int32_t v6 = 0; // 0x100002a34
    _towlower(v2);
    int64_t result2 = function_10000281c(); // 0x100002a54
    v6++;
    int32_t v7 = *(int32_t *)(result2 + (int64_t)(4 * v6));
    int32_t v8 = *v3; // 0x100002a00
    int32_t v9 = v6 - v8; // 0x100002a04
    while (v7 != 0 == (v9 < 0 != ((v9 ^ v6) & (v8 ^ v6)) < 0)) {
        // 0x100002a3c
        _towlower(v7);
        result2 = function_10000281c();
        v6++;
        v7 = *(int32_t *)(result2 + (int64_t)(4 * v6));
        v8 = *v3;
        v9 = v6 - v8;
    }
    // 0x100002a7c
    return result2;
}

// Address range: 0x100002a88 - 0x100002ba0
int64_t function_100002a88(void) {
    // 0x100002a88
    int64_t v1; // 0x100002a88
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002ac0
    int32_t v4 = *v3; // 0x100002ac0
    int32_t v5 = -v4; // 0x100002ac4
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002b94
        int64_t result; // 0x100002a88
        return result;
    }
    int32_t v6 = 0; // 0x100002b80
    int32_t v7 = _iswspace(v2); // 0x100002b00
    int64_t result2 = v7; // 0x100002b0c
    int32_t v8 = 1; // 0x100002b0c
    if (v7 == 0) {
        // 0x100002b50
        result2 = function_10000281c();
        v8 = 0;
    }
    // 0x100002b70
    v6++;
    int32_t v9 = *(int32_t *)(result2 + (int64_t)(4 * v6));
    int32_t v10 = *v3; // 0x100002ac0
    int32_t v11 = v6 - v10; // 0x100002ac4
    int32_t v12 = v8; // 0x100002af4
    while (v9 != 0 == (v11 < 0 != ((v11 ^ v6) & (v10 ^ v6)) < 0)) {
        // 0x100002afc
        v7 = _iswspace(v9);
        result2 = v7;
        v8 = 1;
        if (v7 == 0) {
            // 0x100002b14
            if (v12 != 0) {
                // 0x100002b28
                if (*(int32_t *)(v1 + 8) != 0) {
                    // 0x100002b40
                    function_10000281c();
                }
            }
            // 0x100002b50
            result2 = function_10000281c();
            v8 = 0;
        }
        // 0x100002b70
        v6++;
        v9 = *(int32_t *)(result2 + (int64_t)(4 * v6));
        v10 = *v3;
        v11 = v6 - v10;
        v12 = v8;
    }
    // 0x100002b94
    return result2;
}

// Address range: 0x100002ba0 - 0x100002d30
int64_t function_100002ba0(void) {
    // 0x100002ba0
    int64_t v1; // 0x100002ba0
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002bdc
    int32_t v4 = *v3; // 0x100002bdc
    int32_t v5 = -v4; // 0x100002be0
    int64_t result; // 0x100002ba0
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002d24
        return result;
    }
    int32_t v6 = v1; // 0x100002bb8
    int32_t v7 = -v6; // 0x100002c2c
    int32_t v8 = v2;
    int32_t v9 = 0; // 0x100002d10
    int64_t v10; // 0x100002ba0
    while (true) {
      lab_0x100002c24:;
        int32_t v11 = v8;
        if (v7 < 0 == (v7 & v6) < 0) {
            // 0x100002cf0
            v10 = function_10000281c();
            goto lab_0x100002d04;
        } else {
            int32_t v12 = 0;
            int32_t v13 = *(int32_t *)*(int64_t *)(8 * (int64_t)v12 + v1); // 0x100002c4c
            while (v11 != v13) {
                int32_t v14 = v12 + 2; // 0x100002cd0
                int32_t v15 = v14 - v6; // 0x100002c2c
                int32_t v16 = v14; // 0x100002c34
                if (v15 < 0 == ((v15 ^ v14) & (v14 ^ v6)) < 0) {
                    // 0x100002cf0
                    v10 = function_10000281c();
                    goto lab_0x100002d04;
                }
                v12 = v16;
                v13 = *(int32_t *)*(int64_t *)(8 * (int64_t)v12 + v1);
            }
            int64_t * v17 = (int64_t *)(v1 + (int64_t)(8 * v12 | 8)); // 0x100002c78
            if (*(int32_t *)*v17 == 0) {
                // 0x100002cf0
                v10 = function_10000281c();
                goto lab_0x100002d04;
            } else {
                int64_t v18 = function_10000281c(); // 0x100002cb0
                int32_t v19 = 1; // 0x100002cbc
                int32_t v20 = v19; // 0x100002c8c
                while (*(int32_t *)(4 * (int64_t)v19 + *v17) != 0) {
                    // 0x100002c94
                    v18 = function_10000281c();
                    v19 = v20 + 1;
                    v20 = v19;
                }
                // 0x100002cdc
                v10 = v18;
                if (v19 == 0) {
                    // 0x100002cf0
                    v10 = function_10000281c();
                    goto lab_0x100002d04;
                } else {
                    goto lab_0x100002d04;
                }
            }
        }
    }
    // 0x100002d24
    return result;
  lab_0x100002d04:
    // 0x100002d04
    v9++;
    v8 = *(int32_t *)(v10 + (int64_t)(4 * v9));
    int32_t v21 = *v3; // 0x100002bdc
    int32_t v22 = v9 - v21; // 0x100002be0
    result = v10;
    if (v8 != 0 != v22 < 0 != ((v22 ^ v9) & (v21 ^ v9)) < 0) {
        return result;
    }
    goto lab_0x100002c24;
}

// Address range: 0x100002d30 - 0x100002d68
int64_t function_100002d30(void) {
    // 0x100002d30
    return function_100002ba0();
}

// Address range: 0x100002d68 - 0x100002da0
int64_t function_100002d68(void) {
    // 0x100002d68
    return function_100002ba0();
}

// Address range: 0x100002da0 - 0x100002f94
int64_t function_100002da0(void) {
    // 0x100002da0
    int64_t v1; // 0x100002da0
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002dd8
    int32_t v4 = *v3; // 0x100002dd8
    int32_t v5 = -v4; // 0x100002ddc
    int32_t v6 = v2; // 0x100002e0c
    int32_t v7 = 0; // 0x100002e0c
    int64_t result; // 0x100002da0
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002f88
        return result;
    }
    int32_t v8 = 0; // 0x100002e0c
    int32_t v9; // 0x100002da0
    while (true) {
      lab_0x100002e14:;
        int32_t v10 = v8;
        v9 = v7;
        v8 = v6;
        if (v10 == 0) {
            goto lab_0x100002e58;
        } else {
            // 0x100002e28
            if (_iswalnum(v8) == 0) {
                goto lab_0x100002f4c;
            } else {
                // 0x100002e40
                if (_iswalnum(v10) == 0) {
                    goto lab_0x100002e58;
                } else {
                    goto lab_0x100002f4c;
                }
            }
        }
    }
  lab_0x100002f88:
    // 0x100002f88
    return result;
  lab_0x100002e58:;
    int64_t v11 = 4 * (int64_t)v9;
    int64_t v12 = 5; // 0x100002da0
    int64_t v13; // 0x100002da0
    int32_t v14; // 0x100002da0
    while (true) {
        int64_t v15 = v12;
        int64_t * v16 = (int64_t *)(8 * v15 + (int64_t)"h?"); // 0x100002e88
        int32_t v17 = _wcslen((int16_t *)*v16); // 0x100002e8c
        int64_t v18 = *v16; // 0x100002eb0
        if (_wcsncasecmp((int16_t *)(v11 + (int64_t)v17), (int16_t *)v18, v17) == 0) {
            int32_t v19 = v17 + v9; // 0x100002ee0
            v13 = 0;
            v14 = v19;
            if (_iswalnum(*(int32_t *)(int64_t)(4 * v19)) == 0) {
                // break -> 0x100002f5c
                break;
            }
        }
        // 0x100002f14
        v12 = v15 - 1;
        if (v15 == 0) {
            // 0x100002f38
            v13 = function_10000281c();
            v14 = v9;
            goto lab_0x100002f5c;
        }
    }
    goto lab_0x100002f5c;
  lab_0x100002f5c:
    // 0x100002f5c
    v7 = v14 + 1;
    v6 = *(int32_t *)(v13 + (int64_t)(4 * v7));
    int32_t v20 = *v3; // 0x100002dd8
    int32_t v21 = v7 - v20; // 0x100002ddc
    result = v13;
    if (v6 != 0 != v21 < 0 != ((v21 ^ v7) & (v20 ^ v7)) < 0) {
        // break -> 0x100002f88
        goto lab_0x100002f88;
    }
    goto lab_0x100002e14;
  lab_0x100002f4c:
    // 0x100002f4c
    v13 = function_10000281c();
    v14 = v9;
    goto lab_0x100002f5c;
}

// Address range: 0x100002f94 - 0x1000033a4
int64_t function_100002f94(void) {
    // 0x100002f94
    int64_t v1; // 0x100002f94
    int64_t v2 = *(int64_t *)*(int64_t *)(v1 + 8); // 0x100002fb0
    int64_t v3 = *(int64_t *)*(int64_t *)(v1 + 8); // 0x100002fc0
    int32_t * v4 = (int32_t *)v2;
    int32_t * v5 = (int32_t *)v3;
    int32_t v6 = *v4; // 0x100002fd0
    int32_t v7 = v6; // 0x100002fe4
    int32_t * v8 = v5; // 0x100002fe4
    int32_t * v9 = v4; // 0x100002fe4
    int64_t v10 = v2; // 0x100002fe4
    int64_t v11 = v3; // 0x100002fe4
    int32_t * v12 = v5; // 0x100002fe4
    int64_t result2; // 0x100002f94
    int64_t v13; // 0x100002f94
    int32_t * v14; // 0x100002f94
    int64_t v15; // 0x100002f94
    int32_t v16; // 0x100002f94
    int32_t v17; // 0x100002f94
    if (v6 == 0) {
      lab_0x10000333c:
        // 0x10000333c
        result2 = 0xffffffff;
        if (*v12 == 0) {
            // 0x100003394
            return 0;
        }
    } else {
        while (true) {
          lab_0x100003004:
            // 0x100003004
            v14 = v8;
            result2 = 1;
            if (*v14 == 0) {
                // break -> 0x100003360
                break;
            }
            // 0x100003010
            v15 = v11;
            v13 = v10;
            if (_iswdigit(v7) == 0) {
                goto lab_0x100003254;
            } else {
                int32_t v18 = 0; // 0x100003040
                if (_iswdigit(*v14) == 0) {
                    goto lab_0x100003254;
                } else {
                    while (true) {
                        // 0x100003054
                        v17 = v18;
                        v18 = v17 + 1;
                        v16 = 0;
                        if (*(int32_t *)(4 * (int64_t)v17 + v13) != 48) {
                            goto lab_0x100003084;
                        }
                    }
                    // 0x100003128
                    int32_t v19; // 0x100002f94
                    int32_t v20; // 0x100002f94
                    int32_t v21 = v20 - v19; // 0x100003130
                    int32_t v22; // 0x100002f94
                    int32_t v23 = v22 - v17; // 0x10000313c
                    int32_t v24 = v21 - v23; // 0x100003140
                    int64_t v25 = 0xffffffff; // 0x100003148
                    int64_t result; // 0x100002f94
                    if (v24 != 0 && v24 < 0 == ((v24 ^ v21) & (v21 ^ v23)) < 0) {
                        // 0x100003394
                        result = v25;
                        return result;
                    }
                    // 0x10000315c
                    v25 = 1;
                    if (v24 < 0 != ((v24 ^ v21) & (v21 ^ v23)) < 0) {
                        // 0x100003394
                        result = v25;
                        return result;
                    }
                    int32_t v26 = v19 - v20; // 0x10000319c
                    int32_t v27 = v17; // 0x1000031a4
                    int32_t v28 = v19; // 0x1000031a4
                    if (v26 < 0 != ((v26 ^ v19) & (v20 ^ v19)) < 0) {
                        int32_t v29 = v28;
                        int32_t v30 = v27;
                        int32_t v31 = *(int32_t *)(4 * (int64_t)v30 + v13); // 0x1000031b4
                        int32_t v32 = *(int32_t *)(4 * (int64_t)v29 + v15); // 0x1000031c0
                        int32_t v33 = v31 - v32; // 0x1000031c4
                        v25 = 1;
                        // 0x100003394
                        result = v25;
                        while (v33 == 0 || v33 < 0 != ((v33 ^ v31) & (v32 ^ v31)) < 0) {
                            // 0x1000031e0
                            v25 = 0xffffffff;
                            if (v33 < 0 != ((v33 ^ v31) & (v32 ^ v31)) < 0) {
                                // 0x100003394
                                result = v25;
                                return result;
                            }
                            int32_t v34 = v29 + 1; // 0x100003224
                            int32_t v35 = v34 - v20; // 0x10000319c
                            v27 = v30 + 1;
                            v28 = v34;
                            if (v35 < 0 == ((v35 ^ v34) & (v34 ^ v20)) < 0) {
                                // break -> 0x100003320
                                break;
                            }
                            v29 = v28;
                            v30 = v27;
                            v31 = *(int32_t *)(4 * (int64_t)v30 + v13);
                            v32 = *(int32_t *)(4 * (int64_t)v29 + v15);
                            v33 = v31 - v32;
                            v25 = 1;
                            // 0x100003394
                            result = v25;
                        }
                        return result;
                    }
                    goto lab_0x100003320;
                }
            }
        }
    }
    // 0x100003394
    return result2;
  lab_0x100003084:;
    int32_t v36 = *(int32_t *)(4 * (int64_t)v16 + v15); // 0x10000308c
    v16++;
    if (v36 == 48) {
        goto lab_0x100003084;
    } else {
        // 0x1000030c4
        _iswdigit(*(int32_t *)(4 * (int64_t)v17 + v13));
    }
  lab_0x100003254:
    // 0x100003254
    if (_iswdigit(*v9) != 0) {
        // 0x100003394
        return 1;
    }
    // 0x10000327c
    if (_iswdigit(*v14) != 0) {
        // 0x100003394
        return 0xffffffff;
    }
    int32_t v37 = *v9; // 0x1000032a8
    int32_t v38 = *v14; // 0x1000032b0
    int32_t v39 = v37 - v38; // 0x1000032b4
    if (v39 != 0 && v39 < 0 == ((v39 ^ v37) & (v38 ^ v37)) < 0) {
        // 0x100003394
        return 1;
    }
    // 0x1000032d0
    if (v39 < 0 != ((v39 ^ v37) & (v38 ^ v37)) < 0) {
        // 0x100003394
        return 0xffffffff;
    }
    // 0x1000032fc
    v10 = v13 + 4;
    v11 = v15 + 4;
    goto lab_0x100003320;
  lab_0x100003320:
    // 0x100003320
    v9 = (int32_t *)v10;
    v8 = (int32_t *)v11;
    v7 = *v9;
    v12 = v8;
    if (v7 == 0) {
        goto lab_0x10000333c;
    }
    goto lab_0x100003004;
}

// Address range: 0x1000033a4 - 0x1000033e0
int64_t function_1000033a4(void) {
    // 0x1000033a4
    int64_t v1; // 0x1000033a4
    int64_t v2 = *(int64_t *)(v1 + 8); // 0x1000033bc
    int64_t v3 = *(int64_t *)*(int64_t *)(v1 + 8); // 0x1000033cc
    return _wcscmp((int16_t *)*(int64_t *)v2, (int16_t *)v3);
}

// Address range: 0x1000033e0 - 0x1000035dc
int64_t function_1000033e0(void) {
    // 0x1000033e0
    int64_t v1; // 0x1000033e0
    int32_t v2 = v1; // 0x1000033f0
    int32_t v3 = v1; // 0x1000033f4
    int64_t * v4 = _malloc(16 * v2); // 0x100003404
    int64_t v5 = (int64_t)v4; // 0x100003404
    int32_t v6 = -v2;
    int32_t v7 = 0; // 0x100003424
    if (v6 < 0 == (v6 & v2) < 0) {
        // 0x1000035c8
        _qsort(v4, v2, 16, (v3 & 32) == 0 ? (int32_t (*)(int64_t *, int64_t *))0x1000033a4 : (int32_t (*)(int64_t *, int64_t *))0x100002f94);
        // 0x1000035c8
        _free(v4);
        return &g2;
    }
    int64_t v8 = v7; // 0x100003430
    int64_t v9 = 16 * v8 + v5; // 0x100003444
    *(int64_t *)v9 = *(int64_t *)(8 * v8 + v1);
    int64_t v10 = function_1000028d8(); // 0x100003454
    int64_t * v11 = (int64_t *)(v9 + 8); // 0x100003464
    *v11 = v10;
    int64_t v12 = 0;
    int64_t v13; // 0x1000034b0
    if ((1 << (int32_t)v12 & v3) != 0) {
        // 0x1000034a4
        v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
        if (v13 != 0) {
            // 0x1000034c4
            function_100002958(*v11, v13);
        }
    }
    int64_t v14 = v12 + 1;
    while (v14 != 5) {
        // 0x100003484
        v12 = v14;
        if ((1 << (int32_t)v12 & v3) != 0) {
            // 0x1000034a4
            v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
            if (v13 != 0) {
                // 0x1000034c4
                function_100002958(*v11, v13);
            }
        }
        // 0x1000034f0
        v14 = v12 + 1;
    }
    // 0x100003504
    v7++;
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x10000342c
        v8 = v7;
        v9 = 16 * v8 + v5;
        *(int64_t *)v9 = *(int64_t *)(8 * v8 + v1);
        v10 = function_1000028d8();
        v11 = (int64_t *)(v9 + 8);
        *v11 = v10;
        v12 = 0;
        if ((1 << (int32_t)v12 & v3) != 0) {
            // 0x1000034a4
            v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
            if (v13 != 0) {
                // 0x1000034c4
                function_100002958(*v11, v13);
            }
        }
        // 0x1000034f0
        v14 = v12 + 1;
        while (v14 != 5) {
            // 0x100003484
            v12 = v14;
            if ((1 << (int32_t)v12 & v3) != 0) {
                // 0x1000034a4
                v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
                if (v13 != 0) {
                    // 0x1000034c4
                    function_100002958(*v11, v13);
                }
            }
            // 0x1000034f0
            v14 = v12 + 1;
        }
        // 0x100003504
        v7++;
    }
    // 0x10000356c
    _qsort(v4, v2, 16, (v3 & 32) == 0 ? (int32_t (*)(int64_t *, int64_t *))0x1000033a4 : (int32_t (*)(int64_t *, int64_t *))0x100002f94);
    int32_t v15 = 0; // 0x1000035bc
    int64_t v16 = v15; // 0x100003570
    int64_t v17 = 16 * v16 + v5; // 0x100003574
    int64_t * v18 = (int64_t *)(v17 + 8); // 0x100003578
    _free((int64_t *)*(int64_t *)*v18);
    _free((int64_t *)*v18);
    *(int64_t *)(8 * v16 + v1) = *(int64_t *)v17;
    v15++;
    while (v15 - v2 < 0 != ((v15 - v2 ^ v15) & (v15 ^ v2)) < 0) {
        // 0x10000356c
        v16 = v15;
        v17 = 16 * v16 + v5;
        v18 = (int64_t *)(v17 + 8);
        _free((int64_t *)*(int64_t *)*v18);
        _free((int64_t *)*v18);
        *(int64_t *)(8 * v16 + v1) = *(int64_t *)v17;
        v15++;
    }
    // 0x1000035c8
    _free(v4);
    return &g2;
}

// Address range: 0x1000035dc - 0x100003764
int64_t function_1000035dc(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000035f0
    int64_t v2; // 0x1000035dc
    int32_t v3 = v2; // 0x1000035f8
    int64_t v4; // bp-80, 0x1000035dc
    _memcpy(&v4, (int64_t *)"\b9", 56);
    _printf("Sort flags: (");
    int32_t v5 = v3; // 0x100003638
    if (v3 != 0) {
        if (v5 % 2 != 0) {
            // 0x100003654
            _printf("%s%s", "\b9", (char *)56);
        }
        // 0x1000036ac
        v5 >>= 1;
        while (v5 != 0) {
            // 0x100003640
            if (v5 % 2 != 0) {
                // 0x100003654
                _printf("%s%s", "\b9", (char *)56);
            }
            // 0x1000036ac
            v5 >>= 1;
        }
    }
    // 0x1000036c8
    function_1000033e0();
    for (int32_t i = 0; i < 7; i++) {
        // 0x1000036f4
        _printf("%ls\n", (char *)7);
    }
    int64_t v6 = _printf((char *)0x100003905); // 0x100003730
    int64_t result = v6; // 0x10000374c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003754
        result = ___stack_chk_fail(v6);
    }
    // 0x100003758
    return result;
}

// Address range: 0x100003764 - 0x1000037d0
int64_t entry_point(void) {
    // 0x100003764
    _setlocale(2, (char *)0x100003907);
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    return 0;
}

// Address range: 0x1000037d0 - 0x1000037dc
int64_t function_1000037d0(int64_t a1) {
    // 0x1000037d0
    return ___stack_chk_fail(a1);
}

// Address range: 0x1000037dc - 0x1000037e8
void function_1000037dc(int64_t * ptr) {
    // 0x1000037dc
    _free(ptr);
}

// Address range: 0x1000037e8 - 0x1000037f4
int32_t function_1000037e8(int32_t wc) {
    // 0x1000037e8
    return _iswalnum(wc);
}

// Address range: 0x1000037f4 - 0x100003800
int32_t function_1000037f4(int32_t wc) {
    // 0x1000037f4
    return _iswdigit(wc);
}

// Address range: 0x100003800 - 0x10000380c
int32_t function_100003800(int32_t wc) {
    // 0x100003800
    return _iswspace(wc);
}

// Address range: 0x10000380c - 0x100003818
int64_t * function_10000380c(int32_t size) {
    // 0x10000380c
    return _malloc(size);
}

// Address range: 0x100003818 - 0x100003824
int64_t * function_100003818(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003818
    return _memcpy(dest, src, n);
}

// Address range: 0x100003824 - 0x100003830
int32_t function_100003824(char * format, ...) {
    // 0x100003824
    return _printf(format);
}

// Address range: 0x100003830 - 0x10000383c
void function_100003830(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003830
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x10000383c - 0x100003848
int64_t * function_10000383c(int64_t * ptr, int32_t size) {
    // 0x10000383c
    return _realloc(ptr, size);
}

// Address range: 0x100003848 - 0x100003854
char * function_100003848(int32_t category, char * locale) {
    // 0x100003848
    return _setlocale(category, locale);
}

// Address range: 0x100003854 - 0x100003860
int32_t function_100003854(int32_t wc) {
    // 0x100003854
    return _towlower(wc);
}

// Address range: 0x100003860 - 0x10000386c
int32_t function_100003860(int16_t * s1, int16_t * s2) {
    // 0x100003860
    return _wcscmp(s1, s2);
}

// Address range: 0x10000386c - 0x100003878
int32_t function_10000386c(int16_t * s) {
    // 0x10000386c
    return _wcslen(s);
}

// Address range: 0x100003878 - 0x100003884
int32_t function_100003878(int16_t * s1, int16_t * s2, int32_t n) {
    // 0x100003878
    return _wcsncasecmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 31

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>

int cmpstr(const void *a, const void *b)
{
    return strcmp(*(const char**)a, *(const char**)b);
}

int main(void)
{
    DIR *basedir;
    char path[PATH_MAX];
    struct dirent *entry;
    char **dirnames;
    int diralloc = 128;
    int dirsize  = 0;

    if (!(dirnames = malloc(diralloc * sizeof(char*)))) {
        perror("malloc error:");
        return 1;
    }

    if (!getcwd(path, PATH_MAX)) {
        perror("getcwd error:");
        return 1;
    }

    if (!(basedir = opendir(path))) {
        perror("opendir error:");
        return 1;
    }

    while ((entry = readdir(basedir))) {
        if (dirsize >= diralloc) {
            diralloc *= 2;
            if (!(dirnames = realloc(dirnames, diralloc * sizeof(char*)))) {
                perror("realloc error:");
                return 1;
            }
        }
        dirnames[dirsize++] = strdup(entry->d_name);
    }

    qsort(dirnames, dirsize, sizeof(char*), cmpstr);

    int i;
    for (i = 0; i < dirsize; ++i) {
        if (dirnames[i][0] != '.') {
            printf("%s\n", dirnames[i]);
        }
    }

    for (i = 0; i < dirsize; ++i)
        free(dirnames[i]);
    free(dirnames);
    closedir(basedir);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd8(void);
int64_t function_100003ec4(int64_t a1);
int32_t function_100003ed0(struct __dirstream * dirp);
void function_100003edc(int64_t * ptr);
char * function_100003ee8(char * buf, int32_t size);
int64_t * function_100003ef4(int32_t size);
struct __dirstream * function_100003f00(char * name);
void function_100003f0c(char * s);
int32_t function_100003f18(char * format, ...);
void function_100003f24(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
struct dirent * function_100003f30(struct __dirstream * dirp);
int64_t * function_100003f3c(int64_t * ptr, int32_t size);
int32_t function_100003f48(char * s1, char * s2);
char * function_100003f54(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _closedir(struct __dirstream * a1);
void _free(int64_t * a1);
char * _getcwd(char * a1, int32_t a2);
int64_t * _malloc(int32_t a1);
struct __dirstream * _opendir(char * a1);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
struct dirent * _readdir(struct __dirstream * a1);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bd8 - 0x100003c0c
int64_t function_100003bd8(void) {
    // 0x100003bd8
    int64_t v1; // 0x100003bd8
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003c0c - 0x100003ec4
int64_t entry_point(void) {
    int64_t * v1 = _malloc(1024); // 0x100003c44
    int64_t result; // 0x100003c0c
    int64_t v2; // 0x100003c0c
    if (v1 == NULL) {
        // 0x100003c60
        _perror("malloc error:");
        result = 1;
        v2 = &g1;
    } else {
        // 0x100003c78
        int64_t v3; // bp-1056, 0x100003c0c
        if (_getcwd((char *)&v3, 1024) == NULL) {
            // 0x100003c94
            _perror("getcwd error:");
            result = 1;
            v2 = &g1;
        } else {
            struct __dirstream * v4 = _opendir((char *)&v3); // 0x100003cb0
            if (v4 == NULL) {
                // 0x100003ccc
                _perror("opendir error:");
                result = 1;
                v2 = &g1;
            } else {
                int64_t v5 = (int64_t)v1; // 0x100003c44
                struct dirent * v6 = _readdir(v4); // 0x100003cec
                struct dirent * v7 = v6; // 0x100003d00
                int64_t v8 = v5; // 0x100003d00
                int64_t v9 = 0; // 0x100003d00
                int32_t v10 = 128; // 0x100003d00
                int64_t v11 = 0; // 0x100003d00
                int64_t v12 = v5; // 0x100003d00
                if (v6 == NULL) {
                  lab_0x100003d98:;
                    int64_t v13 = 0x100000000 * v11 >> 32; // 0x100003d9c
                    int64_t * v14 = (int64_t *)v12; // 0x100003dac
                    _qsort(v14, (int32_t)v13, 8, (int32_t (*)(int64_t *, int64_t *))0x100003bd8);
                    int32_t v15 = v11; // 0x100003dbc
                    int32_t v16 = -v15;
                    if (v16 < 0 != (v16 & v15) < 0) {
                        int32_t v17 = 0; // 0x100003e1c
                        int64_t v18 = *(int64_t *)(8 * (int64_t)v17 + v12); // 0x100003dd8
                        if (*(char *)v18 != 46) {
                            // 0x100003df0
                            _printf("%s\n", (char *)v13);
                        }
                        // 0x100003e18
                        v17++;
                        int32_t v19 = v17 - v15; // 0x100003dc0
                        int32_t v20 = 0; // 0x100003dc8
                        while (v19 < 0 != ((v19 ^ v17) & (v17 ^ v15)) < 0) {
                            // 0x100003dd0
                            v18 = *(int64_t *)(8 * (int64_t)v17 + v12);
                            if (*(char *)v18 != 46) {
                                // 0x100003df0
                                _printf("%s\n", (char *)v13);
                            }
                            // 0x100003e18
                            v17++;
                            v19 = v17 - v15;
                            v20 = 0;
                        }
                        int64_t v21 = *(int64_t *)(8 * (int64_t)v20 + v12); // 0x100003e50
                        _free((int64_t *)v21);
                        int32_t v22 = v20 + 1; // 0x100003e60
                        int32_t v23 = v22 - v15; // 0x100003e38
                        v20 = v22;
                        while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v15)) < 0) {
                            // 0x100003e48
                            v21 = *(int64_t *)(8 * (int64_t)v20 + v12);
                            _free((int64_t *)v21);
                            v22 = v20 + 1;
                            v23 = v22 - v15;
                            v20 = v22;
                        }
                    }
                    // 0x100003e6c
                    _free(v14);
                    result = 0;
                    v2 = _closedir(v4);
                } else {
                    while (true) {
                        int32_t v24 = v10;
                        int64_t v25 = v8;
                        int32_t v26 = v9; // 0x100003d08
                        int32_t v27 = v26 - v24; // 0x100003d10
                        int32_t v28 = v24; // 0x100003d18
                        int64_t v29 = v25; // 0x100003d18
                        if (v27 < 0 == ((v27 ^ v26) & (v24 ^ v26)) < 0) {
                            int64_t * v30 = _realloc((int64_t *)v25, 16 * v24); // 0x100003d38
                            v28 = 2 * v24;
                            v29 = (int64_t)v30;
                            if (v30 == NULL) {
                                // break -> 0x100003d54
                                break;
                            }
                        }
                        char * v31 = _strdup((char *)((int64_t)v7 + 21)); // 0x100003d78
                        int64_t v32 = v9 + 1 & 0xffffffff;
                        *(int64_t *)(v29 + (0x100000000 * v9 >> 29)) = (int64_t)v31;
                        struct dirent * v33 = _readdir(v4); // 0x100003cec
                        v7 = v33;
                        v8 = v29;
                        v9 = v32;
                        v10 = v28;
                        v11 = v32;
                        v12 = v29;
                        if (v33 == NULL) {
                            goto lab_0x100003d98;
                        }
                    }
                    // 0x100003d54
                    _perror("realloc error:");
                    result = 1;
                    v2 = &g1;
                }
            }
        }
    }
    int64_t v34 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e98
    if (v34 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003eac
        ___stack_chk_fail(v2);
    }
    // 0x100003eb0
    return result;
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t function_100003ec4(int64_t a1) {
    // 0x100003ec4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(struct __dirstream * dirp) {
    // 0x100003ed0
    return _closedir(dirp);
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(int64_t * ptr) {
    // 0x100003edc
    _free(ptr);
}

// Address range: 0x100003ee8 - 0x100003ef4
char * function_100003ee8(char * buf, int32_t size) {
    // 0x100003ee8
    return _getcwd(buf, size);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t * function_100003ef4(int32_t size) {
    // 0x100003ef4
    return _malloc(size);
}

// Address range: 0x100003f00 - 0x100003f0c
struct __dirstream * function_100003f00(char * name) {
    // 0x100003f00
    return _opendir(name);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(char * s) {
    // 0x100003f0c
    _perror(s);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// Address range: 0x100003f24 - 0x100003f30
void function_100003f24(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f24
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f30 - 0x100003f3c
struct dirent * function_100003f30(struct __dirstream * dirp) {
    // 0x100003f30
    return _readdir(dirp);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * ptr, int32_t size) {
    // 0x100003f3c
    return _realloc(ptr, size);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * s1, char * s2) {
    // 0x100003f48
    return _strcmp(s1, s2);
}

// Address range: 0x100003f54 - 0x100003f60
char * function_100003f54(char * s) {
    // 0x100003f54
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <stdio.h> //printf()
#include <stdlib.h> //srand(), rand(), RAND_MAX, qsort()
#include <stdbool.h> //true, false
#include <time.h> //time()

#define NUMBALLS 5 //NUMBALLS>1

int compar(const void *a, const void *b){
	char c1=*(const char*)a, c2=*(const char*)b; //first cast void* to char*, then dereference
	return c1-c2;
}

_Bool issorted(char *balls){
	int i,state;
	state=0;
	for(i=0;i<NUMBALLS;i++){
		if(balls[i]<state)return false;
		if(balls[i]>state)state=balls[i];
	}
	return true;
}

void printout(char *balls){
	int i;
	char str[NUMBALLS+1];
	for(i=0;i<NUMBALLS;i++)str[i]=balls[i]==0?'r':balls[i]==1?'w':'b';
	printf("%s\n",str);
}

int main(void) {
	char balls[NUMBALLS]; //0=r, 1=w, 2=b
	int i;
	srand(time(NULL)); //not a good seed but good enough for the example
	rand(); //rand() always starts with the same values for certain seeds, making
	        //  testing pretty irritating
	// Generate balls
	for(i=0;i<NUMBALLS;i++)balls[i]=(double)rand()/RAND_MAX*3;
	while(issorted(balls)){ //enforce that we start with non-sorted balls
		printf("Accidentally still sorted: ");
		printout(balls);
		for(i=0;i<NUMBALLS;i++)balls[i]=(double)rand()/RAND_MAX*3;
	}
	printf("Non-sorted: ");
	printout(balls);
	qsort(balls,NUMBALLS,sizeof(char),compar); //sort them using quicksort (stdlib)
	if(issorted(balls)){ //unnecessary check but task enforces it
		printf("Sorted: ");
		printout(balls);
	} else {
		printf("Sort failed: ");
		printout(balls);
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bc4(void);
int64_t function_100003bfc(void);
int64_t function_100003cc4(void);
int32_t function_100003f14(char * format, ...);
void function_100003f20(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003f2c(void);
void function_100003f38(int32_t seed);
int32_t function_100003f44(int32_t * timer);

// --------------------- Global Variables ---------------------

float64_t g1 = 2147483647.0; // 0x100003f50

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bc4 - 0x100003bfc
int64_t function_100003bc4(void) {
    // 0x100003bc4
    return 0;
}

// Address range: 0x100003bfc - 0x100003cc4
int64_t function_100003bfc(void) {
    int32_t v1 = 0; // 0x100003bfc
    int32_t v2 = 0;
    int64_t v3; // 0x100003bfc
    int32_t v4 = (int32_t)*(char *)(v3 + (int64_t)v2); // 0x100003c2c
    int32_t v5 = v4 - v1; // 0x100003c34
    int64_t result = 0; // 0x100003c3c
    while (v5 < 0 == ((v5 ^ v4) & (v1 ^ v4)) < 0) {
        int32_t v6 = v2 + 1; // 0x100003c94
        v1 = v5 == 0 ? v1 : v4;
        result = 1;
        if (v2 < 4 == (3 - v2 & v6) < 0) {
            // break -> 0x100003cb4
            break;
        }
        v2 = v6;
        v4 = (int32_t)*(char *)(v3 + (int64_t)v2);
        v5 = v4 - v1;
        result = 0;
    }
    // 0x100003cb4
    return result;
}

// Address range: 0x100003cc4 - 0x100003d90
int64_t function_100003cc4(void) {
    int64_t v1; // 0x100003cc4
    for (int64_t i = 0; i < 5; i++) {
        char v2 = *(char *)(i + v1); // 0x100003cf8
        char v3 = 114; // 0x100003d04
        if (v2 != 0) {
            // 0x100003d18
            v3 = v2 != 1 ? 98 : 119;
        }
        // 0x100003d48
        int64_t v4; // bp-34, 0x100003cc4
        *(char *)(i + (int64_t)&v4) = v3;
    }
    // 0x100003d6c
    return _printf("%s\n", (char *)v1);
}

// Address range: 0x100003d90 - 0x100003f14
int64_t entry_point(void) {
    // 0x100003d90
    _srand(_time(NULL));
    _rand();
    int64_t v1; // bp-25, 0x100003d90
    int64_t v2 = &v1;
    for (int64_t i = 0; i < 5; i++) {
        int32_t v3 = _rand(); // 0x100003dcc
        *(char *)(i + v2) = (char)(int32_t)(3.0 * (float64_t)v3 / g1);
    }
    // 0x100003e10
    if (function_100003bfc() % 2 != 0) {
        _printf("Accidentally still sorted: ");
        function_100003cc4();
        int32_t v4; // 0x100003e50
        for (int64_t i = 0; i < 5; i++) {
            // 0x100003e50
            v4 = _rand();
            *(char *)(i + v2) = (char)(int32_t)(3.0 * (float64_t)v4 / g1);
        }
        while (function_100003bfc() % 2 != 0) {
            // 0x100003e20
            _printf("Accidentally still sorted: ");
            function_100003cc4();
            for (int64_t i = 0; i < 5; i++) {
                // 0x100003e50
                v4 = _rand();
                *(char *)(i + v2) = (char)(int32_t)(3.0 * (float64_t)v4 / g1);
            }
        }
    }
    // 0x100003e94
    _printf("Non-sorted: ");
    function_100003cc4();
    _qsort(&v1, 5, 1, (int32_t (*)(int64_t *, int64_t *))0x100003bc4);
    if (function_100003bfc() % 2 == 0) {
        // 0x100003eec
        _printf("Sort failed: ");
        function_100003cc4();
    } else {
        // 0x100003ed4
        _printf("Sorted: ");
        function_100003cc4();
    }
    // 0x100003f04
    return 0;
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * format, ...) {
    // 0x100003f14
    return _printf(format);
}

// Address range: 0x100003f20 - 0x100003f2c
void function_100003f20(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f20
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(void) {
    // 0x100003f2c
    return _rand();
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t seed) {
    // 0x100003f38
    _srand(seed);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(int32_t * timer) {
    // 0x100003f44
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

int i;
double sum(int *i, int lo, int hi, double (*term)()) {
    double temp = 0;
    for (*i = lo; *i <= hi; (*i)++)
        temp += term();
    return temp;
}

double term_func() { return 1.0 / i; }

int main () {
    printf("%f\n", sum(&i, 1, 100, term_func));
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e84(int64_t a1);
int128_t function_100003f14(void);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e84 - 0x100003f14
int64_t function_100003e84(int64_t a1) {
    // 0x100003e84
    int64_t result; // 0x100003e84
    *(int32_t *)result = (int32_t)result;
    return result;
}

// Address range: 0x100003f14 - 0x100003f38
int128_t function_100003f14(void) {
    // 0x100003f14
    return __asm_sshll(0.0f, 0);
}

// Address range: 0x100003f38 - 0x100003f90
int64_t entry_point(void) {
    // 0x100003f38
    function_100003e84(0);
    int128_t v1; // 0x100003f38
    _printf("%f\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

typedef int bool;

int next_in_cycle(int *c, int len, int index) {
    return c[index % len];
}

void kolakoski(int *c, int *s, int clen, int slen) {
    int i = 0, j, k = 0;
    while (TRUE) {
        s[i] = next_in_cycle(c, clen, k);
        if (s[k] > 1) {
            for (j = 1; j < s[k]; ++j) {
                if (++i == slen) return;
                s[i] = s[i - 1];
            }
        }
        if (++i == slen) return;
        k++;
    }
}

bool possible_kolakoski(int *s, int len) {
    int i, j = 0, prev = s[0], count = 1;
    int *rle = calloc(len, sizeof(int));
    bool result = TRUE;
    for (i = 1; i < len; ++i) {
        if (s[i] == prev) {
            count++;
        }
        else {
            rle[j++] = count;
            count = 1;
            prev = s[i];
        }
    }
    /* no point adding final 'count' to rle as we're not going to compare it anyway */
    for (i = 0; i < j; i++) {
        if (rle[i] != s[i]) {
           result = FALSE;
           break;
        }
    }
    free(rle);
    return result;
}

void print_array(int *a, int len) {
    int i;
    printf("[");
    for (i = 0; i < len; ++i) {
       printf("%d", a[i]);
       if (i < len - 1) printf(", ");
    }
    printf("]");
}

int main() {
    int i, clen, slen, *s;
    int c0[2] = {1, 2};
    int c1[2] = {2, 1};
    int c2[4] = {1, 3, 1, 2};
    int c3[4] = {1, 3, 2, 1};
    int *cs[4] = {c0, c1, c2, c3};
    bool p;
    int clens[4] = {2, 2, 4, 4};
    int slens[4] = {20, 20, 30, 30};
    for (i = 0; i < 4; ++i) {
        clen = clens[i];
        slen = slens[i];
        s = calloc(slen, sizeof(int));
        kolakoski(cs[i], s, clen, slen);
        printf("First %d members of the sequence generated by ", slen);
        print_array(cs[i], clen);
        printf(":\n");
        print_array(s, slen);
        printf("\n");
        p = possible_kolakoski(s, slen);
        printf("Possible Kolakoski sequence? %s\n\n", p ? "True" : "False");
        free(s);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003940(void);
int64_t function_100003974(void);
int64_t function_100003a98(void);
int64_t function_100003bf8(void);
int64_t function_100003eb4(void);
int64_t * function_100003ec0(int32_t nmemb, int32_t size);
void function_100003ecc(int64_t * ptr);
int32_t function_100003ed8(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.24399158291867592190525751807955525e-313L; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003940 - 0x100003974
int64_t function_100003940(void) {
    // 0x100003940
    int64_t v1; // 0x100003940
    uint32_t result = *(int32_t *)(v1 + (int64_t)(4 * ((int32_t)v1 % (int32_t)v1))); // 0x100003968
    return result;
}

// Address range: 0x100003974 - 0x100003a98
int64_t function_100003974(void) {
    // 0x100003974
    int64_t v1; // 0x100003974
    int32_t v2 = v1; // 0x10000398c
    int32_t v3 = 0; // 0x100003998
    int32_t v4 = 0;
    int64_t result = function_100003940(); // 0x1000039a8
    *(int32_t *)(4 * (int64_t)v4 + v1) = (int32_t)result;
    int32_t * v5 = (int32_t *)(4 * (int64_t)v3 + v1); // 0x1000039c0
    int32_t v6 = *v5; // 0x1000039c0
    int32_t v7 = v6 - 1; // 0x1000039c4
    int32_t v8; // 0x100003974
    int32_t v9; // 0x100003974
    int32_t v10; // 0x1000039f0
    int32_t v11; // 0x100003a04
    int32_t v12; // 0x100003a30
    int32_t v13; // 0x100003a48
    int32_t v14; // 0x1000039ec
    int32_t v15; // 0x1000039f0
    if (v7 != 0 && v7 < 0 == (v6 & -v6) < 0) {
        // 0x1000039e0
        v10 = 1 - v6;
        v9 = 1;
        v8 = v4;
        if (v10 < 0 != (v10 & v6) < 0) {
            v11 = v8 + 1;
            while (v11 != v2) {
                // 0x100003a24
                v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 - 4));
                *(int32_t *)(4 * (int64_t)v11 + v1) = v12;
                v13 = v9 + 1;
                v14 = *v5;
                v15 = v13 - v14;
                v9 = v13;
                if (v15 < 0 == ((v15 ^ v13) & (v14 ^ v13)) < 0) {
                    // break -> 0x100003a58
                    break;
                }
                v11++;
            }
            return result;
        }
    }
    int32_t v16 = v4 + 1; // 0x100003a5c
    v3++;
    while (v16 != v2) {
        // 0x10000399c
        v4 = v16;
        result = function_100003940();
        *(int32_t *)(4 * (int64_t)v4 + v1) = (int32_t)result;
        v5 = (int32_t *)(4 * (int64_t)v3 + v1);
        v6 = *v5;
        v7 = v6 - 1;
        if (v7 != 0 && v7 < 0 == (v6 & -v6) < 0) {
            // 0x1000039e0
            v10 = 1 - v6;
            v9 = 1;
            v8 = v4;
            if (v10 < 0 != (v10 & v6) < 0) {
                v11 = v8 + 1;
                while (v11 != v2) {
                    // 0x100003a24
                    v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 - 4));
                    *(int32_t *)(4 * (int64_t)v11 + v1) = v12;
                    v13 = v9 + 1;
                    v14 = *v5;
                    v15 = v13 - v14;
                    v9 = v13;
                    if (v15 < 0 == ((v15 ^ v13) & (v14 ^ v13)) < 0) {
                        // break -> 0x100003a58
                        break;
                    }
                    v11++;
                }
                return result;
            }
        }
        // 0x100003a58
        v16 = v4 + 1;
        v3++;
    }
    // 0x100003a8c
    return result;
}

// Address range: 0x100003a98 - 0x100003bf8
int64_t function_100003a98(void) {
    // 0x100003a98
    int64_t v1; // 0x100003a98
    int32_t v2 = v1; // 0x100003aa8
    int64_t * v3 = _calloc(v2, 4); // 0x100003ad0
    int64_t v4 = (int64_t)v3; // 0x100003ad0
    int32_t v5 = 1 - v2; // 0x100003af0
    int32_t v6 = 0; // 0x100003af8
    if (v5 < 0 != (v5 & v2) < 0) {
        int32_t v7 = 1; // 0x100003b70
        int32_t v8 = 0;
        int32_t v9 = v1;
        int32_t v10 = 1;
        int32_t * v11 = (int32_t *)(4 * (int64_t)v7 + v1); // 0x100003b08
        int32_t v12; // 0x100003a98
        int32_t v13; // 0x100003a98
        int32_t v14; // 0x100003a98
        if (*v11 == v9) {
            // 0x100003b20
            v12 = v8;
            v13 = v9;
            v14 = v10 + 1;
        } else {
            // 0x100003b30
            *(int32_t *)(4 * (int64_t)v8 + v4) = v10;
            v12 = v8 + 1;
            v13 = *v11;
            v14 = 1;
        }
        int32_t v15 = v12;
        v7++;
        int32_t v16 = v7 - v2; // 0x100003af0
        v6 = v15;
        while (v16 < 0 != ((v16 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003b00
            v8 = v15;
            v9 = v13;
            v10 = v14;
            v11 = (int32_t *)(4 * (int64_t)v7 + v1);
            if (*v11 == v9) {
                // 0x100003b20
                v12 = v8;
                v13 = v9;
                v14 = v10 + 1;
            } else {
                // 0x100003b30
                *(int32_t *)(4 * (int64_t)v8 + v4) = v10;
                v12 = v8 + 1;
                v13 = *v11;
                v14 = 1;
            }
            // 0x100003b6c
            v15 = v12;
            v7++;
            v16 = v7 - v2;
            v6 = v15;
        }
    }
    int32_t v17 = -v6; // 0x100003b8c
    int32_t v18 = 0; // 0x100003b94
    if (v17 < 0 == (v6 & v17) < 0) {
        // 0x100003be0
        _free(v3);
        return 1;
    }
    int64_t v19 = 4 * (int64_t)v18; // 0x100003ba4
    int64_t result = 0; // 0x100003bbc
    while (*(int32_t *)(v19 + v4) == *(int32_t *)(v19 + v1)) {
        // 0x100003b84
        v18++;
        int32_t v20 = v18 - v6; // 0x100003b8c
        result = 1;
        if (v20 < 0 == ((v20 ^ v18) & (v18 ^ v6)) < 0) {
            // break -> 0x100003be0
            break;
        }
        v19 = 4 * (int64_t)v18;
        result = 0;
    }
    // 0x100003be0
    _free(v3);
    return result;
}

// Address range: 0x100003bf8 - 0x100003cb4
int64_t function_100003bf8(void) {
    // 0x100003bf8
    int64_t v1; // 0x100003bf8
    int32_t v2 = v1; // 0x100003c08
    _printf("[");
    int32_t v3 = -v2; // 0x100003c28
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003c9c
        return _printf("]");
    }
    int32_t v4 = v2 - 1;
    int32_t v5 = 0;
    _printf("%d", v1);
    int32_t v6 = v5 - v4; // 0x100003c68
    if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
        // 0x100003c78
        _printf(", ");
    }
    int32_t v7 = v5 + 1; // 0x100003c90
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003c38
        v5 = v7;
        _printf("%d", v1);
        v6 = v5 - v4;
        if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
            // 0x100003c78
            _printf(", ");
        }
        // 0x100003c8c
        v7 = v5 + 1;
    }
    // 0x100003c9c
    return _printf("]");
}

// Address range: 0x100003cb4 - 0x100003eb4
int64_t entry_point(void) {
    float128_t v1 = g1; // bp-144, 0x100003d54
    for (int64_t i = 0; i < 4; i++) {
        uint32_t v2 = *(int32_t *)(4 * i + (int64_t)&v1); // 0x100003d8c
        int64_t * v3 = _calloc(v2, 4); // 0x100003d9c
        function_100003974();
        _printf("First %d members of the sequence generated by ", (int64_t)v3);
        function_100003bf8();
        _printf(":\n");
        function_100003bf8();
        _printf("\n");
        function_100003a98();
        _printf("Possible Kolakoski sequence? %s\n\n", (char *)(int64_t)v2);
        _free(v3);
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e8c
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ea0
        ___stack_chk_fail();
    }
    // 0x100003ea4
    return 0;
}

// Address range: 0x100003eb4 - 0x100003ec0
int64_t function_100003eb4(void) {
    // 0x100003eb4
    return ___stack_chk_fail();
}

// Address range: 0x100003ec0 - 0x100003ecc
int64_t * function_100003ec0(int32_t nmemb, int32_t size) {
    // 0x100003ec0
    return _calloc(nmemb, size);
}

// Address range: 0x100003ecc - 0x100003ed8
void function_100003ecc(int64_t * ptr) {
    // 0x100003ecc
    _free(ptr);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(char * format, ...) {
    // 0x100003ed8
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>

size_t rprint(char *s, int *x, int len)
{
#define sep (a > s ? "," : "") /* use comma except before first output */
#define ol (s ? 100 : 0)       /* print only if not testing for length */
	int i, j;
	char *a = s;
	for (i = j = 0; i < len; i = ++j) {
		for (; j < len - 1 && x[j + 1] == x[j] + 1; j++);

		if (i + 1 < j)
			a += snprintf(s?a:s, ol, "%s%d-%d", sep, x[i], x[j]);
		else
			while (i <= j)
				a += snprintf(s?a:s, ol, "%s%d", sep, x[i++]);
	}
	return a - s;
#undef sep
#undef ol
}

int main()
{
	int x[] = {	0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
			15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
			25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
			37, 38, 39 };

	char *s = malloc(rprint(0, x, sizeof(x) / sizeof(int)) + 1);
	rprint(s, x, sizeof(x) / sizeof(int));
	printf("%s\n", s);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003af8(void);
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int64_t function_100003ee0(int64_t a1);
int64_t * function_100003eec(int32_t size);
int64_t * function_100003ef8(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f04(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000000; // 0x100003f24

// ------- Dynamically Linked Functions Without Header --------

int64_t ___snprintf_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003af8 - 0x100003e20
int64_t function_100003af8(void) {
    // 0x100003af8
    int64_t v1; // 0x100003af8
    int32_t v2 = v1; // 0x100003b0c
    int32_t v3 = -v2; // 0x100003b2c
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e08
        int64_t v4; // 0x100003af8
        return v4 - v1;
    }
    int32_t v5 = v2 - 1; // 0x100003b48
    int64_t v6 = v1 == 0 ? 0 : 100;
    int32_t v7 = 0;
    int32_t v8 = v7 - v5; // 0x100003b4c
    int32_t v9 = v7; // 0x100003b5c
    int32_t v10 = v7; // 0x100003b5c
    int32_t v11; // 0x100003af8
    int32_t v12; // 0x100003b70
    int32_t v13; // 0x100003ba8
    int32_t v14; // 0x100003b4c
    if (v8 < 0 != ((v8 ^ v7) & (v7 ^ v5)) < 0) {
        v11 = v9;
        v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
        v10 = v11;
        while (v12 == *(int32_t *)(4 * (int64_t)v11 + v1) + 1) {
            // 0x100003ba4
            v13 = v11 + 1;
            v14 = v13 - v5;
            v9 = v13;
            v10 = v13;
            if (v14 < 0 == ((v14 ^ v13) & (v13 ^ v5)) < 0) {
                // break -> 0x100003bb4
                break;
            }
            v11 = v9;
            v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
            v10 = v11;
        }
    }
    int32_t v15 = v10;
    int32_t v16 = v7 + 1; // 0x100003bb8
    int32_t v17 = v16 - v15; // 0x100003bc0
    int32_t v18; // 0x100003af8
    int64_t v19; // 0x100003af8
    int64_t v20; // 0x100003af8
    int64_t v21; // 0x100003af8
    int64_t v22; // 0x100003af8
    int64_t v23; // 0x100003af8
    int32_t v24; // 0x100003ce0
    int32_t v25; // 0x100003dac
    int64_t v26; // 0x100003de0
    int32_t v27; // 0x100003ce0
    if (v17 < 0 == ((v17 ^ v16) & (v15 ^ v16)) < 0) {
        // 0x100003cd8
        v24 = v7 - v15;
        v18 = v7;
        v21 = v19;
        if (v24 == 0 || v24 < 0 != ((v24 ^ v7) & (v15 ^ v7)) < 0) {
            v23 = v1 == 0 ? 0 : v19;
            v25 = v18 + 1;
            v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v19;
            v27 = v25 - v15;
            v18 = v25;
            v20 = v26;
            v21 = v26;
            while (v27 == 0 || v27 < 0 != ((v27 ^ v25) & (v25 ^ v15)) < 0) {
                // 0x100003cf0
                v23 = v1 == 0 ? 0 : v20;
                v25 = v18 + 1;
                v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v20;
                v27 = v25 - v15;
                v18 = v25;
                v20 = v26;
                v21 = v26;
            }
        }
    } else {
        // 0x100003bd0
        v22 = v1 == 0 ? 0 : v19;
        v21 = (0x100000000 * ___snprintf_chk(v22, v6, 0, -1, "%s%d-%d") >> 32) + v19;
    }
    int32_t v28 = v15 + 1; // 0x100003df8
    int32_t v29 = v28 - v2; // 0x100003b2c
    while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v2)) < 0) {
        int64_t v30 = v21;
        v7 = v28;
        v8 = v7 - v5;
        v9 = v7;
        v10 = v7;
        if (v8 < 0 != ((v8 ^ v7) & (v7 ^ v5)) < 0) {
            v11 = v9;
            v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
            v10 = v11;
            while (v12 == *(int32_t *)(4 * (int64_t)v11 + v1) + 1) {
                // 0x100003ba4
                v13 = v11 + 1;
                v14 = v13 - v5;
                v9 = v13;
                v10 = v13;
                if (v14 < 0 == ((v14 ^ v13) & (v13 ^ v5)) < 0) {
                    // break -> 0x100003bb4
                    break;
                }
                v11 = v9;
                v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
                v10 = v11;
            }
        }
        // 0x100003bb4
        v15 = v10;
        v16 = v7 + 1;
        v17 = v16 - v15;
        if (v17 < 0 == ((v17 ^ v16) & (v15 ^ v16)) < 0) {
            // 0x100003cd8
            v24 = v7 - v15;
            v18 = v7;
            v20 = v30;
            v21 = v30;
            if (v24 == 0 || v24 < 0 != ((v24 ^ v7) & (v15 ^ v7)) < 0) {
                v23 = v1 == 0 ? 0 : v20;
                v25 = v18 + 1;
                v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v20;
                v27 = v25 - v15;
                v18 = v25;
                v20 = v26;
                v21 = v26;
                while (v27 == 0 || v27 < 0 != ((v27 ^ v25) & (v25 ^ v15)) < 0) {
                    // 0x100003cf0
                    v23 = v1 == 0 ? 0 : v20;
                    v25 = v18 + 1;
                    v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v20;
                    v27 = v25 - v15;
                    v18 = v25;
                    v20 = v26;
                    v21 = v26;
                }
            }
        } else {
            // 0x100003bd0
            v22 = v1 == 0 ? 0 : v30;
            v21 = (0x100000000 * ___snprintf_chk(v22, v6, 0, -1, "%s%d-%d") >> 32) + v30;
        }
        // 0x100003df4
        v28 = v15 + 1;
        v29 = v28 - v2;
    }
    // 0x100003e08
    return v21 - v1;
}

// Address range: 0x100003e20 - 0x100003ed4
int64_t entry_point(void) {
    // 0x100003e20
    int64_t v1; // bp-156, 0x100003e20
    _memcpy(&v1, &g1, 132);
    _malloc((int32_t)function_100003af8() + 1);
    function_100003af8();
    int32_t v2 = _printf("%s\n", &v1); // 0x100003e9c
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003eac
    if (v3 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003ec0
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003ec4
    return 0;
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5) {
    // 0x100003ed4
    return ___snprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t function_100003ee0(int64_t a1) {
    // 0x100003ee0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003eec - 0x100003ef8
int64_t * function_100003eec(int32_t size) {
    // 0x100003eec
    return _malloc(size);
}

// Address range: 0x100003ef8 - 0x100003f04
int64_t * function_100003ef8(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ef8
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(char * format, ...) {
    // 0x100003f04
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

int dsum(int n)
{
	int sum, x;
	for (sum = 0; n; n /= 10) x = n % 10, sum += x * x;
	return sum;
}

int happy(int n)
{
	int nn;
	while (n > 999) n = dsum(n); /* 4 digit numbers can't cycle */
	nn = dsum(n);
	while (nn != n && nn != 1)
		n = dsum(n), nn = dsum(dsum(nn));
	return n == 1;
}

int main()
{
	int i, cnt = 8;
	for (i = 1; cnt || !printf("\n"); i++)
		if (happy(i)) --cnt, printf("%d ", i);

	printf("The %dth happy number: ", cnt = 1000000);
	for (i = 1; cnt; i++)
		if (happy(i)) --cnt || printf("%d\n", i);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cb0(void);
int64_t function_100003d28(void);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cb0 - 0x100003d28
int64_t function_100003cb0(void) {
    // 0x100003cb0
    int64_t v1; // 0x100003cb0
    int32_t v2 = v1; // 0x100003cb4
    int32_t v3 = v2; // 0x100003ccc
    if (v2 == 0) {
        // 0x100003d1c
        return 0;
    }
    int32_t result = 0; // 0x100003ccc
    int32_t v4 = v3 % 10;
    result += v4 * v4;
    while (v3 >= 10) {
        // 0x100003cd4
        v3 /= 10;
        v4 = v3 % 10;
        result += v4 * v4;
    }
    // 0x100003d1c
    return result;
}

// Address range: 0x100003d28 - 0x100003dec
int64_t function_100003d28(void) {
    int64_t v1; // 0x100003d28
    int32_t v2 = v1;
    int32_t v3 = v2 - 999; // 0x100003d40
    int64_t v4 = function_100003cb0();
    while (v3 != 0 && v3 < 0 == (998 - v2 & v2) < 0) {
        // 0x100003d3c
        v2 = v4;
        v3 = v2 - 999;
        v4 = function_100003cb0();
    }
    // 0x100003d70
    if (v2 != (int32_t)v4 != (int32_t)v4 != 1) {
        // 0x100003dd0
        return v2 == 1;
    }
    int32_t v5 = function_100003cb0();
    function_100003cb0();
    int32_t v6 = function_100003cb0();
    while (v5 != v6 == (v6 != 1)) {
        // 0x100003db0
        v5 = function_100003cb0();
        function_100003cb0();
        v6 = function_100003cb0();
    }
    // 0x100003dd0
    return v5 == 1;
}

// Address range: 0x100003dec - 0x100003f70
int64_t entry_point(void) {
    int32_t v1 = 8; // 0x100003e0c
    int64_t v2; // 0x100003dec
    while (true) {
        int32_t v3 = v1;
        if (v3 == 0) {
            // 0x100003e48
            if (_printf("\n") != 0) {
                // break -> 0x100003eac
                break;
            }
        }
        // 0x100003e54
        v1 = v3;
        if ((int32_t)function_100003d28() != 0) {
            // 0x100003e6c
            _printf("%d ", v2);
            v1 = v3 - 1;
        }
    }
    // 0x100003eac
    _printf("The %dth happy number: ", v2);
    int32_t v4 = 0xf4240; // 0x100003f10
    while (true) {
        int32_t v5 = v4;
        v4 = v5;
        if ((int32_t)function_100003d28() != 0) {
            // 0x100003f0c
            v4 = v5 - 1;
            if (v4 == 0) {
                // break -> 0x100003f60
                break;
            }
        }
    }
    // 0x100003f60
    _printf("%d\n", v2);
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

int even_sel(int x) { return !(x & 1); }
int tri_sel(int x) { return x % 3; }

/* using a predicate function sel() to select elements */
int* grep(int *in, int len, int *outlen, int (*sel)(int), int inplace)
{
	int i, j, *out;

	if (inplace)	out = in;
	else		out = malloc(sizeof(int) * len);

	for (i = j = 0; i < len; i++)
		if (sel(in[i]))
			out[j++] = in[i];

	if (!inplace && j < len)
		out = realloc(out, sizeof(int) * j);

	*outlen = j;
	return out;
}

int main()
{
	int in[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int i, len;

	int *even = grep(in, 10, &len, even_sel, 0);
	printf("Filtered even:");
	for (i = 0; i < len; i++) printf(" %d", even[i]);
	printf("\n");

	grep(in, 8, &len, tri_sel, 1);
	printf("In-place filtered not multiple of 3:");
	for (i = 0; i < len; i++) printf(" %d", in[i]);

	printf("\n");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bec(void);
int64_t function_100003c0c(void);
int64_t function_100003c30(int64_t a1);
int64_t function_100003f00(int64_t a1);
int64_t * function_100003f0c(int32_t size);
int64_t * function_100003f18(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f24(char * format, ...);
int64_t * function_100003f30(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x200000001; // 0x100003f3c
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bec - 0x100003c0c
int64_t function_100003bec(void) {
    // 0x100003bec
    int64_t v1; // 0x100003bec
    return (uint64_t)v1 % 2 == 0;
}

// Address range: 0x100003c0c - 0x100003c30
int64_t function_100003c0c(void) {
    // 0x100003c0c
    int64_t v1; // 0x100003c0c
    return (int32_t)v1 % 3;
}

// Address range: 0x100003c30 - 0x100003d70
int64_t function_100003c30(int64_t a1) {
    // 0x100003c30
    int64_t v1; // 0x100003c30
    int32_t v2 = v1; // 0x100003c40
    int64_t result; // 0x100003c30
    if ((int32_t)v1 == 0) {
        // 0x100003c70
        result = (int64_t)_malloc(4 * v2);
    }
    int32_t v3 = -v2; // 0x100003c9c
    if (v3 < 0 != (v2 & v3) < 0) {
        // 0x100003cac
        return (int64_t)*(int32_t *)v1;
    }
    // 0x100003d54
    *(int32_t *)v1 = 0;
    return result;
}

// Address range: 0x100003d70 - 0x100003f00
int64_t entry_point(void) {
    // 0x100003d70
    int64_t v1; // bp-64, 0x100003d70
    _memcpy(&v1, &g1, 40);
    function_100003c30((int64_t)&g2);
    _printf("Filtered even:");
    int32_t v2; // 0x100003d70
    int32_t v3 = -v2;
    int32_t v4 = 0; // 0x100003df4
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003ec0
        _printf("\n");
        function_100003c30((int64_t)&g2);
        _printf("In-place filtered not multiple of 3:");
    } else {
        _printf(" %d", 10);
        v4++;
        while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
            // 0x100003dfc
            _printf(" %d", 10);
            v4++;
        }
        // 0x100003e88
        _printf("\n");
        function_100003c30((int64_t)&g2);
        _printf("In-place filtered not multiple of 3:");
        int32_t v5 = 0; // 0x100003eb4
        _printf(" %d", 8);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003e88
            _printf(" %d", 8);
            v5++;
        }
    }
    int32_t v6 = _printf("\n"); // 0x100003ec8
    int64_t v7 = *(int64_t *)0x100004008; // 0x100003ed4
    if (*(int64_t *)v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003eec
        ___stack_chk_fail((int64_t)v6);
    }
    // 0x100003ef0
    return 0;
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t function_100003f00(int64_t a1) {
    // 0x100003f00
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t * function_100003f0c(int32_t size) {
    // 0x100003f0c
    return _malloc(size);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f18
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t * function_100003f30(int64_t * ptr, int32_t size) {
    // 0x100003f30
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

bool is_sorted(int *a, int n)
{
  while ( --n >= 1 ) {
    if ( a[n] < a[n-1] ) return false;
  }
  return true;
}

void shuffle(int *a, int n)
{
  int i, t, r;
  for(i=0; i < n; i++) {
    t = a[i];
    r = rand() % n;
    a[i] = a[r];
    a[r] = t;
  }
}

void bogosort(int *a, int n)
{
  while ( !is_sorted(a, n) ) shuffle(a, n);
}

int main()
{
  int numbers[] = { 1, 10, 9,  7, 3, 0 };
  int i;

  bogosort(numbers, 6);
  for (i=0; i < 6; i++) printf("%d ", numbers[i]);
  printf("\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cfc(void);
int64_t function_100003d90(void);
int64_t function_100003e34(void);
int64_t function_100003f5c(int64_t a1);
int32_t function_100003f68(char * format, ...);
int32_t function_100003f74(void);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003cfc - 0x100003d90
int64_t function_100003cfc(void) {
    // 0x100003cfc
    int64_t v1; // 0x100003cfc
    int32_t v2 = v1;
    int32_t v3 = v2 - 1; // 0x100003d10
    int64_t result = 1; // 0x100003d20
    while (v2 < 2 == (v3 & 1 - v2) < 0) {
        int32_t v4 = *(int32_t *)(4 * (int64_t)v3 + v1); // 0x100003d30
        int32_t v5 = *(int32_t *)(v1 + (int64_t)(4 * v3 - 4)); // 0x100003d40
        int32_t v6 = v4 - v5; // 0x100003d44
        result = 0;
        if (v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0) {
            // break -> 0x100003d80
            break;
        }
        v2 = v3;
        v3 = v2 - 1;
        result = 1;
    }
    // 0x100003d80
    return result;
}

// Address range: 0x100003d90 - 0x100003e34
int64_t function_100003d90(void) {
    // 0x100003d90
    int64_t v1; // 0x100003d90
    int32_t v2 = v1; // 0x100003da0
    int32_t v3 = -v2; // 0x100003db4
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e28
        int64_t result; // 0x100003d90
        return result;
    }
    int32_t v4 = 0; // 0x100003dbc
    int32_t * v5 = (int32_t *)(4 * (int64_t)v4 + v1); // 0x100003dcc
    int32_t result2 = _rand(); // 0x100003dd4
    int32_t * v6 = (int32_t *)(4 * (int64_t)(result2 % v2) + v1); // 0x100003df4
    *v5 = *v6;
    *v6 = *v5;
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003dc4
        v5 = (int32_t *)(4 * (int64_t)v4 + v1);
        result2 = _rand();
        v6 = (int32_t *)(4 * (int64_t)(result2 % v2) + v1);
        *v5 = *v6;
        *v6 = *v5;
        v4++;
    }
    // 0x100003e28
    return result2;
}

// Address range: 0x100003e34 - 0x100003e7c
int64_t function_100003e34(void) {
    int64_t result = function_100003cfc(); // 0x100003e54
    if (result % 2 != 0) {
        // 0x100003e70
        return result;
    }
    function_100003d90();
    int64_t result2 = function_100003cfc(); // 0x100003e54
    while (result2 % 2 == 0) {
        // 0x100003e60
        function_100003d90();
        result2 = function_100003cfc();
    }
    // 0x100003e70
    return result2;
}

// Address range: 0x100003e7c - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003e7c
    function_100003e34();
    for (int32_t i = 0; i < 6; i++) {
        // 0x100003edc
        _printf("%d ", 6);
    }
    int32_t v1 = _printf((char *)0x100003f9c); // 0x100003f1c
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f34
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f48
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f4c
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(int64_t a1) {
    // 0x100003f5c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(void) {
    // 0x100003f74
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

int main()
{
	fprintf(stderr, "Goodbye, ");
	fputs("World!\n", stderr);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f88(char * s, struct _IO_FILE * stream);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fputs(char * a1, struct _IO_FILE * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003f24 - 0x100003f7c
int64_t entry_point(void) {
    int64_t * v1 = (int64_t *)*(int64_t *)0x100004000; // 0x100003f48
    _fprintf((struct _IO_FILE *)*v1, "Goodbye, ");
    _fputs("World!\n", (struct _IO_FILE *)*v1);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f7c
    return _fprintf(stream, format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * s, struct _IO_FILE * stream) {
    // 0x100003f88
    return _fputs(s, stream);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

int SumDigits(unsigned long long n, const int base) {
    int sum = 0;
    for (; n; n /= base)
    	sum += n % base;
    return sum;
}

int main() {
    printf("%d %d %d %d %d\n",
        SumDigits(1, 10),
        SumDigits(12345, 10),
        SumDigits(123045, 10),
        SumDigits(0xfe, 16),
        SumDigits(0xf0e, 16) );
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e50(void);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e50 - 0x100003ebc
int64_t function_100003e50(void) {
    // 0x100003e50
    int64_t v1; // 0x100003e50
    if (v1 == 0) {
        // 0x100003eb0
        return 0;
    }
    uint64_t v2 = 0x100000000 * v1 >> 32; // 0x100003e7c
    int32_t result = 0; // 0x100003e94
    int64_t v3; // 0x100003e50
    uint64_t v4 = v3;
    result += (int32_t)(v4 % v2);
    v3 = v4 / v2;
    while (v2 <= v4) {
        // 0x100003e78
        v4 = v3;
        result += (int32_t)(v4 % v2);
        v3 = v4 / v2;
    }
    // 0x100003eb0
    return result;
}

// Address range: 0x100003ebc - 0x100003f84
int64_t entry_point(void) {
    // 0x100003ebc
    function_100003e50();
    function_100003e50();
    function_100003e50();
    function_100003e50();
    function_100003e50();
    int64_t v1; // 0x100003ebc
    _printf("%d %d %d %d %d\n", 16, v1, v1, v1, v1);
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

int droot(long long int x, int base, int *pers)
{
	int d = 0;
	if (pers)
		for (*pers = 0; x >= base; x = d, (*pers)++)
			for (d = 0; x; d += x % base, x /= base);
	else if (x && !(d = x % (base - 1)))
			d = base - 1;

	return d;
}

int main(void)
{
	int i, d, pers;
	long long x[] = {627615, 39390, 588225, 393900588225LL};

	for (i = 0; i < 4; i++) {
		d = droot(x[i], 10, &pers);
		printf("%lld: pers %d, root %d\n", x[i], pers, d);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d2c(void);
int64_t function_100003f50(void);
int32_t function_100003f5c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d2c - 0x100003e5c
int64_t function_100003d2c(void) {
    // 0x100003d2c
    int64_t v1; // 0x100003d2c
    int32_t v2 = v1; // 0x100003d30
    int32_t v3 = v1; // 0x100003d34
    if (v1 == 0) {
        int32_t result = 0; // 0x100003dfc
        if (v2 != 0) {
            int32_t v4 = (0x100000000 * v1 >> 32) % (0x100000000 * v1 - 0x100000000 >> 32); // 0x100003e28
            result = v4 == 0 ? v3 - 1 : v4;
        }
        // 0x100003e50
        return result;
    }
    int32_t * v5 = (int32_t *)v1; // 0x100003d38
    *v5 = 0;
    int64_t v6 = 0x100000000 * v1 >> 32; // 0x100003d60
    int64_t v7 = 0x100000000 * v1 >> 32; // 0x100003d64
    int64_t v8 = v6 - v7; // 0x100003d68
    if (v8 < 0 != ((v8 ^ v6) & 0x100000000 * (v1 ^ v1)) < 0) {
        // 0x100003e50
        return 0;
    }
    int32_t v9 = 0; // 0x100003d8c
    int32_t v10; // 0x100003d2c
    int64_t v11; // 0x100003d98
    int32_t v12; // 0x100003db4
    int32_t v13; // 0x100003dc4
    if (v2 != 0) {
        v11 = v2;
        v12 = v11 % v7;
        v13 = v11 / v7;
        v10 = v12;
        v9 = v12;
        while (v13 != 0) {
            // 0x100003d98
            v11 = v13;
            v12 = v10 + (int32_t)(v11 % v7);
            v13 = v11 / v7;
            v10 = v12;
            v9 = v12;
        }
    }
    int32_t result2 = v9;
    int64_t v14; // 0x100003d2c
    *v5 = *(int32_t *)&v14 + 1;
    int64_t v15 = result2; // 0x100003d60
    int64_t v16 = v15 - v7; // 0x100003d68
    while (v16 < 0 == ((v16 ^ v15) & (int64_t)(result2 ^ v3)) < 0) {
        int32_t v17 = result2; // 0x100003d8c
        v9 = 0;
        if (result2 != 0) {
            v11 = v17;
            v12 = v11 % v7;
            v13 = v11 / v7;
            v10 = v12;
            v9 = v12;
            while (v13 != 0) {
                // 0x100003d98
                v11 = v13;
                v12 = v10 + (int32_t)(v11 % v7);
                v13 = v11 / v7;
                v10 = v12;
                v9 = v12;
            }
        }
        // 0x100003dd0
        result2 = v9;
        *v5 = *(int32_t *)&v14 + 1;
        v15 = result2;
        v16 = v15 - v7;
    }
    // 0x100003e50
    return result2;
}

// Address range: 0x100003e5c - 0x100003f50
int64_t entry_point(void) {
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003eb0
        function_100003d2c();
        int64_t v1; // bp-80, 0x100003e5c
        int64_t v2; // 0x100003e5c
        _printf("%lld: pers %d, root %d\n", 10, (int64_t)&v1, v2);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f28
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f3c
        ___stack_chk_fail();
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(void) {
    // 0x100003f50
    return ___stack_chk_fail();
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#define EMPTY_TILE 0
#define ROWS 4
#define COLUMNS 4


/*
 *                                     GENERAL CONCEPT
 *
 * How do you add up tiles when there is whitespace between them?
 * You sort the array so that there are no empty tiles between them while stacking them all to one side
 * then the addition function always adds up from left to right or up to bottom. It does not care
 * about the left movements or the down movement. This can be achieved by reversing the array
 * whenever the player chooses to move to the right or down, when the addition is finished
 * the array gets reversed back and its like it had been added from right to left or bottom to top
 * When the addition is done, the program scans for the number of empty tiles and uses that
 * in its selection of the next tile to be filled. 10% of times a tile gets occupied with a 4
 *
*/



/*
 * the remove_whitespace functions; it is pretty clear what they do.
 * they use a bubble short algorith to move the 0's or empty tiles to the end of the array
 * depending on the direction moved (without carring about going right or up
 *
*/

void remove_whitespace_horizontaly(int board[ROWS][COLUMNS], int rows, int columns)
{
  int a = columns;
  int tmp;


  for (; a < COLUMNS - 1; ++a) {
    tmp = board[rows][a];
    board[rows][a] = board[rows][a+1];
    board[rows][a+1] = tmp;
  }
}

void remove_whitespace_verticaly(int board[ROWS][COLUMNS], int columns, int rows)
{
  int a = rows;
  int tmp;

  for (; a < ROWS - 1; ++a) {
    tmp = board[a][columns];
    board[a][columns] = board[a+1][columns];
    board[a+1][columns] = tmp;
  }
}

/*
 * the add_tiles functions. those functions do the heavy work of adding the tiles and
 * taking care of special situations such as when adding two equal tiles a 0 gets generated
 * they are quite difficult to understand i think (which means not that you need to be too clever
 * but that i have done a poor job of creating them) and it took around 4 hours to get the
 * proper result
*/

void add_tiles_horizontaly(int board[ROWS][COLUMNS])
{
  int a, b, flag;

  for (a = 0; a < ROWS; ++a) {
    for (b = 0, flag = 0; b < COLUMNS - 1 && flag != 4; ++b) {
      if (board[a][b] == EMPTY_TILE) {
	remove_whitespace_horizontaly(board, a, b);
	--b;
	++flag;
      }
      else {
	if (board[a][b+1] == EMPTY_TILE) {
	  board[a][b+1] = board[a][b];
	  board[a][b] = EMPTY_TILE;
	  --b;
	} else if (board[a][b] == board[a][b+1]) {
	  board[a][b] += board[a][b+1];
	  board[a][b+1] = EMPTY_TILE;
	}
      }
    }
  }
}

void add_tiles_verticaly(int board[ROWS][COLUMNS])
{
  int a, b, flag;

  for (a = 0; a < COLUMNS; ++a) {
    for (b = 0, flag = 0; b < ROWS-1 && flag != 4; ++b) {
      if (board[b][a] == EMPTY_TILE) {
	remove_whitespace_verticaly(board, a, b);
	--b;
	++flag;
      }
      else {
	if (board[b+1][a] == EMPTY_TILE) {
	  board[b+1][a] = board[b][a];
	  board[b][a] = EMPTY_TILE;
	  --b;
	} else if (board[b][a] == board[b+1][a]) {
	  board[b][a] += board[b+1][a];
	  board[b+1][a] = EMPTY_TILE;
	}
      }
    }
  }
}
	
/*
 * ... print the board
 */

void print_board(int board[ROWS][COLUMNS])
{
  int a, b;

  for (a = 0; a < ROWS; ++a) {
    printf("\n");
    for (b = 0; b < COLUMNS; ++b) {
      printf("%5i", board[a][b]);
    }
  }
  printf("\n");
}

/*
 * The reverse_board function reverses the array
 * if the movement is right or down reverse the array
*/

void reverse_board(char input[], int board[ROWS][COLUMNS])
{
  int a, b, c, tmp;

  if (!strcmp(input, "right")) {
    for (a = 0; a < ROWS; ++a) {
      for (b = 0, c = 3; b < 2; ++b, --c) {
	tmp = board[a][b];
	board[a][b] = board[a][c];
	board[a][c] = tmp;
      }
    }
  }
  else if  (!strcmp(input, "down")) {
    for (a = 0; a < COLUMNS; ++a) {
      for (b = 0, c = 3; b < 2; ++b, --c) {
	tmp = board[b][a];
	board[b][a] = board[c][a];
	board[c][a] = tmp;
      }
    }
  }
}

/*
 * the check_board function is the one which evaluates the win or lose condition
 * for each turn and at the same time providing the number of empty tiles for the random generator
 * function
*/

int check_board (int board[ROWS][COLUMNS])
{
  int a, b;

  int result = 0;
  int empty_tiles = 0;


  for (a = 0; a < ROWS; ++a)
    for (b = 0; b < COLUMNS; ++b)
      if (board[a][b] == 2048)
	result = -1;
      else if (board[a][b] == EMPTY_TILE)
	++empty_tiles;

  result = result == -1 ? result : empty_tiles;

  return result;
}

/*
 * the generate_random functin generates a random number between 0 and the number of
 * empty tiles. the generated number will assign to the Nth empty tile = (random_number)
 * the new value, it also takes care of the 10% chance for producing a 4 tile
*/

void generate_random(int board[ROWS][COLUMNS], int empty_tiles )
{

  srand(time(NULL));

  int a, b;
  int random = 0;
  int tile = 0;

  random = rand() % empty_tiles;
  tile = (rand() % 9 == 4) ? 4 : 2;

  for (a = 0; a < ROWS; ++a)
    for (b = 0; b < COLUMNS; ++b)
      if (board[a][b] == EMPTY_TILE && random != 0)
	--random;
      else if (board[a][b] == EMPTY_TILE && random == 0) {
	board[a][b] = tile;
	return;
      }
}

/*
 * infinite loop, get the movements or exit code and act accordingly
*/

int play_game(int board[ROWS][COLUMNS])
{

  char movement[81];
  int tiles = 0;

  printf("this is the 2048 game\n"					\
	 "The goal of this game is make a tile reach the value of 2048\n"\
	 "The board starts of with only one occupied tile.\n"\
	 "On each round a new tile gets added with the value of 2\n"\
	 "or at 10%% of the times with the value of 4\n"\
	 "If you run out of tiles you lose\n"\
	 "There are 4 movements you can supply to the game\n"\
	 "right, left, up, and down.\n"\
	 "For each of this movements the tiles move to the direction specified\n"\
	 "If two tiles have the same value the get added up just once.\n"\
	 "If 2 occupied tiles share the same row or column but are seperated by empty tiles\n"\
	 "then the occupied tiles travel along the empty tiles stacking in the direction\n"\
	 "they were directed\n"\
	 "For a more visual explanation you can check the wikipedia entry\n"
	 " if you search for 2058 board game\n"	\
	 "Here we go\n");

  print_board(board);
  while (1) {
    printf("(enter: left,right,up,down,exit)>> ");
    scanf("%s", movement);
    if (!strcmp(movement, "down")) {
      reverse_board(movement,board);
      add_tiles_verticaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
      reverse_board(movement, board);
    }
    else if (!strcmp(movement, "up")) {
      add_tiles_verticaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
    }
    else if (!strcmp(movement, "right")) {
      reverse_board(movement,board);
      add_tiles_horizontaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
      reverse_board(movement, board);
    }
    else if (!strcmp(movement, "left")) {
      add_tiles_horizontaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
    }
    else if (!strcmp(movement, "exit")) {
      return 1;
    }
    else {
      printf("Do not recognize this movement please type again\n");
      continue;
    }
    print_board(board);
  }
}


int main(void)
{
  int play_game(int board[ROWS][COLUMNS]);
  void generate_random(int board[ROWS][COLUMNS], int empty_tiles );
  int check_board (int board[ROWS][COLUMNS]);
  void reverse_board(char input[], int board[ROWS][COLUMNS]);
  void print_board(int board[ROWS][COLUMNS]);
  void add_tiles_verticaly(int board[ROWS][COLUMNS]);
  void add_tiles_horizontaly(int board[ROWS][COLUMNS]);
  void remove_whitespace_verticaly(int board[ROWS][COLUMNS], int columns, int rows);
  void remove_whitespace_horizontaly(int board[ROWS][COLUMNS], int rows, int columns);

  int win_condition;
  int board[ROWS][COLUMNS] = {
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0}
  };


  generate_random(board, 16); /* initialize the board */

  win_condition = play_game(board);
  switch (win_condition) {
  case 1:
    printf("But you are not done yet!!!\n"	\
	   "Fine, see you another day\n");
    break;
  case 0:
    printf("Ohh noo, you run out of tiles\n"	\
	   "Run me agan to play some more\n"	\
	   "Byyyeee\n");
    break;
  case -1:
    printf("WooooW you did it, Good job!!!\n"	\
	   "See ya later homie\n");
    break;
  }

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002c20(void);
int64_t function_100002ccc(void);
int64_t function_100002d78(void);
int64_t function_100002f88(void);
int64_t function_100003198(void);
int64_t function_100003258(void);
int64_t function_10000345c(void);
int64_t function_100003574(void);
int64_t function_1000036f4(void);
int64_t function_100003b18(int64_t a1);
int64_t * function_100003b24(int64_t * s, int32_t c, int32_t n);
int32_t function_100003b30(char * format, ...);
int32_t function_100003b3c(void);
int32_t function_100003b48(char * format, ...);
void function_100003b54(int32_t seed);
int32_t function_100003b60(char * s1, char * s2);
int32_t function_100003b6c(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
int32_t _scanf(char * a1, ...);
void _srand(int32_t a1);
int32_t _strcmp(char * a1, char * a2);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002c20 - 0x100002ccc
int64_t function_100002c20(void) {
    // 0x100002c20
    int64_t result; // 0x100002c20
    int32_t v1 = result; // 0x100002c2c
    if (v1 < 3 == (2 - v1 & v1) < 0) {
        // 0x100002cc4
        return result;
    }
    int64_t v2 = (0x100000000 * result >> 28) + result; // 0x100002c58
    int32_t v3 = v1;
    int32_t * v4 = (int32_t *)(4 * (int64_t)v3 + v2); // 0x100002c60
    int32_t * v5 = (int32_t *)(v2 + (int64_t)(4 * v3 + 4)); // 0x100002c7c
    *v4 = *v5;
    *v5 = *v4;
    int32_t v6 = v3 + 1; // 0x100002cb8
    while (v3 < 2 != (1 - v3 & v6) < 0) {
        // 0x100002c50
        v3 = v6;
        v4 = (int32_t *)(4 * (int64_t)v3 + v2);
        v5 = (int32_t *)(v2 + (int64_t)(4 * v3 + 4));
        *v4 = *v5;
        *v5 = *v4;
        v6 = v3 + 1;
    }
    // 0x100002cc4
    return result;
}

// Address range: 0x100002ccc - 0x100002d78
int64_t function_100002ccc(void) {
    // 0x100002ccc
    int64_t result; // 0x100002ccc
    int32_t v1 = result; // 0x100002cd8
    if (v1 < 3 == (2 - v1 & v1) < 0) {
        // 0x100002d70
        return result;
    }
    int64_t v2 = (0x100000000 * result >> 30) + result;
    int32_t v3 = v1;
    int32_t * v4 = (int32_t *)(16 * (int64_t)v3 + v2); // 0x100002d0c
    int32_t v5 = v3 + 1; // 0x100002d1c
    int32_t * v6 = (int32_t *)(16 * (int64_t)v5 + v2); // 0x100002d28
    *v4 = *v6;
    *v6 = *v4;
    while (v3 < 2 != (1 - v3 & v5) < 0) {
        // 0x100002cfc
        v3 = v5;
        v4 = (int32_t *)(16 * (int64_t)v3 + v2);
        v5 = v3 + 1;
        v6 = (int32_t *)(16 * (int64_t)v5 + v2);
        *v4 = *v6;
        *v6 = *v4;
    }
    // 0x100002d70
    return result;
}

// Address range: 0x100002d78 - 0x100002f88
int64_t function_100002d78(void) {
    int64_t v1 = 0;
    int64_t v2; // 0x100002d78
    int64_t v3 = 16 * v1 + v2; // 0x100002df4
    int32_t v4 = 0;
    int32_t v5 = 0;
    int32_t * v6 = (int32_t *)(4 * (int64_t)v4 + v3); // 0x100002dfc
    int32_t v7 = *v6; // 0x100002dfc
    int32_t v8; // 0x100002d78
    int32_t v9; // 0x100002d78
    int32_t * v10; // 0x100002e50
    int32_t v11; // 0x100002e50
    int64_t v12; // 0x100002d78
    if (v7 == 0) {
        // 0x100002e10
        v8 = v4 - 1;
        v9 = v5 + 1;
        v12 = function_100002c20();
    } else {
        // 0x100002e3c
        v10 = (int32_t *)(v3 + (int64_t)(4 * v4 + 4));
        v11 = *v10;
        int64_t v13; // 0x100002d78
        if (v11 == 0) {
            // 0x100002e64
            *v10 = v7;
            *v6 = 0;
            v8 = v4 - 1;
            v9 = v5;
            v12 = v13;
        } else {
            // 0x100002eb8
            v8 = v4;
            v9 = v5;
            v12 = v13;
            if (v7 == v11) {
                // 0x100002ef4
                *v6 = 2 * v7;
                *v10 = 0;
                v8 = v4;
                v9 = v5;
                v12 = v13;
            }
        }
    }
    int64_t result = v12;
    int32_t v14 = v9;
    int32_t v15 = v8;
    int32_t v16 = v15 + 1; // 0x100002f5c
    int64_t v17; // 0x100002d78
    while (v14 != 4 == (v15 < 2 != (1 - v15 & v16) < 0)) {
        // 0x100002dec
        v4 = v16;
        v5 = v14;
        v6 = (int32_t *)(4 * (int64_t)v4 + v3);
        v7 = *v6;
        if (v7 == 0) {
            // 0x100002e10
            v8 = v4 - 1;
            v9 = v5 + 1;
            v12 = function_100002c20();
        } else {
            // 0x100002e3c
            v17 = result;
            v10 = (int32_t *)(v3 + (int64_t)(4 * v4 + 4));
            v11 = *v10;
            if (v11 == 0) {
                // 0x100002e64
                *v10 = v7;
                *v6 = 0;
                v8 = v4 - 1;
                v9 = v5;
                v12 = v17;
            } else {
                // 0x100002eb8
                v8 = v4;
                v9 = v5;
                v12 = v17;
                if (v7 == v11) {
                    // 0x100002ef4
                    *v6 = 2 * v7;
                    *v10 = 0;
                    v8 = v4;
                    v9 = v5;
                    v12 = v17;
                }
            }
        }
        // 0x100002f58
        result = v12;
        v14 = v9;
        v15 = v8;
        v16 = v15 + 1;
    }
    // 0x100002f6c
    v1++;
    while (v1 != 4) {
        // 0x100002db0
        v3 = 16 * v1 + v2;
        int64_t v18 = result; // 0x100002d78
        v4 = 0;
        v5 = 0;
        v6 = (int32_t *)(4 * (int64_t)v4 + v3);
        v7 = *v6;
        if (v7 == 0) {
            // 0x100002e10
            v8 = v4 - 1;
            v9 = v5 + 1;
            v12 = function_100002c20();
        } else {
            // 0x100002e3c
            v17 = v18;
            v10 = (int32_t *)(v3 + (int64_t)(4 * v4 + 4));
            v11 = *v10;
            if (v11 == 0) {
                // 0x100002e64
                *v10 = v7;
                *v6 = 0;
                v8 = v4 - 1;
                v9 = v5;
                v12 = v17;
            } else {
                // 0x100002eb8
                v8 = v4;
                v9 = v5;
                v12 = v17;
                if (v7 == v11) {
                    // 0x100002ef4
                    *v6 = 2 * v7;
                    *v10 = 0;
                    v8 = v4;
                    v9 = v5;
                    v12 = v17;
                }
            }
        }
        // 0x100002f58
        result = v12;
        v14 = v9;
        v15 = v8;
        v16 = v15 + 1;
        while (v14 != 4 == (v15 < 2 != (1 - v15 & v16) < 0)) {
            // 0x100002dec
            v4 = v16;
            v5 = v14;
            v6 = (int32_t *)(4 * (int64_t)v4 + v3);
            v7 = *v6;
            if (v7 == 0) {
                // 0x100002e10
                v8 = v4 - 1;
                v9 = v5 + 1;
                v12 = function_100002c20();
            } else {
                // 0x100002e3c
                v17 = result;
                v10 = (int32_t *)(v3 + (int64_t)(4 * v4 + 4));
                v11 = *v10;
                if (v11 == 0) {
                    // 0x100002e64
                    *v10 = v7;
                    *v6 = 0;
                    v8 = v4 - 1;
                    v9 = v5;
                    v12 = v17;
                } else {
                    // 0x100002eb8
                    v8 = v4;
                    v9 = v5;
                    v12 = v17;
                    if (v7 == v11) {
                        // 0x100002ef4
                        *v6 = 2 * v7;
                        *v10 = 0;
                        v8 = v4;
                        v9 = v5;
                        v12 = v17;
                    }
                }
            }
            // 0x100002f58
            result = v12;
            v14 = v9;
            v15 = v8;
            v16 = v15 + 1;
        }
        // 0x100002f6c
        v1++;
    }
    // 0x100002f7c
    return result;
}

// Address range: 0x100002f88 - 0x100003198
int64_t function_100002f88(void) {
    int64_t v1 = 0;
    int64_t v2; // 0x100002f88
    int64_t v3 = 4 * v1 + v2;
    int32_t v4 = 0;
    int32_t v5 = 0;
    int32_t * v6 = (int32_t *)(16 * (int64_t)v4 + v3); // 0x10000300c
    int32_t v7 = *v6; // 0x10000300c
    int32_t v8; // 0x100002f88
    int32_t v9; // 0x100002f88
    int32_t * v10; // 0x100003060
    int32_t v11; // 0x100003060
    int64_t v12; // 0x100002f88
    if (v7 == 0) {
        // 0x100003020
        v8 = v4 - 1;
        v9 = v5 + 1;
        v12 = function_100002ccc();
    } else {
        // 0x10000304c
        v10 = (int32_t *)(16 * (int64_t)(v4 + 1) + v3);
        v11 = *v10;
        int64_t v13; // 0x100002f88
        if (v11 == 0) {
            // 0x100003074
            *v10 = v7;
            *v6 = 0;
            v8 = v4 - 1;
            v9 = v5;
            v12 = v13;
        } else {
            // 0x1000030c8
            v8 = v4;
            v9 = v5;
            v12 = v13;
            if (v7 == v11) {
                // 0x100003104
                *v6 = 2 * v7;
                *v10 = 0;
                v8 = v4;
                v9 = v5;
                v12 = v13;
            }
        }
    }
    int64_t result = v12;
    int32_t v14 = v9;
    int32_t v15 = v8;
    int32_t v16 = v15 + 1; // 0x10000316c
    int64_t v17; // 0x100002f88
    while (v14 != 4 == (v15 < 2 != (1 - v15 & v16) < 0)) {
        // 0x100002ffc
        v4 = v16;
        v5 = v14;
        v6 = (int32_t *)(16 * (int64_t)v4 + v3);
        v7 = *v6;
        if (v7 == 0) {
            // 0x100003020
            v8 = v4 - 1;
            v9 = v5 + 1;
            v12 = function_100002ccc();
        } else {
            // 0x10000304c
            v17 = result;
            v10 = (int32_t *)(16 * (int64_t)(v4 + 1) + v3);
            v11 = *v10;
            if (v11 == 0) {
                // 0x100003074
                *v10 = v7;
                *v6 = 0;
                v8 = v4 - 1;
                v9 = v5;
                v12 = v17;
            } else {
                // 0x1000030c8
                v8 = v4;
                v9 = v5;
                v12 = v17;
                if (v7 == v11) {
                    // 0x100003104
                    *v6 = 2 * v7;
                    *v10 = 0;
                    v8 = v4;
                    v9 = v5;
                    v12 = v17;
                }
            }
        }
        // 0x100003168
        result = v12;
        v14 = v9;
        v15 = v8;
        v16 = v15 + 1;
    }
    // 0x10000317c
    v1++;
    while (v1 != 4) {
        // 0x100002fc0
        v3 = 4 * v1 + v2;
        int64_t v18 = result; // 0x100002f88
        v4 = 0;
        v5 = 0;
        v6 = (int32_t *)(16 * (int64_t)v4 + v3);
        v7 = *v6;
        if (v7 == 0) {
            // 0x100003020
            v8 = v4 - 1;
            v9 = v5 + 1;
            v12 = function_100002ccc();
        } else {
            // 0x10000304c
            v17 = v18;
            v10 = (int32_t *)(16 * (int64_t)(v4 + 1) + v3);
            v11 = *v10;
            if (v11 == 0) {
                // 0x100003074
                *v10 = v7;
                *v6 = 0;
                v8 = v4 - 1;
                v9 = v5;
                v12 = v17;
            } else {
                // 0x1000030c8
                v8 = v4;
                v9 = v5;
                v12 = v17;
                if (v7 == v11) {
                    // 0x100003104
                    *v6 = 2 * v7;
                    *v10 = 0;
                    v8 = v4;
                    v9 = v5;
                    v12 = v17;
                }
            }
        }
        // 0x100003168
        result = v12;
        v14 = v9;
        v15 = v8;
        v16 = v15 + 1;
        while (v14 != 4 == (v15 < 2 != (1 - v15 & v16) < 0)) {
            // 0x100002ffc
            v4 = v16;
            v5 = v14;
            v6 = (int32_t *)(16 * (int64_t)v4 + v3);
            v7 = *v6;
            if (v7 == 0) {
                // 0x100003020
                v8 = v4 - 1;
                v9 = v5 + 1;
                v12 = function_100002ccc();
            } else {
                // 0x10000304c
                v17 = result;
                v10 = (int32_t *)(16 * (int64_t)(v4 + 1) + v3);
                v11 = *v10;
                if (v11 == 0) {
                    // 0x100003074
                    *v10 = v7;
                    *v6 = 0;
                    v8 = v4 - 1;
                    v9 = v5;
                    v12 = v17;
                } else {
                    // 0x1000030c8
                    v8 = v4;
                    v9 = v5;
                    v12 = v17;
                    if (v7 == v11) {
                        // 0x100003104
                        *v6 = 2 * v7;
                        *v10 = 0;
                        v8 = v4;
                        v9 = v5;
                        v12 = v17;
                    }
                }
            }
            // 0x100003168
            result = v12;
            v14 = v9;
            v15 = v8;
            v16 = v15 + 1;
        }
        // 0x10000317c
        v1++;
    }
    // 0x10000318c
    return result;
}

// Address range: 0x100003198 - 0x100003258
int64_t function_100003198(void) {
    // 0x100003198
    _printf("\n");
    int32_t v1 = 0; // 0x100003234
    int64_t v2; // 0x100003198
    for (int32_t i = 0; i < 4; i++) {
        // 0x1000031ec
        _printf("%5i", v2);
    }
    // 0x100003230
    v1++;
    int32_t result = _printf("\n");
    while (v1 != 4) {
        for (int32_t i = 0; i < 4; i++) {
            // 0x1000031ec
            _printf("%5i", v2);
        }
        // 0x100003230
        v1++;
        result = _printf("\n");
    }
    // 0x100003240
    return result;
}

// Address range: 0x100003258 - 0x10000345c
int64_t function_100003258(void) {
    // 0x100003258
    int64_t v1; // 0x100003258
    char * v2 = (char *)v1; // 0x100003264
    int32_t result = _strcmp(v2, "right"); // 0x100003278
    int64_t v3 = 0; // 0x100003284
    if (result == 0) {
        int64_t v4 = 16 * v3 + v1; // 0x1000032d4
        int64_t v5 = 0;
        int64_t v6 = 3; // 0x100003258
        int32_t * v7 = (int32_t *)(4 * v5 + v4); // 0x1000032dc
        int32_t * v8 = (int32_t *)(4 * v6 + v4); // 0x1000032f4
        *v7 = *v8;
        *v8 = *v7;
        v5++;
        v6--;
        while (v5 != 2) {
            // 0x1000032cc
            v7 = (int32_t *)(4 * v5 + v4);
            v8 = (int32_t *)(4 * v6 + v4);
            *v7 = *v8;
            *v8 = *v7;
            v5++;
            v6--;
        }
        // 0x100003348
        v3++;
        while (v3 != 4) {
            // 0x1000032b8
            v4 = 16 * v3 + v1;
            v5 = 0;
            v6 = 3;
            v7 = (int32_t *)(4 * v5 + v4);
            v8 = (int32_t *)(4 * v6 + v4);
            *v7 = *v8;
            *v8 = *v7;
            v5++;
            v6--;
            while (v5 != 2) {
                // 0x1000032cc
                v7 = (int32_t *)(4 * v5 + v4);
                v8 = (int32_t *)(4 * v6 + v4);
                *v7 = *v8;
                *v8 = *v7;
                v5++;
                v6--;
            }
            // 0x100003348
            v3++;
        }
        // 0x100003450
        return result;
    }
    int32_t v9 = _strcmp(v2, "down"); // 0x100003368
    int64_t result2 = v9; // 0x100003368
    if (v9 != 0) {
        // 0x100003450
        return result2;
    }
    for (int64_t i = 0; i < 4; i++) {
        int64_t v10 = 4 * i + v1;
        int64_t v11 = 0;
        int64_t v12 = 3; // 0x100003258
        int32_t * v13 = (int32_t *)(16 * v11 + v10); // 0x1000033cc
        int32_t * v14 = (int32_t *)(16 * v12 + v10); // 0x1000033e4
        *v13 = *v14;
        *v14 = *v13;
        v11++;
        v12--;
        while (v11 != 2) {
            // 0x1000033bc
            v13 = (int32_t *)(16 * v11 + v10);
            v14 = (int32_t *)(16 * v12 + v10);
            *v13 = *v14;
            *v14 = *v13;
            v11++;
            v12--;
        }
    }
    // 0x100003450
    return result2;
}

// Address range: 0x10000345c - 0x100003574
int64_t function_10000345c(void) {
    int64_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = 0;
    int64_t v4; // 0x10000345c
    int32_t v5; // 0x10000345c
    int32_t v6; // 0x10000345c
    while (true) {
        // 0x100003490
        int64_t v7; // 0x10000345c
        int64_t v8 = 16 * v1 + v7; // 0x1000034ac
        v4 = 0;
        while (true) {
          lab_0x1000034a4:;
            int32_t v9 = v3;
            int32_t v10 = v2;
            v5 = -1;
            v6 = v10;
            int64_t v11; // 0x10000345c
            switch (*(int32_t *)(v8 + 4 * v11)) {
                case 2048: {
                    goto lab_0x100003510;
                }
                case 0: {
                    // 0x1000034f8
                    v5 = v9;
                    v6 = v10 + 1;
                    goto lab_0x100003510;
                }
                default: {
                    // 0x100003510
                    v5 = v9;
                    v6 = v10;
                    goto lab_0x100003510;
                }
            }
        }
      lab_0x100003524:
        // 0x100003524
        v1++;
        if (v1 == 4) {
            // break -> 0x100003534
            break;
        }
    }
    // 0x100003534
    return v3 == -1 ? -1 : v2;
  lab_0x100003510:
    // 0x100003510
    v2 = v6;
    v3 = v5;
    int64_t v12 = v4 + 1;
    v4 = v12;
    if (v12 == 4) {
        // break -> 0x100003524
        goto lab_0x100003524;
    }
    goto lab_0x1000034a4;
}

// Address range: 0x100003574 - 0x1000036f4
int64_t function_100003574(void) {
    // 0x100003574
    _srand(_time(NULL));
    int32_t v1 = _rand(); // 0x10000359c
    int32_t v2 = _rand(); // 0x1000035b4
    int64_t result = v2; // 0x1000035b4
    int32_t v3 = 0;
    uint64_t v4 = 0;
    int64_t v5; // 0x100003574
    int32_t v6 = v1 % (int32_t)v5;
    int32_t v7 = 0;
    uint64_t v8 = 0;
    int32_t * v9 = (int32_t *)(16 * v4 + v5 + 4 * v8);
    int32_t v10 = *v9; // 0x100003630
    int32_t v11; // 0x100003574
    if (v6 == 0 || v10 != 0) {
        // 0x100003668
        v11 = v6;
        if ((v10 || v6) == 0) {
            // break (via goto) -> 0x1000036a0
            goto lab_0x1000036a0;
        }
    } else {
        // 0x100003658
        v11 = v6 - 1;
    }
    int64_t v12 = v8 + 1;
    int32_t v13 = v7 + 1; // 0x100003618
    while (v8 < 3 != (2 - v7 & (int32_t)v12) < 0) {
        // 0x100003620
        v6 = v11;
        v7 = v13;
        v8 = v12;
        v9 = (int32_t *)(16 * v4 + v5 + 4 * v8);
        v10 = *v9;
        if (v6 == 0 || v10 != 0) {
            // 0x100003668
            v11 = v6;
            if ((v10 || v6) == 0) {
                // break (via goto) -> 0x1000036a0
                goto lab_0x1000036a0;
            }
        } else {
            // 0x100003658
            v11 = v6 - 1;
        }
        // 0x1000036c4
        v12 = v8 + 1;
        v13 = v7 + 1;
    }
    int64_t v14 = v4 + 1;
    int32_t v15 = v3 + 1; // 0x1000035fc
    while (v4 < 3 != (2 - v3 & (int32_t)v14) < 0) {
        // 0x10000360c
        v3 = v15;
        v4 = v14;
        v6 = v11;
        v7 = 0;
        v8 = 0;
        v9 = (int32_t *)(16 * v4 + v5 + 4 * v8);
        v10 = *v9;
        if (v6 == 0 || v10 != 0) {
            // 0x100003668
            v11 = v6;
            if ((v10 || v6) == 0) {
                // break (via goto) -> 0x1000036a0
                goto lab_0x1000036a0;
            }
        } else {
            // 0x100003658
            v11 = v6 - 1;
        }
        // 0x1000036c4
        v12 = v8 + 1;
        v13 = v7 + 1;
        while (v8 < 3 != (2 - v7 & (int32_t)v12) < 0) {
            // 0x100003620
            v6 = v11;
            v7 = v13;
            v8 = v12;
            v9 = (int32_t *)(16 * v4 + v5 + 4 * v8);
            v10 = *v9;
            if (v6 == 0 || v10 != 0) {
                // 0x100003668
                v11 = v6;
                if ((v10 || v6) == 0) {
                    // break (via goto) -> 0x1000036a0
                    goto lab_0x1000036a0;
                }
            } else {
                // 0x100003658
                v11 = v6 - 1;
            }
            // 0x1000036c4
            v12 = v8 + 1;
            v13 = v7 + 1;
        }
        // 0x1000036d8
        v14 = v4 + 1;
        v15 = v3 + 1;
    }
    // 0x1000036e8
    return result;
  lab_0x1000036a0:
    // 0x1000036a0
    *v9 = v2 % 9 != 4 ? 2 : 4;
    // 0x1000036e8
    return result;
}

// Address range: 0x1000036f4 - 0x100003a28
int64_t function_1000036f4(void) {
    // 0x1000036f4
    _printf("this is the 2048 game\nThe goal of this game is make a tile reach the value of 2048\nThe board starts of with only one occupied tile.\nOn each round a new tile gets added with the value of 2\nor at 10%% of the times with the value of 4\nIf you run out of tiles you lose\nThere are 4 movements you can supply to the game\nright, left, up, and down.\nFor each of this movements the tiles move to the direction specified\nIf two tiles have the same value the get added up just once.\nIf 2 occupied tiles share the same row or column but are seperated by empty tiles\nthen the occupied tiles travel along the empty tiles stacking in the direction\nthey were directed\nFor a more visual explanation you can check the wikipedia entry\n if you search for 2058 board game\nHere we go\n");
    function_100003198();
    int64_t result; // 0x1000036f4
    int64_t v1; // 0x1000036f4
    int64_t v2; // 0x1000036f4
    int64_t v3; // 0x1000036f4
    int64_t v4; // 0x1000036f4
    while (true) {
      lab_0x100003730_2:
        // 0x100003730
        _printf("(enter: left,right,up,down,exit)>> ");
        _scanf("%s", (char **)v3);
        int64_t v5; // bp-105, 0x1000036f4
        if (_strcmp((char *)&v5, "down") == 0) {
            // 0x100003778
            function_100003258();
            function_100002f88();
            int64_t v6 = function_10000345c(); // 0x100003790
            v1 = v6;
            result = 0xffffffff;
            v2 = v6;
            switch ((int32_t)v6) {
                case -1: {
                    goto lab_0x1000039ec;
                }
                case 0: {
                    goto lab_0x1000039ec_2;
                }
                default: {
                    // 0x1000037d8
                    function_100003574();
                    function_100003258();
                    goto lab_0x1000039e0;
                }
            }
        } else {
            // 0x1000037f4
            if (_strcmp((char *)&v5, "up") == 0) {
                // 0x100003814
                function_100002f88();
                int64_t v7 = function_10000345c(); // 0x100003820
                v1 = v7;
                result = 0xffffffff;
                v2 = v7;
                switch ((int32_t)v7) {
                    case -1: {
                        goto lab_0x1000039ec;
                    }
                    case 0: {
                        goto lab_0x1000039ec_2;
                    }
                    default: {
                        // 0x100003868
                        function_100003574();
                        v4 = v7 & 0xffffffff;
                        goto lab_0x1000039e0;
                    }
                }
            } else {
                // 0x100003878
                if (_strcmp((char *)&v5, "right") == 0) {
                    // 0x100003898
                    function_100003258();
                    function_100002d78();
                    int64_t v8 = function_10000345c(); // 0x1000038b0
                    v1 = v8;
                    result = 0xffffffff;
                    v2 = v8;
                    switch ((int32_t)v8) {
                        case -1: {
                            goto lab_0x1000039ec;
                        }
                        case 0: {
                            goto lab_0x1000039ec_2;
                        }
                        default: {
                            // 0x1000038f8
                            function_100003574();
                            function_100003258();
                            goto lab_0x1000039e0;
                        }
                    }
                } else {
                    // 0x100003914
                    if (_strcmp((char *)&v5, "left") == 0) {
                        // 0x100003934
                        function_100002d78();
                        int64_t v9 = function_10000345c(); // 0x100003940
                        v1 = v9;
                        result = 0xffffffff;
                        v2 = v9;
                        switch ((int32_t)v9) {
                            case -1: {
                                goto lab_0x1000039ec;
                            }
                            case 0: {
                                goto lab_0x1000039ec_2;
                            }
                            default: {
                                // 0x100003988
                                function_100003574();
                                v4 = v9 & 0xffffffff;
                                goto lab_0x1000039e0;
                            }
                        }
                    } else {
                        int32_t v10 = _strcmp((char *)&v5, "exit"); // 0x1000039a4
                        result = 1;
                        v2 = 0;
                        if (v10 == 0) {
                            // break -> 0x1000039ec
                            break;
                        }
                        // 0x1000039c4
                        _printf("Do not recognize this movement please type again\n");
                        // 0x100003730
                        v3 = (int64_t)"exit";
                        goto lab_0x100003730_2;
                    }
                }
            }
        }
    }
    goto lab_0x1000039ec;
  lab_0x1000039ec:;
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003a00
    if (v11 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003a14
        ___stack_chk_fail(v2);
    }
    // 0x100003a18
    return result;
  lab_0x1000039ec_2:
    // 0x1000039ec
    result = 0;
    v2 = v1;
    goto lab_0x1000039ec;
  lab_0x1000039e0:
    // 0x1000039e0
    function_100003198();
    // 0x100003730
    v3 = v4;
    goto lab_0x100003730_2;
}

// Address range: 0x100003a28 - 0x100003b18
int64_t entry_point(void) {
    // 0x100003a28
    int64_t v1; // bp-88, 0x100003a28
    _memset(&v1, 0, 64);
    function_100003574();
    int64_t v2 = function_1000036f4(); // 0x100003a6c
    int64_t v3 = v2; // 0x100003a28
    switch ((int32_t)v2) {
        case -1: {
            // 0x100003ad4
            v3 = _printf("WooooW you did it, Good job!!!\nSee ya later homie\n");
            // break -> 0x100003ae4
            break;
        }
        case 0: {
            // 0x100003ac4
            v3 = _printf("Ohh noo, you run out of tiles\nRun me agan to play some more\nByyyeee\n");
            // break -> 0x100003ae4
            break;
        }
        case 1: {
            // 0x100003ab4
            v3 = _printf("But you are not done yet!!!\nFine, see you another day\n");
            // break -> 0x100003ae4
            break;
        }
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003af0
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003b04
        ___stack_chk_fail(v3);
    }
    // 0x100003b08
    return 0;
}

// Address range: 0x100003b18 - 0x100003b24
int64_t function_100003b18(int64_t a1) {
    // 0x100003b18
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003b24 - 0x100003b30
int64_t * function_100003b24(int64_t * s, int32_t c, int32_t n) {
    // 0x100003b24
    return _memset(s, c, n);
}

// Address range: 0x100003b30 - 0x100003b3c
int32_t function_100003b30(char * format, ...) {
    // 0x100003b30
    return _printf(format);
}

// Address range: 0x100003b3c - 0x100003b48
int32_t function_100003b3c(void) {
    // 0x100003b3c
    return _rand();
}

// Address range: 0x100003b48 - 0x100003b54
int32_t function_100003b48(char * format, ...) {
    // 0x100003b48
    return _scanf(format);
}

// Address range: 0x100003b54 - 0x100003b60
void function_100003b54(int32_t seed) {
    // 0x100003b54
    _srand(seed);
}

// Address range: 0x100003b60 - 0x100003b6c
int32_t function_100003b60(char * s1, char * s2) {
    // 0x100003b60
    return _strcmp(s1, s2);
}

// Address range: 0x100003b6c - 0x100003b78
int32_t function_100003b6c(int32_t * timer) {
    // 0x100003b6c
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 18

`
`#include <inttypes.h>
#include <stdio.h>

uint32_t modpow(uint32_t b, uint32_t e, uint32_t m)
{
    uint32_t p;
    for (p = 1; e; e >>= 1) {
        if (e & 1)
            p = (uint64_t)p * b % m;
        b = (uint64_t)b * b % m;
    }
    return p;
}

int is_deceptive(uint32_t n)
{
    uint32_t x;
    if (n & 1 && n % 3 && n % 5 && modpow(10, n - 1, n) == 1) {
        for (x = 7; x * x <= n; x += 6) {
            if (!(n % x && n % (x + 4)))
                return 1;
        }
    }
    return 0;
}

int main(void)
{
    uint32_t n = 49;
    unsigned int c;
    for (c = 0; c != 500; ++n) {
        if (is_deceptive(n)) {
            printf(" %" PRIu32, n);
            ++c;
        }
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d00(void);
int64_t function_100003db0(void);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d00 - 0x100003db0
int64_t function_100003d00(void) {
    // 0x100003d00
    int64_t v1; // 0x100003d00
    int32_t v2 = v1; // 0x100003d08
    if (v2 == 0) {
        // 0x100003da4
        return 1;
    }
    uint64_t v3 = v1 & 0xffffffff;
    uint32_t v4 = v2;
    int32_t v5 = 1;
    int64_t v6; // 0x100003d00
    int32_t v7; // 0x100003d00
    int64_t v8; // 0x100003d00
    int64_t v9; // 0x100003d00
    if (v4 % 2 == 0) {
        // 0x100003d30
        v6 = v8 & 0xffffffff;
        v7 = v5;
    } else {
        // 0x100003d44
        v9 = v8 & 0xffffffff;
        v6 = v9;
        v7 = v9 * (int64_t)v5 % v3;
    }
    int32_t result = v7;
    int32_t v10 = v4 / 2; // 0x100003d28
    while (v4 >= 2) {
        // 0x100003d30
        v4 = v10;
        int64_t v11 = v6 * v6 % v3;
        v5 = result;
        if (v4 % 2 == 0) {
            // 0x100003d30
            v6 = v11 & 0xffffffff;
            v7 = v5;
        } else {
            // 0x100003d44
            v9 = v11 & 0xffffffff;
            v6 = v9;
            v7 = v9 * (int64_t)v5 % v3;
        }
        // 0x100003d6c
        result = v7;
        v10 = v4 / 2;
    }
    // 0x100003da4
    return result;
}

// Address range: 0x100003db0 - 0x100003ef4
int64_t function_100003db0(void) {
    // 0x100003db0
    int64_t v1; // 0x100003db0
    uint32_t v2 = (int32_t)v1; // 0x100003dbc
    if (v2 % 5 == 0 || v2 % 2 == 0 || v2 % 3 == 0 || (int32_t)function_100003d00() != 1) {
        // 0x100003ee4
        return 0;
    }
    // 0x100003e4c
    if (v2 <= 49 == (v2 != 49)) {
        // 0x100003ee4
        return 0;
    }
    int32_t v3 = 7; // 0x100003e64
    int64_t result = 1; // 0x100003e88
    while (v2 % v3 != 0) {
        // 0x100003e90
        result = 1;
        if (v2 % (v3 + 4) == 0) {
            // break -> 0x100003ee4
            break;
        }
        // 0x100003e4c
        v3 += 6;
        uint32_t v4 = v3 * v3; // 0x100003e54
        result = 0;
        if (v4 >= v2 == (v4 != v2)) {
            // break -> 0x100003ee4
            break;
        }
        result = 1;
    }
    // 0x100003ee4
    return result;
}

// Address range: 0x100003ef4 - 0x100003f90
int64_t entry_point(void) {
    int32_t v1 = 0;
    int32_t v2 = v1; // 0x100003f38
    int64_t v3; // 0x100003ef4
    if ((int32_t)function_100003db0() != 0) {
        // 0x100003f40
        _printf(" %u", (int32_t)v3);
        v2 = v1 + 1;
    }
    // 0x100003f70
    while (v2 != 500) {
        // 0x100003f28
        v1 = v2;
        v2 = v1;
        if ((int32_t)function_100003db0() != 0) {
            // 0x100003f40
            _printf(" %u", (int32_t)v3);
            v2 = v1 + 1;
        }
    }
    // 0x100003f80
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint;

int main(int argc, char **argv)
{
  uint top = atoi(argv[1]);
  uint *divsum = malloc((top + 1) * sizeof(*divsum));
  uint pows[32] = {1, 0};

  for (uint i = 0; i <= top; i++) divsum[i] = 1;

  // sieve
  // only sieve within lower half , the modification starts at 2*p
  for (uint p = 2; p+p <= top; p++) {
    if (divsum[p] > 1) {
      divsum[p] -= p;// subtract number itself from divisor sum ('proper')
      continue;}     // p not prime

    uint x; // highest power of p we need
    //checking x <= top/y instead of x*y <= top to avoid overflow
    for (x = 1; pows[x - 1] <= top/p; x++)
      pows[x] = p*pows[x - 1];

    //counter where n is not a*p with a = ?*p, useful for most p.
    //think of p>31 seldom divisions or p>sqrt(top) than no division is needed
    //n = 2*p, so the prime itself is left unchanged => k=p-1
    uint k= p-1;
    for (uint n = p+p; n <= top; n += p) {
      uint s=1+pows[1];
      k--;
      // search the right power only if needed
      if ( k==0) {
        for (uint i = 2; i < x && !(n%pows[i]); s += pows[i++]);
        k = p; }
      divsum[n] *= s;
    }
  }

  //now correct the upper half
  for (uint p = (top >> 1)+1; p <= top; p++) {
    if (divsum[p] > 1){
      divsum[p] -= p;}
  }

  uint cnt = 0;
  for (uint a = 1; a <= top; a++) {
    uint b = divsum[a];
    if (b > a && b <= top && divsum[b] == a){
      printf("%u %u\n", a, b);
      cnt++;}
  }
  printf("\nTop %u count : %u\n",top,cnt);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f50(int64_t a1);
int32_t function_100003f5c(char * nptr);
int64_t * function_100003f68(int32_t size);
int64_t * function_100003f74(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _atoi(char * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ab8 - 0x100003f50
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ad0
    int64_t v2; // 0x100003ab8
    uint32_t v3 = _atoi((char *)*(int64_t *)(v2 + 8)); // 0x100003af4
    int64_t v4 = (int64_t)_malloc(4 * v3 + 4); // 0x100003b14
    int64_t v5; // bp-168, 0x100003ab8
    _memset(&v5, 0, 128);
    v5 = 1;
    int32_t v6 = 0; // 0x100003b4c
    if (v3 == 0 != v3 != 0) {
        *(int32_t *)(4 * (int64_t)v6 + v4) = 1;
        v6++;
        while (v6 >= v3 != v6 != v3) {
            // 0x100003b54
            *(int32_t *)(4 * (int64_t)v6 + v4) = 1;
            v6++;
        }
    }
    if (v3 <= 4 != v3 != 4) {
        int64_t v7 = &v5;
        int32_t v8; // 0x100003ab8
        int32_t v9 = v8 + 1;
        int32_t v10 = 2;
        int32_t * v11 = (int32_t *)(4 * (int64_t)v10 + v4); // 0x100003bb0
        int32_t v12 = *v11; // 0x100003bb0
        int32_t v13; // 0x100003ab8
        int32_t v14; // 0x100003ab8
        int32_t v15; // 0x100003ab8
        int32_t v16; // 0x100003ab8
        int32_t v17; // 0x100003ab8
        int32_t v18; // 0x100003ab8
        int32_t v19; // 0x100003ab8
        uint32_t v20; // 0x100003ab8
        int32_t v21; // 0x100003ab8
        int32_t v22; // 0x100003ab8
        uint32_t v23; // 0x100003ab8
        uint32_t v24; // 0x100003ab8
        uint32_t v25; // 0x100003bfc
        uint32_t v26; // 0x100003c08
        int32_t v27; // 0x100003c44
        uint32_t v28; // 0x100003bfc
        int32_t v29; // 0x100003c98
        int32_t * v30; // 0x100003d68
        int32_t v31; // 0x100003d80
        uint32_t v32; // 0x100003cf0
        int32_t v33; // 0x100003d2c
        int32_t v34; // 0x100003d40
        if (v12 == 1 || v12 == 0) {
            // 0x100003bf0
            v14 = 4;
            v25 = *(int32_t *)&v5;
            v26 = v3 / v10;
            v13 = v25;
            v21 = 1;
            v22 = 1;
            if (v25 >= v26 != v25 != v26) {
                *(int32_t *)(4 * (int64_t)v21 + v7) = v13 * v10;
                v27 = v21 + 1;
                v28 = *(int32_t *)((int64_t)(4 * v27 - 4) + v7);
                v21 = v27;
                v22 = v27;
                while (v28 >= v26 != v28 != v26) {
                    // 0x100003c1c
                    *(int32_t *)(4 * (int64_t)v21 + v7) = v28 * v10;
                    v27 = v21 + 1;
                    v28 = *(int32_t *)((int64_t)(4 * v27 - 4) + v7);
                    v21 = v27;
                    v22 = v27;
                }
            }
            if (v14 >= v3 != v14 != v3) {
                // 0x100003c88
                v23 = v22;
                v24 = v14;
                v29 = v10 - 2;
                v15 = v29 != 0 ? v29 : v10;
                v18 = v9;
                if (v23 >= 3 && v29 == 0) {
                    v17 = v9;
                    v20 = 2;
                    v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                    v15 = v10;
                    v18 = v17;
                    while (v24 % v32 == 0) {
                        // 0x100003d20
                        v33 = v20 + 1;
                        v34 = v32 + v17;
                        v19 = v33;
                        v16 = v34;
                        v15 = v10;
                        v18 = v34;
                        if (v33 >= v23) {
                            // break -> 0x100003d58
                            break;
                        }
                        v17 = v16;
                        v20 = v19;
                        v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                        v15 = v10;
                        v18 = v17;
                    }
                }
                // 0x100003d58
                v30 = (int32_t *)(4 * (int64_t)v24 + v4);
                *v30 = *v30 * v18;
                v31 = v24 + v10;
                while (v31 >= v3 != v31 != v3) {
                    // 0x100003c88
                    v24 = v31;
                    v29 = v15 - 1;
                    v15 = v29 != 0 ? v29 : v10;
                    v18 = v9;
                    if (v23 >= 3 && v29 == 0) {
                        v17 = v9;
                        v20 = 2;
                        v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                        v15 = v10;
                        v18 = v17;
                        while (v24 % v32 == 0) {
                            // 0x100003d20
                            v33 = v20 + 1;
                            v34 = v32 + v17;
                            v19 = v33;
                            v16 = v34;
                            v15 = v10;
                            v18 = v34;
                            if (v33 >= v23) {
                                // break -> 0x100003d58
                                break;
                            }
                            v17 = v16;
                            v20 = v19;
                            v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                            v15 = v10;
                            v18 = v17;
                        }
                    }
                    // 0x100003d58
                    v30 = (int32_t *)(4 * (int64_t)v24 + v4);
                    *v30 = *v30 * v18;
                    v31 = v24 + v10;
                }
            }
        } else {
            // 0x100003bc4
            *v11 = v12 - v10;
        }
        int32_t v35 = v10 + 1; // 0x100003d94
        int32_t v36 = 2 * v35; // 0x100003b90
        while (v36 >= v3 != v36 != v3) {
            // 0x100003ba8
            v10 = v35;
            v11 = (int32_t *)(4 * (int64_t)v10 + v4);
            v12 = *v11;
            if (v12 == 1 || v12 == 0) {
                // 0x100003bf0
                v14 = v36;
                v25 = *(int32_t *)&v5;
                v26 = v3 / v10;
                v13 = v25;
                v21 = 1;
                v22 = 1;
                if (v25 >= v26 != v25 != v26) {
                    *(int32_t *)(4 * (int64_t)v21 + v7) = v13 * v10;
                    v27 = v21 + 1;
                    v28 = *(int32_t *)((int64_t)(4 * v27 - 4) + v7);
                    v21 = v27;
                    v22 = v27;
                    while (v28 >= v26 != v28 != v26) {
                        // 0x100003c1c
                        *(int32_t *)(4 * (int64_t)v21 + v7) = v28 * v10;
                        v27 = v21 + 1;
                        v28 = *(int32_t *)((int64_t)(4 * v27 - 4) + v7);
                        v21 = v27;
                        v22 = v27;
                    }
                }
                if (v14 >= v3 != v14 != v3) {
                    // 0x100003c88
                    v23 = v22;
                    v24 = v14;
                    v29 = v10 - 2;
                    v15 = v29 != 0 ? v29 : v10;
                    v18 = v9;
                    if (v23 >= 3 && v29 == 0) {
                        v17 = v9;
                        v20 = 2;
                        v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                        v15 = v10;
                        v18 = v17;
                        while (v24 % v32 == 0) {
                            // 0x100003d20
                            v33 = v20 + 1;
                            v34 = v32 + v17;
                            v19 = v33;
                            v16 = v34;
                            v15 = v10;
                            v18 = v34;
                            if (v33 >= v23) {
                                // break -> 0x100003d58
                                break;
                            }
                            v17 = v16;
                            v20 = v19;
                            v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                            v15 = v10;
                            v18 = v17;
                        }
                    }
                    // 0x100003d58
                    v30 = (int32_t *)(4 * (int64_t)v24 + v4);
                    *v30 = *v30 * v18;
                    v31 = v24 + v10;
                    while (v31 >= v3 != v31 != v3) {
                        // 0x100003c88
                        v24 = v31;
                        v29 = v15 - 1;
                        v15 = v29 != 0 ? v29 : v10;
                        v18 = v9;
                        if (v23 >= 3 && v29 == 0) {
                            v17 = v9;
                            v20 = 2;
                            v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                            v15 = v10;
                            v18 = v17;
                            while (v24 % v32 == 0) {
                                // 0x100003d20
                                v33 = v20 + 1;
                                v34 = v32 + v17;
                                v19 = v33;
                                v16 = v34;
                                v15 = v10;
                                v18 = v34;
                                if (v33 >= v23) {
                                    // break -> 0x100003d58
                                    break;
                                }
                                v17 = v16;
                                v20 = v19;
                                v32 = *(int32_t *)(4 * (int64_t)v20 + v7);
                                v15 = v10;
                                v18 = v17;
                            }
                        }
                        // 0x100003d58
                        v30 = (int32_t *)(4 * (int64_t)v24 + v4);
                        *v30 = *v30 * v18;
                        v31 = v24 + v10;
                    }
                }
            } else {
                // 0x100003bc4
                *v11 = v12 - v10;
            }
            // 0x100003d90
            v35 = v10 + 1;
            v36 = 2 * v35;
        }
    }
    int32_t v37 = v3 / 2 + 1;
    if (v37 >= v3 != v37 != v3) {
        int32_t * v38 = (int32_t *)(4 * (int64_t)v37 + v4); // 0x100003dd4
        int32_t v39 = *v38; // 0x100003dd4
        if (v39 != 1 && v39 != 0) {
            // 0x100003de8
            *v38 = v39 - v37;
        }
        int32_t v40 = v37 + 1;
        while (v40 >= v3 != v40 != v3) {
            uint32_t v41 = v40;
            v38 = (int32_t *)(4 * (int64_t)v41 + v4);
            v39 = *v38;
            if (v39 != 1 && v39 != 0) {
                // 0x100003de8
                *v38 = v39 - v41;
            }
            // 0x100003e0c
            v40 = v41 + 1;
        }
    }
    // 0x100003e2c
    if (v3 <= 1 != v3 != 1) {
        uint32_t v42 = 1;
        uint32_t v43 = *(int32_t *)(4 * (int64_t)v42 + v4); // 0x100003e4c
        if (v43 != v42 && v43 >= v42) {
            if (v43 >= v3 != v43 != v3) {
                // 0x100003e84
                if (*(int32_t *)(4 * (int64_t)v43 + v4) == v42) {
                    // 0x100003ea4
                    _printf("%u %u\n", 0, 128);
                }
            }
        }
        int32_t v44 = v42 + 1; // 0x100003ee4
        while (v44 >= v3 != v44 != v3) {
            // 0x100003e44
            v42 = v44;
            v43 = *(int32_t *)(4 * (int64_t)v42 + v4);
            if (v43 != v42 && v43 >= v42) {
                if (v43 >= v3 != v43 != v3) {
                    // 0x100003e84
                    if (*(int32_t *)(4 * (int64_t)v43 + v4) == v42) {
                        // 0x100003ea4
                        _printf("%u %u\n", 0, 128);
                    }
                }
            }
            // 0x100003ee0
            v44 = v42 + 1;
        }
    }
    int32_t v45 = _printf("\nTop %u count : %u\n", 0, 128); // 0x100003f14
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f38
        ___stack_chk_fail((int64_t)v45);
    }
    // 0x100003f3c
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(int64_t a1) {
    // 0x100003f50
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * nptr) {
    // 0x100003f5c
    return _atoi(nptr);
}

// Address range: 0x100003f68 - 0x100003f74
int64_t * function_100003f68(int32_t size) {
    // 0x100003f68
    return _malloc(size);
}

// Address range: 0x100003f74 - 0x100003f80
int64_t * function_100003f74(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f74
    return _memset(s, c, n);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

// returns x where (a * x) % b == 1
int mul_inv(int a, int b)
{
	int b0 = b, t, q;
	int x0 = 0, x1 = 1;
	if (b == 1) return 1;
	while (a > 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 < 0) x1 += b0;
	return x1;
}

int chinese_remainder(int *n, int *a, int len)
{
	int p, i, prod = 1, sum = 0;

	for (i = 0; i < len; i++) prod *= n[i];

	for (i = 0; i < len; i++) {
		p = prod / n[i];
		sum += a[i] * mul_inv(p, n[i]) * p;
	}

	return sum % prod;
}

int main(void)
{
	int n[] = { 3, 5, 7 };
	int a[] = { 2, 3, 2 };

	printf("%d\n", chinese_remainder(n, a, sizeof(n)/sizeof(n[0])));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca8(void);
int64_t function_100003da4(void);
int64_t function_100003f6c(int64_t a1);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x300000002; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca8 - 0x100003da4
int64_t function_100003ca8(void) {
    // 0x100003ca8
    int64_t v1; // 0x100003ca8
    int32_t v2 = v1; // 0x100003cb0
    if (v2 == 1) {
        // 0x100003d98
        return 1;
    }
    int32_t v3 = v1; // 0x100003cac
    int32_t v4 = v3 - 1; // 0x100003cf0
    if (v4 == 0 || v4 < 0 != (v3 & -v3) < 0) {
        // 0x100003d98
        return 1;
    }
    int32_t v5 = v2; // 0x100003cf8
    int32_t v6 = 0;
    int32_t v7 = v3;
    int32_t v8 = v5 - 1; // 0x100003cf0
    int32_t v9 = v6; // 0x100003cf8
    int32_t v10 = v5; // 0x100003cf8
    int32_t v11 = 1 - v7 / v5 * v6; // 0x100003cf8
    while (v8 != 0 && v8 < 0 == (v5 & -v5) < 0) {
        // 0x100003d00
        v5 = v7 % v5;
        v6 = v11;
        v7 = v10;
        int32_t v12 = v9;
        v8 = v5 - 1;
        v9 = v6;
        v10 = v5;
        v11 = v12 - v7 / v5 * v6;
    }
    // 0x100003d98
    return (v6 < 0 ? v2 : 0) + v6;
}

// Address range: 0x100003da4 - 0x100003ec0
int64_t function_100003da4(void) {
    // 0x100003da4
    int64_t v1; // 0x100003da4
    int32_t v2 = v1; // 0x100003db8
    int32_t v3 = -v2;
    int32_t v4 = 0; // 0x100003de0
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003ea0
        return 0;
    }
    int32_t v5 = 1; // 0x100003de0
    v5 *= *(int32_t *)(4 * (int64_t)v4 + v1);
    v4++;
    int32_t v6 = v4 - v2; // 0x100003dd8
    int32_t v7 = 0; // 0x100003de0
    int32_t v8 = 0; // 0x100003de0
    while (v6 < 0 != ((v6 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003de8
        v5 *= *(int32_t *)(4 * (int64_t)v4 + v1);
        v4++;
        v6 = v4 - v2;
        v7 = 0;
        v8 = 0;
    }
    int64_t v9 = 4 * (int64_t)v7; // 0x100003e40
    int32_t v10 = *(int32_t *)(v9 + v1); // 0x100003e40
    int32_t v11 = *(int32_t *)(v9 + v1); // 0x100003e54
    int32_t v12 = v11 * v5 / v10 * (int32_t)function_100003ca8() + v8; // 0x100003e84
    int32_t v13 = v7 + 1; // 0x100003e94
    int32_t v14 = v13 - v2; // 0x100003e24
    v7 = v13;
    v8 = v12;
    while (v14 < 0 != ((v14 ^ v13) & (v13 ^ v2)) < 0) {
        // 0x100003e34
        v9 = 4 * (int64_t)v7;
        v10 = *(int32_t *)(v9 + v1);
        v11 = *(int32_t *)(v9 + v1);
        v12 = v11 * v5 / v10 * (int32_t)function_100003ca8() + v8;
        v13 = v7 + 1;
        v14 = v13 - v2;
        v7 = v13;
        v8 = v12;
    }
    // 0x100003ea0
    return v12 % v5;
}

// Address range: 0x100003ec0 - 0x100003f6c
int64_t entry_point(void) {
    int64_t v1 = g1; // bp-56, 0x100003f0c
    function_100003da4();
    int32_t v2 = _printf("%d\n", (int64_t)&v1); // 0x100003f34
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f44
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f58
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f5c
    return 0;
}

// Address range: 0x100003f6c - 0x100003f78
int64_t function_100003f6c(int64_t a1) {
    // 0x100003f6c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int power (int base, int exponent) {
    int result = 1;
    for (int i = 1; i <= exponent; i++) {
        result *= base;
    }
    return result;
}

int is_disarium (int num) {
    int n = num;
    int sum = 0;
    int len = n <= 9 ? 1 : floor(log10(n)) + 1;
    while (n > 0) {
        sum += power(n % 10, len);
        n /= 10;
        len--;
    }

    return num == sum;
}

int main() {
    int count = 0;
    int i = 0;
    while (count < 19) {
        if (is_disarium(i)) {
            printf("%d ", i);
            count++;
        }
        i++;
    }
    printf("%s\n", "\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d74(void);
int64_t function_100003dd8(void);
float64_t function_100003f7c(float64_t a1);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

float64_t _log10(float64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d74 - 0x100003dd8
int64_t function_100003d74(void) {
    // 0x100003d74
    int64_t v1; // 0x100003d74
    int32_t v2 = v1; // 0x100003d7c
    int32_t v3 = 1 - v2; // 0x100003d98
    int32_t v4 = 1; // 0x100003da0
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003dcc
        return 1;
    }
    int32_t result = 1; // 0x100003da0
    result *= (int32_t)v1;
    v4++;
    while (v4 - v2 == 0 || v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003da8
        result *= (int32_t)v1;
        v4++;
    }
    // 0x100003dcc
    return result;
}

// Address range: 0x100003dd8 - 0x100003ecc
int64_t function_100003dd8(void) {
    // 0x100003dd8
    int64_t v1; // 0x100003dd8
    int32_t v2 = v1; // 0x100003de4
    int32_t v3 = v2 - 9; // 0x100003df8
    if (v3 != 0 && v3 < 0 == (8 - v2 & v2) < 0) {
        // 0x100003e14
        _log10((float64_t)(int64_t)__asm_sshll(0.0f, 0));
        float64_t v4; // 0x100003dd8
        __asm_frintm(v4);
    }
    // 0x100003e3c
    if (v2 < 1) {
        // 0x100003eac
        return 0 == v2;
    }
    int32_t v5 = 0; // 0x100003e58
    uint32_t v6 = v2;
    v5 += (int32_t)function_100003d74();
    int32_t v7 = v6 / 10; // 0x100003e58
    while (v6 >= 10) {
        // 0x100003e60
        v6 = v7;
        v5 += (int32_t)function_100003d74();
        v7 = v6 / 10;
    }
    // 0x100003eac
    return v5 == v2;
}

// Address range: 0x100003ecc - 0x100003f7c
int64_t entry_point(void) {
    int32_t v1 = 0;
    int32_t v2 = v1; // 0x100003f0c
    int64_t v3; // 0x100003ecc
    if ((int32_t)function_100003dd8() != 0) {
        // 0x100003f14
        _printf("%d ", v3);
        v2 = v1 + 1;
    }
    // 0x100003f40
    while (v2 < 19 != (18 - v2 & v2) < 0) {
        // 0x100003efc
        v1 = v2;
        v2 = v1;
        if ((int32_t)function_100003dd8() != 0) {
            // 0x100003f14
            _printf("%d ", v3);
            v2 = v1 + 1;
        }
    }
    // 0x100003f50
    _printf("%s\n", (char *)v3);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
float64_t function_100003f7c(float64_t a1) {
    // 0x100003f7c
    return _log10(a1);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<stdio.h>

#define UNITS_LENGTH 13

int main(int argC,char* argV[])
{
	int i,reference;
	char *units[UNITS_LENGTH] = {"kilometer","meter","centimeter","tochka","liniya","diuym","vershok","piad","fut","arshin","sazhen","versta","milia"};
    double factor, values[UNITS_LENGTH] = {1000.0,1.0,0.01,0.000254,0.00254,0.0254,0.04445,0.1778,0.3048,0.7112,2.1336,1066.8,7467.6};
	
	if(argC!=3)
		printf("Usage : %s followed by length as <value> <unit>");
	else{
		for(i=0;argV[2][i]!=00;i++)
			argV[2][i] = tolower(argV[2][i]);
		
		for(i=0;i<UNITS_LENGTH;i++){
			if(strstr(argV[2],units[i])!=NULL){
				reference = i;
				factor = atof(argV[1])*values[i];
				break;
			}
		}
		
		printf("%s %s is equal in length to : \n",argV[1],argV[2]);
		
		for(i=0;i<UNITS_LENGTH;i++){
			if(i!=reference)
				printf("\n%lf %s",factor/values[i],units[i]);
		}
	}
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e44(void);
float64_t function_100003e50(char * nptr);
int64_t * function_100003e5c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003e68(char * format, ...);
char * function_100003e74(char * haystack, char * needle);
int32_t function_100003e80(int32_t c);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f40
int64_t g2 = 0x10000000003e8c; // 0x100004038

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
float64_t _atof(char * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
char * _strstr(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bfc - 0x100003e44
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c14
    int64_t v2; // bp-144, 0x100003bfc
    _memcpy(&v2, &g2, 104);
    int64_t v3; // bp-248, 0x100003bfc
    _memcpy(&v3, (int64_t *)&g1, 104);
    int64_t v4; // 0x100003bfc
    if ((int32_t)v4 == 3) {
        int64_t * v5 = (int64_t *)(v4 + 16); // 0x100003c84
        char * v6 = (char *)*v5;
        char c = *v6; // 0x100003c8c
        char * v7 = v6; // 0x100003c98
        if (c != 0) {
            *(char *)*v5 = (char)_tolower((int32_t)c);
            int32_t v8 = 1; // 0x100003ccc
            int64_t v9 = *v5; // 0x100003c84
            int64_t v10 = v8; // 0x100003c88
            char v11 = *(char *)(v9 + v10); // 0x100003c8c
            char c2 = v11; // 0x100003c98
            int64_t v12 = v10; // 0x100003c98
            int32_t v13 = v8; // 0x100003c98
            while (v11 != 0) {
                // 0x100003ca0
                *(char *)(*v5 + v12) = (char)_tolower((int32_t)c2);
                v8 = v13 + 1;
                v9 = *v5;
                v10 = v8;
                v11 = *(char *)(v9 + v10);
                c2 = v11;
                v12 = v10;
                v13 = v8;
            }
            // 0x100003ce0
            v7 = (char *)v9;
        }
        char * v14 = (char *)v2;
        char * v15 = _strstr(v7, v14); // 0x100003d08
        int32_t v16 = 0; // 0x100003d14
        char * v17 = v14; // 0x100003d14
        int32_t v18 = 0; // 0x100003d14
        int64_t v19 = 0; // 0x100003d14
        char * v20; // 0x100003bfc
        int32_t v21; // 0x100003bfc
        int64_t v22; // 0x100003bfc
        if (v15 == NULL) {
            int64_t v23 = v19 + 1;
            int32_t v24 = v23;
            v20 = v14;
            int128_t v25; // 0x100003bfc
            v22 = v25;
            while (v19 < 12 != (11 - v18 & v24) < 0) {
                int64_t v26 = *(int64_t *)(8 * v23 + (int64_t)&v2); // 0x100003d04
                char * v27 = (char *)v26;
                char * v28 = _strstr((char *)*v5, v27); // 0x100003d08
                v16 = v24;
                v17 = v27;
                v18++;
                v19 = v23;
                if (v28 != NULL) {
                    goto lab_0x100003d1c;
                }
                v23 = v19 + 1;
                v24 = v23;
                v20 = v27;
                v22 = v25;
            }
        } else {
          lab_0x100003d1c:;
            int64_t v29 = *(int64_t *)(v4 + 8); // 0x100003d28
            v20 = v17;
            v21 = v16;
            v22 = (float32_t)_atof((char *)v29);
        }
        // 0x100003d5c
        _printf("%s %s is equal in length to : \n", v20, (char *)104);
        for (int32_t i = 0; i < 13; i++) {
            // 0x100003da0
            if (i != v21) {
                // 0x100003db8
                _printf("\n%lf %s", (float64_t)v22, v20);
            }
        }
    } else {
        // 0x100003c68
        _printf("Usage : %s followed by length as <value> <unit>", (char *)&g1);
    }
    // 0x100003e0c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e2c
        ___stack_chk_fail();
    }
    // 0x100003e30
    return 0;
}

// Address range: 0x100003e44 - 0x100003e50
int64_t function_100003e44(void) {
    // 0x100003e44
    return ___stack_chk_fail();
}

// Address range: 0x100003e50 - 0x100003e5c
float64_t function_100003e50(char * nptr) {
    // 0x100003e50
    return _atof(nptr);
}

// Address range: 0x100003e5c - 0x100003e68
int64_t * function_100003e5c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e5c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003e68 - 0x100003e74
int32_t function_100003e68(char * format, ...) {
    // 0x100003e68
    return _printf(format);
}

// Address range: 0x100003e74 - 0x100003e80
char * function_100003e74(char * haystack, char * needle) {
    // 0x100003e74
    return _strstr(haystack, needle);
}

// Address range: 0x100003e80 - 0x100003e8c
int32_t function_100003e80(int32_t c) {
    // 0x100003e80
    return _tolower(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

const char *shades = ".:!*oe&#%@";

double light[3] = { 30, 30, -50 };
void normalize(double * v)
{
        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        v[0] /= len; v[1] /= len; v[2] /= len;
}

double dot(double *x, double *y)
{
        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
        return d < 0 ? -d : 0;
}

void draw_sphere(double R, double k, double ambient)
{
        int i, j, intensity;
        double b;
        double vec[3], x, y;
        for (i = floor(-R); i <= ceil(R); i++) {
                x = i + .5;
                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {
                        y = j / 2. + .5;
                        if (x * x + y * y <= R * R) {
                                vec[0] = x;
                                vec[1] = y;
                                vec[2] = sqrt(R * R - x * x - y * y);
                                normalize(vec);
                                b = pow(dot(light, vec), k) + ambient;
                                intensity = (1 - b) * (sizeof(shades) - 1);
                                if (intensity < 0) intensity = 0;
                                if (intensity >= sizeof(shades) - 1)
                                        intensity = sizeof(shades) - 2;
                                putchar(shades[intensity]);
                        } else
                                putchar(' ');
                }
                putchar('\n');
        }
}


int main()
{
        normalize(light);
        draw_sphere(20, 4, .1);
        draw_sphere(10, 2, .4);

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b78(void);
int64_t function_100003c08(void);
int64_t function_100003c90(void);
int64_t function_100003f54(void);
float64_t function_100003f60(float64_t a1, float64_t a2);
int32_t function_100003f6c(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x3f88; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b78 - 0x100003c08
int64_t function_100003b78(void) {
    // 0x100003b78
    int64_t v1; // 0x100003b78
    int64_t result = v1;
    float64_t * v2 = (float64_t *)(result + 8); // 0x100003b94
    float64_t v3 = *v2; // 0x100003b94
    float64_t * v4 = (float64_t *)(result + 16); // 0x100003bac
    float64_t v5 = *v4; // 0x100003bac
    float64_t v6 = sqrt((float64_t)result * (float64_t)result + v3 * v3 + v5 * v5); // 0x100003bbc
    *(float64_t *)result = (float64_t)result / v6;
    *v2 = *v2 / v6;
    *v4 = *v4 / v6;
    return result;
}

// Address range: 0x100003c08 - 0x100003c90
int64_t function_100003c08(void) {
    // 0x100003c08
    int64_t result; // 0x100003c08
    return result;
}

// Address range: 0x100003c90 - 0x100003ef8
int64_t function_100003c90(void) {
    // 0x100003c90
    float64_t v1; // 0x100003c90
    float64_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ca4
    float64_t v4 = -v2; // 0x100003cbc
    __asm_fcvtms(v4);
    __asm_sshll(0.0f, 0);
    float64_t v5 = __asm_frintp(v2); // 0x100003ce0
    int64_t v6; // 0x100003c90
    if (v5 >= v4 != v5 != v4) {
        float64_t v7 = -2.0 * v2;
        float64_t v8 = 2.0 * v2;
        float64_t v9 = v2 * v2;
        __asm_sshll(0.0f, 0);
        __asm_fcvtms(v7);
        __asm_sshll(0.0f, 0);
        float64_t v10 = __asm_frintp(v8); // 0x100003d44
        float64_t v11 = v7; // 0x100003d50
        float64_t v12; // 0x100003c90
        float64_t v13; // 0x100003c90
        uint32_t v14; // 0x100003c90
        float64_t v15; // 0x100003d08
        float64_t v16; // 0x100003c90
        float64_t v17; // 0x100003c90
        int128_t v18; // 0x100003d60
        float64_t v19; // 0x100003d74
        float64_t v20; // 0x100003d8c
        float64_t v21; // 0x100003d90
        float64_t v22; // 0x100003dec
        float64_t v23; // 0x100003e2c
        int32_t v24; // 0x100003e30
        char v25; // 0x100003e80
        float64_t v26; // 0x100003d44
        int128_t v27; // 0x100003c90
        if (v7 <= v10 != v7 != v10) {
            // 0x100003d58
            v15 = v4 + 0.5;
            v16 = v15 * v15;
            v17 = -((v16 - v9));
            v18 = __asm_sshll(0.0f, 0);
            v19 = 0.5 * v7 + 0.5;
            v20 = v19 * v19;
            v21 = v16 + v20;
            if (v21 <= v9 == (v21 != v9)) {
                // 0x100003e8c
                _putchar(32);
                v12 = v21;
            } else {
                // 0x100003db0
                v22 = sqrt(v17 - v20);
                function_100003b78();
                function_100003c08();
                _pow((float64_t)(int64_t)v18, (float64_t)(int64_t)v27);
                v23 = 7.0 * (1.0 - (v1 + v22));
                v24 = v23;
                v14 = v24 > 0 ? v24 : 0;
                v25 = *(char *)(g1 + (int64_t)(v14 < 6 ? v14 : 6));
                _putchar((int32_t)v25);
                v12 = v23;
            }
            // 0x100003e9c
            v13 = v12;
            __asm_sshll(0.0f, 0);
            v26 = __asm_frintp(v8);
            v11 = v13;
            while (v13 <= v26 != v13 != v26) {
                // 0x100003d58
                v18 = __asm_sshll(0.0f, 0);
                v19 = 0.5 * v13 + 0.5;
                v20 = v19 * v19;
                v21 = v16 + v20;
                if (v21 <= v9 == (v21 != v9)) {
                    // 0x100003e8c
                    _putchar(32);
                    v12 = v21;
                } else {
                    // 0x100003db0
                    v22 = sqrt(v17 - v20);
                    function_100003b78();
                    function_100003c08();
                    _pow((float64_t)(int64_t)v18, (float64_t)(int64_t)v27);
                    v23 = 7.0 * (1.0 - (v1 + v22));
                    v24 = v23;
                    v14 = v24 > 0 ? v24 : 0;
                    v25 = *(char *)(g1 + (int64_t)(v14 < 6 ? v14 : 6));
                    _putchar((int32_t)v25);
                    v12 = v23;
                }
                // 0x100003e9c
                v13 = v12;
                __asm_sshll(0.0f, 0);
                v26 = __asm_frintp(v8);
                v11 = v13;
            }
        }
        float64_t v28 = v11;
        int32_t v29 = _putchar(10); // 0x100003eb0
        __asm_sshll(0.0f, 0);
        float64_t v30 = __asm_frintp(v2); // 0x100003ce0
        float64_t v31 = v28; // 0x100003cec
        while (v28 <= v30 != v28 != v30) {
            // 0x100003cf4
            __asm_sshll(0.0f, 0);
            __asm_fcvtms(v7);
            __asm_sshll(0.0f, 0);
            v10 = __asm_frintp(v8);
            v11 = v7;
            if (v7 <= v10 != v7 != v10) {
                // 0x100003d58
                v15 = v31 + 0.5;
                v16 = v15 * v15;
                v17 = -((v16 - v9));
                v18 = __asm_sshll(0.0f, 0);
                v19 = 0.5 * v7 + 0.5;
                v20 = v19 * v19;
                v21 = v16 + v20;
                if (v21 <= v9 == (v21 != v9)) {
                    // 0x100003e8c
                    _putchar(32);
                    v12 = v21;
                } else {
                    // 0x100003db0
                    v22 = sqrt(v17 - v20);
                    function_100003b78();
                    function_100003c08();
                    _pow((float64_t)(int64_t)v18, (float64_t)(int64_t)v27);
                    v23 = 7.0 * (1.0 - (v1 + v22));
                    v24 = v23;
                    v14 = v24 > 0 ? v24 : 0;
                    v25 = *(char *)(g1 + (int64_t)(v14 < 6 ? v14 : 6));
                    _putchar((int32_t)v25);
                    v12 = v23;
                }
                // 0x100003e9c
                v13 = v12;
                __asm_sshll(0.0f, 0);
                v26 = __asm_frintp(v8);
                v11 = v13;
                while (v13 <= v26 != v13 != v26) {
                    // 0x100003d58
                    v18 = __asm_sshll(0.0f, 0);
                    v19 = 0.5 * v13 + 0.5;
                    v20 = v19 * v19;
                    v21 = v16 + v20;
                    if (v21 <= v9 == (v21 != v9)) {
                        // 0x100003e8c
                        _putchar(32);
                        v12 = v21;
                    } else {
                        // 0x100003db0
                        v22 = sqrt(v17 - v20);
                        function_100003b78();
                        function_100003c08();
                        _pow((float64_t)(int64_t)v18, (float64_t)(int64_t)v27);
                        v23 = 7.0 * (1.0 - (v1 + v22));
                        v24 = v23;
                        v14 = v24 > 0 ? v24 : 0;
                        v25 = *(char *)(g1 + (int64_t)(v14 < 6 ? v14 : 6));
                        _putchar((int32_t)v25);
                        v12 = v23;
                    }
                    // 0x100003e9c
                    v13 = v12;
                    __asm_sshll(0.0f, 0);
                    v26 = __asm_frintp(v8);
                    v11 = v13;
                }
            }
            // 0x100003eac
            v28 = v11;
            v29 = _putchar(10);
            __asm_sshll(0.0f, 0);
            v30 = __asm_frintp(v2);
            v31 = v28;
        }
        // 0x100003ccc
        v6 = v29;
    }
    int64_t result = v6; // 0x100003ee0
    if (*(int64_t *)*(int64_t *)0x100004008 != v3) {
        // 0x100003ee8
        result = ___stack_chk_fail();
    }
    // 0x100003eec
    return result;
}

// Address range: 0x100003ef8 - 0x100003f54
int64_t entry_point(void) {
    // 0x100003ef8
    function_100003b78();
    function_100003c90();
    function_100003c90();
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int64_t function_100003f54(void) {
    // 0x100003f54
    return ___stack_chk_fail();
}

// Address range: 0x100003f60 - 0x100003f6c
float64_t function_100003f60(float64_t a1, float64_t a2) {
    // 0x100003f60
    return _pow(a1, a2);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int32_t c) {
    // 0x100003f6c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <assert.h>
#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct bit_array_tag {
    uint32_t size;
    uint32_t* array;
} bit_array;

bool bit_array_create(bit_array* b, uint32_t size) {
    uint32_t* array = calloc((size + 31)/32, sizeof(uint32_t));
    if (array == NULL)
        return false;
    b->size = size;
    b->array = array;
    return true;
}

void bit_array_destroy(bit_array* b) {
    free(b->array);
    b->array = NULL;
}

void bit_array_set(bit_array* b, uint32_t index, bool value) {
    assert(index < b->size);
    uint32_t* p = &b->array[index >> 5];
    uint32_t bit = 1 << (index & 31);
    if (value)
        *p |= bit;
    else
        *p &= ~bit;
}

bool bit_array_get(const bit_array* b, uint32_t index) {
    assert(index < b->size);
    uint32_t* p = &b->array[index >> 5];
    uint32_t bit = 1 << (index & 31);
    return (*p & bit) != 0;
}

typedef struct sieve_tag {
    uint32_t limit;
    bit_array not_prime;
} sieve;

bool sieve_create(sieve* s, uint32_t limit) {
    if (!bit_array_create(&s->not_prime, limit/2))
        return false;
    for (uint32_t p = 3; p * p <= limit; p += 2) {
        if (bit_array_get(&s->not_prime, p/2 - 1) == false) {
            uint32_t inc = 2 * p;
            for (uint32_t q = p * p; q <= limit; q += inc)
                bit_array_set(&s->not_prime, q/2 - 1, true);
        }
    }
    s->limit = limit;
    return true;
}

void sieve_destroy(sieve* s) {
    bit_array_destroy(&s->not_prime);
}

bool is_prime(const sieve* s, uint32_t n) {
    assert(n <= s->limit);
    if (n == 2)
        return true;
    if (n < 2 || n % 2 == 0)
        return false;
    return bit_array_get(&s->not_prime, n/2 - 1) == false;
}

// return number of decimal digits
uint32_t count_digits(uint32_t n) {
    uint32_t digits = 0;
    for (; n > 0; ++digits)
        n /= 10;
    return digits;
}

// return the number with one digit replaced
uint32_t change_digit(uint32_t n, uint32_t index, uint32_t new_digit) {
    uint32_t p = 1;
    uint32_t changed = 0;
    for (; index > 0; p *= 10, n /= 10, --index)
        changed += p * (n % 10);
    changed += (10 * (n/10) + new_digit) * p;
    return changed;
}

// returns true if n unprimeable
bool unprimeable(const sieve* s, uint32_t n) {
    if (is_prime(s, n))
        return false;
    uint32_t d = count_digits(n);
    for (uint32_t i = 0; i < d; ++i) {
        for (uint32_t j = 0; j <= 9; ++j) {
            uint32_t m = change_digit(n, i, j);
            if (m != n && is_prime(s, m))
                return false;
        }
    }
    return true;
}

int main() {
    const uint32_t limit = 10000000;
    setlocale(LC_ALL, "");
    sieve s = { 0 };
    if (!sieve_create(&s, limit)) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    printf("First 35 unprimeable numbers:\n");
    uint32_t n = 100;
    uint32_t lowest[10] = { 0 };
    for (uint32_t count = 0, found = 0; n < limit && (found < 10 || count < 600); ++n) {
        if (unprimeable(&s, n)) {
            if (count < 35) {
                if (count != 0)
                    printf(", ");
                printf("%'u", n);
            }
            ++count;
            if (count == 600)
                printf("\n600th unprimeable number: %'u\n", n);
            uint32_t last_digit = n % 10;
            if (lowest[last_digit] == 0) {
                lowest[last_digit] = n;
                ++found;
            }
        }
    }
    sieve_destroy(&s);
    for (uint32_t i = 0; i < 10; ++i)
        printf("Least unprimeable number ending in %u: %'u\n" , i, lowest[i]);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000341c(void);
int64_t function_1000034bc(int64_t a1);
int64_t function_1000034ec(void);
int64_t function_1000035cc(void);
int64_t function_10000367c(void);
int64_t function_1000037e0(int64_t * a1);
int64_t function_100003808(void);
int64_t function_100003930(void);
int64_t function_100003984(void);
int64_t function_100003a48(void);
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003e68(int64_t a1);
int64_t * function_100003e74(int32_t nmemb, int32_t size);
int32_t function_100003e80(struct _IO_FILE * stream, char * format, ...);
void function_100003e8c(int64_t * ptr);
int64_t * function_100003e98(int64_t * s, int32_t c, int32_t n);
int32_t function_100003ea4(char * format, ...);
char * function_100003eb0(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f15
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x10000341c - 0x1000034bc
int64_t function_10000341c(void) {
    // 0x10000341c
    int64_t v1; // 0x10000341c
    int32_t v2 = v1; // 0x10000342c
    int64_t * v3 = _calloc((v2 + 31) / 32, 4); // 0x10000344c
    int64_t result = 0; // 0x100003460
    if (v3 != NULL) {
        // 0x10000347c
        *(int32_t *)v1 = v2;
        *(int64_t *)(v1 + 8) = (int64_t)v3;
        result = 1;
    }
    // 0x1000034a8
    return result;
}

// Address range: 0x1000034bc - 0x1000034ec
int64_t function_1000034bc(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1000034d0
    _free((int64_t *)*v1);
    *v1 = 0;
    return &g2;
}

// Address range: 0x1000034ec - 0x1000035cc
int64_t function_1000034ec(void) {
    // 0x1000034ec
    int64_t v1; // 0x1000034ec
    uint32_t v2 = (int32_t)v1; // 0x1000034fc
    int64_t result; // 0x1000034ec
    if ((int32_t)v1 <= v2) {
        // 0x100003534
        result = ___assert_rtn("bit_array_set", "unprimeable-numbers.c", 28, "index < b->size");
    }
    int32_t * v3 = (int32_t *)(*(int64_t *)(v1 + 8) + (v1 / 8 & 0x1ffffffc)); // 0x10000356c
    int32_t v4 = 1 << v2 % 32; // 0x10000357c
    int32_t v5 = *v3;
    *v3 = (uint64_t)v1 % 2 == 0 ? v5 & -1 - v4 : v5 | v4;
    return result;
}

// Address range: 0x1000035cc - 0x10000367c
int64_t function_1000035cc(void) {
    // 0x1000035cc
    int64_t v1; // 0x1000035cc
    uint64_t v2 = v1;
    uint32_t v3 = (int32_t)v2; // 0x1000035dc
    if ((int32_t)v1 <= v3) {
        // 0x100003608
        ___assert_rtn("bit_array_get", "unprimeable-numbers.c", 38, "index < b->size");
    }
    int32_t v4 = *(int32_t *)(*(int64_t *)(v1 + 8) + (v2 / 8 & 0x1ffffffc)); // 0x10000365c
    return (v4 & 1 << v3 % 32) != 0;
}

// Address range: 0x10000367c - 0x1000037e0
int64_t function_10000367c(void) {
    // 0x10000367c
    if (function_10000341c() % 2 == 0) {
        // 0x1000037cc
        return 0;
    }
    // 0x1000036d0
    int64_t v1; // 0x10000367c
    uint32_t v2 = (int32_t)v1; // 0x10000368c
    if (v2 <= 9 == (v2 != 9)) {
        // 0x1000037ac
        *(int32_t *)v1 = v2;
        // 0x1000037cc
        return 1;
    }
    int32_t v3 = 3;
    int32_t v4; // 0x10000367c
    int32_t v5; // 0x10000367c
    int32_t v6; // 0x100003788
    int32_t v7; // 0x100003724
    if (function_1000035cc() % 2 == 0) {
        // 0x10000371c
        v4 = 9;
        v7 = 2 * v3;
        v5 = v4;
        if (v4 >= v2 != v4 != v2) {
            function_1000034ec();
            v6 = v5 + v7;
            v5 = v6;
            while (v6 >= v2 != v6 != v2) {
                // 0x100003758
                function_1000034ec();
                v6 = v5 + v7;
                v5 = v6;
            }
        }
    }
    int32_t v8 = v3 + 2; // 0x1000037a0
    int32_t v9 = v8 * v8; // 0x1000036d8
    int32_t v10 = v9; // 0x1000036e8
    while (v9 >= v2 != v9 != v2) {
        // 0x1000036f0
        v3 = v8;
        if (function_1000035cc() % 2 == 0) {
            // 0x10000371c
            v4 = v10;
            v7 = 2 * v3;
            v5 = v4;
            if (v4 >= v2 != v4 != v2) {
                function_1000034ec();
                v6 = v5 + v7;
                v5 = v6;
                while (v6 >= v2 != v6 != v2) {
                    // 0x100003758
                    function_1000034ec();
                    v6 = v5 + v7;
                    v5 = v6;
                }
            }
        }
        // 0x10000379c
        v8 = v3 + 2;
        v9 = v8 * v8;
        v10 = v9;
    }
    // 0x1000037ac
    *(int32_t *)v1 = v2;
    // 0x1000037cc
    return 1;
}

// Address range: 0x1000037e0 - 0x100003808
int64_t function_1000037e0(int64_t * a1) {
    // 0x1000037e0
    return function_1000034bc((int64_t)a1 + 8);
}

// Address range: 0x100003808 - 0x100003930
int64_t function_100003808(void) {
    // 0x100003808
    int64_t v1; // 0x100003808
    uint32_t v2 = (int32_t)v1; // 0x100003818
    uint32_t v3 = (int32_t)v1;
    if (v3 <= v2 == (v3 != v2)) {
        // 0x100003844
        ___assert_rtn("is_prime", "unprimeable-numbers.c", 68, "n <= s->limit");
    }
    // 0x100003868
    if (v2 == 2) {
        // 0x10000391c
        return 1;
    }
    // 0x100003890
    if (v2 < 2) {
        // 0x10000391c
        return 0;
    }
    int64_t result = 0; // 0x1000038c0
    if (2 * v2 / 2 != v2) {
        // 0x1000038dc
        result = function_1000035cc() % 2 == 0;
    }
    // 0x10000391c
    return result;
}

// Address range: 0x100003930 - 0x100003984
int64_t function_100003930(void) {
    // 0x100003930
    int64_t v1; // 0x100003930
    int32_t v2 = v1; // 0x100003934
    int32_t result = 0; // 0x10000394c
    if (v2 == 0) {
        // 0x100003978
        return 0;
    }
    uint32_t v3 = v2; // 0x10000394c
    result++;
    while (v3 >= 10) {
        // 0x100003954
        v3 /= 10;
        result++;
    }
    // 0x100003978
    return result;
}

// Address range: 0x100003984 - 0x100003a48
int64_t function_100003984(void) {
    // 0x100003984
    int64_t v1; // 0x100003984
    int32_t v2 = v1; // 0x100003988
    int32_t v3 = v1; // 0x10000398c
    int32_t v4 = v2 % 10;
    int32_t v5 = v2; // 0x1000039b0
    int32_t v6 = v3; // 0x1000039b0
    int32_t v7 = 0; // 0x1000039b0
    if (v3 == 0) {
        // 0x100003a10
        return v2 + (int32_t)v1 - v4;
    }
    int32_t v8 = 1; // 0x1000039b0
    v7 += v8 * v4;
    v8 *= 10;
    v5 /= 10;
    v6--;
    int32_t v9 = v5 % 10;
    while (v6 != 0) {
        // 0x1000039b8
        v7 += v8 * v9;
        v8 *= 10;
        v5 /= 10;
        v6--;
        v9 = v5 % 10;
    }
    // 0x100003a10
    return (v5 + (int32_t)v1 - v9) * v8 + v7;
}

// Address range: 0x100003a48 - 0x100003b70
int64_t function_100003a48(void) {
    // 0x100003a48
    if (function_100003808() % 2 != 0) {
        // 0x100003b5c
        return 0;
    }
    uint32_t v1 = (int32_t)function_100003930(); // 0x100003a8c
    int32_t v2 = 0; // 0x100003aa8
    int64_t result = 1; // 0x100003aa8
    if (v1 == 0) {
      lab_0x100003b5c:
        // 0x100003b5c
        return result;
    }
    int32_t v3 = 0; // 0x100003b28
    int64_t v4; // 0x100003a48
    if ((int32_t)v4 != (int32_t)function_100003984()) {
        // 0x100003af8
        result = 0;
        if (function_100003808() % 2 != 0) {
            return result;
        }
    }
    while (v3 >= 8 != v3 != 8) {
        // 0x100003b24
        v3++;
        if ((int32_t)v4 != (int32_t)function_100003984()) {
            // 0x100003af8
            result = 0;
            if (function_100003808() % 2 != 0) {
                return result;
            }
        }
    }
    // 0x100003b38
    v2++;
    while (v2 < v1) {
        // 0x100003ab8
        v3 = 0;
        if ((int32_t)v4 != (int32_t)function_100003984()) {
            // 0x100003af8
            result = 0;
            if (function_100003808() % 2 != 0) {
                return result;
            }
        }
        while (v3 >= 8 != v3 != 8) {
            // 0x100003b24
            v3++;
            if ((int32_t)v4 != (int32_t)function_100003984()) {
                // 0x100003af8
                result = 0;
                if (function_100003808() % 2 != 0) {
                    return result;
                }
            }
        }
        // 0x100003b38
        v2++;
    }
    // 0x100003b5c
    return 1;
}

// Address range: 0x100003b70 - 0x100003e5c
int64_t entry_point(void) {
    // 0x100003b70
    _setlocale(0, (char *)&g1);
    int64_t v1 = 0; // bp-96, 0x100003bb8
    int64_t result; // 0x100003b70
    int32_t v2; // 0x100003b70
    if (function_10000367c() % 2 == 0) {
        int64_t v3 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003bd8
        v2 = _fprintf((struct _IO_FILE *)v3, "Out of memory\n");
        result = 1;
    } else {
        // 0x100003bf4
        _printf("First 35 unprimeable numbers:\n");
        int64_t v4; // bp-64, 0x100003b70
        _memset(&v4, 0, 40);
        int64_t v5 = &v4;
        int32_t v6 = 100;
        uint32_t v7 = 0;
        int32_t v8 = 0;
        if (v8 >= 10) {
            // 0x100003c80
            if (v7 >= 600) {
                // break -> 0x100003dac
                break;
            }
        }
        int32_t v9 = v7; // 0x100003c98
        int32_t v10 = v8; // 0x100003c98
        int32_t v11; // 0x100003b70
        int32_t v12; // 0x100003b70
        int32_t * v13; // 0x100003d5c
        if (function_100003a48() % 2 != 0) {
            if (v7 < 35) {
                if (v7 != 0) {
                    // 0x100003cc8
                    _printf(", ");
                }
                // 0x100003cf8
                _printf("%'u", v6);
                v11 = v7 + 1;
            } else {
                // 0x100003cf8
                v11 = v7 + 1;
                if (v7 == 599) {
                    // 0x100003d18
                    _printf("\n600th unprimeable number: %'u\n", v6);
                    v11 = 600;
                }
            }
            // 0x100003d38
            v12 = v11;
            v13 = (int32_t *)((int64_t)(4 * (v6 % 10)) + v5);
            v9 = v12;
            v10 = v8;
            if (*v13 == 0) {
                // 0x100003d70
                *v13 = v6;
                v9 = v12;
                v10 = v8 + 1;
            }
        }
        int32_t v14 = v6 + 1; // 0x100003da0
        int32_t v15 = v6; // 0x100003c3c
        int32_t v16 = 0x98967f; // 0x100003c3c
        while (v14 < 0x989680) {
            // 0x100003c44
            v6 = v14;
            v7 = v9;
            v8 = v10;
            if (v8 >= 10) {
                // 0x100003c80
                v16 = v15;
                if (v7 >= 600) {
                    // break -> 0x100003dac
                    break;
                }
            }
            // 0x100003c8c
            v9 = v7;
            v10 = v8;
            if (function_100003a48() % 2 != 0) {
                if (v7 < 35) {
                    if (v7 != 0) {
                        // 0x100003cc8
                        _printf(", ");
                    }
                    // 0x100003cf8
                    _printf("%'u", v6);
                    v11 = v7 + 1;
                } else {
                    // 0x100003cf8
                    v11 = v7 + 1;
                    if (v7 == 599) {
                        // 0x100003d18
                        _printf("\n600th unprimeable number: %'u\n", v6);
                        v11 = 600;
                    }
                }
                // 0x100003d38
                v12 = v11;
                v13 = (int32_t *)((int64_t)(4 * (v6 % 10)) + v5);
                v9 = v12;
                v10 = v8;
                if (*v13 == 0) {
                    // 0x100003d70
                    *v13 = v6;
                    v9 = v12;
                    v10 = v8 + 1;
                }
            }
            // 0x100003d9c
            v14 = v6 + 1;
            v15 = v6;
            v16 = 0x98967f;
        }
        // 0x100003dac
        function_1000037e0(&v1);
        int32_t v17 = 0; // 0x100003e0c
        v17++;
        v2 = _printf("Least unprimeable number ending in %u: %'u\n", v16, 40);
        result = 0;
        while (v17 != 10) {
            // 0x100003dd0
            v17++;
            v2 = _printf("Least unprimeable number ending in %u: %'u\n", v16, 40);
            result = 0;
        }
    }
    int64_t v18 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e34
    if (v18 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003e48
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003e4c
    return result;
}

// Address range: 0x100003e5c - 0x100003e68
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e5c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(int64_t a1) {
    // 0x100003e68
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e74 - 0x100003e80
int64_t * function_100003e74(int32_t nmemb, int32_t size) {
    // 0x100003e74
    return _calloc(nmemb, size);
}

// Address range: 0x100003e80 - 0x100003e8c
int32_t function_100003e80(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e80
    return _fprintf(stream, format);
}

// Address range: 0x100003e8c - 0x100003e98
void function_100003e8c(int64_t * ptr) {
    // 0x100003e8c
    _free(ptr);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int64_t * s, int32_t c, int32_t n) {
    // 0x100003e98
    return _memset(s, c, n);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// Address range: 0x100003eb0 - 0x100003ebc
char * function_100003eb0(int32_t category, char * locale) {
    // 0x100003eb0
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 19

`
`#include <math.h>
#include <stdio.h>
#include <string.h>

int find(char *s, char c) {
    for (char *i = s; *i != 0; i++) {
        if (*i == c) {
            return i - s;
        }
    }
    return -1;
}

void reverse(char *b, char *e) {
    for (e--; b < e; b++, e--) {
        char t = *b;
        *b = *e;
        *e = t;
    }
}

//////////////////////////////////////////////////////

struct Complex {
    double rel, img;
};

void printComplex(struct Complex c) {
    printf("(%3.0f + %3.0fi)", c.rel, c.img);
}

struct Complex makeComplex(double rel, double img) {
    struct Complex c = { rel, img };
    return c;
}

struct Complex addComplex(struct Complex a, struct Complex b) {
    struct Complex c = { a.rel + b.rel, a.img + b.img };
    return c;
}

struct Complex mulComplex(struct Complex a, struct Complex b) {
    struct Complex c = { a.rel * b.rel - a.img * b.img, a.rel * b.img - a.img * b.rel };
    return c;
}

struct Complex mulComplexD(struct Complex a, double b) {
    struct Complex c = { a.rel * b, a.img * b };
    return c;
}

struct Complex negComplex(struct Complex a) {
    return mulComplexD(a, -1.0);
}

struct Complex divComplex(struct Complex a, struct Complex b) {
    double re = a.rel * b.rel + a.img * b.img;
    double im = a.img * b.rel - a.rel * b.img;
    double d = b.rel * b.rel + b.img * b.img;
    struct Complex c = { re / d, im / d };
    return c;
}

struct Complex inv(struct Complex c) {
    double d = c.rel * c.rel + c.img * c.img;
    struct Complex i = { c.rel / d, -c.img / d };
    return i;
}

const struct Complex TWO_I = { 0.0, 2.0 };
const struct Complex INV_TWO_I = { 0.0, -0.5 };

//////////////////////////////////////////////////////

struct QuaterImaginary {
    char *b2i;
    int valid;
};

struct QuaterImaginary makeQuaterImaginary(char *s) {
    struct QuaterImaginary qi = { s, 0 }; // assume invalid until tested
    size_t i, valid = 1, cnt = 0;

    if (*s != 0) {
        for (i = 0; s[i] != 0; i++) {
            if (s[i] < '0' || '3' < s[i]) {
                if (s[i] == '.') {
                    cnt++;
                } else {
                    valid = 0;
                    break;
                }
            }
        }
        if (valid && cnt > 1) {
            valid = 0;
        }
    }

    qi.valid = valid;
    return qi;
}

void printQuaterImaginary(struct QuaterImaginary qi) {
    if (qi.valid) {
        printf("%8s", qi.b2i);
    } else {
        printf(" ERROR  ");
    }
}

//////////////////////////////////////////////////////

struct Complex qi2c(struct QuaterImaginary qi) {
    size_t len = strlen(qi.b2i);
    int pointPos = find(qi.b2i, '.');
    size_t posLen = (pointPos > 0) ? pointPos : len;
    struct Complex sum = makeComplex(0.0, 0.0);
    struct Complex prod = makeComplex(1.0, 0.0);
    size_t j;

    for (j = 0; j < posLen; j++) {
        double k = qi.b2i[posLen - 1 - j] - '0';
        if (k > 0.0) {
            sum = addComplex(sum, mulComplexD(prod, k));
        }
        prod = mulComplex(prod, TWO_I);
    }
    if (pointPos != -1) {
        prod = INV_TWO_I;
        for (j = posLen + 1; j < len; j++) {
            double k = qi.b2i[j] - '0';
            if (k > 0.0) {
                sum = addComplex(sum, mulComplexD(prod, k));
            }
            prod = mulComplex(prod, INV_TWO_I);
        }
    }
    return sum;
}

// only works properly if the real and imaginary parts are integral
struct QuaterImaginary c2qi(struct Complex c, char *out) {
    char *p = out;
    int re, im, fi;

    *p = 0;
    if (c.rel == 0.0 && c.img == 0.0) {
        return makeQuaterImaginary("0");
    }

    re = (int)c.rel;
    im = (int)c.img;
    fi = -1;
    while (re != 0) {
        int rem = re % -4;
        re /= -4;
        if (rem < 0) {
            rem += 4;
            re++;
        }
        *p++ = rem + '0';
        *p++ = '0';
        *p = 0;
    }
    if (im != 0) {
        size_t index = 1;
        struct Complex fc = divComplex((struct Complex) { 0.0, c.img }, (struct Complex) { 0.0, 2.0 });
        double f = fc.rel;
        im = (int)ceil(f);
        f = -4.0 * (f - im);
        while (im != 0) {
            int rem = im % -4;
            im /= -4;
            if (rem < 0) {
                rem += 4;
                im++;
            }
            if (index < (p - out)) {
                out[index] = rem + '0';
            } else {
                *p++ = '0';
                *p++ = rem + '0';
                *p = 0;
            }
            index += 2;
        }
        fi = (int)f;
    }

    reverse(out, p);
    if (fi != -1) {
        *p++ = '.';
        *p++ = fi + '0';
        *p = 0;
    }
    while (out[0] == '0' && out[1] != '.') {
        size_t i;
        for (i = 0; out[i] != 0; i++) {
            out[i] = out[i + 1];
        }
    }
    if (*out == '.') {
        reverse(out, p);
        *p++ = '0';
        *p = 0;
        reverse(out, p);
    }
    return makeQuaterImaginary(out);
}

//////////////////////////////////////////////////////

int main() {
    char buffer[16];
    int i;

    for (i = 1; i <= 16; i++) {
        struct Complex c1 = { i, 0.0 };
        struct QuaterImaginary qi = c2qi(c1, buffer);
        struct Complex c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("     ");

        c1 = negComplex(c1);
        qi = c2qi(c1, buffer);
        c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("\n");
    }

    printf("\n");

    for (i = 1; i <= 16; i++) {
        struct Complex c1 = { 0.0, i };
        struct QuaterImaginary qi = c2qi(c1, buffer);
        struct Complex c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("     ");

        c1 = negComplex(c1);
        qi = c2qi(c1, buffer);
        c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("\n");
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002ff8(void);
int64_t function_100003084(void);
int64_t function_100003108(int64_t a1);
int64_t function_100003148(void);
int64_t function_100003174(void);
int64_t function_1000031b8(void);
int64_t function_100003214(void);
int64_t function_100003254(int64_t a1);
int64_t function_100003294(void);
int64_t function_10000332c(void);
int64_t function_100003388(void);
int64_t function_1000034b8(void);
int64_t function_100003518(void);
int64_t function_1000037b0(void);
int64_t function_100003f04(int64_t a1);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002ff8 - 0x100003084
int64_t function_100002ff8(void) {
    // 0x100002ff8
    int64_t v1; // 0x100002ff8
    char v2 = *(char *)v1; // 0x100003014
    if (v2 == 0) {
        // 0x100003078
        return 0xffffffff;
    }
    char v3 = v2; // 0x100003014
    int64_t v4; // 0x100002ff8
    int64_t v5 = v4;
    while (0x1000000 * (int32_t)v1 >> 24 != (int32_t)v3) {
        int64_t v6 = v5 + 1; // 0x100003060
        v3 = *(char *)v6;
        if (v3 == 0) {
            // 0x100003078
            return 0xffffffff;
        }
        v5 = v6;
    }
    // 0x100003078
    return v5 - v1 & 0xffffffff;
}

// Address range: 0x100003084 - 0x100003108
int64_t function_100003084(void) {
    // 0x100003084
    int64_t result; // 0x100003084
    char * v1 = (char *)result;
    int64_t v2 = result - 1;
    char * v3 = (char *)v2;
    int64_t v4 = v2; // 0x1000030b0
    if (v1 >= v3) {
        // 0x100003100
        return result;
    }
    *v1 = *v3;
    *v3 = *v1;
    int64_t v5; // 0x100003084
    int64_t v6 = v5 + 1; // 0x1000030e8
    char * v7 = (char *)v6;
    v4--;
    char * v8 = (char *)v4;
    while (v7 < v8) {
        // 0x1000030b8
        *v7 = *v8;
        *v8 = *v7;
        v6++;
        v7 = (char *)v6;
        v4--;
        v8 = (char *)v4;
    }
    // 0x100003100
    return result;
}

// Address range: 0x100003108 - 0x100003148
int64_t function_100003108(int64_t a1) {
    // 0x100003108
    int128_t v1; // 0x100003108
    return _printf("(%3.0f + %3.0fi)", (float64_t)(int64_t)v1, (float64_t)(int64_t)v1);
}

// Address range: 0x100003148 - 0x100003174
int64_t function_100003148(void) {
    // 0x100003148
    int64_t result; // 0x100003148
    return result;
}

// Address range: 0x100003174 - 0x1000031b8
int64_t function_100003174(void) {
    // 0x100003174
    int64_t result; // 0x100003174
    return result;
}

// Address range: 0x1000031b8 - 0x100003214
int64_t function_1000031b8(void) {
    // 0x1000031b8
    int64_t result; // 0x1000031b8
    return result;
}

// Address range: 0x100003214 - 0x100003254
int64_t function_100003214(void) {
    // 0x100003214
    int64_t result; // 0x100003214
    return result;
}

// Address range: 0x100003254 - 0x100003294
int64_t function_100003254(int64_t a1) {
    // 0x100003254
    return function_100003214();
}

// Address range: 0x100003294 - 0x10000332c
int64_t function_100003294(void) {
    // 0x100003294
    int64_t result; // 0x100003294
    return result;
}

// Address range: 0x10000332c - 0x100003388
int64_t function_10000332c(void) {
    // 0x10000332c
    int64_t result; // 0x10000332c
    return result;
}

// Address range: 0x100003388 - 0x1000034b8
int64_t function_100003388(void) {
    // 0x100003388
    int64_t result; // 0x100003388
    if ((char)result == 0) {
        // 0x100003480
        return result;
    }
    char v1 = *(char *)result; // 0x1000033d0
    if (v1 == 0) {
        // 0x100003480
        return result;
    }
    int64_t v2 = 0; // 0x1000033dc
    int32_t v3 = v1; // 0x1000033ec
    int32_t v4; // 0x100003410
    if (v1 < 48 == (47 - v3 & v3) < 0) {
        // 0x100003400
        v4 = 51 - v3;
        if (v1 != 46 && v4 < 0 != (v4 & v3) < 0) {
            // break -> 0x100003480
            break;
        }
    } else {
        if (v1 != 46) {
            // break -> 0x100003480
            break;
        }
    }
    // 0x10000345c
    v2++;
    char v5 = *(char *)(v2 + result); // 0x1000033d0
    while (v5 != 0) {
        char v6 = v5; // 0x100003428
        v3 = v6;
        if (v6 < 48 == (47 - v3 & v3) < 0) {
            // 0x100003400
            v4 = 51 - v3;
            if (v6 != 46 && v4 < 0 != (v4 & v3) < 0) {
                // break -> 0x100003480
                break;
            }
        } else {
            if (v6 != 46) {
                // break -> 0x100003480
                break;
            }
        }
        // 0x10000345c
        v2++;
        v5 = *(char *)(v2 + result);
    }
    // 0x100003480
    return result;
}

// Address range: 0x1000034b8 - 0x100003518
int64_t function_1000034b8(void) {
    // 0x1000034b8
    int32_t result; // 0x1000034b8
    int64_t v1; // 0x1000034b8
    if ((int32_t)v1 == 0) {
        // 0x1000034fc
        result = _printf(" ERROR  ");
    } else {
        // 0x1000034e0
        result = _printf("%8s", (char *)v1);
    }
    // 0x10000350c
    return result;
}

// Address range: 0x100003518 - 0x1000037b0
int64_t function_100003518(void) {
    // 0x100003518
    int64_t v1; // 0x100003518
    uint64_t v2 = (int64_t)_strlen((char *)v1); // 0x100003538
    int64_t v3 = function_100002ff8(); // 0x100003548
    int32_t v4 = v3; // 0x10000354c
    int64_t v5 = v4 < 1 ? v2 : 0x100000000 * v3 >> 32;
    function_100003148();
    int64_t result = function_100003148(); // 0x1000035d0
    if (v5 != 0) {
        int64_t v6 = 0; // 0x10000368c
        if (*(char *)(v5 + v1 + -1 - v6) <= 47) {
            // 0x100003610
            function_100003214();
            function_100003174();
        }
        // 0x100003654
        v6++;
        result = function_1000031b8();
        while (v6 != v5) {
            // 0x1000035d8
            if (*(char *)(v5 + v1 + -1 - v6) <= 47) {
                // 0x100003610
                function_100003214();
                function_100003174();
            }
            // 0x100003654
            v6++;
            result = function_1000031b8();
        }
    }
    // 0x100003698
    if (v4 == -1) {
        // 0x10000379c
        return result;
    }
    int64_t v7 = v5 + 1;
    if (v7 >= v2) {
        // 0x10000379c
        return result;
    }
    int64_t v8 = v7; // 0x1000036dc
    if (*(char *)(v8 + v1) <= 47) {
        // 0x100003710
        function_100003214();
        function_100003174();
    }
    // 0x100003754
    v8++;
    int64_t result2 = function_1000031b8(); // 0x1000036dc
    while (v8 != v2) {
        // 0x1000036e4
        if (*(char *)(v8 + v1) <= 47) {
            // 0x100003710
            function_100003214();
            function_100003174();
        }
        // 0x100003754
        v8++;
        result2 = function_1000031b8();
    }
    // 0x10000379c
    return result2;
}

// Address range: 0x1000037b0 - 0x100003bdc
int64_t function_1000037b0(void) {
    // 0x1000037b0
    int64_t v1; // 0x1000037b0
    char * v2 = (char *)v1;
    *v2 = 0;
    float64_t v3; // bp-40, 0x1000037b0
    float64_t v4; // 0x1000037b0
    if (v4 == 0.0 == v3 == 0.0) {
        // 0x100003bc8
        return function_100003388();
    }
    int32_t v5 = v4; // 0x10000381c
    int32_t v6 = v5; // 0x100003848
    char * v7 = v2; // 0x100003848
    if (v5 != 0) {
        int32_t v8 = v6 % 4;
        v6 = v6 / -4 + (int32_t)(v8 < 0);
        int64_t v9 = (int64_t)v2; // 0x1000038ac
        *v2 = (char)(v8 < 0 ? v8 + 4 : v8) + 48;
        char * v10 = (char *)(v9 + 2);
        *(char *)(v9 + 1) = 48;
        *v10 = 0;
        v7 = v10;
        while (v6 != 0) {
            // 0x100003850
            v8 = v6 % 4;
            v6 = v6 / -4 + (int32_t)(v8 < 0);
            v9 = (int64_t)v10;
            *v10 = (char)(v8 < 0 ? v8 + 4 : v8) + 48;
            v10 = (char *)(v9 + 2);
            *(char *)(v9 + 1) = 48;
            *v10 = 0;
            v7 = v10;
        }
    }
    // 0x1000038dc
    char * v11; // 0x1000037b0
    if ((int32_t)v3 == 0) {
        // 0x100003a64
        function_100003084();
        v11 = v7;
    } else {
        // 0x1000038f0
        function_100003294();
        int32_t v12 = __asm_fcvtps(0.0); // 0x10000393c
        __asm_sshll(0.0f, 0);
        char * v13 = v7; // 0x100003978
        if (v12 != 0) {
            uint64_t v14 = 1;
            int32_t v15 = v12 % 4;
            int32_t v16 = v15 < 0 ? v15 + 4 : v15;
            int64_t v17 = (int64_t)v7; // 0x1000039d8
            char * v18; // 0x1000037b0
            char * v19; // 0x100003a30
            if (v14 < v17 - v1) {
                // 0x1000039f4
                *(char *)(v14 + v1) = (char)v16 + 48;
                v18 = v7;
            } else {
                // 0x100003a0c
                *v7 = 48;
                v19 = (char *)(v17 + 2);
                *(char *)(v17 + 1) = (char)v16 + 48;
                *v19 = 0;
                v18 = v19;
            }
            int32_t v20 = v12 / -4 + (int32_t)(v15 < 0);
            int64_t v21 = v14 + 2; // 0x100003978
            int32_t v22 = v20; // 0x100003978
            v13 = v18;
            while (v20 != 0) {
                char * v23 = v18;
                v14 = v21;
                v15 = v22 % 4;
                v16 = v15 < 0 ? v15 + 4 : v15;
                v17 = (int64_t)v23;
                if (v14 < v17 - v1) {
                    // 0x1000039f4
                    *(char *)(v14 + v1) = (char)v16 + 48;
                    v18 = v23;
                } else {
                    // 0x100003a0c
                    *v23 = 48;
                    v19 = (char *)(v17 + 2);
                    *(char *)(v17 + 1) = (char)v16 + 48;
                    *v19 = 0;
                    v18 = v19;
                }
                // 0x100003a44
                v20 = v22 / -4 + (int32_t)(v15 < 0);
                v21 = v14 + 2;
                v22 = v20;
                v13 = v18;
            }
        }
        int32_t v24 = -4.0 * -v3; // 0x100003a58
        function_100003084();
        v11 = v13;
        if (v24 != -1) {
            int64_t v25 = (int64_t)v13; // 0x100003a84
            *v13 = 46;
            char * v26 = (char *)(v25 + 2); // 0x100003aa8
            *(char *)(v25 + 1) = (char)v24 + 48;
            *v26 = 0;
            v11 = v26;
        }
    }
    // 0x100003abc
    int64_t v27; // 0x1000037b0
    char v28 = *(char *)&v27;
    char v29 = v28; // 0x100003ad8
    if (v28 == 48) {
        // 0x100003af8
        v29 = 48;
        while (*(char *)(v1 + 1) != 46) {
            char v30 = 48; // 0x100003b20
            if (*v2 != 0) {
                int64_t v31 = 1; // 0x100003b30
                char * v32 = (char *)(v31 + v1);
                *v2 = *v32;
                char * v33 = v32; // 0x100003b20
                int64_t v34 = v31; // 0x100003b20
                while (*v32 != 0) {
                    // 0x100003b28
                    v31 = v34 + 1;
                    v32 = (char *)(v31 + v1);
                    *v33 = *v32;
                    v33 = v32;
                    v34 = v31;
                }
                // 0x100003b0c
                v30 = *(char *)&v27;
            }
            // 0x100003ac0
            v29 = v30;
            if (v30 != 48) {
                // break -> 0x100003b64
                break;
            }
            v29 = v30;
        }
    }
    // 0x100003b64
    if (v29 == 46) {
        // 0x100003b7c
        function_100003084();
        *v11 = 48;
        *(char *)((int64_t)v11 + 1) = 0;
        function_100003084();
    }
    // 0x100003bc8
    return function_100003388();
}

// Address range: 0x100003bdc - 0x100003f04
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003bf4
    int32_t v2 = 1;
    __asm_sshll(0.0f, 0);
    function_1000037b0();
    function_100003108(function_100003518());
    _printf(" -> ");
    function_1000034b8();
    function_100003108((int64_t)_printf(" -> "));
    function_100003254((int64_t)_printf("     "));
    function_1000037b0();
    function_100003108(function_100003518());
    _printf(" -> ");
    function_1000034b8();
    function_100003108((int64_t)_printf(" -> "));
    _printf((char *)0x100003f53);
    int32_t v3 = v2 + 1; // 0x100003d54
    while (v2 == 15 || v2 < 15 != (14 - v2 & v3) < 0) {
        // 0x100003c20
        v2 = v3;
        __asm_sshll(0.0f, 0);
        function_1000037b0();
        function_100003108(function_100003518());
        _printf(" -> ");
        function_1000034b8();
        function_100003108((int64_t)_printf(" -> "));
        function_100003254((int64_t)_printf("     "));
        function_1000037b0();
        function_100003108(function_100003518());
        _printf(" -> ");
        function_1000034b8();
        function_100003108((int64_t)_printf(" -> "));
        _printf((char *)0x100003f53);
        v3 = v2 + 1;
    }
    // 0x100003d60
    _printf("\n");
    int32_t v4 = 1;
    __asm_sshll(0.0f, 0);
    function_1000037b0();
    function_100003108(function_100003518());
    _printf(" -> ");
    function_1000034b8();
    function_100003108((int64_t)_printf(" -> "));
    function_100003254((int64_t)_printf("     "));
    function_1000037b0();
    function_100003108(function_100003518());
    _printf(" -> ");
    function_1000034b8();
    function_100003108((int64_t)_printf(" -> "));
    int32_t v5 = _printf("\n"); // 0x100003eb4
    int32_t v6 = v4 + 1; // 0x100003ec0
    while (v4 == 15 || v4 < 15 != (14 - v4 & v6) < 0) {
        // 0x100003d8c
        v4 = v6;
        __asm_sshll(0.0f, 0);
        function_1000037b0();
        function_100003108(function_100003518());
        _printf(" -> ");
        function_1000034b8();
        function_100003108((int64_t)_printf(" -> "));
        function_100003254((int64_t)_printf("     "));
        function_1000037b0();
        function_100003108(function_100003518());
        _printf(" -> ");
        function_1000034b8();
        function_100003108((int64_t)_printf(" -> "));
        v5 = _printf("\n");
        v6 = v4 + 1;
    }
    // 0x100003ecc
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003eec
        ___stack_chk_fail((int64_t)v5);
    }
    // 0x100003ef0
    return 0;
}

// Address range: 0x100003f04 - 0x100003f10
int64_t function_100003f04(int64_t a1) {
    // 0x100003f04
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * s) {
    // 0x100003f1c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 18

`
`#include <stdio.h>
#include <stdbool.h>

bool is_substring(unsigned n, unsigned k) {
    unsigned startMatch = 0;

    for (unsigned pfx = k; n > 0; n /= 10) {
        if (pfx % 10 == n % 10) {
            pfx /= 10;
            if (startMatch == 0) startMatch = n;
        } else {
            pfx = k;
            if (startMatch != 0) n = startMatch;
            startMatch = 0;
        }

        if (pfx == 0) return true;
    }
    return false;
}

bool factors_are_substrings(unsigned n) {
    if (n%2==0 || n%3==0 || n%5==0 || n%7==0) return false;

    unsigned factor_count = 0;
    for (unsigned factor = 11, n_rest = n; factor <= n_rest; factor += 2) {
        if (n_rest % factor != 0) continue;
        while (n_rest % factor == 0) n_rest /= factor;
        if (!is_substring(n, factor)) return false;
        factor_count++;
    }
    return factor_count > 1;
}

int main(void) {
    unsigned amount = 10;
    for (unsigned n = 11; amount > 0; n += 2) {
        if (factors_are_substrings(n)) {
            printf("%u\n", n);
            amount--;
        }
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c08(void);
int64_t function_100003d34(void);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c08 - 0x100003d34
int64_t function_100003c08(void) {
    // 0x100003c08
    int64_t v1; // 0x100003c08
    int32_t v2 = v1; // 0x100003c0c
    int32_t v3 = v1; // 0x100003c10
    if (v2 == 0) {
        // 0x100003d24
        return 0;
    }
    int32_t v4 = 0;
    int32_t v5; // 0x100003c08
    int32_t v6; // 0x100003c08
    int32_t v7; // 0x100003c08
    if (v3 % 10 == v2 % 10) {
        // 0x100003c6c
        v5 = v4 == 0 ? v2 : v4;
        v6 = v3 / 10;
        v7 = v2;
    } else {
        // 0x100003ca0
        v5 = 0;
        v6 = v3;
        v7 = v4 == 0 ? v2 : v4;
    }
    int64_t result = 1; // 0x100003cdc
    while (v6 != 0) {
        // 0x100003cfc
        result = 0;
        if (v7 < 10) {
            // break -> 0x100003d24
            break;
        }
        v4 = v5;
        uint32_t v8 = v6;
        int32_t v9 = v7 / 10;
        if (v8 % 10 == v9 % 10) {
            int32_t v10 = v4 == 0 ? v9 : v4;
            v5 = v10;
            v6 = v8 / 10;
            v7 = v9;
        } else {
            int32_t v11 = v4 == 0 ? v9 : v4;
            v5 = 0;
            v6 = v3;
            v7 = v11;
        }
        // 0x100003cd0
        result = 1;
    }
    // 0x100003d24
    return result;
}

// Address range: 0x100003d34 - 0x100003ef8
int64_t function_100003d34(void) {
    // 0x100003d34
    int64_t v1; // 0x100003d34
    uint32_t v2 = (int32_t)v1; // 0x100003d40
    if (v2 % 7 == 0 || v2 % 5 == 0 || v2 % 3 == 0 || 2 * v2 / 2 == v2) {
        // 0x100003ee4
        return 0;
    }
    // 0x100003e00
    int32_t v3; // 0x100003d34
    if (v2 <= 11 == (v2 != 11)) {
        // 0x100003ec4
        v3 = 0;
        // 0x100003ee4
        return v3 != 0 == (v3 != 1);
    }
    int32_t v4 = 0;
    uint32_t v5 = 11;
    int32_t v6 = v4; // 0x100003e34
    int32_t v7 = v2; // 0x100003e34
    int32_t v8; // 0x100003d34
    if (v2 % v5 == 0) {
        v7 = v2 / v5;
        v8 = v7;
        while (v7 % v5 == 0) {
            // 0x100003e68
            v7 = v8 / v5;
            v8 = v7;
        }
        // 0x100003e7c
        if (function_100003c08() % 2 == 0) {
            // 0x100003ee4
            return 0;
        }
        // 0x100003ea4
        v6 = v4 + 1;
    }
    int32_t v9 = v7;
    int32_t v10 = v6;
    int32_t v11 = v5 + 2; // 0x100003eb8
    while (v11 >= v9 != v11 != v9) {
        // 0x100003e18
        v4 = v10;
        v5 = v11;
        v8 = v9;
        v6 = v4;
        int32_t v12 = v9; // 0x100003e34
        if (v9 % v5 == 0) {
            v7 = v8 / v5;
            v8 = v7;
            while (v7 % v5 == 0) {
                // 0x100003e68
                v7 = v8 / v5;
                v8 = v7;
            }
            // 0x100003e7c
            if (function_100003c08() % 2 == 0) {
                // 0x100003ee4
                return 0;
            }
            // 0x100003ea4
            v6 = v4 + 1;
            v12 = v7;
        }
        // 0x100003eb4
        v9 = v12;
        v10 = v6;
        v11 = v5 + 2;
    }
    // 0x100003ec4
    v3 = v10;
    // 0x100003ee4
    return v3 != 0 == (v3 != 1);
}

// Address range: 0x100003ef8 - 0x100003f90
int64_t entry_point(void) {
    int32_t v1 = 10;
    int32_t v2 = v1; // 0x100003f38
    int64_t v3; // 0x100003ef8
    if (function_100003d34() % 2 != 0) {
        // 0x100003f40
        _printf("%u\n", (int32_t)v3);
        v2 = v1 - 1;
    }
    // 0x100003f70
    while (v2 != 0) {
        // 0x100003f30
        v1 = v2;
        v2 = v1;
        if (function_100003d34() % 2 != 0) {
            // 0x100003f40
            _printf("%u\n", (int32_t)v3);
            v2 = v1 - 1;
        }
    }
    // 0x100003f80
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <limits.h>

#define DEBUG

void best_shuffle(const char* txt, char* result) {
    const size_t len = strlen(txt);
    if (len == 0)
        return;

#ifdef DEBUG
    // txt and result must have the same length
    assert(len == strlen(result));
#endif

    // how many of each character?
    size_t counts[UCHAR_MAX];
    memset(counts, '\0', UCHAR_MAX * sizeof(int));
    size_t fmax = 0;
    for (size_t i = 0; i < len; i++) {
        counts[(unsigned char)txt[i]]++;
        const size_t fnew = counts[(unsigned char)txt[i]];
        if (fmax < fnew)
             fmax = fnew;
    }
    assert(fmax > 0 && fmax <= len);

    // all character positions, grouped by character
    size_t *ndx1 = malloc(len * sizeof(size_t));
    if (ndx1 == NULL)
        exit(EXIT_FAILURE);
    for (size_t ch = 0, i = 0; ch < UCHAR_MAX; ch++)
       if (counts[ch])
            for (size_t j = 0; j < len; j++)
                if (ch == (unsigned char)txt[j]) {
                    ndx1[i] = j;
                    i++;
                }

    // regroup them for cycles
    size_t *ndx2 = malloc(len * sizeof(size_t));
    if (ndx2 == NULL)
        exit(EXIT_FAILURE);
    for (size_t i = 0, n = 0, m = 0; i < len; i++) {
        ndx2[i] = ndx1[n];
        n += fmax;
        if (n >= len) {
            m++;
            n = m;
        }
    }

    // how long can our cyclic groups be?
    const size_t grp = 1 + (len - 1) / fmax;
    assert(grp > 0 && grp <= len);

    // how many of them are full length?
    const size_t lng = 1 + (len - 1) % fmax;
    assert(lng > 0 && lng <= len);

    // rotate each group
    for (size_t i = 0, j = 0; i < fmax; i++) {
        const size_t first = ndx2[j];
        const size_t glen = grp - (i < lng ? 0 : 1);
        for (size_t k = 1; k < glen; k++)
            ndx1[j + k - 1] = ndx2[j + k];
        ndx1[j + glen - 1] = first;
        j += glen;
    }

    // result is original permuted according to our cyclic groups
    result[len] = '\0';
    for (size_t i = 0; i < len; i++)
        result[ndx2[i]] = txt[ndx1[i]];

    free(ndx1);
    free(ndx2);
}

void display(const char* txt1, const char* txt2) {
    const size_t len = strlen(txt1);
    assert(len == strlen(txt2));
    int score = 0;
    for (size_t i = 0; i < len; i++)
        if (txt1[i] == txt2[i])
            score++;
    (void)printf("%s, %s, (%u)\n", txt1, txt2, score);
}

int main() {
    const char* data[] = {"abracadabra", "seesaw", "elk", "grrrrrr",
                          "up", "a", "aabbbbaa", "", "xxxxx"};
    const size_t data_len = sizeof(data) / sizeof(data[0]);
    for (size_t i = 0; i < data_len; i++) {
        const size_t shuf_len = strlen(data[i]) + 1;
        char shuf[shuf_len];

#ifdef DEBUG
        memset(shuf, 0xFF, sizeof shuf);
        shuf[shuf_len - 1] = '\0';
#endif

        best_shuffle(data[i], shuf);
        display(data[i], shuf);
    }

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_1000035a4(void);
int64_t function_100003bec(void);
int64_t function_100003e50(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003e5c(void);
int64_t function_100003e68(int64_t a1);
void function_100003e74(int64_t * s, int32_t n);
void function_100003e80(int32_t status);
void function_100003e8c(int64_t * ptr);
int64_t * function_100003e98(int32_t size);
int64_t * function_100003ea4(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003eb0(char * format, ...);
int32_t function_100003ebc(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(int64_t a1);
int64_t ___memset_chk(void);
int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000035a4 - 0x100003bec
int64_t function_1000035a4(void) {
    // 0x1000035a4
    int64_t v1; // 0x1000035a4
    int32_t v2 = _strlen((char *)v1); // 0x1000035d0
    int64_t v3 = 0; // 0x1000035e4
    uint64_t v4; // 0x1000035a4
    uint64_t v5; // 0x1000035d0
    int64_t v6; // 0x100003684
    if (v2 == 0) {
        goto lab_0x100003bb8;
    } else {
        // 0x1000035f0
        if (v2 != _strlen((char *)v1)) {
            // 0x100003620
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 16, "len == strlen(result)");
        }
        // 0x100003674
        v5 = (int64_t)v2;
        int64_t v7; // bp-2072, 0x1000035a4
        _bzero(&v7, 1020);
        v6 = &v7;
        int64_t v8 = 0; // 0x1000036dc
        uint64_t v9 = 0;
        char * v10 = (char *)(v8 + v1); // 0x10000367c
        int64_t * v11 = (int64_t *)(8 * (int64_t)*v10 + v6); // 0x100003690
        *v11 = *v11 + 1;
        uint64_t v12 = *(int64_t *)(8 * (int64_t)*v10 + v6); // 0x1000036a8
        v4 = v9 < v12 ? v12 : v9;
        v8++;
        while (v8 < v5) {
            // 0x100003674
            v9 = v4;
            v10 = (char *)(v8 + v1);
            v11 = (int64_t *)(8 * (int64_t)*v10 + v6);
            *v11 = *v11 + 1;
            v12 = *(int64_t *)(8 * (int64_t)*v10 + v6);
            v4 = v9 < v12 ? v12 : v9;
            v8++;
        }
        if (v4 == 0) {
            // 0x100003738
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 29, "fmax > 0 && fmax <= len");
            goto lab_0x10000375c;
        } else {
            if (v4 != v5 && v4 >= v5) {
                // 0x100003738
                ___assert_rtn("best_shuffle", "best-shuffle-1.c", 29, "fmax > 0 && fmax <= len");
                goto lab_0x10000375c;
            } else {
                goto lab_0x10000375c;
            }
        }
    }
  lab_0x100003bb8:;
    int64_t v13 = *(int64_t *)*(int64_t *)0x100004020; // 0x100003bc4
    int64_t result = v3; // 0x100003bd0
    if (v13 != *(int64_t *)*(int64_t *)0x100004020) {
        // 0x100003bd8
        result = ___stack_chk_fail(v3);
    }
    // 0x100003bdc
    return result;
  lab_0x10000375c:;
    int32_t v14 = 8 * v2; // 0x100003764
    int64_t * v15 = _malloc(v14); // 0x100003764
    int64_t v16 = (int64_t)v15; // 0x100003764
    int64_t v17 = 0; // 0x100003778
    if (v15 == NULL) {
        // 0x100003780
        _exit(1);
        // UNREACHABLE
    }
    int64_t v18 = 0;
    int64_t v19 = v17; // 0x1000037bc
    int64_t v20 = v17; // 0x1000037bc
    int64_t v21; // 0x1000035a4
    int64_t v22; // 0x1000035a4
    int64_t v23; // 0x1000035a4
    int64_t v24; // 0x10000382c
    if (*(int64_t *)(8 * v18 + v6) != 0) {
        v21 = v19;
        v23 = 0;
        v22 = v21;
        if (v18 == (int64_t)*(char *)(v23 + v1)) {
            // 0x100003804
            *(int64_t *)(8 * v21 + v16) = v23;
            v22 = v21 + 1;
        }
        // 0x100003828
        v24 = v23 + 1;
        v20 = v22;
        while (v24 < v5) {
            // 0x1000037e4
            v21 = v22;
            v23 = v24;
            v22 = v21;
            if (v18 == (int64_t)*(char *)(v23 + v1)) {
                // 0x100003804
                *(int64_t *)(8 * v21 + v16) = v23;
                v22 = v21 + 1;
            }
            // 0x100003828
            v24 = v23 + 1;
            v20 = v22;
        }
    }
    int64_t v25 = v18 + 1; // 0x100003844
    v17 = v20;
    while (v25 != 255) {
        // 0x1000037a8
        v18 = v25;
        v19 = v17;
        v20 = v17;
        if (*(int64_t *)(8 * v18 + v6) != 0) {
            v21 = v19;
            v23 = 0;
            v22 = v21;
            if (v18 == (int64_t)*(char *)(v23 + v1)) {
                // 0x100003804
                *(int64_t *)(8 * v21 + v16) = v23;
                v22 = v21 + 1;
            }
            // 0x100003828
            v24 = v23 + 1;
            v20 = v22;
            while (v24 < v5) {
                // 0x1000037e4
                v21 = v22;
                v23 = v24;
                v22 = v21;
                if (v18 == (int64_t)*(char *)(v23 + v1)) {
                    // 0x100003804
                    *(int64_t *)(8 * v21 + v16) = v23;
                    v22 = v21 + 1;
                }
                // 0x100003828
                v24 = v23 + 1;
                v20 = v22;
            }
        }
        // 0x100003840
        v25 = v18 + 1;
        v17 = v20;
    }
    int64_t * v26 = _malloc(v14); // 0x100003858
    int64_t v27 = (int64_t)v26; // 0x100003858
    int64_t v28 = 0; // 0x10000386c
    int64_t v29 = 0; // 0x10000386c
    int64_t v30 = 0; // 0x10000386c
    if (v26 == NULL) {
        // 0x100003874
        _exit(1);
        // UNREACHABLE
    }
    int64_t v31 = *(int64_t *)(8 * v29 + v16); // 0x1000038ac
    *(int64_t *)(8 * v30 + v27) = v31;
    uint64_t v32 = v29 + v4; // 0x1000038c4
    int64_t v33 = v28 + 1;
    int64_t v34 = v30 + 1; // 0x100003904
    v28 = v32 < v5 ? v28 : v33;
    v29 = v32 < v5 ? v32 : v33;
    v30 = v34;
    while (v34 < v5) {
        // 0x1000038a4
        v31 = *(int64_t *)(8 * v29 + v16);
        *(int64_t *)(8 * v30 + v27) = v31;
        v32 = v29 + v4;
        v33 = v28 + 1;
        v34 = v30 + 1;
        v28 = v32 < v5 ? v28 : v33;
        v29 = v32 < v5 ? v32 : v33;
        v30 = v34;
    }
    uint64_t v35 = v5 - 1; // 0x100003914
    uint64_t v36 = v35 / v4 + 1; // 0x100003920
    if (v36 == 0) {
        // 0x100003978
        ___assert_rtn("best_shuffle", "best-shuffle-1.c", 58, "grp > 0 && grp <= len");
        goto lab_0x10000399c;
    } else {
        if (v36 != v5 && v36 >= v5) {
            // 0x100003978
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 58, "grp > 0 && grp <= len");
            goto lab_0x10000399c;
        } else {
            goto lab_0x10000399c;
        }
    }
  lab_0x10000399c:;
    uint64_t v37 = v35 % v4 + 1; // 0x1000039b4
    if (v37 == 0) {
        // 0x100003a0c
        ___assert_rtn("best_shuffle", "best-shuffle-1.c", 62, "lng > 0 && lng <= len");
        goto lab_0x100003a30;
    } else {
        if (v37 != v5 && v37 >= v5) {
            // 0x100003a0c
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 62, "lng > 0 && lng <= len");
            goto lab_0x100003a30;
        } else {
            goto lab_0x100003a30;
        }
    }
  lab_0x100003a30:
    if (v4 != 0) {
        int64_t v38 = v16 - 8;
        int64_t v39 = 0; // 0x100003b24
        int64_t v40 = 0;
        int64_t v41 = *(int64_t *)(8 * v40 + v27); // 0x100003a5c
        uint64_t v42 = v36 - (int64_t)(v39 >= v37); // 0x100003a84
        int64_t v43 = 1; // 0x100003aa8
        int64_t v44; // 0x100003ac0
        int64_t v45; // 0x100003ae4
        if (v42 > 1) {
            v44 = 8 * (v43 + v40);
            *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
            v45 = v43 + 1;
            v43 = v45;
            while (v45 != v42) {
                // 0x100003ab0
                v44 = 8 * (v43 + v40);
                *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
                v45 = v43 + 1;
                v43 = v45;
            }
        }
        int64_t v46 = v42 + v40; // 0x100003b00
        *(int64_t *)(8 * v46 + v38) = v41;
        v39++;
        while (v39 != v4) {
            // 0x100003a54
            v40 = v46;
            v41 = *(int64_t *)(8 * v40 + v27);
            v42 = v36 - (int64_t)(v39 >= v37);
            v43 = 1;
            if (v42 > 1) {
                v44 = 8 * (v43 + v40);
                *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
                v45 = v43 + 1;
                v43 = v45;
                while (v45 != v42) {
                    // 0x100003ab0
                    v44 = 8 * (v43 + v40);
                    *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
                    v45 = v43 + 1;
                    v43 = v45;
                }
            }
            // 0x100003af0
            v46 = v42 + v40;
            *(int64_t *)(8 * v46 + v38) = v41;
            v39++;
        }
    }
    // 0x100003b60
    *(char *)(v1 + v5) = 0;
    int64_t v47 = 0; // 0x1000035a4
    int64_t v48 = 8 * v47; // 0x100003b6c
    char v49 = *(char *)(*(int64_t *)(v48 + v16) + v1); // 0x100003b74
    *(char *)(*(int64_t *)(v48 + v27) + v1) = v49;
    int64_t v50 = v47 + 1; // 0x100003b98
    v47 = v50;
    while (v50 < v5) {
        // 0x100003b60
        v48 = 8 * v47;
        v49 = *(char *)(*(int64_t *)(v48 + v16) + v1);
        *(char *)(*(int64_t *)(v48 + v27) + v1) = v49;
        v50 = v47 + 1;
        v47 = v50;
    }
    // 0x100003ba4
    _free(v15);
    _free(v26);
    v3 = &g1;
    goto lab_0x100003bb8;
}

// Address range: 0x100003bec - 0x100003d08
int64_t function_100003bec(void) {
    // 0x100003bec
    int64_t v1; // 0x100003bec
    int64_t v2; // 0x100003bec
    int64_t v3; // 0x100003bec
    int64_t v4; // 0x100003bec
    if (_strlen((char *)v1) != _strlen((char *)v1)) {
        // 0x100003c3c
        ___assert_rtn("display", "best-shuffle-1.c", 85, "len == strlen(txt2)");
        v2 = (int64_t)"best-shuffle-1.c";
        v3 = 85;
        v4 = (int64_t)"len == strlen(txt2)";
    }
    // 0x100003c60
    return _printf("%s, %s, (%u)\n", (char *)v2, (char *)v3, (int32_t)v4);
}

// Address range: 0x100003d08 - 0x100003e50
int64_t entry_point(int64_t a1) {
    // 0x100003d08
    int64_t v1; // bp-88, 0x100003d08
    _memcpy(&v1, (int64_t *)"j?", 72);
    return ___chkstk_darwin((int64_t)_strlen((char *)v1));
}

// Address range: 0x100003e50 - 0x100003e5c
int64_t function_100003e50(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e50
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e5c - 0x100003e68
int64_t function_100003e5c(void) {
    // 0x100003e5c
    return ___memset_chk();
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(int64_t a1) {
    // 0x100003e68
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e74 - 0x100003e80
void function_100003e74(int64_t * s, int32_t n) {
    // 0x100003e74
    _bzero(s, n);
}

// Address range: 0x100003e80 - 0x100003e8c
void function_100003e80(int32_t status) {
    // 0x100003e80
    _exit(status);
}

// Address range: 0x100003e8c - 0x100003e98
void function_100003e8c(int64_t * ptr) {
    // 0x100003e8c
    _free(ptr);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int32_t size) {
    // 0x100003e98
    return _malloc(size);
}

// Address range: 0x100003ea4 - 0x100003eb0
int64_t * function_100003ea4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ea4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * format, ...) {
    // 0x100003eb0
    return _printf(format);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * s) {
    // 0x100003ebc
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <string.h>

char trans[] = "___#_##_";

#define v(i) (cell[i] != '_')
int evolve(char cell[], char backup[], int len)
{
	int i, diff = 0;

	for (i = 0; i < len; i++) {
		/* use left, self, right as binary number bits for table index */
		backup[i] = trans[ v(i-1) * 4 + v(i) * 2 + v(i + 1) ];
		diff += (backup[i] != cell[i]);
	}

	strcpy(cell, backup);
	return diff;
}

int main()
{
	char	c[] = "_###_##_#_#_#_#__#__\n",
		b[] = "____________________\n";

	do { printf(c + 1); } while (evolve(c + 1, b + 1, sizeof(c) - 3));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d74(void);
int64_t function_100003f58(int64_t a1);
int64_t function_100003f64(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d74 - 0x100003e90
int64_t function_100003d74(void) {
    // 0x100003d74
    int64_t v1; // 0x100003d74
    int32_t v2 = v1; // 0x100003d88
    int32_t v3 = -v2; // 0x100003da0
    int32_t v4 = 0; // 0x100003da8
    int32_t result = 0; // 0x100003da8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e70
        ___strcpy_chk(v1, v1, -1);
        return 0;
    }
    char v5 = *(char *)(v1 + (int64_t)(v4 - 1)); // 0x100003dbc
    int64_t v6 = v4; // 0x100003dd0
    char * v7 = (char *)(v1 + v6); // 0x100003dd4
    char v8 = *v7; // 0x100003dd4
    v4++;
    char v9 = *(char *)(v1 + (int64_t)v4); // 0x100003df8
    char v10 = *(char *)((2 * (int64_t)(v8 != 95) | 4 * (int64_t)(v5 != 95) | (int64_t)(v9 != 95)) + (int64_t)"___#_##_"); // 0x100003e18
    *(char *)(v1 + v6) = v10;
    result += (int32_t)(v10 != *v7);
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003db0
        v5 = *(char *)(v1 + (int64_t)(v4 - 1));
        v6 = v4;
        v7 = (char *)(v1 + v6);
        v8 = *v7;
        v4++;
        v9 = *(char *)(v1 + (int64_t)v4);
        v10 = *(char *)((2 * (int64_t)(v8 != 95) | 4 * (int64_t)(v5 != 95) | (int64_t)(v9 != 95)) + (int64_t)"___#_##_");
        *(char *)(v1 + v6) = v10;
        result += (int32_t)(v10 != *v7);
    }
    // 0x100003e70
    ___strcpy_chk(v1, v1, -1);
    return result;
}

// Address range: 0x100003e90 - 0x100003f58
int64_t entry_point(void) {
    int64_t v1; // bp-47, 0x100003e90
    _printf((char *)&v1);
    int64_t v2 = function_100003d74(); // 0x100003f10
    // 0x100003e90
    while ((int32_t)v2 != 0) {
        // 0x100003eec
        _printf((char *)&v1);
        v2 = function_100003d74();
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f30
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f44
        ___stack_chk_fail(v2);
    }
    // 0x100003f48
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t a1) {
    // 0x100003f58
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003f64
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  printf("Hello world!\n");
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f58 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f58
    _printf("Hello world!\n");
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <wchar.h>
#include <stdlib.h>
#include <locale.h>

int main(void)
{
    /* If your native locale doesn't use UTF-8 encoding
     * you need to replace the empty string with a
     * locale like "en_US.utf8"
     */
    char *locale = setlocale(LC_ALL, "");
    FILE *in = fopen("input.txt", "r");

    wint_t c;
    while ((c = fgetwc(in)) != WEOF)
        putwchar(c);
    fclose(in);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f5c(struct _IO_FILE * stream);
int32_t function_100003f68(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f74(char * filename, char * modes);
int32_t function_100003f80(int16_t wc);
char * function_100003f8c(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f98

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetwc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _putwchar(int16_t a1);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003edc - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003edc
    _setlocale(0, (char *)&g1);
    struct _IO_FILE * v1 = _fopen("input.txt", (char *)0x100003fa3); // 0x100003f10
    int32_t v2 = _fgetwc(v1); // 0x100003f20
    if (v2 == -1) {
        // 0x100003f44
        _fclose(v1);
        return 0;
    }
    _putwchar((int16_t)v2);
    int32_t v3 = _fgetwc(v1); // 0x100003f20
    while (v3 != -1) {
        // 0x100003f38
        _putwchar((int16_t)v3);
        v3 = _fgetwc(v1);
    }
    // 0x100003f44
    _fclose(v1);
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(struct _IO_FILE * stream) {
    // 0x100003f5c
    return _fclose(stream);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(struct _IO_FILE * stream) {
    // 0x100003f68
    return _fgetwc(stream);
}

// Address range: 0x100003f74 - 0x100003f80
struct _IO_FILE * function_100003f74(char * filename, char * modes) {
    // 0x100003f74
    return _fopen(filename, modes);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(int16_t wc) {
    // 0x100003f80
    return _putwchar(wc);
}

// Address range: 0x100003f8c - 0x100003f98
char * function_100003f8c(int32_t category, char * locale) {
    // 0x100003f8c
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdbool.h>

int proper_divisors(const int n, bool print_flag)
{
    int count = 0;

    for (int i = 1; i < n; ++i) {
        if (n % i == 0) {
            count++;
            if (print_flag)
                printf("%d ", i);
        }
    }

    if (print_flag)
        printf("\n");

    return count;
}

int countProperDivisors(int n){
	int prod = 1,i,count=0;
	
	while(n%2==0){
		count++;
		n /= 2;
	}
	
	prod *= (1+count);

	for(i=3;i*i<=n;i+=2){
		count = 0;
		
		while(n%i==0){
			count++;
			n /= i;
		}
		
		prod *= (1+count);
	}
	
	if(n>2)
		prod *= 2;
	
	return prod - 1;
}

int main(void)
{
    for (int i = 1; i <= 10; ++i) {
        printf("%d: ", i);
        proper_divisors(i, true);
    }

    int max = 0;
    int max_i = 1;

    for (int i = 1; i <= 20000; ++i) {
        int v = countProperDivisors(i);
        if (v >= max) {
            max = v;
            max_i = i;
        }
    }

    printf("%d with %d divisors\n", max_i, max);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c30(void);
int64_t function_100003d10(void);
int32_t function_100003f74(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c30 - 0x100003d10
int64_t function_100003c30(void) {
    // 0x100003c30
    int64_t v1; // 0x100003c30
    int32_t v2 = v1; // 0x100003c3c
    uint32_t v3 = (int32_t)v1 % 2; // 0x100003c44
    int32_t v4 = 1 - v2; // 0x100003c60
    int32_t result = 0; // 0x100003c68
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v5 = 1; // 0x100003cd8
        int32_t v6 = 0;
        int32_t v7 = v6; // 0x100003c8c
        int32_t v8; // 0x100003c98
        if (v2 % v5 == 0) {
            // 0x100003c94
            v8 = v6 + 1;
            v7 = v8;
            if (v3 != 0) {
                // 0x100003cac
                _printf("%d ", v1);
                v7 = v8;
            }
        }
        int32_t v9 = v7;
        v5++;
        int32_t v10 = v5 - v2; // 0x100003c60
        result = v9;
        while (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003c70
            v6 = v9;
            v7 = v6;
            if (v2 % v5 == 0) {
                // 0x100003c94
                v8 = v6 + 1;
                v7 = v8;
                if (v3 != 0) {
                    // 0x100003cac
                    _printf("%d ", v1);
                    v7 = v8;
                }
            }
            // 0x100003cd4
            v9 = v7;
            v5++;
            v10 = v5 - v2;
            result = v9;
        }
    }
    // 0x100003ce4
    if (v3 != 0) {
        // 0x100003cf0
        _printf("\n");
    }
    // 0x100003d00
    return result;
}

// Address range: 0x100003d10 - 0x100003e54
int64_t function_100003d10(void) {
    int32_t v1 = 0; // 0x100003d24
    int64_t v2; // 0x100003d10
    int32_t v3 = v2;
    int32_t v4 = v3 / 2; // 0x100003d30
    v1++;
    while (v3 == 2 * v4) {
        // 0x100003d28
        v3 = v4;
        v4 = v3 / 2;
        v1++;
    }
    int32_t v5 = 9 - v3; // 0x100003d9c
    int32_t v6 = v1; // 0x100003da4
    int32_t v7; // 0x100003d10
    int32_t v8; // 0x100003e24
    if (v5 != 0 && v5 < 0 == (v5 & v3) < 0) {
        // 0x100003e20
        v7 = v3;
        v8 = v7 - 2;
        return (v1 << (int32_t)(v8 != 0 == v8 < 0 == (1 - v7 & v7) < 0)) - 1;
    }
    int32_t v9 = 3;
    int32_t v10 = v3; // 0x100003dd0
    int32_t v11 = 1; // 0x100003dd0
    int32_t v12; // 0x100003d10
    int32_t v13; // 0x100003d10
    int32_t v14; // 0x100003dec
    int32_t v15; // 0x100003d10
    if (v3 % v9 == 0) {
        v14 = v3 / v9;
        v15 = 2;
        v12 = v15;
        v13 = v14;
        v10 = v14;
        v11 = v15;
        while (v14 % v9 == 0) {
            // 0x100003dd8
            v14 = v13 / v9;
            v15 = v12 + 1;
            v12 = v15;
            v13 = v14;
            v10 = v14;
            v11 = v15;
        }
    }
    int32_t v16 = v10;
    v6 *= v11;
    int32_t v17 = v9 + 2; // 0x100003e14
    int32_t v18 = v17 * v17; // 0x100003d94
    int32_t v19 = v18 - v16; // 0x100003d9c
    while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v16 ^ v18)) < 0) {
        // 0x100003db4
        v9 = v17;
        v13 = v16;
        v10 = v16;
        v11 = 1;
        if (v16 % v9 == 0) {
            v14 = v13 / v9;
            v15 = 2;
            v12 = v15;
            v13 = v14;
            v10 = v14;
            v11 = v15;
            while (v14 % v9 == 0) {
                // 0x100003dd8
                v14 = v13 / v9;
                v15 = v12 + 1;
                v12 = v15;
                v13 = v14;
                v10 = v14;
                v11 = v15;
            }
        }
        // 0x100003df8
        v16 = v10;
        v6 *= v11;
        v17 = v9 + 2;
        v18 = v17 * v17;
        v19 = v18 - v16;
    }
    // 0x100003e20
    v7 = v16;
    v8 = v7 - 2;
    return (v6 << (int32_t)(v8 != 0 == v8 < 0 == (1 - v7 & v7) < 0)) - 1;
}

// Address range: 0x100003e54 - 0x100003f74
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e54
    _printf("%d: ", v2);
    function_100003c30();
    int32_t v3 = v1 + 1; // 0x100003eb8
    int32_t v4 = v1 - 9; // 0x100003e74
    v2 = 1;
    while (v4 == 0 || v4 < 0 != (8 - v1 & v3) < 0) {
        // 0x100003e84
        v1 = v3;
        _printf("%d: ", v2);
        function_100003c30();
        v3 = v1 + 1;
        v4 = v1 - 9;
        v2 = 1;
    }
    int32_t v5 = 1;
    function_100003d10();
    int32_t v6 = v5 + 1; // 0x100003f30
    int32_t v7 = v5 - 0x4e1f; // 0x100003ee0
    while (v7 == 0 || v7 < 0 != (0x4e1e - v5 & v6) < 0) {
        // 0x100003ef0
        v5 = v6;
        function_100003d10();
        v6 = v5 + 1;
        v7 = v5 - 0x4e1f;
    }
    // 0x100003f3c
    int64_t v8; // 0x100003e54
    _printf("%d with %d divisors\n", 1, v8);
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

int main() {
  for (int i=1; i<=105; i++) if (i%3 && i%5) printf("%3d ", i); else printf("%s%s%s", i%3?"":"Fizz", i%5?"":"Buzz", i%15?" ":"\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e04 - 0x100003f80
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e04
    if (v1 % 3 == 0 || v1 % 5 == 0) {
        // 0x100003e9c
        _printf("%s%s%s", (char *)v2, (char *)v2, (char *)v2);
    } else {
        // 0x100003e7c
        _printf("%3d ", v2);
    }
    int32_t v3 = v1 + 1; // 0x100003f64
    while (v1 == 104 || v1 < 104 != (103 - v1 & v3) < 0) {
        // 0x100003e34
        v1 = v3;
        if (v1 % 3 == 0 || v1 % 5 == 0) {
            // 0x100003e9c
            _printf("%s%s%s", (char *)v2, (char *)v2, (char *)v2);
        } else {
            // 0x100003e7c
            _printf("%3d ", v2);
        }
        // 0x100003f60
        v3 = v1 + 1;
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>

int main()
{
  rename("input.txt", "output.txt");
  rename("docs", "mydocs");
  rename("/input.txt", "/output.txt");
  rename("/docs", "/mydocs");
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f54(char * old, char * new);

// ------- Dynamically Linked Functions Without Header --------

int32_t _rename(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003edc - 0x100003f54
int64_t entry_point(void) {
    // 0x100003edc
    _rename("input.txt", "output.txt");
    _rename("docs", "mydocs");
    _rename("/input.txt", "/output.txt");
    _rename("/docs", "/mydocs");
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * old, char * new) {
    // 0x100003f54
    return _rename(old, new);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include<stdio.h>

int main()
{
    int i,j;

    char days[12][10] =
    {
        "First",
        "Second",
        "Third",
        "Fourth",
        "Fifth",
        "Sixth",
        "Seventh",
        "Eighth",
        "Ninth",
        "Tenth",
        "Eleventh",
        "Twelfth"
    };

    char gifts[12][33] =
    {
        "Twelve drummers drumming",
        "Eleven pipers piping",
        "Ten lords a-leaping",
        "Nine ladies dancing",
        "Eight maids a-milking",
        "Seven swans a-swimming",
        "Six geese a-laying",
        "Five golden rings",
        "Four calling birds",
        "Three french hens",
        "Two turtle doves",
        "And a partridge in a pear tree."
    };

    for(i=0;i<12;i++)
    {
        printf("\n\nOn the %s day of Christmas\nMy true love gave to me:",days[i]);

        for(j=i;j>=0;j--)
        {
            (i==0)?printf("\nA partridge in a pear tree."):printf("\n%s%c",gifts[11-j],(j!=0)?',':' ');
        }
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d24(int64_t a1);
int64_t * function_100003d30(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003d3c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b98 - 0x100003d24
int64_t entry_point(void) {
    // 0x100003b98
    int64_t v1; // bp-152, 0x100003b98
    _memcpy(&v1, (int64_t *)"First", 120);
    int64_t v2; // bp-548, 0x100003b98
    _memcpy(&v2, (int64_t *)"Twelve drummers drumming", 396);
    int32_t v3; // 0x100003b98
    for (int32_t i = 0; i < 12; i++) {
        // 0x100003c48
        _printf("\n\nOn the %s day of Christmas\nMy true love gave to me:", "Twelve drummers drumming");
        int32_t v4 = i;
        if (i == 0) {
            // 0x100003c5c
            v3 = _printf("\nA partridge in a pear tree.");
        } else {
            // 0x100003c6c
            v3 = _printf("\n%s%c", "Twelve drummers drumming", -116);
        }
        int32_t v5 = v4 - 1; // 0x100003c40
        while (v4 >= 1) {
            // 0x100003c48
            v4 = v5;
            if (i == 0) {
                // 0x100003c5c
                v3 = _printf("\nA partridge in a pear tree.");
            } else {
                // 0x100003c6c
                v3 = _printf("\n%s%c", "Twelve drummers drumming", -116);
            }
            // 0x100003cc4
            v5 = v4 - 1;
        }
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cf8
    if (v6 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d0c
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003d10
    return 0;
}

// Address range: 0x100003d24 - 0x100003d30
int64_t function_100003d24(int64_t a1) {
    // 0x100003d24
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d30 - 0x100003d3c
int64_t * function_100003d30(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003d30
    return _memcpy(dest, src, n);
}

// Address range: 0x100003d3c - 0x100003d48
int32_t function_100003d3c(char * format, ...) {
    // 0x100003d3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  FILE *fh = tmpfile(); /* file is automatically deleted when program exits */
  /* do stuff with stream "fh" */
  fclose(fh);
  /* The C standard library also has a tmpnam() function to create a file
    for you to open later. But you should not use it because someone else might
    be able to open the file from the time it is created by this function to the
    time you open it. */
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f90(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f9c(void);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _tmpfile(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003f58 - 0x100003f90
int64_t entry_point(void) {
    // 0x100003f58
    _fclose(_tmpfile());
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(struct _IO_FILE * stream) {
    // 0x100003f90
    return _fclose(stream);
}

// Address range: 0x100003f9c - 0x100003fa8
struct _IO_FILE * function_100003f9c(void) {
    // 0x100003f9c
    return _tmpfile();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <math.h>
#include <stdbool.h>
#include <stdio.h>

bool approxEquals(double value, double other, double epsilon) {
    return fabs(value - other) < epsilon;
}

void test(double a, double b) {
    double epsilon = 1e-18;
    printf("%f, %f => %d\n", a, b, approxEquals(a, b, epsilon));
}

int main() {
    test(100000000000000.01, 100000000000000.011);
    test(100.01, 100.011);
    test(10000000000000.001 / 10000.0, 1000000000.0000001000);
    test(0.001, 0.0010000001);
    test(0.000000000000000000000101, 0.0);
    test(sqrt(2.0) * sqrt(2.0), 2.0);
    test(-sqrt(2.0) * sqrt(2.0), -2.0);
    test(3.14159265358979323846, 3.14159265358979324);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dc4(void);
int64_t function_100003df8(void);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dc4 - 0x100003df8
int64_t function_100003dc4(void) {
    // 0x100003dc4
    float64_t v1; // 0x100003dc4
    return __asm_fabd(v1, v1) > v1;
}

// Address range: 0x100003df8 - 0x100003e70
int64_t function_100003df8(void) {
    // 0x100003df8
    function_100003dc4();
    int64_t v1; // 0x100003df8
    int128_t v2; // 0x100003df8
    return _printf("%f, %f => %d\n", (float64_t)(int64_t)v2, (float64_t)(int64_t)v2, v1);
}

// Address range: 0x100003e70 - 0x100003f34
int64_t entry_point(void) {
    // 0x100003e70
    function_100003df8();
    function_100003df8();
    function_100003df8();
    function_100003df8();
    function_100003df8();
    function_100003df8();
    function_100003df8();
    function_100003df8();
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

double Invsqr(double n)
{
	return 1 / (n*n);
}

int main (int argc, char *argv[])
{
	int i, start = 1, end = 1000;
	double sum = 0.0;
	
	for( i = start; i <= end; i++)
		sum += Invsqr((double)i);
	
	printf("%16.14f\n", sum);
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003eb0(void);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003eb0 - 0x100003ed4
int64_t function_100003eb0(void) {
    // 0x100003eb0
    int64_t result; // 0x100003eb0
    return result;
}

// Address range: 0x100003ed4 - 0x100003f88
int64_t entry_point(void) {
    int32_t v1 = 1;
    int128_t v2 = __asm_sshll(0.0f, 0); // 0x100003f30
    function_100003eb0();
    int32_t v3 = v1 + 1; // 0x100003f54
    while (v1 == 999 || v1 < 999 != (998 - v1 & v3) < 0) {
        // 0x100003f28
        v1 = v3;
        v2 = __asm_sshll(0.0f, 0);
        function_100003eb0();
        v3 = v1 + 1;
    }
    // 0x100003f60
    _printf("%16.14f\n", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdlib.h>
#include <stdio.h>

long getFileSize(const char *filename)
{
  long result;
  FILE *fh = fopen(filename, "rb");
  fseek(fh, 0, SEEK_END);
  result = ftell(fh);
  fclose(fh);
  return result;
}

int main(void)
{
  printf("%ld\n", getFileSize("input.txt"));
  printf("%ld\n", getFileSize("/input.txt"));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e88(void);
int32_t function_100003f4c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f58(char * filename, char * modes);
int32_t function_100003f64(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003f70(struct _IO_FILE * stream);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _ftell(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e88 - 0x100003ee0
int64_t function_100003e88(void) {
    // 0x100003e88
    int64_t v1; // 0x100003e88
    struct _IO_FILE * v2 = _fopen((char *)v1, "rb"); // 0x100003ea4
    _fseek(v2, 0, 2);
    int32_t result = _ftell(v2); // 0x100003ec0
    _fclose(v2);
    return result;
}

// Address range: 0x100003ee0 - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003ee0
    function_100003e88();
    int64_t v1; // 0x100003ee0
    int32_t v2 = v1; // 0x100003f18
    _printf("%ld\n", v2);
    function_100003e88();
    _printf("%ld\n", v2);
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(struct _IO_FILE * stream) {
    // 0x100003f4c
    return _fclose(stream);
}

// Address range: 0x100003f58 - 0x100003f64
struct _IO_FILE * function_100003f58(char * filename, char * modes) {
    // 0x100003f58
    return _fopen(filename, modes);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003f64
    return _fseek(stream, off, whence);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(struct _IO_FILE * stream) {
    // 0x100003f70
    return _ftell(stream);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include "stdio.h"
#include "stdlib.h"
#include "stdbool.h"
#include "string.h"

struct int_a {
    int *ptr;
    size_t size;
};

struct int_a divisors(int n) {
    int *divs, *divs2, *out;
    int i, j, c1 = 0, c2 = 0;
    struct int_a array;

    divs = malloc(n * sizeof(int) / 2);
    divs2 = malloc(n * sizeof(int) / 2);
    divs[c1++] = 1;

    for (i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            j = n / i;
            divs[c1++] = i;
            if (i != j) {
                divs2[c2++] = j;
            }
        }
    }

    out = malloc((c1 + c2) * sizeof(int));
    for (int i = 0; i < c2; i++) {
        out[i] = divs2[i];
    }
    for (int i = 0; i < c1; i++) {
        out[c2 + i] = divs[c1 - i - 1];
    }
    array.ptr = out;
    array.size = c1 + c2;

    free(divs);
    free(divs2);
    return array;
}

bool abundant(int n, struct int_a divs) {
    int sum = 0;
    int i;
    for (i = 0; i < divs.size; i++) {
        sum += divs.ptr[i];
    }
    return sum > n;
}

bool semiperfect(int n, struct int_a divs) {
    if (divs.size > 0) {
        int h = *divs.ptr;
        int *t = divs.ptr + 1;

        struct int_a ta;
        ta.ptr = t;
        ta.size = divs.size - 1;

        if (n < h) {
            return semiperfect(n, ta);
        } else {
            return n == h
                || semiperfect(n - h, ta)
                || semiperfect(n, ta);
        }
    } else {
        return false;
    }
}

bool *sieve(int limit) {
    bool *w = calloc(limit, sizeof(bool));
    struct int_a divs;
    int i, j;

    for (i = 2; i < limit; i += 2) {
        if (w[i]) continue;
        divs = divisors(i);
        if (!abundant(i, divs)) {
            w[i] = true;
        } else if (semiperfect(i, divs)) {
            for (j = i; j < limit; j += i) {
                w[j] = true;
            }
        }
    }

    free(divs.ptr);
    return w;
}

int main() {
    bool *w = sieve(17000);
    int count = 0;
    int max = 25;
    int n;

    printf("The first 25 weird numbers:\n");
    for (n = 2; count < max; n += 2) {
        if (!w[n]) {
            printf("%d ", n);
            count++;
        }
    }
    printf("\n");

    free(w);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003948(void);
int64_t function_100003b8c(void);
int64_t function_100003c08(void);
int64_t function_100003d34(void);
int64_t * function_100003f4c(int32_t nmemb, int32_t size);
void function_100003f58(int64_t * ptr);
int64_t * function_100003f64(int32_t size);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003948 - 0x100003b8c
int64_t function_100003948(void) {
    // 0x100003948
    int64_t v1; // 0x100003948
    int32_t v2 = v1; // 0x100003954
    int32_t v3 = (0x100000000 * v1 >> 30) / 2; // 0x100003974
    int64_t * v4 = _malloc(v3); // 0x100003974
    int64_t v5 = (int64_t)v4; // 0x100003974
    int64_t * v6 = _malloc(v3); // 0x10000398c
    int64_t v7 = (int64_t)v6; // 0x10000398c
    *(int32_t *)v4 = 1;
    int32_t v8 = 4 - v2; // 0x1000039cc
    int32_t v9 = 1; // 0x1000039d4
    int32_t v10 = 0; // 0x1000039d4
    if (v8 == 0 || v8 < 0 != (v8 & v2) < 0) {
        int32_t v11 = 1;
        int32_t v12 = 0;
        int32_t v13 = 2;
        int32_t v14 = v11; // 0x1000039f8
        int32_t v15 = v12; // 0x1000039f8
        int32_t v16; // 0x100003a08
        int32_t v17; // 0x100003a20
        if (v2 % v13 == 0) {
            // 0x100003a00
            v16 = v2 / v13;
            v17 = v11 + 1;
            *(int32_t *)(4 * (int64_t)v11 + v5) = v13;
            v14 = v17;
            v15 = v12;
            if (v13 != v16) {
                // 0x100003a44
                *(int32_t *)(4 * (int64_t)v12 + v7) = v16;
                v14 = v17;
                v15 = v12 + 1;
            }
        }
        int32_t v18 = v15;
        int32_t v19 = v14;
        int32_t v20 = v13 + 1; // 0x100003a70
        int32_t v21 = v20 * v20; // 0x1000039c4
        int32_t v22 = v21 - v2; // 0x1000039cc
        v9 = v19;
        v10 = v18;
        while (v22 == 0 || v22 < 0 != ((v22 ^ v21) & (v21 ^ v2)) < 0) {
            // 0x1000039dc
            v11 = v19;
            v12 = v18;
            v13 = v20;
            v14 = v11;
            v15 = v12;
            if (v2 % v13 == 0) {
                // 0x100003a00
                v16 = v2 / v13;
                v17 = v11 + 1;
                *(int32_t *)(4 * (int64_t)v11 + v5) = v13;
                v14 = v17;
                v15 = v12;
                if (v13 != v16) {
                    // 0x100003a44
                    *(int32_t *)(4 * (int64_t)v12 + v7) = v16;
                    v14 = v17;
                    v15 = v12 + 1;
                }
            }
            // 0x100003a6c
            v18 = v15;
            v19 = v14;
            v20 = v13 + 1;
            v21 = v20 * v20;
            v22 = v21 - v2;
            v9 = v19;
            v10 = v18;
        }
    }
    int64_t result = (int64_t)_malloc(4 * (v10 + v9)); // 0x100003a94
    int32_t v23 = -v10; // 0x100003aac
    int32_t v24 = 0; // 0x100003ab4
    if (v23 < 0 != (v10 & v23) < 0) {
        int64_t v25 = 4 * (int64_t)v24; // 0x100003ac4
        *(int32_t *)(v25 + result) = *(int32_t *)(v25 + v7);
        v24++;
        while (v24 - v10 < 0 != ((v24 - v10 ^ v24) & (v24 ^ v10)) < 0) {
            // 0x100003abc
            v25 = 4 * (int64_t)v24;
            *(int32_t *)(v25 + result) = *(int32_t *)(v25 + v7);
            v24++;
        }
    }
    int32_t v26 = -v9; // 0x100003af8
    int32_t v27 = 0; // 0x100003b00
    if (v26 < 0 == (v9 & v26) < 0) {
        // 0x100003b48
        _free(v4);
        _free(v6);
        return result;
    }
    int32_t v28 = *(int32_t *)((int64_t)(4 * ((v27 ^ 0x3fffffff) + v9)) + v5); // 0x100003b1c
    *(int32_t *)((int64_t)(4 * (v27 + v10)) + result) = v28;
    v27++;
    while (v27 - v9 < 0 != ((v27 - v9 ^ v27) & (v27 ^ v9)) < 0) {
        // 0x100003b08
        v28 = *(int32_t *)((int64_t)(4 * ((v27 ^ 0x3fffffff) + v9)) + v5);
        *(int32_t *)((int64_t)(4 * (v27 + v10)) + result) = v28;
        v27++;
    }
    // 0x100003b48
    _free(v4);
    _free(v6);
    return result;
}

// Address range: 0x100003b8c - 0x100003c08
int64_t function_100003b8c(void) {
    // 0x100003b8c
    int64_t v1; // 0x100003b8c
    uint64_t v2 = v1;
    int32_t v3 = 0; // 0x100003bb8
    int32_t v4 = 0; // 0x100003bb8
    int32_t v5; // 0x100003b8c
    int32_t v6; // 0x100003b98
    int32_t v7; // 0x100003bf4
    if (v2 == 0) {
        // 0x100003bec
        v6 = v1;
        v5 = 0;
        v7 = v5 - v6;
        return !((v7 == 0 | v7 < 0 != ((v7 ^ v5) & (v5 ^ v6)) < 0));
    }
    v4 += *(int32_t *)v1;
    v3++;
    int64_t v8 = v3; // 0x100003ba8
    while (v2 > v8) {
        // 0x100003bc0
        v4 += *(int32_t *)(4 * v8 + v1);
        v3++;
        v8 = v3;
    }
    // 0x100003bec
    v6 = v1;
    v5 = v4;
    v7 = v5 - v6;
    return !((v7 == 0 | v7 < 0 != ((v7 ^ v5) & (v5 ^ v6)) < 0));
}

// Address range: 0x100003c08 - 0x100003d34
int64_t function_100003c08(void) {
    // 0x100003c08
    int64_t v1; // 0x100003c08
    if (v1 == 0) {
        // 0x100003d20
        return 0;
    }
    int32_t v2 = v1; // 0x100003c1c
    int32_t v3 = v1;
    int32_t v4 = v2 - v3; // 0x100003c68
    if (v4 < 0 != ((v4 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003d20
        return function_100003c08() % 2;
    }
    // 0x100003c98
    if (v2 == v3) {
        // 0x100003d20
        return 1;
    }
    int64_t result = 1; // 0x100003cd8
    if (function_100003c08() % 2 == 0) {
        // 0x100003ce0
        result = function_100003c08() % 2;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d34 - 0x100003e78
int64_t function_100003d34(void) {
    // 0x100003d34
    int64_t v1; // 0x100003d34
    int32_t v2 = v1; // 0x100003d40
    int64_t result = (int64_t)_calloc(v2, 1); // 0x100003d4c
    int32_t v3 = 2 - v2; // 0x100003d68
    float128_t v4; // 0x100003d34
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e60
        _free((int64_t *)(int64_t)(float64_t)v4);
        return result;
    }
    int32_t v5 = 2;
    char * v6 = (char *)((int64_t)v5 + result); // 0x100003d84
    float128_t v7; // 0x100003d34
    float128_t v8 = v7; // 0x100003d88
    int32_t v9; // 0x100003d34
    int32_t v10; // 0x100003e08
    int32_t v11; // 0x100003e38
    int32_t v12; // 0x100003e08
    int64_t v13; // 0x100003d98
    if (*v6 % 2 == 0) {
        // 0x100003d94
        v13 = function_100003948();
        if (function_100003b8c() % 2 == 0) {
            // 0x100003dc4
            *v6 = 1;
            v8 = (int128_t)v13;
        } else {
            // 0x100003ddc
            v8 = (int128_t)v13;
            if (function_100003c08() % 2 != 0) {
                // 0x100003e00
                v10 = v5 - v2;
                v9 = v5;
                v8 = (int128_t)v13;
                if (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
                    *(char *)((int64_t)v9 + result) = 1;
                    v11 = v9 + v5;
                    v12 = v11 - v2;
                    v9 = v11;
                    v8 = (int128_t)v13;
                    while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
                        // 0x100003e18
                        *(char *)((int64_t)v9 + result) = 1;
                        v11 = v9 + v5;
                        v12 = v11 - v2;
                        v9 = v11;
                        v8 = (int128_t)v13;
                    }
                }
            }
        }
    }
    int32_t v14 = v5 + 2; // 0x100003e54
    int32_t v15 = v14 - v2; // 0x100003d68
    v4 = v8;
    while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
        // 0x100003d78
        v5 = v14;
        v6 = (char *)((int64_t)v5 + result);
        if (*v6 % 2 == 0) {
            // 0x100003d94
            v13 = function_100003948();
            if (function_100003b8c() % 2 == 0) {
                // 0x100003dc4
                *v6 = 1;
                v8 = (int128_t)v13;
            } else {
                // 0x100003ddc
                v8 = (int128_t)v13;
                if (function_100003c08() % 2 != 0) {
                    // 0x100003e00
                    v10 = v5 - v2;
                    v9 = v5;
                    v8 = (int128_t)v13;
                    if (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
                        *(char *)((int64_t)v9 + result) = 1;
                        v11 = v9 + v5;
                        v12 = v11 - v2;
                        v9 = v11;
                        v8 = (int128_t)v13;
                        while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
                            // 0x100003e18
                            *(char *)((int64_t)v9 + result) = 1;
                            v11 = v9 + v5;
                            v12 = v11 - v2;
                            v9 = v11;
                            v8 = (int128_t)v13;
                        }
                    }
                }
            }
        }
        // 0x100003e50
        v14 = v5 + 2;
        v15 = v14 - v2;
        v4 = v8;
    }
    // 0x100003e60
    _free((int64_t *)(int64_t)(float64_t)v4);
    return result;
}

// Address range: 0x100003e78 - 0x100003f4c
int64_t entry_point(void) {
    int64_t v1 = function_100003d34(); // 0x100003e8c
    _printf("The first 25 weird numbers:\n");
    int32_t v2 = 2; // 0x100003e78
    int32_t v3 = 0;
    int32_t v4 = v3; // 0x100003ee0
    int64_t v5; // 0x100003e78
    if (*(char *)(v1 + (int64_t)v2) % 2 == 0) {
        // 0x100003ee8
        _printf("%d ", v5);
        v4 = v3 + 1;
    }
    // 0x100003f18
    v2 += 2;
    while (v4 < 25 != (24 - v4 & v4) < 0) {
        // 0x100003ed0
        v3 = v4;
        v4 = v3;
        if (*(char *)(v1 + (int64_t)v2) % 2 == 0) {
            // 0x100003ee8
            _printf("%d ", v5);
            v4 = v3 + 1;
        }
        // 0x100003f18
        v2 += 2;
    }
    // 0x100003f28
    _printf((char *)0x100003f9d);
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int64_t * function_100003f4c(int32_t nmemb, int32_t size) {
    // 0x100003f4c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f58 - 0x100003f64
void function_100003f58(int64_t * ptr) {
    // 0x100003f58
    _free(ptr);
}

// Address range: 0x100003f64 - 0x100003f70
int64_t * function_100003f64(int32_t size) {
    // 0x100003f64
    return _malloc(size);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>

int* mertens_numbers(int max) {
    int* m = malloc((max + 1) * sizeof(int));
    if (m == NULL)
        return m;
    m[1] = 1;
    for (int n = 2; n <= max; ++n) {
        m[n] = 1;
        for (int k = 2; k <= n; ++k)
            m[n] -= m[n/k];
    }
    return m;
}

int main() {
    const int max = 1000;
    int* mertens = mertens_numbers(max);
    if (mertens == NULL) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    printf("First 199 Mertens numbers:\n");
    const int count = 200;
    for (int i = 0, column = 0; i < count; ++i) {
        if (column > 0)
            printf(" ");
        if (i == 0)
            printf("  ");
        else
            printf("%2d", mertens[i]);
        ++column;
        if (column == 20) {
            printf("\n");
            column = 0;
        }
    }
    int zero = 0, cross = 0, previous = 0;
    for (int i = 1; i <= max; ++i) {
        int m = mertens[i];
        if (m == 0) {
            ++zero;
            if (previous != 0)
                ++cross;
        }
        previous = m;
    }
    free(mertens);
    printf("M(n) is zero %d times for 1 <= n <= %d.\n", zero, max);
    printf("M(n) crosses zero %d times for 1 <= n <= %d.\n", cross, max);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b78(void);
int32_t function_100003ee8(struct _IO_FILE * stream, char * format, ...);
void function_100003ef4(int64_t * ptr);
int64_t * function_100003f00(int32_t size);
int32_t function_100003f0c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b78 - 0x100003c98
int64_t function_100003b78(void) {
    // 0x100003b78
    int64_t v1; // 0x100003b78
    int64_t * v2 = _malloc((int32_t)((0x100000000 * v1 + 0x100000000) / 0x40000000)); // 0x100003b9c
    int64_t result = (int64_t)v2; // 0x100003b9c
    if (v2 == NULL) {
        // 0x100003c88
        return result;
    }
    int32_t v3 = v1; // 0x100003b84
    *(int32_t *)(result + 4) = 1;
    int32_t v4 = 2 - v3; // 0x100003be4
    if (v4 != 0 && v4 < 0 == (v4 & v3) < 0) {
        // 0x100003c88
        return result;
    }
    int32_t v5 = 2;
    int32_t * v6 = (int32_t *)(4 * (int64_t)v5 + result); // 0x100003c00
    *v6 = 1;
    int32_t v7 = 2 - v5; // 0x100003c18
    int32_t v8 = 2; // 0x100003c20
    int32_t v9; // 0x100003b78
    int32_t v10; // 0x100003c4c
    int32_t v11; // 0x100003c5c
    int32_t v12; // 0x100003c18
    int32_t v13; // 0x100003c38
    if (v7 == 0 || v7 < 0 != (v7 & v5) < 0) {
        v10 = 1 - *(int32_t *)((int64_t)(4 * v5 / v8) + result);
        *v6 = v10;
        v11 = v8 + 1;
        v12 = v11 - v5;
        v9 = v10;
        v8 = v11;
        while (v12 == 0 || v12 < 0 != ((v12 ^ v11) & (v11 ^ v5)) < 0) {
            // 0x100003c28
            v13 = *(int32_t *)((int64_t)(4 * v5 / v8) + result);
            v10 = v9 - v13;
            *v6 = v10;
            v11 = v8 + 1;
            v12 = v11 - v5;
            v9 = v10;
            v8 = v11;
        }
    }
    int32_t v14 = v5 + 1; // 0x100003c70
    while (v14 - v3 == 0 || v14 - v3 < 0 != ((v14 - v3 ^ v14) & (v14 ^ v3)) < 0) {
        // 0x100003bf4
        v5 = v14;
        v6 = (int32_t *)(4 * (int64_t)v5 + result);
        *v6 = 1;
        v7 = 2 - v5;
        v8 = 2;
        if (v7 == 0 || v7 < 0 != (v7 & v5) < 0) {
            v10 = 1 - *(int32_t *)((int64_t)(4 * v5 / v8) + result);
            *v6 = v10;
            v11 = v8 + 1;
            v12 = v11 - v5;
            v9 = v10;
            v8 = v11;
            while (v12 == 0 || v12 < 0 != ((v12 ^ v11) & (v11 ^ v5)) < 0) {
                // 0x100003c28
                v13 = *(int32_t *)((int64_t)(4 * v5 / v8) + result);
                v10 = v9 - v13;
                *v6 = v10;
                v11 = v8 + 1;
                v12 = v11 - v5;
                v9 = v10;
                v8 = v11;
            }
        }
        // 0x100003c6c
        v14 = v5 + 1;
    }
    // 0x100003c88
    return result;
}

// Address range: 0x100003c98 - 0x100003ee8
int64_t entry_point(void) {
    int64_t v1 = function_100003b78(); // 0x100003cb0
    if (v1 == 0) {
        // 0x100003ccc
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "Out of memory\n");
        // 0x100003ed8
        return 1;
    }
    // 0x100003cf0
    _printf("First 199 Mertens numbers:\n");
    uint32_t v2 = 0;
    int32_t v3 = 0;
    if (v2 >= 1) {
        // 0x100003d38
        _printf(" ");
    }
    int64_t v4; // 0x100003c98
    if (v3 == 0) {
        // 0x100003d5c
        _printf("  ");
    } else {
        // 0x100003d6c
        _printf("%2d", v4);
    }
    int32_t v5 = v2 + 1; // 0x100003dac
    if (v2 == 19) {
        // 0x100003db4
        _printf("\n");
        v5 = 0;
    }
    int32_t v6 = v3 + 1; // 0x100003dd0
    while (v3 < 199 != (198 - v3 & v6) < 0) {
        // 0x100003d24
        v2 = v5;
        v3 = v6;
        if (v2 >= 1) {
            // 0x100003d38
            _printf(" ");
        }
        if (v3 == 0) {
            // 0x100003d5c
            _printf("  ");
        } else {
            // 0x100003d6c
            _printf("%2d", v4);
        }
        // 0x100003d94
        v5 = v2 + 1;
        if (v2 == 19) {
            // 0x100003db4
            _printf("\n");
            v5 = 0;
        }
        // 0x100003dcc
        v6 = v3 + 1;
    }
    int32_t v7 = 1;
    int32_t v8 = v7 + 1; // 0x100003e70
    int32_t v9 = v7 - 999; // 0x100003df8
    while (v9 == 0 || v9 < 0 != (998 - v7 & v8) < 0) {
        // 0x100003e08
        v7 = v8;
        v8 = v7 + 1;
        v9 = v7 - 999;
    }
    // 0x100003e7c
    _free((int64_t *)v1);
    _printf("M(n) is zero %d times for 1 <= n <= %d.\n", v4, v4);
    _printf("M(n) crosses zero %d times for 1 <= n <= %d.\n", v4, v4);
    // 0x100003ed8
    return 0;
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ee8
    return _fprintf(stream, format);
}

// Address range: 0x100003ef4 - 0x100003f00
void function_100003ef4(int64_t * ptr) {
    // 0x100003ef4
    _free(ptr);
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t * function_100003f00(int32_t size) {
    // 0x100003f00
    return _malloc(size);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * format, ...) {
    // 0x100003f0c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#define _ISOC99_SOURCE

#include <math.h>
#include <stdio.h>

int main() {
  printf("%g\n", INFINITY);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f48 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f48
    int128_t v1; // 0x100003f48
    _printf("%g\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`/**
 * @file
 * @brief Program to identify if a number is [palindrome
 * number](https://en.wikipedia.org/wiki/Palindrome) or not.
 * @see project_euler/problem_4/sol1.c
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

bool isPalindrome(int number);

/** Driver Code */
int main()
{
    assert(isPalindrome(0));
    assert(isPalindrome(1));
    assert(isPalindrome(12321));
    assert(!isPalindrome(1234));
    return 0;
}

/**
 * Check given number whether is palindrome number or not
 * @param number number to check
 * @return true if given number is palindrome number
 * @return false if number is not a palindrome number
 */
bool isPalindrome(int number)
{
    int reversedNumber = 0;
    int originalNumber = number;
    while (number != 0)
    {
        int remainder = number % 10;
        reversedNumber = reversedNumber * 10 + remainder;
        number /= 10;
    }
    return originalNumber == reversedNumber;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003eb4(void);
int64_t function_100003f38(char * a1, char * a2, int64_t a3, char * a4);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);

// ------------------------ Functions -------------------------

// Address range: 0x100003d74 - 0x100003eb4
int64_t entry_point(void) {
    // 0x100003d74
    if ((uint64_t)function_100003eb4() % 2 == 0) {
        // 0x100003da4
        ___assert_rtn("main", "palindrome.c", 16, "isPalindrome(0)");
    }
    // 0x100003dc8
    if (function_100003eb4() % 2 == 0) {
        // 0x100003df0
        ___assert_rtn("main", "palindrome.c", 17, "isPalindrome(1)");
    }
    // 0x100003e14
    if (function_100003eb4() % 2 == 0) {
        // 0x100003e34
        ___assert_rtn("main", "palindrome.c", 18, "isPalindrome(12321)");
    }
    // 0x100003e58
    if (function_100003eb4() % 2 != 0) {
        // 0x100003e80
        ___assert_rtn("main", "palindrome.c", 19, "!isPalindrome(1234)");
    }
    // 0x100003ea4
    return 0;
}

// Address range: 0x100003eb4 - 0x100003f38
int64_t function_100003eb4(void) {
    // 0x100003eb4
    int64_t v1; // 0x100003eb4
    int32_t v2 = v1; // 0x100003eb8
    if (v2 == 0) {
        // 0x100003f1c
        return 0 == v2;
    }
    int32_t v3 = 0; // 0x100003ed8
    int32_t v4 = v2;
    v3 = 10 * v3 + v4 % 10;
    int32_t v5 = v4 / 10; // 0x100003ed8
    while (v4 >= 10) {
        // 0x100003ee0
        v4 = v5;
        v3 = 10 * v3 + v4 % 10;
        v5 = v4 / 10;
    }
    // 0x100003f1c
    return v3 == v2;
}

// Address range: 0x100003f38 - 0x100003f44
int64_t function_100003f38(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003f38
    return ___assert_rtn(a1, a2, a3, a4);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

typedef unsigned long long ull;

ull binomial(ull m, ull n)
{
	ull r = 1, d = m - n;
	if (d > n) { n = d; d = m - n; }

	while (m > n) {
		r *= m--;
		while (d > 1 && ! (r%d) ) r /= d--;
	}

	return r;
}

ull catalan1(int n) {
	return binomial(2 * n, n) / (1 + n);
}

ull catalan2(int n) {
	int i;
	ull r = !n;

	for (i = 0; i < n; i++)
		r += catalan2(i) * catalan2(n - 1 - i);
	return r;
}

ull catalan3(int n)
{
	return n ? 2 * (2 * n - 1) * catalan3(n - 1) / (1 + n) : 1;
}

int main(void)
{
	int i;
	puts("\tdirect\tsumming\tfrac");
	for (i = 0; i < 16; i++) {
		printf("%d\t%llu\t%llu\t%llu\n", i,
			catalan1(i), catalan2(i), catalan3(i));
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c24(void);
int64_t function_100003d2c(int32_t a1);
int64_t function_100003d78(void);
int64_t function_100003e1c(void);
int32_t function_100003f60(char * format, ...);
int32_t function_100003f6c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c24 - 0x100003d2c
int64_t function_100003c24(void) {
    // 0x100003c24
    int64_t v1; // 0x100003c24
    uint64_t v2 = v1;
    uint64_t v3 = v1;
    uint64_t v4 = v3 - v2; // 0x100003c40
    bool v5 = v4 == v2 | v4 < v2; // 0x100003c54
    uint64_t v6 = v5 ? v2 : v4;
    if (v3 == v6 || v3 < v6) {
        // 0x100003d20
        return 1;
    }
    int64_t v7 = v5 ? v4 : v2;
    int64_t v8; // 0x100003c24
    int64_t v9 = v8; // 0x100003ca8
    int64_t v10 = v7; // 0x100003cc8
    int64_t v11 = v9; // 0x100003cc8
    int64_t v12 = v9; // 0x100003cc8
    int64_t v13 = v7; // 0x100003cc8
    uint64_t v14; // 0x100003c24
    uint64_t v15; // 0x100003c24
    int64_t v16; // 0x100003d04
    int64_t v17; // 0x100003d10
    if (v7 != 1 && v7 != 0) {
        v14 = v13;
        v15 = v12;
        v10 = v14;
        v11 = v15;
        while (v15 % v14 == 0) {
            // 0x100003d00
            v16 = v14 - 1;
            v17 = v15 / v14;
            v10 = 1;
            v11 = v17;
            v12 = v17;
            v13 = v16;
            if (v16 == 1) {
                // break -> 0x100003c80
                break;
            }
            v14 = v13;
            v15 = v12;
            v10 = v14;
            v11 = v15;
        }
    }
    int64_t result = v11;
    int64_t v18 = v8 - 1; // 0x100003c9c
    while (v18 != v6 && v18 >= v6) {
        // 0x100003c98
        v7 = v10;
        v9 = result * v18;
        v10 = v7;
        v11 = v9;
        v12 = v9;
        v13 = v7;
        if (v7 != 1 && v7 != 0) {
            v14 = v13;
            v15 = v12;
            v10 = v14;
            v11 = v15;
            while (v15 % v14 == 0) {
                // 0x100003d00
                v16 = v14 - 1;
                v17 = v15 / v14;
                v10 = 1;
                v11 = v17;
                v12 = v17;
                v13 = v16;
                if (v16 == 1) {
                    // break -> 0x100003c80
                    break;
                }
                v14 = v13;
                v15 = v12;
                v10 = v14;
                v11 = v15;
            }
        }
        // 0x100003c80
        result = v11;
        v18--;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d2c - 0x100003d78
int64_t function_100003d2c(int32_t a1) {
    // 0x100003d2c
    return (uint64_t)function_100003c24() / (int64_t)(a1 + 1);
}

// Address range: 0x100003d78 - 0x100003e1c
int64_t function_100003d78(void) {
    // 0x100003d78
    int64_t v1; // 0x100003d78
    int32_t v2 = v1; // 0x100003d84
    int64_t result = v2 == 0; // 0x100003d90
    int32_t v3 = -v2; // 0x100003db0
    int32_t v4 = 0; // 0x100003db8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e0c
        return result;
    }
    int64_t result2 = result; // 0x100003db8
    int64_t v5 = function_100003d78(); // 0x100003dc4
    result2 += function_100003d78() * v5;
    v4++;
    int32_t v6 = v4 - v2; // 0x100003db0
    while (v6 < 0 != ((v6 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003dc0
        v5 = function_100003d78();
        result2 += function_100003d78() * v5;
        v4++;
        v6 = v4 - v2;
    }
    // 0x100003e0c
    return result2;
}

// Address range: 0x100003e1c - 0x100003eac
int64_t function_100003e1c(void) {
    // 0x100003e1c
    int64_t v1; // 0x100003e1c
    int32_t v2 = v1; // 0x100003e28
    int64_t result = 1; // 0x100003e38
    if (v2 != 0) {
        // 0x100003e40
        result = function_100003e1c() * (int64_t)(4 * v2 - 2) / (0x100000000 * v1 + 0x100000000 >> 32);
    }
    // 0x100003e9c
    return result;
}

// Address range: 0x100003eac - 0x100003f60
int64_t entry_point(void) {
    // 0x100003eac
    _puts("\tdirect\tsumming\tfrac");
    for (int32_t i = 0; i < 16; i++) {
        // 0x100003ee4
        function_100003d2c(i);
        function_100003d78();
        function_100003e1c();
        int64_t v1; // 0x100003eac
        _printf("%d\t%llu\t%llu\t%llu\n", v1, v1, v1, v1);
    }
    // 0x100003f50
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * s) {
    // 0x100003f6c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

typedef union uwb {
    unsigned w;
    unsigned char b[4];
} WBunion;

typedef unsigned Digest[4];

unsigned f0( unsigned abcd[] ){
    return ( abcd[1] & abcd[2]) | (~abcd[1] & abcd[3]);}

unsigned f1( unsigned abcd[] ){
    return ( abcd[3] & abcd[1]) | (~abcd[3] & abcd[2]);}

unsigned f2( unsigned abcd[] ){
    return  abcd[1] ^ abcd[2] ^ abcd[3];}

unsigned f3( unsigned abcd[] ){
    return abcd[2] ^ (abcd[1] |~ abcd[3]);}

typedef unsigned (*DgstFctn)(unsigned a[]);

unsigned *calcKs( unsigned *k)
{
    double s, pwr;
    int i;

    pwr = pow( 2, 32);
    for (i=0; i<64; i++) {
        s = fabs(sin(1+i));
        k[i] = (unsigned)( s * pwr );
    }
    return k;
}

// ROtate v Left by amt bits
unsigned rol( unsigned v, short amt )
{
    unsigned  msk1 = (1<<amt) -1;
    return ((v>>(32-amt)) & msk1) | ((v<<amt) & ~msk1);
}

unsigned *md5( const char *msg, int mlen)
{
    static Digest h0 = { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476 };
//    static Digest h0 = { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 };
    static DgstFctn ff[] = { &f0, &f1, &f2, &f3 };
    static short M[] = { 1, 5, 3, 7 };
    static short O[] = { 0, 1, 5, 0 };
    static short rot0[] = { 7,12,17,22};
    static short rot1[] = { 5, 9,14,20};
    static short rot2[] = { 4,11,16,23};
    static short rot3[] = { 6,10,15,21};
    static short *rots[] = {rot0, rot1, rot2, rot3 };
    static unsigned kspace[64];
    static unsigned *k;

    static Digest h;
    Digest abcd;
    DgstFctn fctn;
    short m, o, g;
    unsigned f;
    short *rotn;
    union {
        unsigned w[16];
        char     b[64];
    }mm;
    int os = 0;
    int grp, grps, q, p;
    unsigned char *msg2;

    if (k==NULL) k= calcKs(kspace);

    for (q=0; q<4; q++) h[q] = h0[q];   // initialize

    {
        grps  = 1 + (mlen+8)/64;
        msg2 = malloc( 64*grps);
        memcpy( msg2, msg, mlen);
        msg2[mlen] = (unsigned char)0x80;
        q = mlen + 1;
        while (q < 64*grps){ msg2[q] = 0; q++ ; }
        {
//            unsigned char t;
            WBunion u;
            u.w = 8*mlen;
//            t = u.b[0]; u.b[0] = u.b[3]; u.b[3] = t;
//            t = u.b[1]; u.b[1] = u.b[2]; u.b[2] = t;
            q -= 8;
            memcpy(msg2+q, &u.w, 4 );
        }
    }

    for (grp=0; grp<grps; grp++)
    {
        memcpy( mm.b, msg2+os, 64);
        for(q=0;q<4;q++) abcd[q] = h[q];
        for (p = 0; p<4; p++) {
            fctn = ff[p];
            rotn = rots[p];
            m = M[p]; o= O[p];
            for (q=0; q<16; q++) {
                g = (m*q + o) % 16;
                f = abcd[1] + rol( abcd[0]+ fctn(abcd) + k[q+16*p] + mm.w[g], rotn[q%4]);

                abcd[0] = abcd[3];
                abcd[3] = abcd[2];
                abcd[2] = abcd[1];
                abcd[1] = f;
            }
        }
        for (p=0; p<4; p++)
            h[p] += abcd[p];
        os += 64;
    }

    if( msg2 )
        free( msg2 );

    return h;
}

int main( int argc, char *argv[] )
{
    int j,k;
    const char *msg = "The quick brown fox jumps over the lazy dog.";
    unsigned *d = md5(msg, strlen(msg));
    WBunion u;

    printf("= 0x");
    for (j=0;j<4; j++){
        u.w = d[j];
        for (k=0;k<4;k++) printf("%02x",u.b[k]);
    }
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000037a4(void);
int64_t function_1000037e0(void);
int64_t function_10000381c(void);
int64_t function_10000384c(void);
int64_t function_10000387c(void);
int64_t function_100003914(void);
int64_t function_100003970(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003ee4(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t function_100003ef0(void);
void function_100003efc(int64_t * ptr);
int64_t * function_100003f08(int32_t size);
int64_t * function_100003f14(int64_t * dest, int64_t * src, int32_t n);
float64_t function_100003f20(float64_t a1, float64_t a2);
int32_t function_100003f2c(char * format, ...);
float64_t function_100003f38(float64_t a1);
int32_t function_100003f44(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008180
int32_t * g2 = NULL; // 0x100008188
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);
float64_t _sin(float64_t a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000037a4 - 0x1000037e0
int64_t function_1000037a4(void) {
    // 0x1000037a4
    int64_t v1; // 0x1000037a4
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x1000037b0
    int32_t v3 = *(int32_t *)(v1 + 12); // 0x1000037cc
    return (int64_t)(v3 & -1 - v2 | *(int32_t *)(v1 + 8) & v2);
}

// Address range: 0x1000037e0 - 0x10000381c
int64_t function_1000037e0(void) {
    // 0x1000037e0
    int64_t v1; // 0x1000037e0
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x1000037ec
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x100003808
    return (int64_t)(v3 & -1 - v2 | *(int32_t *)(v1 + 4) & v2);
}

// Address range: 0x10000381c - 0x10000384c
int64_t function_10000381c(void) {
    // 0x10000381c
    int64_t v1; // 0x10000381c
    int64_t v2 = v1;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x10000383c
    return (int64_t)(*(int32_t *)(v2 + 8) ^ *(int32_t *)(v2 + 4) ^ v3);
}

// Address range: 0x10000384c - 0x10000387c
int64_t function_10000384c(void) {
    // 0x10000384c
    int64_t v1; // 0x10000384c
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x100003868
    return (int64_t)((*(int32_t *)(v1 + 4) | -1 - v2) ^ *(int32_t *)(v1 + 8));
}

// Address range: 0x10000387c - 0x100003914
int64_t function_10000387c(void) {
    // 0x10000387c
    int128_t v1; // 0x10000387c
    float64_t v2 = _pow((float64_t)(int64_t)v1, (float64_t)(int64_t)v1); // 0x1000038c8
    int64_t v3 = 0;
    int64_t v4 = v3 + 1;
    v2 = _sin(v2);
    float64_t v5 = fabs((float64_t)(int32_t)v4); // 0x1000038cc
    int64_t result; // 0x10000387c
    *(int32_t *)(4 * v3 + result) = (int32_t)(2.0 * v5);
    while (v4 != 64) {
        // 0x1000038bc
        v3 = v4;
        v4 = v3 + 1;
        v2 = _sin(v2);
        v5 = fabs((float64_t)(int32_t)v4);
        *(int32_t *)(4 * v3 + result) = (int32_t)(2.0 * v5);
    }
    // 0x100003904
    return result;
}

// Address range: 0x100003914 - 0x100003970
int64_t function_100003914(void) {
    // 0x100003914
    int64_t v1; // 0x100003914
    uint32_t v2 = (int32_t)v1; // 0x100003918
    uint32_t v3 = 0x10000 * (int32_t)v1 >> 16; // 0x100003920
    return v2 >> 32 - v3 & -1 - (-1 << v3) | v2 << v3;
}

// Address range: 0x100003970 - 0x100003de0
// Used cryptographic patterns:
//  - Lucifer__outerbridge__DFLTKY (8-bit)
int64_t function_100003970(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x10000398c
    if (g1 == 0) {
        // 0x1000039b8
        g1 = function_10000387c();
    }
    // 0x1000039d0
    int64_t v2; // 0x100003970
    int32_t v3 = v2; // 0x100003998
    for (int64_t i = 0; i < 4; i++) {
        int64_t v4 = 4 * i; // 0x1000039f8
        int32_t v5 = *(int32_t *)(v4 + (int64_t)"\x01#Eg\x89\xab\xcd\xef\xfe\xdc\xba\x98vT2\x10"); // 0x1000039f8
        *(int32_t *)(v4 + (int64_t)&g2) = v5;
    }
    int32_t v6 = v3 + 8; // 0x100003a24
    int32_t v7 = v6 / 64; // 0x100003a2c
    int32_t v8 = v7 + 1; // 0x100003a30
    int32_t v9 = 64 * v8; // 0x100003a3c
    int64_t * v10 = _malloc(v9); // 0x100003a48
    int64_t v11 = (int64_t)v10; // 0x100003a48
    ___memcpy_chk(v11, v2, v3, -1);
    *(char *)((0x100000000 * v2 >> 32) + v11) = -128;
    int32_t v12 = v3 + 1;
    int32_t v13 = v12 - v9; // 0x100003a9c
    int32_t v14 = v3; // 0x100003aa4
    if (v13 < 0 != ((v13 ^ v12) & (v9 ^ v12)) < 0) {
        *(char *)((int64_t)v12 + v11) = 0;
        int32_t v15 = v12 + 1;
        int32_t v16 = v15 - v9; // 0x100003a9c
        v14 = v12;
        while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v9)) < 0) {
            int32_t v17 = v15;
            *(char *)((int64_t)v17 + v11) = 0;
            v15 = v17 + 1;
            v16 = v15 - v9;
            v14 = v17;
        }
    }
    int64_t v18 = 8 * v3; // bp-188, 0x100003adc
    ___memcpy_chk((int64_t)(v14 - 7) + v11, (int64_t)&v18, 4, -1);
    if (v6 > -64 == (v8 & -v7) < 0) {
        if (v10 != NULL) {
            // 0x100003d9c
            _free(v10);
        }
        // 0x100003da8
        if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
            // 0x100003dc8
            ___stack_chk_fail();
        }
        // 0x100003c18
        return (int64_t)&g2;
    }
    // 0x100003b24
    int64_t v19; // bp-152, 0x100003970
    _memcpy(&v19, v10, 64);
    int64_t v20; // bp-40, 0x100003970
    int64_t result = &v20;
    for (int64_t i = 0; i < 4; i++) {
        int64_t v21 = 4 * i; // 0x100003b64
        int32_t v22 = *(int32_t *)(v21 + (int64_t)&g2); // 0x100003b64
        *(int32_t *)(v21 + result) = v22;
    }
    // 0x100003c18
    return result;
}

// Address range: 0x100003de0 - 0x100003ee4
int64_t entry_point(void) {
    int32_t v1 = _strlen("The quick brown fox jumps over the lazy dog."); // 0x100003e10
    function_100003970((int64_t)&g3, (int64_t)&g3, (int64_t)&g3);
    _printf("= 0x");
    for (int32_t i = 0; i < 4; i++) {
        for (int32_t j = 0; j < 4; j++) {
            // 0x100003e7c
            _printf("%02x", v1);
        }
    }
    // 0x100003ec8
    _printf((char *)0x100003f8f);
    return 0;
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003ee4
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t function_100003ef0(void) {
    // 0x100003ef0
    return ___stack_chk_fail();
}

// Address range: 0x100003efc - 0x100003f08
void function_100003efc(int64_t * ptr) {
    // 0x100003efc
    _free(ptr);
}

// Address range: 0x100003f08 - 0x100003f14
int64_t * function_100003f08(int32_t size) {
    // 0x100003f08
    return _malloc(size);
}

// Address range: 0x100003f14 - 0x100003f20
int64_t * function_100003f14(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f14
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f20 - 0x100003f2c
float64_t function_100003f20(float64_t a1, float64_t a2) {
    // 0x100003f20
    return _pow(a1, a2);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
float64_t function_100003f38(float64_t a1) {
    // 0x100003f38
    return _sin(a1);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * s) {
    // 0x100003f44
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include <stdio.h>
#include <stdlib.h>

typedef struct exception {
        int extype;
        char what[128];
} exception;

typedef struct exception_ctx {
        exception * exs;
        int size;
        int pos;
} exception_ctx;

exception_ctx * Create_Ex_Ctx(int length) {
        const int safety = 8; // alignment precaution.
        char * tmp = (char*) malloc(safety+sizeof(exception_ctx)+sizeof(exception)*length);
        if (! tmp) return NULL;
        exception_ctx * ctx = (exception_ctx*)tmp;
        ctx->size = length;
        ctx->pos = -1;
        ctx->exs = (exception*) (tmp + sizeof(exception_ctx));
        return ctx;
}

void Free_Ex_Ctx(exception_ctx * ctx) {
        free(ctx);
}

int Has_Ex(exception_ctx * ctx) {
        return (ctx->pos >= 0) ? 1 : 0;
}

int Is_Ex_Type(exception_ctx * exctx, int extype) {
        return (exctx->pos >= 0 && exctx->exs[exctx->pos].extype == extype) ? 1 : 0;
}

void Pop_Ex(exception_ctx * ctx) {
        if (ctx->pos >= 0) --ctx->pos;
}

const char * Get_What(exception_ctx * ctx) {
        if (ctx->pos >= 0) return ctx->exs[ctx->pos].what;
        return NULL;
}

int Push_Ex(exception_ctx * exctx, int extype, const char * msg) {
        if (++exctx->pos == exctx->size) {
                // Use last slot and report error.
                --exctx->pos;
                fprintf(stderr, "*** Error: Overflow in exception context.\n");
        }
        snprintf(exctx->exs[exctx->pos].what, sizeof(exctx->exs[0].what), "%s", msg);
        exctx->exs[exctx->pos].extype = extype;
        return -1;
}

//////////////////////////////////////////////////////////////////////

exception_ctx * GLOBALEX = NULL;
enum { U0_DRINK_ERROR = 10, U1_ANGRYBARTENDER_ERROR };

void baz(int n) {
        if (! n) {
                Push_Ex(GLOBALEX, U0_DRINK_ERROR , "U0 Drink Error. Insufficient drinks in bar Baz.");
                return;
        }
        else {
                Push_Ex(GLOBALEX, U1_ANGRYBARTENDER_ERROR , "U1 Bartender Error. Bartender kicked customer out of bar Baz.");
                return;
        }
}

void bar(int n) {
        fprintf(stdout, "Bar door is open.\n");
        baz(n);
        if (Has_Ex(GLOBALEX)) goto bar_cleanup;
        fprintf(stdout, "Baz has been called without errors.\n");
bar_cleanup:
        fprintf(stdout, "Bar door is closed.\n");
}

void foo() {
        fprintf(stdout, "Foo entering bar.\n");
        bar(0);
        while (Is_Ex_Type(GLOBALEX, U0_DRINK_ERROR)) {
                fprintf(stderr, "I am foo() and I deaall wrth U0 DriNk Errors with my own bottle... GOT oNE! [%s]\n", Get_What(GLOBALEX));
                Pop_Ex(GLOBALEX);
        }
        if (Has_Ex(GLOBALEX)) return;
        fprintf(stdout, "Foo left the bar.\n");
        fprintf(stdout, "Foo entering bar again.\n");
        bar(1);
        while (Is_Ex_Type(GLOBALEX, U0_DRINK_ERROR)) {
                fprintf(stderr, "I am foo() and I deaall wrth U0 DriNk Errors with my own bottle... GOT oNE! [%s]\n", Get_What(GLOBALEX));
                Pop_Ex(GLOBALEX);
        }
        if (Has_Ex(GLOBALEX)) return;
        fprintf(stdout, "Foo left the bar.\n");
}


int main(int argc, char ** argv) {
        exception_ctx * ctx = Create_Ex_Ctx(5);
        GLOBALEX = ctx;

        foo();
        if (Has_Ex(ctx)) goto main_ex;

        fprintf(stdout, "No errors encountered.\n");

main_ex:
        while (Has_Ex(ctx)) {
                fprintf(stderr, "*** Error: %s\n", Get_What(ctx));
                Pop_Ex(ctx);
        }
        Free_Ex_Ctx(ctx);
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003768(void);
int64_t function_100003800(int64_t a1);
int64_t function_100003824(void);
int64_t function_100003854(void);
int64_t function_1000038cc(void);
int64_t function_100003908(void);
int64_t function_100003964(void);
int64_t function_100003a48(void);
int64_t function_100003ab0(void);
int64_t function_100003b40(void);
int64_t function_100003dcc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int32_t function_100003dd8(struct _IO_FILE * stream, char * format, ...);
void function_100003de4(int64_t * ptr);
int64_t * function_100003df0(int32_t size);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___snprintf_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003768 - 0x100003800
int64_t function_100003768(void) {
    // 0x100003768
    int64_t v1; // 0x100003768
    int32_t v2 = v1; // 0x100003774
    int64_t * v3 = _malloc(132 * v2 + 24); // 0x100003790
    int64_t result = 0; // 0x1000037a4
    if (v3 != NULL) {
        // 0x1000037b4
        result = (int64_t)v3;
        *(int32_t *)(result + 8) = v2;
        *(int32_t *)(result + 12) = -1;
        *v3 = result + 16;
    }
    // 0x1000037f0
    return result;
}

// Address range: 0x100003800 - 0x100003824
int64_t function_100003800(int64_t a1) {
    // 0x100003800
    _free((int64_t *)a1);
    return &g2;
}

// Address range: 0x100003824 - 0x100003854
int64_t function_100003824(void) {
    // 0x100003824
    int64_t v1; // 0x100003824
    return *(int32_t *)(v1 + 12) >= 0;
}

// Address range: 0x100003854 - 0x1000038cc
int64_t function_100003854(void) {
    // 0x100003854
    int64_t v1; // 0x100003854
    uint32_t v2 = *(int32_t *)(v1 + 12); // 0x100003864
    int64_t result = 0; // 0x100003878
    if (v2 >= 0) {
        int32_t v3 = *(int32_t *)(132 * (int64_t)v2 + v1); // 0x100003898
        result = v3 == (int32_t)v1;
    }
    // 0x1000038b0
    return result;
}

// Address range: 0x1000038cc - 0x100003908
int64_t function_1000038cc(void) {
    // 0x1000038cc
    int64_t result; // 0x1000038cc
    int32_t * v1 = (int32_t *)(result + 12); // 0x1000038d8
    uint32_t v2 = *v1; // 0x1000038d8
    if (v2 >= 0) {
        // 0x1000038ec
        *v1 = v2 - 1;
    }
    // 0x100003900
    return result;
}

// Address range: 0x100003908 - 0x100003964
int64_t function_100003908(void) {
    // 0x100003908
    int64_t v1; // 0x100003908
    uint32_t v2 = *(int32_t *)(v1 + 12); // 0x100003914
    int64_t result = 0; // 0x100003920
    if (v2 >= 0) {
        // 0x100003928
        result = v1 + 4 + 132 * (int64_t)v2;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003964 - 0x100003a48
int64_t function_100003964(void) {
    // 0x100003964
    int64_t v1; // 0x100003964
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x100003980
    int32_t v3 = *v2; // 0x100003980
    int32_t v4 = v3 + 1; // 0x100003984
    *v2 = v4;
    int32_t v5 = v4; // 0x10000399c
    int64_t v6; // 0x100003964
    if (v4 == *(int32_t *)(v1 + 8)) {
        // 0x1000039a4
        *v2 = v3;
        int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000039bc
        int32_t v8 = _fprintf((struct _IO_FILE *)v7, "*** Error: Overflow in exception context.\n"); // 0x1000039c8
        v5 = *v2;
        v6 = v8;
    }
    int64_t v9 = ___snprintf_chk(v6 + 4 + 132 * (int64_t)v5, 128, 0, -1, "%s"); // 0x100003a14
    *(int32_t *)(132 * (int64_t)*v2 + v9) = (int32_t)v1;
    return 0xffffffff;
}

// Address range: 0x100003a48 - 0x100003ab0
int64_t function_100003a48(void) {
    // 0x100003a48
    return function_100003964();
}

// Address range: 0x100003ab0 - 0x100003b40
int64_t function_100003ab0(void) {
    // 0x100003ab0
    _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "Bar door is open.\n");
    function_100003a48();
    if ((int32_t)function_100003824() == 0) {
        int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b08
        _fprintf((struct _IO_FILE *)v1, "Baz has been called without errors.\n");
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b24
    return _fprintf((struct _IO_FILE *)v2, "Bar door is closed.\n");
}

// Address range: 0x100003b40 - 0x100003cec
int64_t function_100003b40(void) {
    // 0x100003b40
    _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "Foo entering bar.\n");
    function_100003ab0();
    int64_t v1; // 0x100003b40
    if ((int32_t)function_100003854() != 0) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b98
        function_100003908();
        _fprintf((struct _IO_FILE *)v2, "I am foo() and I deaall wrth U0 DriNk Errors with my own bottle... GOT oNE! [%s]\n", (char *)v1);
        function_1000038cc();
        // 0x100003b90
        while ((int32_t)function_100003854() != 0) {
            // 0x100003b90
            v2 = *(int64_t *)*(int64_t *)0x100004008;
            function_100003908();
            _fprintf((struct _IO_FILE *)v2, "I am foo() and I deaall wrth U0 DriNk Errors with my own bottle... GOT oNE! [%s]\n", (char *)v1);
            function_1000038cc();
        }
    }
    int64_t result = function_100003824(); // 0x100003be4
    if ((int32_t)result != 0) {
        // 0x100003ce0
        return result;
    }
    int64_t * v3 = (int64_t *)*(int64_t *)0x100004010; // 0x100003c08
    _fprintf((struct _IO_FILE *)*v3, "Foo left the bar.\n");
    _fprintf((struct _IO_FILE *)*v3, "Foo entering bar again.\n");
    function_100003ab0();
    if ((int32_t)function_100003854() != 0) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c60
        function_100003908();
        _fprintf((struct _IO_FILE *)v4, "I am foo() and I deaall wrth U0 DriNk Errors with my own bottle... GOT oNE! [%s]\n", (char *)v1);
        function_1000038cc();
        // 0x100003c58
        while ((int32_t)function_100003854() != 0) {
            // 0x100003c58
            v4 = *(int64_t *)*(int64_t *)0x100004008;
            function_100003908();
            _fprintf((struct _IO_FILE *)v4, "I am foo() and I deaall wrth U0 DriNk Errors with my own bottle... GOT oNE! [%s]\n", (char *)v1);
            function_1000038cc();
        }
    }
    int64_t v5 = function_100003824(); // 0x100003cac
    int64_t result2 = v5; // 0x100003cb8
    if ((int32_t)v5 == 0) {
        int64_t v6 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003ccc
        result2 = _fprintf((struct _IO_FILE *)v6, "Foo left the bar.\n");
    }
    // 0x100003ce0
    return result2;
}

// Address range: 0x100003cec - 0x100003dcc
int64_t entry_point(void) {
    int64_t v1 = function_100003768(); // 0x100003d08
    g1 = v1;
    function_100003b40();
    if ((int32_t)function_100003824() == 0) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d44
        _fprintf((struct _IO_FILE *)v2, "No errors encountered.\n");
    }
    // 0x100003d58
    if ((int32_t)function_100003824() == 0) {
        // 0x100003db4
        function_100003800(v1);
        return 0;
    }
    int64_t v3 = *(int64_t *)0x100004008; // 0x100003d78
    function_100003908();
    int64_t v4; // 0x100003cec
    _fprintf((struct _IO_FILE *)*(int64_t *)v3, "*** Error: %s\n", (char *)v4);
    function_1000038cc();
    // 0x100003d74
    while ((int32_t)function_100003824() != 0) {
        // 0x100003d74
        v3 = *(int64_t *)0x100004008;
        function_100003908();
        _fprintf((struct _IO_FILE *)*(int64_t *)v3, "*** Error: %s\n", (char *)v4);
        function_1000038cc();
    }
    // 0x100003db4
    function_100003800(v1);
    return 0;
}

// Address range: 0x100003dcc - 0x100003dd8
int64_t function_100003dcc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5) {
    // 0x100003dcc
    return ___snprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003dd8 - 0x100003de4
int32_t function_100003dd8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003dd8
    return _fprintf(stream, format);
}

// Address range: 0x100003de4 - 0x100003df0
void function_100003de4(int64_t * ptr) {
    // 0x100003de4
    _free(ptr);
}

// Address range: 0x100003df0 - 0x100003dfc
int64_t * function_100003df0(int32_t size) {
    // 0x100003df0
    return _malloc(size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include<stdio.h>
long long seed;
long long random(){
        seed = seed * seed / 1000 % 1000000;
        return seed;
}
int main(){
        seed = 675248;
        for(int i=1;i<=5;i++)
                printf("%lld\n",random());
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ed0(void);
int32_t function_100003f8c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ed0 - 0x100003f0c
int64_t function_100003ed0(void) {
    int64_t v1 = g1;
    int64_t v2 = v1 * v1; // 0x100003ee0
    int64_t result = -0xf4240 * v2 / 0x3b9aca00 + v2 / 1000; // 0x100003efc
    g1 = result;
    return result;
}

// Address range: 0x100003f0c - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f0c
    g1 = 0xa4db0;
    int32_t v1 = 1;
    function_100003ed0();
    int64_t v2; // 0x100003f0c
    _printf("%lld\n", v2);
    int32_t v3 = v1 + 1; // 0x100003f70
    while (v1 == 4 || v1 < 4 != (3 - v1 & v3) < 0) {
        // 0x100003f50
        v1 = v3;
        function_100003ed0();
        _printf("%lld\n", v2);
        v3 = v1 + 1;
    }
    // 0x100003f7c
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>

#define die(msg) fprintf(stderr, msg"\n"), abort();
double get(const char *s, const char *e, char **new_e)
{
	const char *t;
	double a, b;

	for (e--; e >= s && isspace(*e); e--);
	for (t = e; t > s && !isspace(t[-1]); t--);

	if (t < s) die("underflow");

#define get2(expr) b = get(s, t, (char **)&t), a = get(s, t, (char **)&t), a = expr
	a = strtod(t, (char **)&e);
	if (e <= t) {
		if	(t[0] == '+') get2(a + b);
		else if (t[0] == '-') get2(a - b);
		else if (t[0] == '*') get2(a * b);
		else if (t[0] == '/') get2(a / b);
		else if (t[0] == '^') get2(pow(a, b));
		else {
			fprintf(stderr, "'%c': ", t[0]);
			die("unknown token");
		}
	}
#undef get2

	*(const char **)new_e = t;
	return a;
}

double rpn(const char *s)
{
	const char *e = s + strlen(s);
	double v = get(s, e, (char**)&e);

	while (e > s && isspace(e[-1])) e--;
	if (e == s) return v;

	fprintf(stderr, "\"%.*s\": ", e - s, s);
	die("front garbage");
}

int main(void)
{
	printf("%g\n", rpn("3 4 2 * 1 5 - 2 3 ^ ^ / +"));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a28(void);
int64_t function_100003da0(void);
void function_100003efc(void);
int32_t function_100003f08(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f14(int32_t c);
float64_t function_100003f20(float64_t a1, float64_t a2);
int32_t function_100003f2c(char * format, ...);
int32_t function_100003f38(char * s);
float64_t function_100003f44(char * nptr, char ** endptr);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void _abort(void);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _isspace(int32_t a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);
float64_t _strtod(char * a1, char ** a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a28 - 0x100003da0
int64_t function_100003a28(void) {
    // 0x100003a28
    int64_t v1; // 0x100003a28
    uint64_t v2 = v1;
    int64_t v3 = v1 - 1;
    char * v4 = (char *)v3;
    char * v5 = v4;
    char * v6 = v4; // 0x100003a68
    char * v7 = v4; // 0x100003a68
    int64_t v8 = v3; // 0x100003a68
    if (v2 <= v3) {
        while (_isspace((int32_t)*v6) != 0) {
            int64_t v9 = (int64_t)v5 - 1;
            v6 = (char *)v9;
            v5 = v6;
            v7 = v6;
            v8 = v9;
            if (v2 > v9) {
                goto lab_0x100003aac;
            }
        }
        // 0x100003a8c
        v7 = v5;
        v8 = (int64_t)v5;
    }
  lab_0x100003aac:;
    int64_t v10 = v8;
    char * v11 = v7; // 0x100003ad0
    int64_t v12 = v10; // 0x100003ad0
    char * v13 = v7; // 0x100003ad0
    if (v2 != v10 && v2 <= v10) {
        v13 = v11;
        while (_isspace((int32_t)*(char *)(v12 - 1)) == 0) {
            int64_t v14 = (int64_t)v11 - 1; // 0x100003b08
            char * v15 = (char *)v14;
            v11 = v15;
            v12 = v14;
            v13 = v15;
            if (v2 == v14 || v2 > v14) {
                // break -> 0x100003b14
                break;
            }
            v13 = v11;
        }
    }
    char * v16 = v13; // 0x100003d84
    uint64_t v17 = (int64_t)v16;
    if (v2 > v17) {
        // 0x100003b2c
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "underflow\n");
        _abort();
    }
    float64_t v18 = _strtod(v16, &v5); // 0x100003b50
    char * v19 = v5; // 0x100003b58
    int64_t result = v18; // 0x100003b68
    if (v19 >= v16 != v19 != v16) {
        // 0x100003b70
        switch (*v16) {
            case 43: {
                // 0x100003b88
                function_100003a28();
                result = function_100003a28();
                // break -> 0x100003d84
                break;
            }
            case 45: {
                // 0x100003be0
                function_100003a28();
                result = function_100003a28();
                // break -> 0x100003d84
                break;
            }
            case 42: {
                // 0x100003c38
                function_100003a28();
                result = function_100003a28();
                // break -> 0x100003d84
                break;
            }
            case 47: {
                // 0x100003c90
                function_100003a28();
                result = function_100003a28();
                // break -> 0x100003d84
                break;
            }
            case 94: {
                // 0x100003ce8
                function_100003a28();
                function_100003a28();
                int128_t v20; // 0x100003a28
                result = _pow(v18, (float64_t)(int64_t)v20);
                // break -> 0x100003d84
                break;
            }
            default: {
                int64_t * v21 = (int64_t *)*(int64_t *)0x100004000; // 0x100003d34
                _fprintf((struct _IO_FILE *)*v21, "'%c': ", (char)v1);
                _fprintf((struct _IO_FILE *)*v21, "unknown token\n");
                _abort();
                result = &g1;
                // break -> 0x100003d84
                break;
            }
        }
    }
    // 0x100003d84
    *(int64_t *)v1 = v17;
    return result;
}

// Address range: 0x100003da0 - 0x100003eb4
int64_t function_100003da0(void) {
    // 0x100003da0
    int64_t v1; // 0x100003da0
    uint64_t v2 = v1;
    int64_t v3 = v2 + (int64_t)_strlen((char *)v2); // bp-32, 0x100003dcc
    int64_t v4 = v3; // 0x100003de4
    int64_t v5 = v4; // 0x100003dfc
    int64_t result = function_100003a28(); // 0x100003dfc
    if (v4 != v2 && v4 >= v2) {
        int32_t v6 = _isspace((int32_t)*(char *)(v4 - 1)); // 0x100003e0c
        v5 = v3;
        result = 0;
        while (v6 != 0) {
            int64_t v7 = v3 - 1; // 0x100003e30
            v3 = v7;
            if (v7 == v2 || v7 < v2) {
                // 0x100003de4
                v5 = v7;
                result = v6;
                goto lab_0x100003e3c;
            }
            v6 = _isspace((int32_t)*(char *)(v7 - 1));
            v5 = v3;
            result = 0;
        }
    }
    goto lab_0x100003e3c;
  lab_0x100003e3c:
    // 0x100003e3c
    if (v5 == v2) {
        // 0x100003e54
        return result;
    }
    int64_t * v8 = (int64_t *)*(int64_t *)0x100004000; // 0x100003e70
    int64_t v9 = *v8; // 0x100003e70
    _fprintf((struct _IO_FILE *)v9, "\"%.*s\": ", (int64_t)&v3, (char *)v1);
    _fprintf((struct _IO_FILE *)*v8, "front garbage\n");
    _abort();
    return &g1;
}

// Address range: 0x100003eb4 - 0x100003efc
int64_t entry_point(void) {
    // 0x100003eb4
    function_100003da0();
    int128_t v1; // 0x100003eb4
    _printf("%g\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
void function_100003efc(void) {
    // 0x100003efc
    _abort();
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f08
    return _fprintf(stream, format);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(int32_t c) {
    // 0x100003f14
    return _isspace(c);
}

// Address range: 0x100003f20 - 0x100003f2c
float64_t function_100003f20(float64_t a1, float64_t a2) {
    // 0x100003f20
    return _pow(a1, a2);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * s) {
    // 0x100003f38
    return _strlen(s);
}

// Address range: 0x100003f44 - 0x100003f50
float64_t function_100003f44(char * nptr, char ** endptr) {
    // 0x100003f44
    return _strtod(nptr, endptr);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>

int icmp(const void *a, const void *b)
{
	return *(const int*)a < *(const int*)b ? -1 : *(const int*)a > *(const int*)b;
}

void leaf_plot(int *x, int len)
{
	int i, j, d;

	qsort(x, len, sizeof(int), icmp);

	i = x[0] / 10 - 1;
	for (j = 0; j < len; j++) {
		d = x[j] / 10;
		while (d > i) printf("%s%3d |", j ? "\n" : "", ++i);
		printf(" %d", x[j] % 10);
	}
}

int main()
{
	int data[] = {
	  12, 127,  28,  42,  39, 113,  42,  18,  44, 118,  44,  37, 113, 124,
	  37,  48, 127,  36,  29,  31, 125, 139, 131, 115, 105, 132, 104, 123,
	  35, 113, 122,  42, 117, 119,  58, 109,  23, 105,  63,  27,  44, 105,
	  99,  41, 128, 121, 116, 125,  32,  61,  37, 127,  29, 113, 121,  58,
	 114, 126,  53, 114,  96,  25, 109,   7,  31, 141,  46,  13,  27,  43,
	 117, 116,  27,   7,  68,  40,  31, 115, 124,  42, 128,  52,  71, 118,
	 117,  38,  27, 106,  33, 117, 116, 111,  40, 119,  47, 105,  57, 122,
	 109, 124, 115,  43, 120,  43,  27,  27,  18,  28,  48, 125, 107, 114,
	  34, 133,  45, 120,  30, 127,  31, 116, 146 };

	leaf_plot(data, sizeof(data)/sizeof(data[0]));

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b4c(void);
int64_t function_100003bb4(void);
int64_t function_100003d74(int64_t a1);
int64_t * function_100003d80(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003d8c(char * format, ...);
void function_100003d98(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

int64_t g1 = 0x7f0000000c; // 0x100003db4
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x100003b4c - 0x100003bb4
int64_t function_100003b4c(void) {
    // 0x100003b4c
    int64_t v1; // 0x100003b4c
    int32_t v2 = v1;
    int32_t v3 = v2 - (int32_t)v1; // 0x100003b68
    int64_t result = v3 < 0 == ((v3 ^ v2) & (int32_t)(v1 ^ v1)) < 0 ? (int64_t)(v3 != 0) : 0xffffffff;
    return result;
}

// Address range: 0x100003bb4 - 0x100003cf4
int64_t function_100003bb4(void) {
    // 0x100003bb4
    int64_t v1; // 0x100003bb4
    int32_t v2 = v1; // 0x100003bc4
    int64_t v3 = 0x100000000 * v1 >> 32; // 0x100003bcc
    _qsort((int64_t *)v1, (int32_t)v3, 4, (int32_t (*)(int64_t *, int64_t *))0x100003b4c);
    int32_t v4 = -v2; // 0x100003c08
    if (v4 < 0 == (v4 & v2) < 0) {
        // 0x100003ce8
        return &g2;
    }
    int32_t v5 = 0; // 0x100003cdc
    int32_t v6 = (int32_t)&g2 / 10 - 1;
    int32_t v7 = *(int32_t *)(4 * (int64_t)v5 + v1) / 10; // 0x100003c28
    int32_t v8 = v7 - v6; // 0x100003c3c
    int32_t v9 = v6; // 0x100003c44
    int32_t v10 = v6; // 0x100003c44
    int32_t v11; // 0x100003c78
    int32_t v12; // 0x100003c3c
    if (v8 != 0 && v8 < 0 == ((v8 ^ v7) & (v7 ^ v6)) < 0) {
        v11 = v9 + 1;
        _printf("%s%3d |", (char *)v3, 4);
        v12 = v7 - v11;
        v9 = v11;
        v10 = v11;
        while (v12 != 0 && v12 < 0 == ((v12 ^ v7) & (v11 ^ v7)) < 0) {
            // 0x100003c4c
            v11 = v9 + 1;
            _printf("%s%3d |", (char *)v3, 4);
            v12 = v7 - v11;
            v9 = v11;
            v10 = v11;
        }
    }
    int32_t result = _printf(" %d", v3); // 0x100003cd0
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003c18
        v6 = v10;
        v7 = *(int32_t *)(4 * (int64_t)v5 + v1) / 10;
        v8 = v7 - v6;
        v9 = v6;
        v10 = v6;
        if (v8 != 0 && v8 < 0 == ((v8 ^ v7) & (v7 ^ v6)) < 0) {
            v11 = v9 + 1;
            _printf("%s%3d |", (char *)v3, 4);
            v12 = v7 - v11;
            v9 = v11;
            v10 = v11;
            while (v12 != 0 && v12 < 0 == ((v12 ^ v7) & (v11 ^ v7)) < 0) {
                // 0x100003c4c
                v11 = v9 + 1;
                _printf("%s%3d |", (char *)v3, 4);
                v12 = v7 - v11;
                v9 = v11;
                v10 = v11;
            }
        }
        // 0x100003ca0
        result = _printf(" %d", v3);
        v5++;
    }
    // 0x100003ce8
    return result;
}

// Address range: 0x100003cf4 - 0x100003d74
int64_t entry_point(void) {
    // 0x100003cf4
    int64_t v1; // bp-516, 0x100003cf4
    _memcpy(&v1, &g1, 484);
    int64_t v2 = function_100003bb4(); // 0x100003d38
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d48
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d5c
        ___stack_chk_fail(v2);
    }
    // 0x100003d60
    return 0;
}

// Address range: 0x100003d74 - 0x100003d80
int64_t function_100003d74(int64_t a1) {
    // 0x100003d74
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d80 - 0x100003d8c
int64_t * function_100003d80(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003d80
    return _memcpy(dest, src, n);
}

// Address range: 0x100003d8c - 0x100003d98
int32_t function_100003d8c(char * format, ...) {
    // 0x100003d8c
    return _printf(format);
}

// Address range: 0x100003d98 - 0x100003da4
void function_100003d98(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003d98
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <sys/ioctl.h>	/* ioctl, TIOCGWINSZ */
#include <err.h>	/* err */
#include <fcntl.h>	/* open */
#include <stdio.h>	/* printf */
#include <unistd.h>	/* close */

int
main()
{
	struct winsize ws;
	int fd;

	/* Open the controlling terminal. */
	fd = open("/dev/tty", O_RDWR);
	if (fd < 0)
		err(1, "/dev/tty");

	/* Get window size of terminal. */
	if (ioctl(fd, TIOCGWINSZ, &ws) < 0)
		err(1, "/dev/tty");

	printf("%d rows by %d columns\n", ws.ws_row, ws.ws_col);
	printf("(%d by %d pixels)\n", ws.ws_xpixel, ws.ws_ypixel);

	close(fd);	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <windows.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f38(int32_t fd);
void function_100003f44(int32_t status, char * format, ...);
int32_t function_100003f50(int32_t fd, int32_t request, ...);
int32_t function_100003f5c(char * file, int32_t oflag, ...);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _ioctl(int32_t a1, int32_t a2, ...);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e4c - 0x100003f38
int64_t entry_point(void) {
    int32_t v1 = _open("/dev/tty", 2); // 0x100003e68
    if (v1 < 0) {
        // 0x100003e84
        _err(1, "/dev/tty");
    }
    int64_t v2 = 0x40087468; // 0x100003eb8
    if (_ioctl(v1, 0x40087468) < 0) {
        // 0x100003ec0
        _err(1, "/dev/tty");
        v2 = (int64_t)"/dev/tty";
    }
    // 0x100003ed0
    int64_t v3; // 0x100003e4c
    _printf("%d rows by %d columns\n", v2, v3);
    _printf("(%d by %d pixels)\n", v2, v3);
    _close(v1);
    return 0;
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(int32_t fd) {
    // 0x100003f38
    return _close(fd);
}

// Address range: 0x100003f44 - 0x100003f50
void function_100003f44(int32_t status, char * format, ...) {
    // 0x100003f44
    _err(status, format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int32_t fd, int32_t request, ...) {
    // 0x100003f50
    return _ioctl(fd, request);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * file, int32_t oflag, ...) {
    // 0x100003f5c
    return _open(file, oflag);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <math.h>

int main(int argc, char **argv) {

   float x[4] = {1,2,3,1e11}, y[4];
   int i = 0;
   FILE *filePtr;

   filePtr = fopen("floatArray","w");

   for (i = 0; i < 4; i++) {
      y[i] = sqrt(x[i]);
      fprintf(filePtr, "%.3g\t%.5g\n", x[i], y[i]);
   }

   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f5c(void);
struct _IO_FILE * function_100003f68(char * filename, char * modes);
int32_t function_100003f74(struct _IO_FILE * stream, char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.0000005L; // 0x100003f80

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e4c - 0x100003f5c
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e60
    float128_t v2 = g1; // bp-48, 0x100003e80
    struct _IO_FILE * v3 = _fopen("floatArray", "w"); // 0x100003e98
    for (int64_t i = 0; i < 4; i++) {
        int64_t v4 = 4 * i; // 0x100003ec4
        float64_t v5 = sqrt((float64_t)*(float32_t *)(v4 + (int64_t)&v2)); // 0x100003ecc
        int64_t v6; // bp-64, 0x100003e4c
        *(float32_t *)(v4 + (int64_t)&v6) = (float32_t)v5;
        int128_t v7; // 0x100003e4c
        _fprintf(v3, "%.3g\t%.5g\n", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
    }
    // 0x100003f28
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f48
        ___stack_chk_fail();
    }
    // 0x100003f4c
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(void) {
    // 0x100003f5c
    return ___stack_chk_fail();
}

// Address range: 0x100003f68 - 0x100003f74
struct _IO_FILE * function_100003f68(char * filename, char * modes) {
    // 0x100003f68
    return _fopen(filename, modes);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f74
    return _fprintf(stream, format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv) //not sure if argv counts as input stream... certainly it is brought here via input stream.
{
   printf("%d\n", atoi(*(argv+1)) + atoi(*(argv+2)));
   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * nptr);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f1c - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f1c
    int64_t v1; // 0x100003f1c
    _atoi((char *)*(int64_t *)(v1 + 8));
    _atoi((char *)*(int64_t *)(v1 + 16));
    _printf("%d\n", v1);
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * nptr) {
    // 0x100003f8c
    return _atoi(nptr);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

typedef unsigned long long u64;

#define FIB_INVALID (~(u64)0)

u64 fib[] = {
	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
	2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
	317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465,
	14930352, 24157817, 39088169, 63245986, 102334155, 165580141,
	267914296, 433494437, 701408733, 1134903170, 1836311903,
	2971215073ULL, 4807526976ULL, 7778742049ULL, 12586269025ULL,
	20365011074ULL, 32951280099ULL, 53316291173ULL, 86267571272ULL,
	139583862445ULL, 225851433717ULL, 365435296162ULL, 591286729879ULL,
	956722026041ULL, 1548008755920ULL, 2504730781961ULL, 4052739537881ULL,
	6557470319842ULL, 10610209857723ULL, 17167680177565ULL,

	27777890035288ULL // this 65-th one is for range check
};

u64 fibbinary(u64 n)
{
	if (n >= fib[64]) return FIB_INVALID;

	u64 ret = 0;
	int i;
	for (i = 64; i--; )
		if (n >= fib[i]) {
			ret |= 1ULL << i;
			n -= fib[i];
		}

	return ret;
}

void bprint(u64 n, int width)
{
	if (width > 64) width = 64;

	u64 b;
	for (b = 1ULL << (width - 1); b; b >>= 1)
		putchar(b == 1 && !n
			? '0'
			: b > n	? ' '
				: b & n ? '1' : '0');
	putchar('\n');
}

int main(void)
{
	int i;

	for (i = 0; i <= 20; i++)
		printf("%2d:", i), bprint(fibbinary(i), 8);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d08(void);
int64_t function_100003de4(void);
int32_t function_100003f80(char * format, ...);
int32_t function_100003f8c(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 1; // 0x100008000
int64_t g2 = 0x19438b44a658; // 0x100008200

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d08 - 0x100003de4
int64_t function_100003d08(void) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    if ((uint64_t)v1 >= g2) {
        // 0x100003dd8
        return -1;
    }
    int64_t v2 = 0;
    uint64_t v3 = 63;
    uint64_t v4 = *(int64_t *)(8 * v3 + (int64_t)&g1); // 0x100003d78
    int64_t v5 = v2; // 0x100003d84
    int64_t v6; // 0x100003d08
    int64_t v7 = v6; // 0x100003d84
    if (v6 >= v4) {
        // 0x100003d8c
        v5 = v2 | 1 << v3;
        v7 = v6 - v4;
    }
    int64_t result = v5;
    int64_t v8 = v3 - 1; // 0x100003d60
    while (v3 != 0) {
        // 0x100003d68
        v2 = result;
        int64_t v9 = v7;
        v3 = v8;
        v4 = *(int64_t *)(8 * v3 + (int64_t)&g1);
        v5 = v2;
        v7 = v9;
        if (v9 >= v4) {
            // 0x100003d8c
            v5 = v2 | 1 << v3;
            v7 = v9 - v4;
        }
        // 0x100003dc8
        result = v5;
        v8 = v3 - 1;
    }
    // 0x100003dd8
    return result;
}

// Address range: 0x100003de4 - 0x100003f04
int64_t function_100003de4(void) {
    // 0x100003de4
    int64_t v1; // 0x100003de4
    uint64_t v2 = v1;
    int32_t v3 = v1; // 0x100003df4
    int32_t v4 = v3 - 64; // 0x100003dfc
    int64_t v5 = v4 == 0 | v4 < 0 != (63 - v3 & v3) < 0 ? 1 << (v1 + 0xffffffff & 0xffffffff) : -0x8000000000000000; // 0x100003e24
    uint64_t v6 = v5;
    while (v2 == 0 != (v6 == 1)) {
        int32_t v7 = 32; // 0x100003e88
        if (v6 == v2 || v6 < v2) {
            // 0x100003e9c
            v7 = (v6 & v2) == 0 ? 48 : 49;
        }
        // 0x100003ed4
        _putchar(v7);
        if (v6 < 2) {
            // 0x100003ef0
            return _putchar(10);
        }
        v6 /= 2;
    }
    // 0x100003ed4
    _putchar(48);
    // 0x100003ef0
    return _putchar(10);
}

// Address range: 0x100003f04 - 0x100003f80
int64_t entry_point(void) {
    int32_t v1 = 0;
    int64_t v2; // 0x100003f04
    _printf("%2d:", v2);
    function_100003d08();
    function_100003de4();
    int32_t v3 = v1 + 1; // 0x100003f64
    int32_t v4 = v1 - 19; // 0x100003f20
    v2 = 8;
    while (v4 == 0 || v4 < 0 != (18 - v1 & v3) < 0) {
        // 0x100003f30
        v1 = v3;
        _printf("%2d:", v2);
        function_100003d08();
        function_100003de4();
        v3 = v1 + 1;
        v4 = v1 - 19;
        v2 = 8;
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t c) {
    // 0x100003f8c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>

const char *ca = "/*", *cb = "*/";
int al = 2, bl = 2;

char *loadfile(const char *fn) {
    FILE *f = fopen(fn, "rb");
    int l;
    char *s;

    if (f != NULL) {
	fseek(f, 0, SEEK_END);
	l = ftell(f);
	s = malloc(l+1);
	rewind(f);
	if (s)
	    fread(s, 1, l, f);
	fclose(f);
    }
    return s;
}

void stripcomments(char *s) {
    char *a, *b;
    int len = strlen(s) + 1;

    while ((a = strstr(s, ca)) != NULL) {
	b = strstr(a+al, cb);
	if (b == NULL)
	    break;
	b += bl;
	memmove(a, b, len-(b-a));
    }
}

int main(int argc, char **argv) {
    const char *fn = "input.txt";
    char *s;

    if (argc >= 2)
	fn = argv[1];
    s = loadfile(fn);
    if (argc == 4) {
	al = strlen(ca = argv[2]);
	bl = strlen(cb = argv[3]);
    }
    stripcomments(s);
    puts(s);
    free(s);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca4(void);
int64_t function_100003d64(void);
int64_t function_100003f04(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003f10(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f1c(char * filename, char * modes);
int32_t function_100003f28(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003f34(int64_t * ptr);
int32_t function_100003f40(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003f4c(struct _IO_FILE * stream);
int64_t * function_100003f58(int32_t size);
int32_t function_100003f64(char * s);
void function_100003f70(struct _IO_FILE * stream);
int32_t function_100003f7c(char * s);
char * function_100003f88(char * haystack, char * needle);

// --------------------- Global Variables ---------------------

char * g1 = "\x94?"; // 0x100008000
char * g2 = "\x97?"; // 0x100008008
int32_t g3 = 2; // 0x100008010
int64_t g4; // 0x100008014

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _ftell(struct _IO_FILE * a1);
int64_t * _malloc(int32_t a1);
int32_t _puts(char * a1);
void _rewind(struct _IO_FILE * a1);
int32_t _strlen(char * a1);
char * _strstr(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca4 - 0x100003d64
int64_t function_100003ca4(void) {
    // 0x100003ca4
    int64_t v1; // 0x100003ca4
    struct _IO_FILE * v2 = _fopen((char *)v1, "rb"); // 0x100003cc0
    if (v2 == NULL) {
        // 0x100003d54
        int64_t result; // 0x100003ca4
        return result;
    }
    // 0x100003cdc
    _fseek(v2, 0, 2);
    int32_t v3 = _ftell(v2); // 0x100003cf0
    int64_t * v4 = _malloc(v3 + 1); // 0x100003d0c
    _rewind(v2);
    if (v4 != NULL) {
        // 0x100003d30
        _fread(v4, 1, v3, v2);
    }
    // 0x100003d48
    _fclose(v2);
    // 0x100003d54
    return (int64_t)v4;
}

// Address range: 0x100003d64 - 0x100003e30
int64_t function_100003d64(void) {
    // 0x100003d64
    int64_t v1; // 0x100003d64
    char * v2 = (char *)v1; // 0x100003d70
    int32_t v3 = _strlen(v2); // 0x100003d78
    char * v4 = _strstr(v2, g1); // 0x100003d94
    int64_t result = (int64_t)v4; // 0x100003d94
    if (v4 == NULL) {
        // 0x100003e24
        return result;
    }
    int64_t v5 = result;
    char * v6 = _strstr((char *)(v5 + (int64_t)g3), g2); // 0x100003dc8
    while (v6 != NULL) {
        int32_t v7 = *(int32_t *)((int64_t)&g1 + 20); // 0x100003dec
        int64_t v8 = (int64_t)v7 + (int64_t)v6; // 0x100003df4
        ___memmove_chk(v5, v8, v5 + (int64_t)(v3 + 1) - v8, -1);
        char * v9 = _strstr(v2, g1); // 0x100003d94
        if (v9 == NULL) {
            // break -> 0x100003e24
            break;
        }
        v5 = (int64_t)v9;
        v6 = _strstr((char *)(v5 + (int64_t)g3), g2);
    }
    // 0x100003e24
    return 0;
}

// Address range: 0x100003e30 - 0x100003f04
int64_t entry_point(void) {
    int64_t v1 = function_100003ca4(); // 0x100003e7c
    int64_t v2; // 0x100003e30
    if ((int32_t)v2 == 4) {
        int64_t v3 = *(int64_t *)(v2 + 16); // 0x100003e9c
        *(int64_t *)&g1 = v3;
        g3 = _strlen((char *)v3);
        char * v4 = (char *)*(int64_t *)(v2 + 24); // 0x100003ec4
        g2 = v4;
        *(int32_t *)&g4 = _strlen(v4);
    }
    // 0x100003edc
    function_100003d64();
    _puts((char *)v1);
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f04 - 0x100003f10
int64_t function_100003f04(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f04
    return ___memmove_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(struct _IO_FILE * stream) {
    // 0x100003f10
    return _fclose(stream);
}

// Address range: 0x100003f1c - 0x100003f28
struct _IO_FILE * function_100003f1c(char * filename, char * modes) {
    // 0x100003f1c
    return _fopen(filename, modes);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f28
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003f40
    return _fseek(stream, off, whence);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(struct _IO_FILE * stream) {
    // 0x100003f4c
    return _ftell(stream);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int32_t size) {
    // 0x100003f58
    return _malloc(size);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _puts(s);
}

// Address range: 0x100003f70 - 0x100003f7c
void function_100003f70(struct _IO_FILE * stream) {
    // 0x100003f70
    _rewind(stream);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * s) {
    // 0x100003f7c
    return _strlen(s);
}

// Address range: 0x100003f88 - 0x100003f94
char * function_100003f88(char * haystack, char * needle) {
    // 0x100003f88
    return _strstr(haystack, needle);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include<stdio.h>

#define start main()

int start
{
	printf("Hello World !");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f58 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f58
    _printf("Hello World !");
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct object *BaseObj;
typedef struct sclass *Class;
typedef void (*CloneFctn)(BaseObj s, BaseObj clo);
typedef const char * (*SpeakFctn)(BaseObj s);
typedef void (*DestroyFctn)(BaseObj s);

typedef struct sclass {
    size_t csize;		/* size of the class instance */
    const char  *cname;		/* name of the class */
    Class  parent;		/* parent class */

    CloneFctn clone;		/* clone function */
    SpeakFctn speak;		/* speak function */
    DestroyFctn del;		/* delete the object */
} sClass;

typedef struct object {
    Class class;
} SObject;

static
BaseObj obj_copy( BaseObj s, Class c )
{
    BaseObj clo;
    if (c->parent)
        clo = obj_copy( s, c->parent);
    else
        clo = malloc( s->class->csize );

    if (clo)
        c->clone( s, clo );
    return clo;
}

static
void obj_del( BaseObj s, Class c )
{
    if (c->del)
        c->del(s);
    if (c->parent)
        obj_del( s, c->parent);
    else
        free(s);
}

BaseObj ObjClone( BaseObj s )
{ return obj_copy( s, s->class ); }

const char * ObjSpeak( BaseObj s )
{
    return s->class->speak(s);
}

void ObjDestroy( BaseObj s )
{ if (s) obj_del( s, s->class ); }

/* * * * * * */
static
void baseClone( BaseObj s, BaseObj clone)
{
    clone->class = s->class;
}

static
const char *baseSpeak(BaseObj s)
{
    return "Hello, I'm base object";
}

sClass boc = { sizeof(SObject), "BaseObj", NULL,
    &baseClone, &baseSpeak, NULL };
Class BaseObjClass = &boc;

/* * * * * * */
/* Dog - a derived class */

typedef struct sDogPart {
    double weight;
    char color[32];
    char name[24];
} DogPart;

typedef struct sDog *Dog;

struct sDog {
    Class   class;		// parent structure
    DogPart dog;
};

static
void dogClone( BaseObj s, BaseObj c)
{
    Dog src = (Dog)s;
    Dog clone = (Dog)c;
    clone->dog = src->dog;	/* no pointers so strncpys not needed */
}

static
const char *dogSpeak( BaseObj s)
{
    Dog d = (Dog)s;
    static char  response[90];
    sprintf(response, "woof! woof! My name is %s. I'm a %s %s",
            d->dog.name, d->dog.color, d->class->cname);
    return response;
}


sClass dogc = { sizeof(struct sDog), "Dog", &boc,
    &dogClone, &dogSpeak, NULL };
Class DogClass = &dogc;

BaseObj NewDog( const char *name, const char *color, double weight )
{
    Dog dog = malloc(DogClass->csize);
    if (dog) {
        DogPart *dogp = &dog->dog;
        dog->class = DogClass;
        dogp->weight = weight;
        strncpy(dogp->name, name, 23);
        strncpy(dogp->color, color, 31);
    }
    return (BaseObj)dog;
}

/* * * * * * * * * */
/* Ferret - a derived class */

typedef struct sFerretPart {
    char color[32];
    char name[24];
    int  age;
} FerretPart;

typedef struct sFerret *Ferret;

struct sFerret {
    Class   class;		// parent structure
    FerretPart ferret;
};

static
void ferretClone( BaseObj s, BaseObj c)
{
    Ferret src = (Ferret)s;
    Ferret clone = (Ferret)c;
    clone->ferret = src->ferret;  /* no pointers so strncpys not needed */
}

static
const char *ferretSpeak(BaseObj s)
{
    Ferret f = (Ferret)s;
    static char  response[90];
    sprintf(response, "My name is %s. I'm a %d mo. old %s wiley %s",
            f->ferret.name, f->ferret.age, f->ferret.color,
            f->class->cname);
    return response;
}

sClass ferretc = { sizeof(struct sFerret), "Ferret", &boc,
    &ferretClone, &ferretSpeak, NULL };
Class FerretClass = &ferretc;

BaseObj NewFerret( const char *name, const char *color, int age )
{
    Ferret ferret = malloc(FerretClass->csize);
    if (ferret) {
        FerretPart *ferretp = &(ferret->ferret);
        ferret->class = FerretClass;
        strncpy(ferretp->name, name, 23);
        strncpy(ferretp->color, color, 31);
        ferretp->age = age;
    }
    return (BaseObj)ferret;
}

/* * Now you really understand why Bjarne created C++ * */

int main()
{
    BaseObj  o1;
    BaseObj  kara = NewFerret( "Kara", "grey", 15 );
    BaseObj  bruce = NewDog("Bruce", "yellow", 85.0 );
    printf("Ok created things\n");

    o1 = ObjClone(kara );
    printf("Karol says %s\n", ObjSpeak(o1));
    printf("Kara says %s\n", ObjSpeak(kara));
    ObjDestroy(o1);

    o1 = ObjClone(bruce );
    strncpy(((Dog)o1)->dog.name, "Donald", 23);
    printf("Don says %s\n", ObjSpeak(o1));
    printf("Bruce says %s\n", ObjSpeak(bruce));
    ObjDestroy(o1);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003870(int64_t a1);
int64_t function_10000389c(void);
int64_t function_100003934(void);
int64_t function_100003958(int64_t a1, int64_t a2);
int64_t function_100003964(void);
int64_t function_1000039a8(void);
int64_t function_100003a2c(void);
int64_t function_100003a50(void);
int64_t function_100003a68(void);
int64_t function_100003ab0(void);
int64_t function_100003b24(void);
int64_t function_100003bd0(void);
int64_t function_100003c18(void);
int64_t function_100003c9c(void);
int64_t function_100003e68(void);
int64_t function_100003e74(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003e80(int64_t * ptr);
int64_t * function_100003e8c(int32_t size);
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ea4(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x20000000008038; // 0x100008068
int64_t g2 = 0x8070; // 0x1000080a0
int64_t g3 = 0; // 0x1000080a8
int64_t g4 = 0; // 0x100008102
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(void);
int64_t ___strncpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003870 - 0x10000389c
int64_t function_100003870(int64_t a1) {
    // 0x100003870
    return function_10000389c();
}

// Address range: 0x10000389c - 0x100003934
int64_t function_10000389c(void) {
    // 0x10000389c
    int64_t v1; // 0x10000389c
    int64_t v2; // 0x10000389c
    if (*(int64_t *)(v2 + 16) == 0) {
        // 0x1000038e0
        v1 = (int64_t)_malloc((int32_t)v2);
    } else {
        // 0x1000038c8
        v1 = function_10000389c();
    }
    // 0x1000038f8
    return v1 == 0 ? 0 : v2;
}

// Address range: 0x100003934 - 0x100003958
int64_t function_100003934(void) {
    // 0x100003934
    int64_t result; // 0x100003934
    return result;
}

// Address range: 0x100003958 - 0x100003964
int64_t function_100003958(int64_t a1, int64_t a2) {
    // 0x100003958
    int64_t result; // 0x100003958
    return result;
}

// Address range: 0x100003964 - 0x1000039a8
int64_t function_100003964(void) {
    int64_t result = 0; // 0x100003980
    int64_t v1; // 0x100003964
    if (v1 != 0) {
        // 0x100003988
        result = function_1000039a8();
    }
    // 0x10000399c
    return result;
}

// Address range: 0x1000039a8 - 0x100003a2c
int64_t function_1000039a8(void) {
    // 0x1000039a8
    int64_t result; // 0x1000039a8
    int64_t v1; // 0x1000039a8
    if (*(int64_t *)(v1 + 40) != 0) {
        // 0x1000039d4
        return result;
    }
    // 0x1000039e8
    if (*(int64_t *)(v1 + 16) == 0) {
        // 0x100003a14
        _free((int64_t *)v1);
        result = &g5;
    } else {
        // 0x100003a00
        result = function_1000039a8();
    }
    // 0x1000039d4
    return result;
}

// Address range: 0x100003a2c - 0x100003a50
int64_t function_100003a2c(void) {
    // 0x100003a2c
    int64_t result; // 0x100003a2c
    return result;
}

// Address range: 0x100003a50 - 0x100003a68
int64_t function_100003a50(void) {
    // 0x100003a50
    return (int64_t)"Hello, I'm base object";
}

// Address range: 0x100003a68 - 0x100003ab0
int64_t function_100003a68(void) {
    // 0x100003a68
    int64_t v1; // 0x100003a68
    return (int64_t)_memcpy((int64_t *)(v1 + 8), (int64_t *)(v1 + 8), 64);
}

// Address range: 0x100003ab0 - 0x100003b24
int64_t function_100003ab0(void) {
    // 0x100003ab0
    ___sprintf_chk();
    return &g3;
}

// Address range: 0x100003b24 - 0x100003bd0
int64_t function_100003b24(void) {
    int64_t * v1 = _malloc((int32_t)*(int64_t *)g1); // 0x100003b48
    int64_t result = (int64_t)v1; // 0x100003b48
    if (v1 != NULL) {
        // 0x100003b64
        *v1 = g1;
        float64_t v2; // 0x100003b24
        *(int64_t *)(result + 8) = (int64_t)v2;
        int64_t v3; // 0x100003b24
        ___strncpy_chk(result + 48, v3, 23, -1);
        ___strncpy_chk(result + 16, v3, 31, 32);
    }
    // 0x100003bc0
    return result;
}

// Address range: 0x100003bd0 - 0x100003c18
int64_t function_100003bd0(void) {
    // 0x100003bd0
    int64_t v1; // 0x100003bd0
    return (int64_t)_memcpy((int64_t *)(v1 + 8), (int64_t *)(v1 + 8), 60);
}

// Address range: 0x100003c18 - 0x100003c9c
int64_t function_100003c18(void) {
    // 0x100003c18
    ___sprintf_chk();
    return &g4;
}

// Address range: 0x100003c9c - 0x100003d44
int64_t function_100003c9c(void) {
    int64_t * v1 = _malloc((int32_t)*(int64_t *)g2); // 0x100003cc0
    int64_t result = (int64_t)v1; // 0x100003cc0
    if (v1 != NULL) {
        // 0x100003cdc
        *v1 = g2;
        int64_t v2; // 0x100003c9c
        ___strncpy_chk(result + 40, v2, 23, 24);
        ___strncpy_chk(result + 8, v2, 31, 32);
        *(int32_t *)(result + 64) = (int32_t)v2;
    }
    // 0x100003d34
    return result;
}

// Address range: 0x100003d44 - 0x100003e68
int64_t entry_point(void) {
    int64_t v1 = function_100003c9c(); // 0x100003d70
    int64_t v2 = function_100003b24(); // 0x100003d90
    _printf("Ok created things\n");
    function_100003870(v1);
    function_100003934();
    _printf("Karol says %s\n", "yellow");
    function_100003934();
    _printf("Kara says %s\n", "yellow");
    function_100003964();
    ___strncpy_chk(function_100003870(v2) + 48, (int64_t)"Donald", 23, -1);
    function_100003934();
    _printf("Don says %s\n", "Donald");
    function_100003934();
    _printf("Bruce says %s\n", "Donald");
    function_100003964();
    return 0;
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(void) {
    // 0x100003e68
    return ___sprintf_chk();
}

// Address range: 0x100003e74 - 0x100003e80
int64_t function_100003e74(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e74
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e80 - 0x100003e8c
void function_100003e80(int64_t * ptr) {
    // 0x100003e80
    _free(ptr);
}

// Address range: 0x100003e8c - 0x100003e98
int64_t * function_100003e8c(int32_t size) {
    // 0x100003e8c
    return _malloc(size);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e98
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 21

`
`#include <math.h>
#include <stdio.h>

int main() {
  double pi = 4 * atan(1);
  /*Pi / 4 is 45 degrees. All answers should be the same.*/
  double radians = pi / 4;
  double degrees = 45.0;
  double temp;
  /*sine*/
  printf("%f %f\n", sin(radians), sin(degrees * pi / 180));
  /*cosine*/
  printf("%f %f\n", cos(radians), cos(degrees * pi / 180));
  /*tangent*/
  printf("%f %f\n", tan(radians), tan(degrees * pi / 180));
  /*arcsine*/
  temp = asin(sin(radians));
  printf("%f %f\n", temp, temp * 180 / pi);
  /*arccosine*/
  temp = acos(cos(radians));
  printf("%f %f\n", temp, temp * 180 / pi);
  /*arctangent*/
  temp = atan(tan(radians));
  printf("%f %f\n", temp, temp * 180 / pi);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f3c(float64_t a1);
float64_t function_100003f48(float64_t a1);
float64_t function_100003f54(float64_t a1);
float64_t function_100003f60(float64_t a1);
int32_t function_100003f6c(char * format, ...);
float64_t function_100003f78(float64_t a1);
float64_t function_100003f84(float64_t a1);

// ------- Dynamically Linked Functions Without Header --------

float64_t _acos(float64_t a1);
float64_t _asin(float64_t a1);
float64_t _atan(float64_t a1);
float64_t _cos(float64_t a1);
int32_t _printf(char * a1, ...);
float64_t _sin(float64_t a1);
float64_t _tan(float64_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d70 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003d70
    int128_t v1; // 0x100003d70
    float64_t v2 = _sin(_sin(_atan((float64_t)(int64_t)v1))); // 0x100003ddc
    _printf("%f %f\n", v2, (float64_t)(int64_t)v1);
    float64_t v3 = _cos(_cos(v2)); // 0x100003e20
    _printf("%f %f\n", v3, (float64_t)(int64_t)v1);
    float64_t v4 = _tan(_tan(v3)); // 0x100003e5c
    _printf("%f %f\n", v4, (float64_t)(int64_t)v1);
    float64_t v5 = _asin(_sin(v4)); // 0x100003e80
    _printf("%f %f\n", v5, (float64_t)(int64_t)v1);
    float64_t v6 = _acos(_cos(v5)); // 0x100003ebc
    _printf("%f %f\n", v6, (float64_t)(int64_t)v1);
    _printf("%f %f\n", _atan(_tan(v6)), (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
float64_t function_100003f3c(float64_t a1) {
    // 0x100003f3c
    return _acos(a1);
}

// Address range: 0x100003f48 - 0x100003f54
float64_t function_100003f48(float64_t a1) {
    // 0x100003f48
    return _asin(a1);
}

// Address range: 0x100003f54 - 0x100003f60
float64_t function_100003f54(float64_t a1) {
    // 0x100003f54
    return _atan(a1);
}

// Address range: 0x100003f60 - 0x100003f6c
float64_t function_100003f60(float64_t a1) {
    // 0x100003f60
    return _cos(a1);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
float64_t function_100003f78(float64_t a1) {
    // 0x100003f78
    return _sin(a1);
}

// Address range: 0x100003f84 - 0x100003f90
float64_t function_100003f84(float64_t a1) {
    // 0x100003f84
    return _tan(a1);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
  struct tm ts;
  time_t t;
  const char *d = "March 7 2009 7:30pm EST";

  strptime(d, "%B %d %Y %I:%M%p %Z", &ts);
  /* ts.tm_hour += 12; instead of t += 12*60*60
     works too. */
  t = mktime(&ts);
  t += 12*60*60;
  printf("%s", ctime(&t));

  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
char * function_100003f48(int32_t * timer);
int32_t function_100003f54(struct tm * tp);
int32_t function_100003f60(char * format, ...);
char * function_100003f6c(char * s, char * fmt, struct tm * tp);

// ------- Dynamically Linked Functions Without Header --------

char * _ctime(int32_t * a1);
int32_t _mktime(struct tm * a1);
int32_t _printf(char * a1, ...);
char * _strptime(char * a1, char * a2, struct tm * a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003ec0 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003ec0
    int64_t v1; // bp-80, 0x100003ec0
    _strptime("March 7 2009 7:30pm EST", "%B %d %Y %I:%M%p %Z", (struct tm *)&v1);
    int64_t v2 = (int64_t)_mktime((struct tm *)&v1) + 0xa8c0; // bp-88, 0x100003f1c
    _ctime((int32_t *)&v2);
    _printf("%s", "%B %d %Y %I:%M%p %Z");
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
char * function_100003f48(int32_t * timer) {
    // 0x100003f48
    return _ctime(timer);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(struct tm * tp) {
    // 0x100003f54
    return _mktime(tp);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
char * function_100003f6c(char * s, char * fmt, struct tm * tp) {
    // 0x100003f6c
    return _strptime(s, fmt, tp);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>

int i, j;

void fliprow(int **b, int sz, int n)
{
	for(i = 0; i < sz; i++)
		b[n+1][i] = !b[n+1][i];
}

void flipcol(int **b, int sz, int n)
{
	for(i = 1; i <= sz; i++)
		b[i][n] = !b[i][n];
}

void initt(int **t, int sz)
{
	for(i = 1; i <= sz; i++)
		for(j = 0; j < sz; j++)
			t[i][j] = rand()%2;
}

void initb(int **t, int **b, int sz)
{
	for(i = 1; i <= sz; i++)
		for(j = 0; j < sz; j++)
			b[i][j] = t[i][j];
	
	for(i = 1; i <= sz; i++)
		fliprow(b, sz, rand()%sz+1);
	for(i = 0; i < sz; i++)
		flipcol(b, sz, rand()%sz);
}

void printb(int **b, int sz)
{
	printf(" ");
	for(i = 0; i < sz; i++)
		printf(" %d", i);
	printf("\n");

	for(i = 1; i <= sz; i++)
	{
		printf("%d", i-1);
		for(j = 0; j < sz; j++)
			printf(" %d", b[i][j]);
		printf("\n");
	}
	
	printf("\n");
}

int eq(int **t, int **b, int sz)
{
	for(i = 1; i <= sz; i++)
		for(j = 0; j < sz; j++)
			if(b[i][j] != t[i][j])
				return 0;
	return 1;
}

void main()
{
	int sz = 3;
	int eql = 0;
	int mov = 0;
	int **t = malloc(sz*(sizeof(int)+1));
	for(i = 1; i <= sz; i++)
		t[i] = malloc(sz*sizeof(int));

	int **b = malloc(sz*(sizeof(int)+1));
	for(i = 1; i <= sz; i++)
		b[i] = malloc(sz*sizeof(int));
	char roc;
	int n;
	initt(t, sz);
	initb(t, b, sz);
	
	while(eq(t, b, sz))
		initb(t, b, sz);
	
	while(!eql)
	{
		printf("Target: \n");
		printb(t, sz);
		printf("Board: \n");
		printb(b, sz);
		printf("What to flip: ");
		scanf(" %c", &roc);
		scanf(" %d", &n);

		switch(roc)
		{
			case 'r':
				fliprow(b, sz, n);
				break;
			case 'c':
				flipcol(b, sz, n);
				break;
			default:
				perror("Please specify r or c and an number");
				break;
		}

		printf("Moves Taken: %d\n", ++mov);

		if(eq(t, b, sz))
		{
			printf("You win!\n");
			eql = 1;
		}
	}
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000350c(void);
int64_t function_1000035b4(void);
int64_t function_100003658(void);
int64_t function_10000374c(void);
int64_t function_10000394c(void);
int64_t function_100003b0c(void);
int64_t * function_100003eec(int32_t size);
void function_100003ef8(char * s);
int32_t function_100003f04(char * format, ...);
int32_t function_100003f10(void);
int32_t function_100003f1c(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int32_t * g2; // 0x100008004

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000350c - 0x1000035b4
int64_t function_10000350c(void) {
    // 0x10000350c
    int64_t result; // 0x10000350c
    int32_t v1 = result; // 0x100003514
    *(int32_t *)&g1 = 0;
    int32_t v2 = -v1; // 0x10000353c
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x1000035ac
        return result;
    }
    int64_t * v3 = (int64_t *)((8 * result + 8 & 0xfffffff8) + result); // 0x100003558
    int32_t * v4 = (int32_t *)*v3; // 0x100003568
    *v4 = (int32_t)(*v4 == 0);
    int32_t v5 = *(int32_t *)&g1 + 1; // 0x1000035a0
    *(int32_t *)&g1 = v5;
    while (v5 - v1 < 0 != ((v5 - v1 ^ v5) & (v5 ^ v1)) < 0) {
        // 0x10000354c
        v4 = (int32_t *)(4 * (int64_t)v5 + *v3);
        *v4 = (int32_t)(*v4 == 0);
        v5 = *(int32_t *)&g1 + 1;
        *(int32_t *)&g1 = v5;
    }
    // 0x1000035ac
    return result;
}

// Address range: 0x1000035b4 - 0x100003658
int64_t function_1000035b4(void) {
    // 0x1000035b4
    int64_t result; // 0x1000035b4
    int32_t v1 = result; // 0x1000035bc
    *(int32_t *)&g1 = 1;
    int32_t v2 = 1 - v1; // 0x1000035e8
    if (v2 != 0 && v2 < 0 == (v2 & v1) < 0) {
        // 0x100003650
        return result;
    }
    int64_t v3 = 0x100000000 * result >> 30; // 0x100003610
    int32_t * v4 = (int32_t *)(*(int64_t *)(8 + result) + v3); // 0x100003610
    *v4 = (int32_t)(*v4 == 0);
    int32_t v5 = *(int32_t *)&g1 + 1; // 0x100003644
    *(int32_t *)&g1 = v5;
    while (v5 - v1 == 0 || v5 - v1 < 0 != ((v5 - v1 ^ v5) & (v5 ^ v1)) < 0) {
        // 0x1000035f8
        v4 = (int32_t *)(*(int64_t *)(8 * (int64_t)v5 + result) + v3);
        *v4 = (int32_t)(*v4 == 0);
        v5 = *(int32_t *)&g1 + 1;
        *(int32_t *)&g1 = v5;
    }
    // 0x100003650
    return result;
}

// Address range: 0x100003658 - 0x10000374c
int64_t function_100003658(void) {
    // 0x100003658
    int64_t v1; // 0x100003658
    int32_t v2 = v1; // 0x100003668
    *(int32_t *)&g1 = 1;
    int32_t v3 = 1 - v2; // 0x100003690
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003740
        int64_t result; // 0x100003658
        return result;
    }
    int32_t v4 = -v2; // 0x1000036c0
    *(int32_t *)&g2 = 0;
    int32_t v5 = 1; // 0x1000036c8
    int64_t v6; // 0x100003658
    int64_t result2 = v6; // 0x1000036c8
    int64_t v7; // 0x1000036f4
    int32_t v8; // 0x100003700
    int32_t v9; // 0x100003718
    int32_t v10; // 0x1000036d0
    if (v4 < 0 != (v4 & v2) < 0) {
        v10 = _rand();
        v7 = *(int64_t *)(8 * (int64_t)*(int32_t *)&g1 + v1);
        v8 = *(int32_t *)&g2;
        *(int32_t *)(4 * (int64_t)v8 + v7) = v10 - 2 * v10 / 2;
        v9 = *(int32_t *)&g2 + 1;
        *(int32_t *)&g2 = v9;
        while (v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
            // 0x1000036d0
            v10 = _rand();
            v7 = *(int64_t *)(8 * (int64_t)*(int32_t *)&g1 + v1);
            v8 = *(int32_t *)&g2;
            *(int32_t *)(4 * (int64_t)v8 + v7) = v10 - 2 * v10 / 2;
            v9 = *(int32_t *)&g2 + 1;
            *(int32_t *)&g2 = v9;
        }
        // 0x1000036b0
        v5 = *(int32_t *)&g1;
        result2 = v10;
    }
    int32_t v11 = v5 + 1; // 0x100003734
    *(int32_t *)&g1 = v11;
    int32_t v12 = v11 - v2; // 0x100003690
    while (v12 == 0 || v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
        // 0x1000036b0
        *(int32_t *)&g2 = 0;
        v5 = v11;
        if (v4 < 0 != (v4 & v2) < 0) {
            v10 = _rand();
            v7 = *(int64_t *)(8 * (int64_t)*(int32_t *)&g1 + v1);
            v8 = *(int32_t *)&g2;
            *(int32_t *)(4 * (int64_t)v8 + v7) = v10 - 2 * v10 / 2;
            v9 = *(int32_t *)&g2 + 1;
            *(int32_t *)&g2 = v9;
            while (v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
                // 0x1000036d0
                v10 = _rand();
                v7 = *(int64_t *)(8 * (int64_t)*(int32_t *)&g1 + v1);
                v8 = *(int32_t *)&g2;
                *(int32_t *)(4 * (int64_t)v8 + v7) = v10 - 2 * v10 / 2;
                v9 = *(int32_t *)&g2 + 1;
                *(int32_t *)&g2 = v9;
            }
            // 0x1000036b0
            v5 = *(int32_t *)&g1;
            result2 = v10;
        }
        // 0x100003728
        v11 = v5 + 1;
        *(int32_t *)&g1 = v11;
        v12 = v11 - v2;
    }
    // 0x100003740
    return result2;
}

// Address range: 0x10000374c - 0x10000394c
int64_t function_10000374c(void) {
    // 0x10000374c
    int64_t v1; // 0x10000374c
    int32_t v2 = v1; // 0x100003760
    *(int32_t *)&g1 = 1;
    int32_t v3 = 1 - v2;
    int32_t v4; // 0x10000374c
    int32_t v5; // 0x10000374c
    int64_t result; // 0x10000374c
    if (v3 == 0 || v3 < 0 != (v3 & v2) < 0) {
        int32_t v6 = -v2;
        int32_t v7 = v6 & v2;
        int32_t v8 = 1; // 0x10000382c
        *(int32_t *)&g2 = 0;
        int32_t v9 = v8; // 0x1000037c0
        int32_t v10 = v8; // 0x1000037c0
        int64_t v11; // 0x1000037d8
        int64_t v12; // 0x1000037e8
        int32_t v13; // 0x1000037e8
        int32_t v14; // 0x100003810
        int32_t v15; // 0x1000037b8
        int32_t v16; // 0x10000374c
        if (v6 < 0 != v7 < 0) {
            v11 = 8 * (int64_t)v9;
            v12 = 0;
            v13 = *(int32_t *)(v12 + *(int64_t *)(v11 + v1));
            *(int32_t *)(*(int64_t *)(v11 + v1) + v12) = v13;
            v14 = *(int32_t *)&g2 + 1;
            *(int32_t *)&g2 = v14;
            v15 = v14 - v2;
            v16 = *(int32_t *)&g1;
            v10 = v16;
            while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
                // 0x1000037c8
                v11 = 8 * (int64_t)v16;
                v12 = 4 * (int64_t)v14;
                v13 = *(int32_t *)(v12 + *(int64_t *)(v11 + v1));
                *(int32_t *)(*(int64_t *)(v11 + v1) + v12) = v13;
                v14 = *(int32_t *)&g2 + 1;
                *(int32_t *)&g2 = v14;
                v15 = v14 - v2;
                v16 = *(int32_t *)&g1;
                v10 = v16;
            }
        }
        // 0x100003820
        v8 = v10 + 1;
        *(int32_t *)&g1 = v8;
        while (v8 - v2 == 0 || v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x1000037a8
            *(int32_t *)&g2 = 0;
            v9 = v8;
            v10 = v8;
            if (v6 < 0 != v7 < 0) {
                v11 = 8 * (int64_t)v9;
                v12 = 0;
                v13 = *(int32_t *)(v12 + *(int64_t *)(v11 + v1));
                *(int32_t *)(*(int64_t *)(v11 + v1) + v12) = v13;
                v14 = *(int32_t *)&g2 + 1;
                *(int32_t *)&g2 = v14;
                v15 = v14 - v2;
                v16 = *(int32_t *)&g1;
                v10 = v16;
                while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
                    // 0x1000037c8
                    v11 = 8 * (int64_t)v16;
                    v12 = 4 * (int64_t)v14;
                    v13 = *(int32_t *)(v12 + *(int64_t *)(v11 + v1));
                    *(int32_t *)(*(int64_t *)(v11 + v1) + v12) = v13;
                    v14 = *(int32_t *)&g2 + 1;
                    *(int32_t *)&g2 = v14;
                    v15 = v14 - v2;
                    v16 = *(int32_t *)&g1;
                    v10 = v16;
                }
            }
            // 0x100003820
            v8 = v10 + 1;
            *(int32_t *)&g1 = v8;
        }
        // 0x10000384c
        *(int32_t *)&g1 = 1;
        _rand();
        int64_t v17 = function_10000350c(); // 0x1000038a0
        int32_t v18 = *(int32_t *)&g1 + 1; // 0x1000038b4
        *(int32_t *)&g1 = v18;
        int32_t v19 = v18 - v2; // 0x10000385c
        v4 = v7;
        v5 = v6;
        result = v17;
        while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
            // 0x10000386c
            _rand();
            v17 = function_10000350c();
            v18 = *(int32_t *)&g1 + 1;
            *(int32_t *)&g1 = v18;
            v19 = v18 - v2;
            v4 = v7;
            v5 = v6;
            result = v17;
        }
    } else {
        // 0x10000384c
        *(int32_t *)&g1 = 1;
        int32_t v20 = -v2; // 0x1000038e0
        v4 = v20 & v2;
        v5 = v20;
    }
    // 0x1000038d0
    *(int32_t *)&g1 = 0;
    if (v5 < 0 == v4 < 0) {
        // 0x100003940
        return result;
    }
    _rand();
    int64_t result2 = function_1000035b4(); // 0x100003920
    int32_t v21 = *(int32_t *)&g1 + 1; // 0x100003934
    *(int32_t *)&g1 = v21;
    int32_t v22 = v21 - v2; // 0x1000038e0
    while (v22 < 0 != ((v22 ^ v21) & (v21 ^ v2)) < 0) {
        // 0x1000038f0
        _rand();
        result2 = function_1000035b4();
        v21 = *(int32_t *)&g1 + 1;
        *(int32_t *)&g1 = v21;
        v22 = v21 - v2;
    }
    // 0x100003940
    return result2;
}

// Address range: 0x10000394c - 0x100003b0c
int64_t function_10000394c(void) {
    // 0x10000394c
    int64_t v1; // 0x10000394c
    int32_t v2 = v1; // 0x10000395c
    _printf(" ");
    *(int32_t *)&g1 = 0;
    int32_t v3 = -v2;
    if (v3 < 0 != (v3 & v2) < 0) {
        _printf(" %d", v1);
        int32_t v4 = *(int32_t *)&g1 + 1; // 0x1000039d0
        *(int32_t *)&g1 = v4;
        while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
            // 0x10000399c
            _printf(" %d", v1);
            v4 = *(int32_t *)&g1 + 1;
            *(int32_t *)&g1 = v4;
        }
    }
    // 0x1000039dc
    _printf("\n");
    *(int32_t *)&g1 = 1;
    if (-v2 != -1 && -v2 < -1 == (1 - v2 & v2) < 0) {
        // 0x100003af4
        return _printf("\n");
    }
    _printf("%d", v1);
    *(int32_t *)&g2 = 0;
    int32_t v5; // 0x100003ac0
    if (v3 < 0 != (v3 & v2) < 0) {
        _printf(" %d", v1);
        v5 = *(int32_t *)&g2 + 1;
        *(int32_t *)&g2 = v5;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003a74
            _printf(" %d", v1);
            v5 = *(int32_t *)&g2 + 1;
            *(int32_t *)&g2 = v5;
        }
    }
    // 0x100003acc
    _printf("\n");
    int32_t v6 = *(int32_t *)&g1 + 1; // 0x100003ae8
    *(int32_t *)&g1 = v6;
    while (v6 - v2 == 0 || v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
        // 0x100003a1c
        _printf("%d", v1);
        *(int32_t *)&g2 = 0;
        if (v3 < 0 != (v3 & v2) < 0) {
            _printf(" %d", v1);
            v5 = *(int32_t *)&g2 + 1;
            *(int32_t *)&g2 = v5;
            while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
                // 0x100003a74
                _printf(" %d", v1);
                v5 = *(int32_t *)&g2 + 1;
                *(int32_t *)&g2 = v5;
            }
        }
        // 0x100003acc
        _printf("\n");
        v6 = *(int32_t *)&g1 + 1;
        *(int32_t *)&g1 = v6;
    }
    // 0x100003af4
    return _printf("\n");
}

// Address range: 0x100003b0c - 0x100003c20
int64_t function_100003b0c(void) {
    // 0x100003b0c
    int64_t v1; // 0x100003b0c
    int32_t v2 = v1; // 0x100003b18
    *(int32_t *)&g1 = 1;
    int32_t v3 = 1 - v2; // 0x100003b40
    int64_t result = 1; // 0x100003b48
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
      lab_0x100003c14:
        // 0x100003c14
        return result;
    }
    int32_t v4 = -v2; // 0x100003b70
    int32_t v5 = 1;
    *(int32_t *)&g2 = 0;
    int64_t v6; // 0x100003b90
    int64_t v7; // 0x100003ba0
    int32_t v8; // 0x100003bb4
    int32_t v9; // 0x100003be0
    if (v4 < 0 != (v4 & v2) < 0) {
        // 0x100003b80
        v6 = 8 * (int64_t)v5;
        v9 = 0;
        v7 = 4 * (int64_t)v9;
        v8 = *(int32_t *)(*(int64_t *)(v6 + v1) + v7);
        result = 0;
        if (*(int32_t *)(v7 + *(int64_t *)(v6 + v1)) != v8) {
            return result;
        }
        // 0x100003b60
        v9++;
        *(int32_t *)&g2 = v9;
        while (v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
            // 0x100003b80
            v7 = 4 * (int64_t)v9;
            v8 = *(int32_t *)(*(int64_t *)(v6 + v1) + v7);
            result = 0;
            if (*(int32_t *)(v7 + *(int64_t *)(v6 + v1)) != v8) {
                return result;
            }
            // 0x100003b60
            v9++;
            *(int32_t *)&g2 = v9;
        }
    }
    int32_t v10 = v5 + 1; // 0x100003bfc
    *(int32_t *)&g1 = v10;
    while (v10 - v2 == 0 || v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
        // 0x100003b60
        v5 = v10;
        *(int32_t *)&g2 = 0;
        if (v4 < 0 != (v4 & v2) < 0) {
            // 0x100003b80
            v6 = 8 * (int64_t)v5;
            v9 = 0;
            v7 = 4 * (int64_t)v9;
            v8 = *(int32_t *)(*(int64_t *)(v6 + v1) + v7);
            result = 0;
            if (*(int32_t *)(v7 + *(int64_t *)(v6 + v1)) != v8) {
                return result;
            }
            // 0x100003b60
            v9++;
            *(int32_t *)&g2 = v9;
            while (v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
                // 0x100003b80
                v7 = 4 * (int64_t)v9;
                v8 = *(int32_t *)(*(int64_t *)(v6 + v1) + v7);
                result = 0;
                if (*(int32_t *)(v7 + *(int64_t *)(v6 + v1)) != v8) {
                    return result;
                }
                // 0x100003b60
                v9++;
                *(int32_t *)&g2 = v9;
            }
        }
        // 0x100003bf0
        v10 = v5 + 1;
        *(int32_t *)&g1 = v10;
    }
    // 0x100003c14
    return 1;
}

// Address range: 0x100003c20 - 0x100003eec
int64_t entry_point(void) {
    int64_t v1 = (int64_t)_malloc(15); // 0x100003c48
    *(int32_t *)&g1 = 1;
    int64_t * v2 = _malloc(12); // 0x100003c8c
    int32_t v3 = *(int32_t *)&g1; // 0x100003c9c
    *(int64_t *)(8 * (int64_t)v3 + v1) = (int64_t)v2;
    int32_t v4 = *(int32_t *)&g1; // 0x100003cb0
    int32_t v5 = v4 + 1; // 0x100003cb4
    *(int32_t *)&g1 = v5;
    while (v4 == 2 || v4 < 2 != (1 - v4 & v5) < 0) {
        // 0x100003c84
        v2 = _malloc(12);
        v3 = *(int32_t *)&g1;
        *(int64_t *)(8 * (int64_t)v3 + v1) = (int64_t)v2;
        v4 = *(int32_t *)&g1;
        v5 = v4 + 1;
        *(int32_t *)&g1 = v5;
    }
    int64_t v6 = (int64_t)_malloc(15); // 0x100003ccc
    *(int32_t *)&g1 = 1;
    int64_t * v7 = _malloc(12); // 0x100003d10
    int32_t v8 = *(int32_t *)&g1; // 0x100003d20
    *(int64_t *)(8 * (int64_t)v8 + v6) = (int64_t)v7;
    int32_t v9 = *(int32_t *)&g1; // 0x100003d34
    int32_t v10 = v9 + 1; // 0x100003d38
    *(int32_t *)&g1 = v10;
    while (v9 == 2 || v9 < 2 != (1 - v9 & v10) < 0) {
        // 0x100003d08
        v7 = _malloc(12);
        v8 = *(int32_t *)&g1;
        *(int64_t *)(8 * (int64_t)v8 + v6) = (int64_t)v7;
        v9 = *(int32_t *)&g1;
        v10 = v9 + 1;
        *(int32_t *)&g1 = v10;
    }
    // 0x100003d44
    function_100003658();
    function_10000374c();
    if ((int32_t)function_100003b0c() != 0) {
        function_10000374c();
        while ((int32_t)function_100003b0c() != 0) {
            // 0x100003d84
            function_10000374c();
        }
    }
    _printf("Target: \n");
    function_10000394c();
    _printf("Board: \n");
    function_10000394c();
    _printf("What to flip: ");
    _scanf(" %c", (char *)3);
    _scanf(" %d", (char *)3);
    int32_t v11; // 0x100003c20
    switch (0x1000000 * v11) {
        case 0x63000000: {
            // 0x100003e5c
            function_1000035b4();
            // break -> 0x100003e80
            break;
        }
        case 0x72000000: {
            // 0x100003e48
            function_10000350c();
            // break -> 0x100003e80
            break;
        }
        default: {
            // 0x100003e70
            _perror("Please specify r or c and an number");
            // break -> 0x100003e80
            break;
        }
    }
    // 0x100003e80
    _printf("Moves Taken: %d\n", 3);
    // 0x100003d9c
    while ((int32_t)function_100003b0c() == 0) {
        // 0x100003db0
        _printf("Target: \n");
        function_10000394c();
        _printf("Board: \n");
        function_10000394c();
        _printf("What to flip: ");
        _scanf(" %c", (char *)3);
        _scanf(" %d", (char *)3);
        switch (0x1000000 * v11) {
            case 0x63000000: {
                // 0x100003e5c
                function_1000035b4();
                // break -> 0x100003e80
                break;
            }
            case 0x72000000: {
                // 0x100003e48
                function_10000350c();
                // break -> 0x100003e80
                break;
            }
            default: {
                // 0x100003e70
                _perror("Please specify r or c and an number");
                // break -> 0x100003e80
                break;
            }
        }
        // 0x100003e80
        _printf("Moves Taken: %d\n", 3);
    }
    // 0x100003ee0
    return _printf("You win!\n");
}

// Address range: 0x100003eec - 0x100003ef8
int64_t * function_100003eec(int32_t size) {
    // 0x100003eec
    return _malloc(size);
}

// Address range: 0x100003ef8 - 0x100003f04
void function_100003ef8(char * s) {
    // 0x100003ef8
    _perror(s);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(char * format, ...) {
    // 0x100003f04
    return _printf(format);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(void) {
    // 0x100003f10
    return _rand();
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * format, ...) {
    // 0x100003f1c
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned long long ULONG;

ULONG get_prime(int idx)
{
        static long n_primes = 0, alloc = 0;
        static ULONG *primes = 0;
        ULONG last, p;
        int i;

        if (idx >= n_primes) {
                if (n_primes >= alloc) {
                        alloc += 16; /* be conservative */
                        primes = realloc(primes, sizeof(ULONG) * alloc);
                }
                if (!n_primes) {
                        primes[0] = 2;
                        primes[1] = 3;
                        n_primes = 2;
                }

                last = primes[n_primes-1];
                while (idx >= n_primes) {
                        last += 2;
                        for (i = 0; i < n_primes; i++) {
                                p = primes[i];
                                if (p * p > last) {
                                        primes[n_primes++] = last;
                                        break;
                                }
                                if (last % p == 0) break;
                        }
                }
        }
        return primes[idx];
}

int main()
{
        ULONG n, x, p;
        int i, first;

        for (x = 1; ; x++) {
                printf("%lld = ", n = x);

                for (i = 0, first = 1; ; i++) {
                        p = get_prime(i);
                        while (n % p == 0) {
                                n /= p;
                                if (!first) printf(" x ");
                                first = 0;
                                printf("%lld", p);
                        }
                        if (n <= p * p) break;
                }

                if (first)      printf("%lld\n", n);
                else if (n > 1) printf(" x %lld\n", n);
                else            printf("\n");
        }
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf4(void);
int32_t function_100003f6c(char * format, ...);
int64_t * function_100003f78(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008000
int64_t g2 = 0; // 0x100008008
int64_t g3 = 0; // 0x100008010

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf4 - 0x100003ddc
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t v1; // 0x100003bf4
    int64_t v2 = 0x100000000 * v1;
    int64_t v3 = v2 >> 32; // 0x100003c04
    int64_t v4 = g1; // 0x100003c0c
    int64_t v5 = v3 - v4; // 0x100003c10
    if (v5 < 0 != ((v5 ^ v3) & (v4 ^ v3)) < 0) {
        // 0x100003dc0
        return *(int64_t *)(g3 + (v2 >> 29));
    }
    int64_t v6 = v4 - g2; // 0x100003c30
    int64_t v7 = v4; // 0x100003c38
    if (v6 < 0 == ((v6 ^ v4) & (g2 ^ v4)) < 0) {
        int64_t v8 = g2 + 16; // 0x100003c48
        g2 = v8;
        g3 = (int64_t)_realloc((int64_t *)g3, 8 * (int32_t)v8);
        v7 = g1;
    }
    int64_t v9 = v7; // 0x100003c88
    if (v7 == 0) {
        // 0x100003c90
        *(int64_t *)g3 = 2;
        *(int64_t *)(g3 + 8) = 3;
        g1 = 2;
        v9 = 2;
    }
    int64_t v10 = v3 - v9; // 0x100003ce4
    if (v10 < 0 != ((v10 ^ v3) & (v9 ^ v3)) < 0) {
        // 0x100003dc0
        return *(int64_t *)(g3 + (v2 >> 29));
    }
    int64_t v11 = v9; // 0x100003ce0
    uint64_t v12 = *(int64_t *)(8 * v9 - 8 + g3); // 0x100003cf8
    while (true) {
        int64_t v13 = v11;
        v12 += 2;
        int64_t v14 = -v13; // 0x100003d14
        int64_t v15 = v13; // 0x100003d1c
        if (v14 < 0 != (v13 & v14) < 0) {
            int32_t v16 = 0; // 0x100003dac
            uint64_t v17 = *(int64_t *)g3; // 0x100003d30
            while (v17 * v17 == v12 || v17 * v17 < v12) {
                // 0x100003d7c
                v15 = v13;
                if (v12 % v17 == 0) {
                    goto lab_0x100003db8_2;
                }
                // 0x100003d08
                v16++;
                int64_t v18 = v16; // 0x100003d08
                int64_t v19 = v18 - v13; // 0x100003d14
                v15 = v13;
                if (v19 < 0 == ((v19 ^ v18) & (v13 ^ v18)) < 0) {
                    goto lab_0x100003db8_2;
                }
                v17 = *(int64_t *)(8 * v18 + g3);
            }
            // 0x100003d58
            g1 = v13 + 1;
            *(int64_t *)(g3 + 8 * v13) = v12;
            v15 = g1;
        }
      lab_0x100003db8_2:
        // 0x100003db8
        v11 = v15;
        int64_t v20 = v3 - v11; // 0x100003ce4
        if (v20 < 0 != ((v20 ^ v3) & (v11 ^ v3)) < 0) {
            // break -> 0x100003dc0
            break;
        }
    }
    // 0x100003dc0
    return *(int64_t *)(g3 + (v2 >> 29));
}

// Address range: 0x100003ddc - 0x100003f6c
int64_t entry_point(void) {
    int64_t v1 = 1; // 0x100003df4
    while (true) {
        // 0x100003df8
        int64_t v2; // 0x100003ddc
        _printf("%lld = ", v2);
        int32_t v3 = 1; // 0x100003e20
        uint64_t v4 = function_100003bf4(); // 0x100003e28
        int32_t v5 = v3; // 0x100003e50
        int64_t v6 = v1; // 0x100003e50
        int64_t v7 = v1; // 0x100003e50
        int32_t v8 = v3; // 0x100003e50
        int64_t v9; // 0x100003e60
        if (v1 % v4 == 0) {
            if (v5 == 0) {
                // 0x100003e7c
                _printf(" x ");
            }
            // 0x100003e8c
            v9 = v6 / v4;
            _printf("%lld", v2);
            v6 = v9;
            v7 = v9;
            v8 = 0;
            while (v9 % v4 == 0) {
                // 0x100003e7c
                _printf(" x ");
                // 0x100003e8c
                v9 = v6 / v4;
                _printf("%lld", v2);
                v6 = v9;
                v7 = v9;
                v8 = 0;
            }
        }
        int32_t v10 = v8;
        int64_t v11 = v7;
        uint64_t v12 = v4 * v4; // 0x100003eb8
        int64_t v13 = v11; // 0x100003ec4
        v3 = v10;
        while (v11 >= v12 == (v11 != v12)) {
            // 0x100003e24
            v4 = function_100003bf4();
            v5 = v3;
            v6 = v13;
            v7 = v13;
            v8 = v3;
            if (v13 % v4 == 0) {
                if (v5 == 0) {
                    // 0x100003e7c
                    _printf(" x ");
                }
                // 0x100003e8c
                v9 = v6 / v4;
                _printf("%lld", v2);
                v6 = v9;
                v7 = v9;
                v8 = 0;
                while (v9 % v4 == 0) {
                    // 0x100003e7c
                    _printf(" x ");
                    // 0x100003e8c
                    v9 = v6 / v4;
                    _printf("%lld", v2);
                    v6 = v9;
                    v7 = v9;
                    v8 = 0;
                }
            }
            // 0x100003eac
            v10 = v8;
            v11 = v7;
            v12 = v4 * v4;
            v13 = v11;
            v3 = v10;
        }
        if (v10 == 0) {
            if (v11 == 1 || v11 == 0) {
                // 0x100003f44
                _printf((char *)0x100003fa4);
            } else {
                // 0x100003f28
                _printf(" x %lld\n", v2);
            }
        } else {
            // 0x100003ef8
            _printf("%lld\n", v2);
        }
        // 0x100003f5c
        v1++;
    }
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
int64_t * function_100003f78(int64_t * ptr, int32_t size) {
    // 0x100003f78
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct { double x, y; } vec;
typedef struct { int n; vec* v; } polygon_t, *polygon;

#define BIN_V(op, xx, yy) vec v##op(vec a,vec b){vec c;c.x=xx;c.y=yy;return c;}
#define BIN_S(op, r) double v##op(vec a, vec b){ return r; }
BIN_V(sub, a.x - b.x, a.y - b.y);
BIN_V(add, a.x + b.x, a.y + b.y);
BIN_S(dot, a.x * b.x + a.y * b.y);
BIN_S(cross, a.x * b.y - a.y * b.x);

/* return a + s * b */
vec vmadd(vec a, double s, vec b)
{
	vec c;
	c.x = a.x + s * b.x;
	c.y = a.y + s * b.y;
	return c;
}

/* check if x0->x1 edge crosses y0->y1 edge. dx = x1 - x0, dy = y1 - y0, then
   solve  x0 + a * dx == y0 + b * dy with a, b in real
   cross both sides with dx, then: (remember, cross product is a scalar)
	x0 X dx = y0 X dx + b * (dy X dx)
   similarly,
	x0 X dy + a * (dx X dy) == y0 X dy
   there is an intersection iff 0 <= a <= 1 and 0 <= b <= 1

   returns: 1 for intersect, -1 for not, 0 for hard to say (if the intersect
   point is too close to y0 or y1)
*/
int intersect(vec x0, vec x1, vec y0, vec y1, double tol, vec *sect)
{
	vec dx = vsub(x1, x0), dy = vsub(y1, y0);
	double d = vcross(dy, dx), a;
	if (!d) return 0; /* edges are parallel */

	a = (vcross(x0, dx) - vcross(y0, dx)) / d;
	if (sect)
		*sect = vmadd(y0, a, dy);

	if (a < -tol || a > 1 + tol) return -1;
	if (a < tol || a > 1 - tol) return 0;

	a = (vcross(x0, dy) - vcross(y0, dy)) / d;
	if (a < 0 || a > 1) return -1;

	return 1;
}

/* distance between x and nearest point on y0->y1 segment.  if the point
   lies outside the segment, returns infinity */
double dist(vec x, vec y0, vec y1, double tol)
{
	vec dy = vsub(y1, y0);
	vec x1, s;
	int r;

	x1.x = x.x + dy.y; x1.y = x.y - dy.x;
	r = intersect(x, x1, y0, y1, tol, &s);
	if (r == -1) return HUGE_VAL;
	s = vsub(s, x);
	return sqrt(vdot(s, s));
}

#define for_v(i, z, p) for(i = 0, z = p->v; i < p->n; i++, z++)
/* returns 1 for inside, -1 for outside, 0 for on edge */
int inside(vec v, polygon p, double tol)
{
	/* should assert p->n > 1 */
	int i, k, crosses, intersectResult;
	vec *pv;
	double min_x, max_x, min_y, max_y;

	for (i = 0; i < p->n; i++) {
		k = (i + 1) % p->n;
		min_x = dist(v, p->v[i], p->v[k], tol);
		if (min_x < tol) return 0;
	}

	min_x = max_x = p->v[0].x;
	min_y = max_y = p->v[1].y;

	/* calculate extent of polygon */
	for_v(i, pv, p) {
		if (pv->x > max_x) max_x = pv->x;
		if (pv->x < min_x) min_x = pv->x;
		if (pv->y > max_y) max_y = pv->y;
		if (pv->y < min_y) min_y = pv->y;
	}
	if (v.x < min_x || v.x > max_x || v.y < min_y || v.y > max_y)
		return -1;

	max_x -= min_x; max_x *= 2;
	max_y -= min_y; max_y *= 2;
	max_x += max_y;

	vec e;
	while (1) {
		crosses = 0;
		/* pick a rand point far enough to be outside polygon */
		e.x = v.x + (1 + rand() / (RAND_MAX + 1.)) * max_x;
		e.y = v.y + (1 + rand() / (RAND_MAX + 1.)) * max_x;

		for (i = 0; i < p->n; i++) {
			k = (i + 1) % p->n;
			intersectResult = intersect(v, e, p->v[i], p->v[k], tol, 0);

			/* picked a bad point, ray got too close to vertex.
			   re-pick */
			if (!intersectResult) break;

			if (intersectResult == 1) crosses++;
		}
		if (i == p->n) break;
	}
	return (crosses & 1) ? 1 : -1;
}

int main()
{
	vec vsq[] = {	{0,0}, {10,0}, {10,10}, {0,10},
			{2.5,2.5}, {7.5,0.1}, {7.5,7.5}, {2.5,7.5}};

	polygon_t sq = { 4, vsq }, /* outer square */
		sq_hole = { 8, vsq }; /* outer and inner square, ie hole */

	vec c = { 10, 5 }; /* on edge */
	vec d = { 5, 5 };

	printf("%d\n", inside(c, &sq, 1e-10));
	printf("%d\n", inside(c, &sq_hole, 1e-10));

	printf("%d\n", inside(d, &sq, 1e-10));	/* in */
	printf("%d\n", inside(d, &sq_hole, 1e-10));  /* out (in the hole) */

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000033fc(void);
int64_t function_100003440(void);
int64_t function_100003484(void);
int64_t function_1000034b8(void);
int64_t function_1000034ec(void);
int64_t function_10000353c(float64_t a1);
int64_t function_100003790(void);
int64_t function_1000038a4(void);
int64_t function_100003e90(int64_t a1);
int64_t * function_100003e9c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ea8(char * format, ...);
int32_t function_100003eb4(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100003ed8

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000033fc - 0x100003440
int64_t function_1000033fc(void) {
    // 0x1000033fc
    int64_t result; // 0x1000033fc
    return result;
}

// Address range: 0x100003440 - 0x100003484
int64_t function_100003440(void) {
    // 0x100003440
    int64_t result; // 0x100003440
    return result;
}

// Address range: 0x100003484 - 0x1000034b8
int64_t function_100003484(void) {
    // 0x100003484
    int64_t result; // 0x100003484
    return result;
}

// Address range: 0x1000034b8 - 0x1000034ec
int64_t function_1000034b8(void) {
    // 0x1000034b8
    int64_t result; // 0x1000034b8
    return result;
}

// Address range: 0x1000034ec - 0x10000353c
int64_t function_1000034ec(void) {
    // 0x1000034ec
    int64_t result; // 0x1000034ec
    return result;
}

// Address range: 0x10000353c - 0x100003790
int64_t function_10000353c(float64_t a1) {
    // 0x10000353c
    function_1000033fc();
    function_1000033fc();
    function_1000034b8();
    float64_t v1; // 0x10000353c
    if (v1 == 0.0) {
        // 0x100003780
        return 0;
    }
    // 0x1000035e0
    function_1000034b8();
    function_1000034b8();
    int64_t v2; // 0x10000353c
    if (v2 != 0) {
        // 0x100003638
        function_1000034ec();
        *(float128_t *)v2 = (float128_t)v1;
    }
    float64_t v3 = 0.0;
    if (v3 > -a1) {
        // 0x100003780
        return 0xffffffff;
    }
    float64_t v4 = a1 + 1.0; // 0x100003698
    if (v3 != v4) {
        if (v3 > v4 == v3 >= v4 == v3 <= v4) {
            // 0x100003780
            return 0xffffffff;
        }
    }
    // 0x1000036b8
    if (v3 > a1) {
        // 0x100003780
        return 0;
    }
    float64_t v5 = 1.0 - a1; // 0x1000036dc
    if (v3 != v5) {
        if (v3 > v5 == v3 >= v5 == v3 <= v5) {
            // 0x100003780
            return 0;
        }
    }
    // 0x1000036f8
    function_1000034b8();
    function_1000034b8();
    if (v3 > 0.0) {
        // 0x100003780
        return 0xffffffff;
    }
    bool v6 = false; // 0x100003758
    bool v7 = true; // 0x100003758
    bool v8 = false; // 0x100003758
    if (v3 != 1.0) {
        v6 = v3 > 1.0;
        v7 = false;
        v8 = v3 >= 1.0 == v3 <= 1.0;
    }
    return v7 | v6 != v8 ? 1 : 0xffffffff;
}

// Address range: 0x100003790 - 0x1000038a4
int64_t function_100003790(void) {
    // 0x100003790
    function_1000033fc();
    float64_t v1; // 0x100003790
    int64_t v2 = function_10000353c(v1); // 0x100003824
    int64_t result = v2; // 0x100003838
    if ((int32_t)v2 != -1) {
        // 0x100003850
        function_1000033fc();
        result = function_100003484();
    }
    // 0x100003894
    return result;
}

// Address range: 0x1000038a4 - 0x100003d14
int64_t function_1000038a4(void) {
    // 0x1000038a4
    float64_t v1; // 0x1000038a4
    float64_t v2 = v1;
    float64_t v3 = v1;
    int64_t v4; // 0x1000038a4
    int32_t v5 = v4;
    int32_t v6 = -v5;
    int32_t v7; // 0x1000038a4
    int32_t v8; // 0x1000038a4
    int32_t v9; // 0x1000038a4
    int32_t v10; // 0x1000038a4
    int32_t v11; // 0x1000038a4
    int32_t v12; // 0x1000038a4
    if (v6 < 0 == (v5 & v6) < 0) {
      lab_0x10000397c:;
        int64_t v13 = *(int64_t *)(v4 + 8);
        int64_t v14 = *(int64_t *)v13;
        int64_t v15 = *(int64_t *)(v13 + 24);
        float64_t v16 = v15; // 0x1000039cc
        float64_t v17 = v14; // 0x1000039cc
        float64_t v18 = v15; // 0x1000039cc
        float64_t v19 = v15; // 0x1000039cc
        float64_t v20 = v14; // 0x1000039cc
        float64_t v21 = v14; // 0x1000039cc
        if (v6 < 0 != (v5 & v6) < 0) {
            float64_t v22 = v14; // 0x1000039dc
            float64_t v23 = v15; // 0x100003a34
            float64_t v24 = v14;
            float64_t v25 = v15;
            float64_t v26 = *(float64_t *)v13; // 0x1000039d8
            float64_t v27 = v24; // 0x1000039e0
            float64_t v28 = v22; // 0x1000039e0
            int64_t v29; // 0x1000038a4
            if (v26 != v22) {
                v27 = v24;
                v28 = v22;
                if (v26 > v22 == v26 >= v22 == v26 <= v22) {
                    // 0x1000039f0
                    v29 = *(int64_t *)v13;
                    v27 = v29;
                    v28 = v29;
                }
            }
            float64_t v30 = v14; // 0x100003a0c
            float64_t v31 = v17; // 0x100003a0c
            int64_t v32; // 0x1000038a4
            if (v26 > v17) {
                // 0x100003a1c
                v32 = *(int64_t *)v13;
                v30 = v32;
                v31 = v32;
            }
            int64_t v33 = v13 + 8; // 0x100003a30
            float64_t v34 = *(float64_t *)v33; // 0x100003a30
            float64_t v35 = v25; // 0x100003a38
            float64_t v36 = v23; // 0x100003a38
            int64_t v37; // 0x1000038a4
            if (v34 != v23) {
                v35 = v25;
                v36 = v23;
                if (v34 > v23 == v34 >= v23 == v34 <= v23) {
                    // 0x100003a48
                    v37 = *(int64_t *)v33;
                    v35 = v37;
                    v36 = v37;
                }
            }
            float64_t v38 = v15; // 0x100003a64
            float64_t v39 = v16; // 0x100003a64
            int64_t v40; // 0x1000038a4
            if (v34 > v16) {
                // 0x100003a74
                v40 = *(int64_t *)v33;
                v38 = v40;
                v39 = v40;
            }
            int32_t v41 = 1; // 0x100003a8c
            int32_t v42 = v41 - v5; // 0x1000039c4
            float64_t v43 = v38; // 0x1000039cc
            float64_t v44 = v30; // 0x1000039cc
            v16 = v39;
            v17 = v31;
            int64_t v45 = v13 + 16; // 0x1000039cc
            int32_t v46 = v41; // 0x1000039cc
            v18 = v35;
            v19 = v38;
            v20 = v27;
            v21 = v30;
            while (v42 < 0 != ((v42 ^ v41) & (v41 ^ v5)) < 0) {
                int64_t v47 = v45;
                v22 = v28;
                v23 = v36;
                v24 = v27;
                v25 = v35;
                v26 = *(float64_t *)v47;
                v27 = v24;
                v28 = v22;
                if (v26 != v22) {
                    v27 = v24;
                    v28 = v22;
                    if (v26 > v22 == v26 >= v22 == v26 <= v22) {
                        // 0x1000039f0
                        v29 = *(int64_t *)v47;
                        v27 = v29;
                        v28 = v29;
                    }
                }
                // 0x100003a00
                v30 = v44;
                v31 = v17;
                if (v26 > v17) {
                    // 0x100003a1c
                    v32 = *(int64_t *)v47;
                    v30 = v32;
                    v31 = v32;
                }
                // 0x100003a2c
                v33 = v47 + 8;
                v34 = *(float64_t *)v33;
                v35 = v25;
                v36 = v23;
                if (v34 != v23) {
                    v35 = v25;
                    v36 = v23;
                    if (v34 > v23 == v34 >= v23 == v34 <= v23) {
                        // 0x100003a48
                        v37 = *(int64_t *)v33;
                        v35 = v37;
                        v36 = v37;
                    }
                }
                // 0x100003a58
                v38 = v43;
                v39 = v16;
                if (v34 > v16) {
                    // 0x100003a74
                    v40 = *(int64_t *)v33;
                    v38 = v40;
                    v39 = v40;
                }
                // 0x100003a88
                v41 = v46 + 1;
                v42 = v41 - v5;
                v43 = v38;
                v44 = v30;
                v16 = v39;
                v17 = v31;
                v45 = v47 + 16;
                v46 = v41;
                v18 = v35;
                v19 = v38;
                v20 = v27;
                v21 = v30;
            }
        }
        // 0x100003aa4
        if (v3 > v21) {
            // 0x100003d04
            return 0xffffffff;
        }
        float64_t v48 = v20; // 0x100003ac0
        float64_t v49 = v18; // 0x100003af0
        if (v3 == v48) {
            // 0x100003ad4
            if (v2 > v19) {
                // 0x100003d04
                return 0xffffffff;
            }
        } else {
            if (v2 > v19 || v3 > v48 == v3 >= v48 == v3 <= v48) {
                // 0x100003d04
                return 0xffffffff;
            }
        }
        if (v2 != v49) {
            if (v2 > v49 == v2 >= v49 == v2 <= v49) {
                // 0x100003d04
                return 0xffffffff;
            }
        }
        while (true) {
            // 0x100003b60
            _rand();
            _rand();
            v10 = 0;
            v7 = 0;
            v8 = 0;
            v12 = 0;
            if (v6 < 0 != (v5 & v6) < 0) {
                while (true) {
                  lab_0x100003bf4:;
                    int32_t v50 = v7;
                    v11 = v10;
                    v9 = v50;
                    v8 = v50;
                    v12 = v11;
                    switch ((int32_t)v51) {
                        case 0: {
                            goto lab_0x100003cbc_2;
                        }
                        case 1: {
                            // 0x100003c98
                            v9 = v50 + 1;
                            goto lab_0x100003cac;
                        }
                        default: {
                            goto lab_0x100003cac;
                        }
                    }
                }
            }
          lab_0x100003cbc_2:
            // 0x100003cbc
            if (v12 == v5) {
                // break -> 0x100003ce0
                break;
            }
        }
        // 0x100003d04
        return v8 % 2 == 0 ? 0xffffffff : 1;
    }
    int32_t v52 = 0; // 0x100003970
    function_100003790();
    while (v3 <= v1) {
        // 0x1000038c8
        v52++;
        int32_t v53 = v52 - v5; // 0x1000038d4
        if (v53 < 0 == ((v53 ^ v52) & (v52 ^ v5)) < 0) {
            goto lab_0x10000397c;
        }
        function_100003790();
    }
    // 0x100003d04
    return 0;
  lab_0x100003cac:;
    int32_t v54 = v11 + 1; // 0x100003cb0
    int32_t v55 = v54 - v5; // 0x100003be4
    v10 = v54;
    v7 = v9;
    v8 = v9;
    v12 = v54;
    if (v55 < 0 == ((v55 ^ v54) & (v54 ^ v5)) < 0) {
        // break -> 0x100003cbc
        goto lab_0x100003cbc_2;
    }
    goto lab_0x100003bf4;
}

// Address range: 0x100003d14 - 0x100003e90
int64_t entry_point(void) {
    // 0x100003d14
    int64_t v1; // bp-168, 0x100003d14
    _memcpy(&v1, &g1, 128);
    function_1000038a4();
    _printf("%d\n", (int64_t)&g1);
    function_1000038a4();
    _printf("%d\n", (int64_t)&g1);
    function_1000038a4();
    _printf("%d\n", (int64_t)&g1);
    function_1000038a4();
    int32_t v2 = _printf("%d\n", (int64_t)&g1); // 0x100003e54
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e64
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e78
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003e7c
    return 0;
}

// Address range: 0x100003e90 - 0x100003e9c
int64_t function_100003e90(int64_t a1) {
    // 0x100003e90
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e9c - 0x100003ea8
int64_t * function_100003e9c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e9c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(char * format, ...) {
    // 0x100003ea8
    return _printf(format);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(void) {
    // 0x100003eb4
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>

double kelvinToCelsius(double k){
    return k - 273.15;
}

double kelvinToFahrenheit(double k){
    return k * 1.8 - 459.67;
}

double kelvinToRankine(double k){
    return k * 1.8;
}
void convertKelvin(double kelvin) {
    printf("K %.2f\n", kelvin);
    printf("C %.2f\n", kelvinToCelsius(kelvin));
    printf("F %.2f\n", kelvinToFahrenheit(kelvin));
    printf("R %.2f", kelvinToRankine(kelvin));
}

int main(int argc, const char * argv[])
{
    if (argc > 1) {
        double kelvin = atof(argv[1]);
        convertKelvin(kelvin);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e08(void);
int64_t function_100003e28(void);
int64_t function_100003e50(void);
int64_t function_100003e70(void);
float64_t function_100003f50(char * nptr);
int32_t function_100003f5c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

float64_t _atof(char * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e08 - 0x100003e28
int64_t function_100003e08(void) {
    // 0x100003e08
    int64_t result; // 0x100003e08
    return result;
}

// Address range: 0x100003e28 - 0x100003e50
int64_t function_100003e28(void) {
    // 0x100003e28
    int64_t result; // 0x100003e28
    return result;
}

// Address range: 0x100003e50 - 0x100003e70
int64_t function_100003e50(void) {
    // 0x100003e50
    int64_t result; // 0x100003e50
    return result;
}

// Address range: 0x100003e70 - 0x100003ef8
int64_t function_100003e70(void) {
    // 0x100003e70
    int128_t v1; // 0x100003e70
    _printf("K %.2f\n", (float64_t)(int64_t)v1);
    function_100003e08();
    _printf("C %.2f\n", (float64_t)(int64_t)v1);
    function_100003e28();
    _printf("F %.2f\n", (float64_t)(int64_t)v1);
    function_100003e50();
    return _printf("R %.2f", (float64_t)(int64_t)v1);
}

// Address range: 0x100003ef8 - 0x100003f50
int64_t entry_point(void) {
    // 0x100003ef8
    int64_t v1; // 0x100003ef8
    int32_t v2 = v1; // 0x100003f08
    int32_t v3 = v2 - 1; // 0x100003f14
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003f24
        _atof((char *)*(int64_t *)(v1 + 8));
        function_100003e70();
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
float64_t function_100003f50(char * nptr) {
    // 0x100003f50
    return _atof(nptr);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <string.h>

void swap(char* p1, char* p2, size_t size) {
    for (; size-- > 0; ++p1, ++p2) {
        char tmp = *p1;
        *p1 = *p2;
        *p2 = tmp;
    }
}

void cocktail_shaker_sort(void* base, size_t count, size_t size,
                          int (*cmp)(const void*, const void*)) {
    char* begin = base;
    char* end = base + size * count;
    if (end == begin)
        return;
    for (end -= size; begin < end; ) {
        char* new_begin = end;
        char* new_end = begin;
        for (char* p = begin; p < end; p += size) {
            char* q = p + size;
            if (cmp(p, q) > 0) {
                swap(p, q, size);
                new_end = p;
            }
        }
        end = new_end;
        for (char* p = end; p > begin; p -= size) {
            char* q = p - size;
            if (cmp(q, p) > 0) {
                swap(p, q, size);
                new_begin = p;
            }
        }
        begin = new_begin;
    }
}

int string_compare(const void* p1, const void* p2) {
    const char* const* s1 = p1;
    const char* const* s2 = p2;
    return strcmp(*s1, *s2);
}

void print(const char** a, size_t len) {
    for (size_t i = 0; i < len; ++i)
        printf("%s ", a[i]);
    printf("\n");
}

int main() {
    const char* a[] = { "one", "two", "three", "four", "five",
        "six", "seven", "eight" };
    const size_t len = sizeof(a)/sizeof(a[0]);
    printf("before: ");
    print(a, len);
    cocktail_shaker_sort(a, len, sizeof(char*), string_compare);
    printf("after: ");
    print(a, len);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b68(void);
int64_t function_100003be8(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003dac(void);
int64_t function_100003df0(void);
int64_t function_100003f30(int64_t a1);
int64_t * function_100003f3c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(char * s1, char * s2);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b68 - 0x100003be8
int64_t function_100003b68(void) {
    // 0x100003b68
    int64_t result; // 0x100003b68
    if (result == 0) {
        // 0x100003be0
        return result;
    }
    int64_t v1; // 0x100003b68
    char * v2 = (char *)v1;
    int64_t v3; // 0x100003b68
    char * v4 = (char *)v3;
    int64_t v5; // 0x100003b68
    int64_t v6 = v5 - 1; // 0x100003b80
    *v2 = *v4;
    *v4 = *v2;
    v1++;
    v3++;
    while (v6 != 0) {
        // 0x100003b98
        v2 = (char *)v1;
        v4 = (char *)v3;
        v6--;
        *v2 = *v4;
        *v4 = *v2;
        v1++;
        v3++;
    }
    // 0x100003be0
    return result;
}

// Address range: 0x100003be8 - 0x100003dac
int64_t function_100003be8(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003be8
    int64_t result; // 0x100003be8
    return result;
}

// Address range: 0x100003dac - 0x100003df0
int64_t function_100003dac(void) {
    // 0x100003dac
    int64_t v1; // 0x100003dac
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003df0 - 0x100003e70
int64_t function_100003df0(void) {
    // 0x100003df0
    int64_t v1; // 0x100003df0
    if (v1 == 0) {
        // 0x100003e58
        return _printf("\n");
    }
    int64_t v2 = 0; // 0x100003e4c
    _printf("%s ", (char *)v1);
    while (v2 + 1 != v1) {
        // 0x100003e24
        v2++;
        _printf("%s ", (char *)v1);
    }
    // 0x100003e58
    return _printf("\n");
}

// Address range: 0x100003e70 - 0x100003f30
int64_t entry_point(void) {
    // 0x100003e70
    int64_t v1; // bp-88, 0x100003e70
    _memcpy(&v1, (int64_t *)"f?", 64);
    _printf("before: ");
    function_100003df0();
    function_100003be8((int64_t)&g1, (int64_t)&g1, (int64_t)&g1, (int64_t)&g1);
    _printf("after: ");
    int64_t v2 = function_100003df0(); // 0x100003ef8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f08
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f1c
        ___stack_chk_fail(v2);
    }
    // 0x100003f20
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(int64_t a1) {
    // 0x100003f30
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f3c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * s1, char * s2) {
    // 0x100003f54
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

char a1[] = {'a','b','c'};
char a2[] = {'A','B','C'};
int a3[] = {1,2,3};

int main(void) {
    for (int i = 0; i < 3; i++) {
        printf("%c%c%i\n", a1[i], a2[i], a3[i]);
    }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003eec - 0x100003f94
int64_t entry_point(void) {
    for (int32_t i = 0; i < 3; i++) {
        // 0x100003f18
        int64_t v1; // 0x100003eec
        _printf("%c%c%i\n", (char)v1, (char)v1, v1);
    }
    // 0x100003f84
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>

/* Calculate day of week in proleptic Gregorian calendar. Sunday == 0. */
int wday(int year, int month, int day)
{
	int adjustment, mm, yy;

	adjustment = (14 - month) / 12;
	mm = month + 12 * adjustment - 2;
	yy = year - adjustment;
	return (day + (13 * mm - 1) / 5 +
		yy + yy / 4 - yy / 100 + yy / 400) % 7;
}

int main()
{
	int y;

	for (y = 2008; y <= 2121; y++) {
		if (wday(y, 12, 25) == 0) printf("%04d-12-25\n", y);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e34(void);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e34 - 0x100003ef4
int64_t function_100003e34(void) {
    // 0x100003e34
    int64_t v1; // 0x100003e34
    int32_t v2 = v1; // 0x100003e3c
    int32_t v3 = (14 - v2) / 12; // 0x100003e54
    int32_t v4 = (int32_t)v1 - v3; // 0x100003e7c
    return (v4 + (int32_t)v1 + v4 / 4 + v4 / -100 + v4 / 400 + (13 * (12 * v3 + v2) - 27) / 5) % 7;
}

// Address range: 0x100003ef4 - 0x100003f88
int64_t entry_point(void) {
    int32_t v1 = 2008;
    if ((int32_t)function_100003e34() == 0) {
        // 0x100003f44
        _printf("%04d-12-25\n", 12);
    }
    int32_t v2 = v1 + 1; // 0x100003f6c
    while (v1 == 2120 || v1 < 2120 != (2119 - v1 & v2) < 0) {
        // 0x100003f24
        v1 = v2;
        if ((int32_t)function_100003e34() == 0) {
            // 0x100003f44
            _printf("%04d-12-25\n", 12);
        }
        // 0x100003f68
        v2 = v1 + 1;
    }
    // 0x100003f78
    return 0;
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

enum {
  LOWER = 0,
  UPPER = 100,
  KEY = LOWER-1 // some value that is not in the valid range
};

char dummy;
// A pointer to represent the integer 0, and the basis of our integer-as-pointer
// representation. We can't use the null pointer because bsearch() returns that
// for not found.
#define ZERO ((void *)&dummy)

int get_value(int x) {
  if (x == KEY)
    return 0;
  printf("My guess is: %d. Is it too high, too low, or correct? (H/L/C) ", x);
  char input[2] = " ";
  scanf("%1s", input);
  switch (tolower(input[0])) {
    case 'l':
      return -1;
    case 'h':
      return 1;
    case 'c':
      return 0;
  }
  fprintf(stderr, "Invalid input\n");
  exit(1);
  return 0;
}

int my_cmp(const void *x, const void *y) {
  return get_value(x - ZERO) - get_value(y - ZERO);
}

int main() {
  printf("Instructions:\n"
	 "Think of integer number from %d (inclusive) to %d (exclusive) and\n"
	 "I will guess it. After each guess, you respond with L, H, or C depending\n"
	 "on if my guess was too low, too high, or correct.\n",
	 LOWER, UPPER);
  void *result = bsearch(ZERO + KEY, ZERO + LOWER, UPPER-LOWER, 1, my_cmp);
  if (result == NULL)
    fprintf(stderr, "That is impossible.\n");
  else
    printf("Your number is %d.\n", (int)(result - ZERO));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bec(void);
int64_t function_100003cf0(void);
int64_t * function_100003e14(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
void function_100003e20(int32_t status);
int32_t function_100003e2c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003e38(char * format, ...);
int32_t function_100003e44(char * format, ...);
int32_t function_100003e50(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t * _bsearch(int64_t * a1, int64_t * a2, int32_t a3, int32_t a4, int32_t (*a5)(int64_t *, int64_t *));
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bec - 0x100003cf0
int64_t function_100003bec(void) {
    int64_t result = 0; // 0x100003c08
    int64_t v1; // 0x100003bec
    if ((int32_t)v1 == -1) {
        // 0x100003ce0
        return result;
    }
    // 0x100003c18
    _printf("My guess is: %d. Is it too high, too low, or correct? (H/L/C) ", v1);
    _scanf("%1s", (char **)v1);
    result = 0xffffffff;
    switch (_tolower(32)) {
        case 99: {
            // 0x100003cb8
            result = 0;
        }
        case 108: {
            // 0x100003ce0
            return result;
        }
        case 104: {
            // 0x100003cac
            result = 1;
            return result;
        }
        default: {
            // 0x100003cc0
            _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "Invalid input\n");
            _exit(1);
            // UNREACHABLE
        }
    }
}

// Address range: 0x100003cf0 - 0x100003d50
int64_t function_100003cf0(void) {
    int64_t v1 = function_100003bec(); // 0x100003d1c
    return v1 - function_100003bec() & 0xffffffff;
}

// Address range: 0x100003d50 - 0x100003e14
int64_t entry_point(void) {
    // 0x100003d50
    int64_t v1; // 0x100003d50
    _printf("Instructions:\nThink of integer number from %d (inclusive) to %d (exclusive) and\nI will guess it. After each guess, you respond with L, H, or C depending\non if my guess was too low, too high, or correct.\n", v1, v1);
    int64_t * v2 = _bsearch((int64_t *)((int64_t)&g1 - 1), &g1, 100, 1, (int32_t (*)(int64_t *, int64_t *))0x100003cf0); // 0x100003da8
    if (v2 == NULL) {
        // 0x100003dc4
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "That is impossible.\n");
    } else {
        // 0x100003de0
        _printf("Your number is %d.\n", (int64_t)&g1);
    }
    // 0x100003e04
    return 0;
}

// Address range: 0x100003e14 - 0x100003e20
int64_t * function_100003e14(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e14
    return _bsearch(key, base, nmemb, size, compar);
}

// Address range: 0x100003e20 - 0x100003e2c
void function_100003e20(int32_t status) {
    // 0x100003e20
    _exit(status);
}

// Address range: 0x100003e2c - 0x100003e38
int32_t function_100003e2c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e2c
    return _fprintf(stream, format);
}

// Address range: 0x100003e38 - 0x100003e44
int32_t function_100003e38(char * format, ...) {
    // 0x100003e38
    return _printf(format);
}

// Address range: 0x100003e44 - 0x100003e50
int32_t function_100003e44(char * format, ...) {
    // 0x100003e44
    return _scanf(format);
}

// Address range: 0x100003e50 - 0x100003e5c
int32_t function_100003e50(int32_t c) {
    // 0x100003e50
    return _tolower(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>

#define S 10
typedef struct { double v; int fixed; } node;

#define each(i, x) for(i = 0; i < x; i++)
node **alloc2(int w, int h)
{
	int i;
	node **a = calloc(1, sizeof(node*)*h + sizeof(node)*w*h);
	each(i, h) a[i] = i ? a[i-1] + w : (node*)(a + h);
	return a;
}

void set_boundary(node **m)
{
	m[1][1].fixed =  1; m[1][1].v =  1;
	m[6][7].fixed = -1; m[6][7].v = -1;
}

double calc_diff(node **m, node **d, int w, int h)
{
	int i, j, n;
	double v, total = 0;
	each(i, h) each(j, w) {
		v = 0; n = 0;
		if (i) v += m[i-1][j].v, n++;
		if (j) v += m[i][j-1].v, n++;
		if (i+1 < h) v += m[i+1][j].v, n++;
		if (j+1 < w) v += m[i][j+1].v, n++;

		d[i][j].v = v = m[i][j].v - v / n;
		if (!m[i][j].fixed) total += v * v;
	}
	return total;
}

double iter(node **m, int w, int h)
{
	node **d = alloc2(w, h);
	int i, j;
	double diff = 1e10;
	double cur[] = {0, 0, 0};

	while (diff > 1e-24) {
		set_boundary(m);
		diff = calc_diff(m, d, w, h);
		each(i,h) each(j, w) m[i][j].v -= d[i][j].v;
	}

	each(i, h) each(j, w)
		cur[ m[i][j].fixed + 1 ] += d[i][j].v *
				(!!i + !!j + (i < h-1) + (j < w -1));

	free(d);
	return (cur[2] - cur[0])/2;
}

int main()
{
	node **mesh = alloc2(S, S);
	printf("R = %g\n", 2 / iter(mesh, S, S));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038a0(void);
int64_t function_100003980(void);
int64_t function_1000039d0(void);
int64_t function_100003c4c(void);
int64_t function_100003f50(int64_t a1);
int64_t * function_100003f5c(int32_t nmemb, int32_t size);
void function_100003f68(int64_t * ptr);
int32_t function_100003f74(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0e-24; // 0x100003f80
float64_t g2 = 1.0e+10; // 0x100003f88
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000038a0 - 0x100003980
int64_t function_1000038a0(void) {
    // 0x1000038a0
    int64_t v1; // 0x1000038a0
    int32_t v2 = v1; // 0x1000038b0
    int64_t v3 = 0x100000000 * v1 >> 28; // 0x1000038c8
    int64_t v4 = 0x100000000 * v1;
    int64_t result = (int64_t)_calloc(1, (int32_t)(v3 * (v4 >> 32) + 8 * v1)); // 0x1000038dc
    int32_t v5 = -v2; // 0x1000038f4
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003970
        return result;
    }
    int32_t v6 = 0;
    int64_t v7 = (v4 >> 29) + result; // 0x100003910
    if (v6 != 0) {
        // 0x100003918
        v7 = *(int64_t *)((int64_t)(8 * v6 - 8) + result) + v3;
    }
    // 0x10000394c
    *(int64_t *)(8 * (int64_t)v6 + result) = v7;
    int32_t v8 = v6 + 1; // 0x100003964
    while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
        // 0x100003904
        v6 = v8;
        v7 = (v4 >> 29) + result;
        if (v6 != 0) {
            // 0x100003918
            v7 = *(int64_t *)((int64_t)(8 * v6 - 8) + result) + v3;
        }
        // 0x10000394c
        *(int64_t *)(8 * (int64_t)v6 + result) = v7;
        v8 = v6 + 1;
    }
    // 0x100003970
    return result;
}

// Address range: 0x100003980 - 0x1000039d0
int64_t function_100003980(void) {
    // 0x100003980
    int64_t result; // 0x100003980
    int64_t * v1 = (int64_t *)(result + 8); // 0x10000398c
    *(int32_t *)(*v1 + 24) = 1;
    *(float64_t *)(*v1 + 16) = 1.0;
    int64_t * v2 = (int64_t *)(result + 48); // 0x1000039ac
    *(int32_t *)(*v2 + 120) = -1;
    *(float64_t *)(*v2 + 112) = -1.0;
    return result;
}

// Address range: 0x1000039d0 - 0x100003c4c
int64_t function_1000039d0(void) {
    // 0x1000039d0
    int64_t result; // 0x1000039d0
    int32_t v1 = result; // 0x1000039e0
    int32_t v2 = -v1; // 0x1000039fc
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003c40
        return result;
    }
    int32_t v3 = result; // 0x1000039dc
    int32_t v4 = -v3; // 0x100003a1c
    float64_t v5 = 0.0;
    int32_t v6 = 0;
    int64_t v7; // 0x1000039d0
    int32_t v8; // 0x100003c34
    int32_t v9; // 0x1000039fc
    int32_t v10; // 0x1000039d0
    int32_t v11; // 0x1000039d0
    int32_t v12; // 0x1000039d0
    float64_t v13; // 0x1000039d0
    float64_t v14; // 0x1000039d0
    float64_t v15; // 0x1000039d0
    float64_t v16; // 0x1000039d0
    float64_t v17; // 0x1000039d0
    float64_t v18; // 0x1000039d0
    float64_t v19; // 0x1000039d0
    float64_t v20; // 0x1000039d0
    float64_t v21; // 0x1000039d0
    float64_t v22; // 0x1000039d0
    float64_t v23; // 0x1000039d0
    float64_t v24; // 0x1000039d0
    float64_t v25; // 0x1000039d0
    int32_t v26; // 0x1000039d0
    int32_t v27; // 0x1000039d0
    int64_t * v28; // 0x1000039d0
    int64_t v29; // 0x1000039d0
    int64_t * v30; // 0x1000039d0
    int32_t v31; // 0x1000039d0
    int32_t v32; // 0x1000039d0
    int32_t v33; // 0x1000039d0
    int64_t * v34; // 0x1000039d0
    float64_t v35; // 0x100003ab8
    int32_t v36; // 0x100003b30
    int32_t v37; // 0x1000039d0
    float64_t v38; // 0x100003b0c
    int64_t v39; // 0x100003b98
    float64_t v40; // 0x100003bb8
    int32_t v41; // 0x100003bec
    float64_t v42; // 0x100003b68
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a14
        v8 = v6 + 1;
        v9 = v8 - v1;
        v11 = (v9 ^ v8) & (v8 ^ v1);
        v10 = v9;
        v12 = v8;
        v24 = v5;
        v14 = v13;
    } else {
        // 0x100003a2c
        v27 = 8 * v6;
        v28 = (int64_t *)(result + (int64_t)(v27 - 8));
        v29 = 8 * (int64_t)v6;
        v30 = (int64_t *)(v29 + result);
        v31 = v6 + 1;
        v32 = v31 - v1;
        v33 = (v32 ^ v31) & (v31 ^ v1);
        v34 = (int64_t *)(result + (int64_t)(v27 + 8));
        v15 = v13;
        v23 = v5;
        v26 = 0;
        v16 = 0.0;
        if (v6 != 0) {
            // 0x100003a4c
            v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
        }
        // 0x100003a84
        v17 = v16;
        v18 = v17;
        if (v26 != 0) {
            // 0x100003a98
            v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
            v18 = v17 + v35;
        }
        // 0x100003ad8
        v19 = v18;
        v20 = v19;
        if (v32 < 0 != v33 < 0) {
            // 0x100003af4
            v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
            v20 = v19 + v38;
        }
        // 0x100003b2c
        v21 = v20;
        v36 = v26 + 1;
        v37 = v36 - v3;
        v7 = *v30;
        v22 = v21;
        if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
            // 0x100003b48
            v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
            v22 = v21 + v42;
        }
        // 0x100003b88
        v39 = 16 * (int64_t)v26;
        __asm_sshll(0.0f, 0);
        v40 = *(float64_t *)(v7 + v39) - v22 / v15;
        *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
        v41 = *(int32_t *)(*v30 + (v39 | 8));
        v25 = v41 == 0 ? v23 + v40 * v40 : v23;
        v15 = v41 == 0 ? v23 : v15;
        v11 = v33;
        v10 = v32;
        v12 = v31;
        v24 = v25;
        v14 = v15;
        while (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
            // 0x100003a2c
            v23 = v25;
            v26 = v36;
            v16 = 0.0;
            if (v6 != 0) {
                // 0x100003a4c
                v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
            }
            // 0x100003a84
            v17 = v16;
            v18 = v17;
            if (v26 != 0) {
                // 0x100003a98
                v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
                v18 = v17 + v35;
            }
            // 0x100003ad8
            v19 = v18;
            v20 = v19;
            if (v32 < 0 != v33 < 0) {
                // 0x100003af4
                v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
                v20 = v19 + v38;
            }
            // 0x100003b2c
            v21 = v20;
            v36 = v26 + 1;
            v37 = v36 - v3;
            v7 = *v30;
            v22 = v21;
            if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003b48
                v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
                v22 = v21 + v42;
            }
            // 0x100003b88
            v39 = 16 * (int64_t)v26;
            __asm_sshll(0.0f, 0);
            v40 = *(float64_t *)(v7 + v39) - v22 / v15;
            *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
            v41 = *(int32_t *)(*v30 + (v39 | 8));
            v25 = v41 == 0 ? v23 + v40 * v40 : v23;
            v15 = v41 == 0 ? v23 : v15;
            v11 = v33;
            v10 = v32;
            v12 = v31;
            v24 = v25;
            v14 = v15;
        }
    }
    // 0x100003c30
    while (v10 < 0 != v11 < 0) {
        // 0x100003a14
        v5 = v24;
        float64_t v43 = v14;
        v6 = v12;
        if (v4 < 0 == (v4 & v3) < 0) {
            // 0x100003a14
            v8 = v6 + 1;
            v9 = v8 - v1;
            v11 = (v9 ^ v8) & (v8 ^ v1);
            v10 = v9;
            v12 = v8;
            v24 = v5;
            v14 = v43;
        } else {
            // 0x100003a2c
            v27 = 8 * v6;
            v28 = (int64_t *)(result + (int64_t)(v27 - 8));
            v29 = 8 * (int64_t)v6;
            v30 = (int64_t *)(v29 + result);
            v31 = v6 + 1;
            v32 = v31 - v1;
            v33 = (v32 ^ v31) & (v31 ^ v1);
            v34 = (int64_t *)(result + (int64_t)(v27 + 8));
            v15 = v43;
            v23 = v5;
            v26 = 0;
            v16 = 0.0;
            if (v6 != 0) {
                // 0x100003a4c
                v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
            }
            // 0x100003a84
            v17 = v16;
            v18 = v17;
            if (v26 != 0) {
                // 0x100003a98
                v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
                v18 = v17 + v35;
            }
            // 0x100003ad8
            v19 = v18;
            v20 = v19;
            if (v32 < 0 != v33 < 0) {
                // 0x100003af4
                v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
                v20 = v19 + v38;
            }
            // 0x100003b2c
            v21 = v20;
            v36 = v26 + 1;
            v37 = v36 - v3;
            v7 = *v30;
            v22 = v21;
            if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003b48
                v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
                v22 = v21 + v42;
            }
            // 0x100003b88
            v39 = 16 * (int64_t)v26;
            __asm_sshll(0.0f, 0);
            v40 = *(float64_t *)(v7 + v39) - v22 / v15;
            *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
            v41 = *(int32_t *)(*v30 + (v39 | 8));
            v25 = v41 == 0 ? v23 + v40 * v40 : v23;
            v15 = v41 == 0 ? v23 : v15;
            v11 = v33;
            v10 = v32;
            v12 = v31;
            v24 = v25;
            v14 = v15;
            while (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003a2c
                v23 = v25;
                v26 = v36;
                v16 = 0.0;
                if (v6 != 0) {
                    // 0x100003a4c
                    v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
                }
                // 0x100003a84
                v17 = v16;
                v18 = v17;
                if (v26 != 0) {
                    // 0x100003a98
                    v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
                    v18 = v17 + v35;
                }
                // 0x100003ad8
                v19 = v18;
                v20 = v19;
                if (v32 < 0 != v33 < 0) {
                    // 0x100003af4
                    v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
                    v20 = v19 + v38;
                }
                // 0x100003b2c
                v21 = v20;
                v36 = v26 + 1;
                v37 = v36 - v3;
                v7 = *v30;
                v22 = v21;
                if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                    // 0x100003b48
                    v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
                    v22 = v21 + v42;
                }
                // 0x100003b88
                v39 = 16 * (int64_t)v26;
                __asm_sshll(0.0f, 0);
                v40 = *(float64_t *)(v7 + v39) - v22 / v15;
                *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
                v41 = *(int32_t *)(*v30 + (v39 | 8));
                v25 = v41 == 0 ? v23 + v40 * v40 : v23;
                v15 = v41 == 0 ? v23 : v15;
                v11 = v33;
                v10 = v32;
                v12 = v31;
                v24 = v25;
                v14 = v15;
            }
        }
    }
    // 0x100003c40
    return result;
}

// Address range: 0x100003c4c - 0x100003ee4
int64_t function_100003c4c(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c60
    int64_t v2; // 0x100003c4c
    int32_t v3 = v2; // 0x100003c6c
    int32_t v4 = v2; // 0x100003c70
    int64_t v5 = function_1000038a0(); // 0x100003c7c
    int64_t v6 = 0; // bp-48, 0x100003c90
    int32_t v7 = -v4;
    int32_t v8 = -v3;
    float64_t v9 = g2; // 0x100003cac
    if (g1 != g2) {
        float64_t v10 = v9;
        while (v10 > g1 == v10 >= g1 == v10 <= g1) {
            // 0x100003cbc
            function_100003980();
            function_1000039d0();
            float64_t v11 = v9;
            float64_t v12 = v10; // 0x100003cf4
            if (v7 < 0 != (v7 & v4) < 0) {
                int32_t v13 = 0;
                int64_t v14; // 0x100003d24
                int64_t v15; // 0x100003d2c
                float64_t * v16; // 0x100003d48
                int32_t v17; // 0x100003d5c
                if (v8 < 0 != (v8 & v3) < 0) {
                    // 0x100003d1c
                    v14 = 8 * (int64_t)v13;
                    v17 = 0;
                    v15 = 16 * (int64_t)v17;
                    v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                    *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                    v17++;
                    while (v17 - v3 < 0 != ((v17 - v3 ^ v17) & (v17 ^ v3)) < 0) {
                        // 0x100003d1c
                        v15 = 16 * (int64_t)v17;
                        v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                        *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                        v17++;
                    }
                }
                int32_t v18 = v13 + 1; // 0x100003d70
                int32_t v19 = v18 - v4; // 0x100003cec
                while (v19 < 0 != ((v19 ^ v18) & (v18 ^ v4)) < 0) {
                    // 0x100003d04
                    v13 = v18;
                    if (v8 < 0 != (v8 & v3) < 0) {
                        // 0x100003d1c
                        v14 = 8 * (int64_t)v13;
                        v17 = 0;
                        v15 = 16 * (int64_t)v17;
                        v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                        *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                        v17++;
                        while (v17 - v3 < 0 != ((v17 - v3 ^ v17) & (v17 ^ v3)) < 0) {
                            // 0x100003d1c
                            v15 = 16 * (int64_t)v17;
                            v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                            *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                            v17++;
                        }
                    }
                    // 0x100003d6c
                    v18 = v13 + 1;
                    v19 = v18 - v4;
                }
                // 0x100003ce4
                v12 = v11;
            }
            // 0x100003ca0
            v9 = v12;
            if (v9 == g1) {
                // break -> 0x100003d88
                break;
            }
            v10 = v9;
        }
    }
    if (v7 < 0 != (v7 & v4) < 0) {
        int32_t v20 = v4 - 1;
        int32_t v21 = v3 - 1;
        int32_t v22 = 0;
        int32_t v23; // 0x100003c4c
        int64_t v24; // 0x100003dc8
        int32_t v25; // 0x100003e08
        int32_t v26; // 0x100003df8
        int64_t v27; // 0x100003dd0
        float64_t v28; // 0x100003dd4
        int32_t v29; // 0x100003e24
        int32_t v30; // 0x100003e4c
        float64_t * v31; // 0x100003e5c
        float64_t v32; // 0x100003e5c
        int32_t v33; // 0x100003e70
        if (v8 < 0 != (v8 & v3) < 0) {
            // 0x100003dc0
            v24 = 8 * (int64_t)v22;
            v25 = v22 - v20;
            v26 = (int32_t)(v25 < 0 != ((v25 ^ v22) & (v22 ^ v20)) < 0) + (int32_t)(v22 != 0);
            v23 = 0;
            v27 = 16 * (int64_t)v23;
            v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
            v29 = v23 - v21;
            v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
            v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
            v32 = *v31;
            *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
            v33 = v23 + 1;
            while (v33 - v3 < 0 != ((v33 - v3 ^ v33) & (v33 ^ v3)) < 0) {
                // 0x100003dc0
                v23 = v33;
                v27 = 16 * (int64_t)v23;
                v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
                v29 = v23 - v21;
                v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
                v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
                v32 = *v31;
                *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
                v33 = v23 + 1;
            }
        }
        int32_t v34 = v22 + 1; // 0x100003e84
        while (v34 - v4 < 0 != ((v34 - v4 ^ v34) & (v34 ^ v4)) < 0) {
            // 0x100003da8
            v22 = v34;
            if (v8 < 0 != (v8 & v3) < 0) {
                // 0x100003dc0
                v24 = 8 * (int64_t)v22;
                v25 = v22 - v20;
                v26 = (int32_t)(v25 < 0 != ((v25 ^ v22) & (v22 ^ v20)) < 0) + (int32_t)(v22 != 0);
                v23 = 0;
                v27 = 16 * (int64_t)v23;
                v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
                v29 = v23 - v21;
                v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
                v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
                v32 = *v31;
                *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
                v33 = v23 + 1;
                while (v33 - v3 < 0 != ((v33 - v3 ^ v33) & (v33 ^ v3)) < 0) {
                    // 0x100003dc0
                    v23 = v33;
                    v27 = 16 * (int64_t)v23;
                    v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
                    v29 = v23 - v21;
                    v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
                    v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
                    v32 = *v31;
                    *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
                    v33 = v23 + 1;
                }
            }
            // 0x100003e80
            v34 = v22 + 1;
        }
    }
    // 0x100003e90
    _free((int64_t *)v5);
    int64_t result = &g3; // 0x100003ec8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ed0
        result = ___stack_chk_fail((int64_t)&g3);
    }
    // 0x100003ed4
    return result;
}

// Address range: 0x100003ee4 - 0x100003f50
int64_t entry_point(void) {
    // 0x100003ee4
    function_1000038a0();
    function_100003c4c();
    int128_t v1; // 0x100003ee4
    _printf("R = %g\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(int64_t a1) {
    // 0x100003f50
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f5c - 0x100003f68
int64_t * function_100003f5c(int32_t nmemb, int32_t size) {
    // 0x100003f5c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f68 - 0x100003f74
void function_100003f68(int64_t * ptr) {
    // 0x100003f68
    _free(ptr);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

#define TRUE 1
#define FALSE 0
#define MAX 120

typedef int bool;

bool is_prime(int n) {
    int d = 5;
    if (n < 2) return FALSE;
    if (!(n % 2)) return n == 2;
    if (!(n % 3)) return n == 3;
    while (d *d <= n) {
        if (!(n % d)) return FALSE;
        d += 2;
        if (!(n % d)) return FALSE;
        d += 4;
    }
    return TRUE;
}

int count_prime_factors(int n) {
    int count = 0, f = 2;
    if (n == 1) return 0;
    if (is_prime(n)) return 1;
    while (TRUE) {
        if (!(n % f)) {
            count++;
            n /= f;
            if (n == 1) return count;
            if (is_prime(n)) f = n;
        }
        else if (f >= 3) f += 2;
        else f = 3;
    }
}

int main() {
    int i, n, count = 0;
    printf("The attractive numbers up to and including %d are:\n", MAX);
    for (i = 1; i <= MAX; ++i) {
        n = count_prime_factors(i);
        if (is_prime(n)) {
            printf("%4d", i);
            if (!(++count % 20)) printf("\n");
        }
    }
    printf("\n");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd8(void);
int64_t function_100003d2c(void);
int32_t function_100003f58(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bd8 - 0x100003d2c
int64_t function_100003bd8(void) {
    // 0x100003bd8
    int64_t v1; // 0x100003bd8
    int32_t v2 = v1; // 0x100003bdc
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003d20
        return false;
    }
    if (2 * v2 / 2 == v2) {
        // 0x100003d20
        return v2 == 2;
    }
    if (v2 % 3 == 0) {
        // 0x100003d20
        return v2 == 3;
    }
    int32_t v3 = 25 - v2; // 0x100003c90
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003d20
        return true;
    }
    int32_t v4 = 5; // 0x100003c98
    bool result = false; // 0x100003cbc
    while (v2 % v4 != 0) {
        // 0x100003ccc
        result = false;
        if (v2 % (v4 + 2) == 0) {
            // break -> 0x100003d20
            break;
        }
        // 0x100003c80
        v4 += 6;
        int32_t v5 = v4 * v4; // 0x100003c88
        int32_t v6 = v5 - v2; // 0x100003c90
        result = true;
        if (v6 != 0 && v6 < 0 == ((v6 ^ v5) & (v5 ^ v2)) < 0) {
            // break -> 0x100003d20
            break;
        }
        result = false;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d2c - 0x100003e5c
int64_t function_100003d2c(void) {
    // 0x100003d2c
    int64_t v1; // 0x100003d2c
    int32_t v2 = v1; // 0x100003d38
    if (v2 == 1) {
        // 0x100003e4c
        return 0;
    }
    int32_t v3 = v2; // 0x100003d74
    int32_t v4 = 0; // 0x100003d74
    if ((int32_t)function_100003bd8() != 0) {
        // 0x100003e4c
        return 1;
    }
    int32_t v5 = 2; // 0x100003d74
    int32_t result; // 0x100003db4
    while (true) {
        int32_t v6 = v5;
        int32_t v7 = v4;
        int32_t v8 = v3;
        if (v8 % v6 == 0) {
            // 0x100003db0
            result = v7 + 1;
            int32_t v9 = v8 / v6; // 0x100003dc4
            if (v9 == 1) {
                // break -> 0x100003de0
                break;
            }
            int32_t v10 = (int32_t)function_100003bd8() == 0 ? v6 : v9;
            v3 = v9;
            v4 = result;
            v5 = v10;
        } else {
            int32_t v11 = v6 < 3 == (2 - v6 & v6) < 0 ? v6 + 2 : 3;
            v3 = v8;
            v4 = v7;
            v5 = v11;
        }
    }
    // 0x100003e4c
    return result;
}

// Address range: 0x100003e5c - 0x100003f58
int64_t entry_point(void) {
    // 0x100003e5c
    int64_t v1; // 0x100003e5c
    _printf("The attractive numbers up to and including %d are:\n", v1);
    int32_t v2 = 0;
    int32_t v3 = 1;
    function_100003d2c();
    int32_t v4 = v2; // 0x100003ec4
    int32_t v5; // 0x100003eec
    if ((int32_t)function_100003bd8() != 0) {
        // 0x100003ecc
        _printf("%4d", v1);
        v5 = v2 + 1;
        v4 = v5;
        if (v5 % 20 == 0) {
            // 0x100003f14
            _printf((char *)0x100003f9c);
            v4 = v5;
        }
    }
    int32_t v6 = v3 + 1; // 0x100003f30
    while (v3 == 119 || v3 < 119 != (118 - v3 & v6) < 0) {
        // 0x100003ea8
        v2 = v4;
        v3 = v6;
        function_100003d2c();
        v4 = v2;
        if ((int32_t)function_100003bd8() != 0) {
            // 0x100003ecc
            _printf("%4d", v1);
            v5 = v2 + 1;
            v4 = v5;
            if (v5 % 20 == 0) {
                // 0x100003f14
                _printf((char *)0x100003f9c);
                v4 = v5;
            }
        }
        // 0x100003f2c
        v6 = v3 + 1;
    }
    // 0x100003f3c
    _printf("\n");
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * format, ...) {
    // 0x100003f58
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

void divisor_count_and_sum(unsigned int n, unsigned int* pcount,
                           unsigned int* psum) {
    unsigned int divisor_count = 1;
    unsigned int divisor_sum = 1;
    unsigned int power = 2;
    for (; (n & 1) == 0; power <<= 1, n >>= 1) {
        ++divisor_count;
        divisor_sum += power;
    }
    for (unsigned int p = 3; p * p <= n; p += 2) {
        unsigned int count = 1, sum = 1;
        for (power = p; n % p == 0; power *= p, n /= p) {
            ++count;
            sum += power;
        }
        divisor_count *= count;
        divisor_sum *= sum;
    }
    if (n > 1) {
        divisor_count *= 2;
        divisor_sum *= n + 1;
    }
    *pcount = divisor_count;
    *psum = divisor_sum;
}

int main() {
    unsigned int arithmetic_count = 0;
    unsigned int composite_count = 0;

    for (unsigned int n = 1; arithmetic_count <= 1000000; ++n) {
        unsigned int divisor_count;
        unsigned int divisor_sum;
        divisor_count_and_sum(n, &divisor_count, &divisor_sum);
        if (divisor_sum % divisor_count != 0)
            continue;
        ++arithmetic_count;
        if (divisor_count > 2)
            ++composite_count;
        if (arithmetic_count <= 100) {
            printf("%3u ", n);
            if (arithmetic_count % 10 == 0)
                printf("\n");
        }
        if (arithmetic_count == 1000 || arithmetic_count == 10000 ||
            arithmetic_count == 100000 || arithmetic_count == 1000000) {
            printf("\n%uth arithmetic number is %u\n", arithmetic_count, n);
            printf("Number of composite arithmetic numbers <= %u: %u\n", n,
                   composite_count);
        }
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ba0(void);
int32_t function_100003f3c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ba0 - 0x100003d50
int64_t function_100003ba0(void) {
    // 0x100003ba0
    int64_t result; // 0x100003ba0
    int32_t v1 = result; // 0x100003ba4
    int32_t v2 = 1; // 0x100003bd4
    int32_t v3 = 1; // 0x100003bd4
    int32_t v4 = v1; // 0x100003bd4
    int32_t v5 = 2; // 0x100003bd4
    int32_t v6 = 1; // 0x100003bd4
    int32_t v7 = 1; // 0x100003bd4
    if (v1 % 2 == 0) {
        uint32_t v8 = v1;
        v7++;
        v6 += v5;
        int32_t v9 = v8 / 2; // 0x100003c0c
        v2 = v7;
        v3 = v6;
        v4 = v9;
        v5 *= 2;
        while ((v8 & 2) == 0) {
            // 0x100003bdc
            v8 = v9;
            v7++;
            v6 += v5;
            v9 = v8 / 2;
            v2 = v7;
            v3 = v6;
            v4 = v9;
            v5 *= 2;
        }
    }
    int32_t v10 = v4;
    int32_t v11 = v3; // 0x100003c3c
    int32_t v12 = v2; // 0x100003c3c
    int32_t v13 = v2; // 0x100003c3c
    int32_t v14 = v3; // 0x100003c3c
    int32_t v15 = v10; // 0x100003c3c
    if (v10 <= 9 != v10 != 9) {
        uint32_t v16 = 3;
        int32_t v17 = v16; // 0x100003c78
        int32_t v18 = 1; // 0x100003c78
        int32_t v19 = v10; // 0x100003c78
        int32_t v20 = 1; // 0x100003c78
        int32_t v21; // 0x100003ba0
        int32_t v22; // 0x100003ba0
        int32_t v23; // 0x100003ba0
        int32_t v24; // 0x100003c94
        int32_t v25; // 0x100003cb8
        int32_t v26; // 0x100003c84
        if (v10 % v16 == 0) {
            v26 = 2;
            v24 = v17 + 1;
            v25 = v10 / v16;
            v22 = v24;
            v23 = v25;
            v21 = v26;
            v17 *= v16;
            v18 = v26;
            v19 = v25;
            v20 = v24;
            while (v25 % v16 == 0) {
                // 0x100003c80
                v26 = v21 + 1;
                v24 = v17 + v22;
                v25 = v23 / v16;
                v22 = v24;
                v23 = v25;
                v21 = v26;
                v17 *= v16;
                v18 = v26;
                v19 = v25;
                v20 = v24;
            }
        }
        int32_t v27 = v19;
        v12 *= v18;
        v11 *= v20;
        int32_t v28 = v16 + 2; // 0x100003cec
        uint32_t v29 = v28 * v28; // 0x100003c2c
        v13 = v12;
        v14 = v11;
        v15 = v27;
        while (v29 >= v27 != v29 != v27) {
            // 0x100003c5c
            v16 = v28;
            v23 = v27;
            v17 = v16;
            v18 = 1;
            v19 = v27;
            v20 = 1;
            if (v27 % v16 == 0) {
                v26 = 2;
                v24 = v17 + 1;
                v25 = v23 / v16;
                v22 = v24;
                v23 = v25;
                v21 = v26;
                v17 *= v16;
                v18 = v26;
                v19 = v25;
                v20 = v24;
                while (v25 % v16 == 0) {
                    // 0x100003c80
                    v26 = v21 + 1;
                    v24 = v17 + v22;
                    v25 = v23 / v16;
                    v22 = v24;
                    v23 = v25;
                    v21 = v26;
                    v17 *= v16;
                    v18 = v26;
                    v19 = v25;
                    v20 = v24;
                }
            }
            // 0x100003cc4
            v27 = v19;
            v12 *= v18;
            v11 *= v20;
            v28 = v16 + 2;
            v29 = v28 * v28;
            v13 = v12;
            v14 = v11;
            v15 = v27;
        }
    }
    int32_t v30 = v15;
    int32_t v31 = v13; // 0x100003d04
    int32_t v32 = v14; // 0x100003d04
    if (v30 != 1 && v30 != 0) {
        // 0x100003d0c
        v31 = 2 * v13;
        v32 = (v30 + 1) * v14;
    }
    // 0x100003d30
    *(int32_t *)result = v31;
    *(int32_t *)result = v32;
    return result;
}

// Address range: 0x100003d50 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003d50
    int32_t v1; // bp-36, 0x100003d50
    int32_t v2 = &v1;
    int32_t v3; // bp-40, 0x100003d50
    int32_t v4 = &v3;
    int32_t v5 = 0;
    function_100003ba0();
    int32_t v6 = v5; // 0x100003dbc
    int32_t v7; // 0x100003dcc
    if (v3 % v1 == 0) {
        // 0x100003dc8
        v7 = v5 + 1;
        if (v7 >= 100 != v7 != 100) {
            // 0x100003e0c
            _printf("%3u ", v2);
            if (v7 % 10 == 0) {
                // 0x100003e4c
                _printf("\n");
            }
        }
        // 0x100003e60
        v6 = v7;
        switch (v5) {
            case 0xf423f: {
            }
            case 0x1869f: {
            }
            case 0x270f: {
            }
            case 999: {
                // 0x100003ec4
                _printf("\n%uth arithmetic number is %u\n", v2, v4);
                _printf("Number of composite arithmetic numbers <= %u: %u\n", v2, v4);
                v6 = v7;
                // break -> 0x100003f1c
                break;
            }
        }
    }
    // 0x100003f1c
    while (v6 >= 0xf4240 != v6 != 0xf4240) {
        // 0x100003d90
        v5 = v6;
        function_100003ba0();
        v6 = v5;
        if (v3 % v1 == 0) {
            // 0x100003dc8
            v7 = v5 + 1;
            if (v7 >= 100 != v7 != 100) {
                // 0x100003e0c
                _printf("%3u ", v2);
                if (v7 % 10 == 0) {
                    // 0x100003e4c
                    _printf("\n");
                }
            }
            // 0x100003e60
            v6 = v7;
            switch (v5) {
                case 0xf423f: {
                }
                case 0x1869f: {
                }
                case 0x270f: {
                }
                case 999: {
                    // 0x100003ec4
                    _printf("\n%uth arithmetic number is %u\n", v2, v4);
                    _printf("Number of composite arithmetic numbers <= %u: %u\n", v2, v4);
                    v6 = v7;
                    // break -> 0x100003f1c
                    break;
                }
            }
        }
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h> /* malloc */
#include <string.h> /* strlen */
#define _XOPEN_SOURCE /* requred for time functions */
#define __USE_XOPEN
#include <time.h>
#define DB "database.csv" /* database name */
#define TRY(a)  if (!(a)) {perror(#a);exit(1);}
#define TRY2(a) if((a)<0) {perror(#a);exit(1);}
#define FREE(a) if(a) {free(a);a=NULL;}
#define sort_by(foo) \
static int by_##foo (const void*p1, const void*p2) { \
    return strcmp ((*(const pdb_t*)p1)->foo, (*(const pdb_t*)p2)->foo); }
typedef struct db {
    char title[26];
    char first_name[26];
    char last_name[26];
    time_t date;
    char publ[100];
    struct db *next;
}
db_t,*pdb_t;
typedef int (sort)(const void*, const void*);
enum {CREATE,PRINT,TITLE,DATE,AUTH,READLINE,READ,SORT,DESTROY};
static pdb_t dao (int cmd, FILE *f, pdb_t db, sort sortby);
static char *time2str (time_t *time);
static time_t str2time (char *date);
/* qsort callbacks */
sort_by(last_name);
sort_by(title);
static int by_date(pdb_t *p1, pdb_t *p2);
/* main */
int main (int argc, char **argv) {
    char buf[100];
    const char *commands[]={"-c", "-p", "-t", "-d", "-a", NULL};
    db_t db;
    db.next=NULL;
    pdb_t dblist;
    int i;
    FILE *f;
    TRY (f=fopen(DB,"a+"));
    if (argc<2) {
usage:  printf ("Usage: %s [commands]\n"
        "-c  Create new entry.\n"
        "-p  Print the latest entry.\n"
        "-t  Print all entries sorted by title.\n"
        "-d  Print all entries sorted by date.\n"
        "-a  Print all entries sorted by author.\n",argv[0]);
        fclose (f);
        return 0;
    }
    for (i=0;commands[i]&&strcmp(argv[1],commands[i]);i++);
    switch (i) {
        case CREATE:
        printf("-c  Create a new entry.\n");
        printf("Title           :");if((scanf(" %25[^\n]",db.title     ))<0)break;
        printf("Author Firstname:");if((scanf(" %25[^\n]",db.first_name))<0)break;
        printf("Author Lastname :");if((scanf(" %25[^\n]",db.last_name ))<0)break;
        printf("Date 10-12-2000 :");if((scanf(" %10[^\n]",buf          ))<0)break;
        printf("Publication     :");if((scanf(" %99[^\n]",db.publ      ))<0)break;
        db.date=str2time (buf);
        dao (CREATE,f,&db,NULL);
        break;
        case PRINT:
        printf ("-p  Print the latest entry.\n");
        while (!feof(f)) dao (READLINE,f,&db,NULL);
        dao (PRINT,f,&db,NULL);
        break;
        case TITLE:
        printf ("-t  Print all entries sorted by title.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,by_title);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        case DATE:
        printf ("-d  Print all entries sorted by date.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,(int (*)(const void *,const  void *)) by_date);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        case AUTH:
        printf ("-a  Print all entries sorted by author.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,by_last_name);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        default: {
            printf ("Unknown command: %s.\n",strlen(argv[1])<10?argv[1]:"");
            goto usage;
    }   }
    fclose (f);
    return 0;
}
/* Data Access Object (DAO) */
static pdb_t dao (int cmd, FILE *f, pdb_t in_db, sort sortby) {
    pdb_t *pdb=NULL,rec=NULL,hd=NULL;
    int i=0,ret;
    char buf[100];
    switch (cmd) {
        case CREATE:
        fprintf (f,"\"%s\",",in_db->title);
        fprintf (f,"\"%s\",",in_db->first_name);
        fprintf (f,"\"%s\",",in_db->last_name);
        fprintf (f,"\"%s\",",time2str(&in_db->date));
        fprintf (f,"\"%s\" \n",in_db->publ);
        break;
        case PRINT:
        for (;in_db;i++) {
            printf ("Title       : %s\n",     in_db->title);
            printf ("Author      : %s %s\n",  in_db->first_name, in_db->last_name);
            printf ("Date        : %s\n",     time2str(&in_db->date));
            printf ("Publication : %s\n\n",   in_db->publ);
            if (!((i+1)%3)) {
                printf ("Press Enter to continue.\n");
                ret = scanf ("%*[^\n]");
                if (ret<0) return rec; /* handle EOF */
                else getchar();
            }
            in_db=in_db->next;
        }
        break;
        case READLINE:
        if((fscanf(f," \"%[^\"]\",",in_db->title     ))<0)break;
        if((fscanf(f," \"%[^\"]\",",in_db->first_name))<0)break;
        if((fscanf(f," \"%[^\"]\",",in_db->last_name ))<0)break;
        if((fscanf(f," \"%[^\"]\",",buf              ))<0)break;
        if((fscanf(f," \"%[^\"]\" ",in_db->publ      ))<0)break;
        in_db->date=str2time (buf);
        break;
        case READ:
        while (!feof(f)) {
            dao (READLINE,f,in_db,NULL);
            TRY (rec=malloc(sizeof(db_t)));
            *rec=*in_db; /* copy contents */
            rec->next=hd;/* to linked list */
            hd=rec;i++;
        }
        if (i<2) {
            puts ("Empty database. Please create some entries.");
            fclose (f);
            exit (0);
        }
        break;
        case SORT:
        rec=in_db;
        for (;in_db;i++) in_db=in_db->next;
        TRY (pdb=malloc(i*sizeof(pdb_t)));
        in_db=rec;
        for (i=0;in_db;i++) {
            pdb[i]=in_db;
            in_db=in_db->next;
        }
        qsort (pdb,i,sizeof in_db,sortby);
        pdb[i-1]->next=NULL;
        for (i=i-1;i;i--) {
            pdb[i-1]->next=pdb[i];
        }
        rec=pdb[0];
        FREE (pdb);
        pdb=NULL;
        break;
        case DESTROY: {
            while ((rec=in_db)) {
                in_db=in_db->next;
                FREE (rec);
    }   }   }
    return rec;
}
/* convert numeric time to date string */
static char *time2str (time_t *time) {
    static char buf[255];
    struct tm *ptm;
    ptm=localtime (time);
    strftime(buf, 255, "%m-%d-%Y", ptm);
    return buf;
}
/* convert date string to numeric time */
static time_t str2time (char *date) {
    struct tm tm;
    memset (&tm, 0, sizeof(struct tm));
    strptime(date, "%m-%d-%Y", &tm);
    return mktime(&tm);
}
/* sort by date callback for qsort */
static int by_date (pdb_t *p1, pdb_t *p2) {
    if ((*p1)->date < (*p2)->date) {
        return -1;
    }
    else return ((*p1)->date > (*p2)->date);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_10000335c(void);
int64_t function_1000033a8(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t function_100003a18(void);
int64_t function_100003a4c(void);
int64_t function_100003ac4(void);
int64_t function_100003b00(void);
int64_t function_100003b4c(int64_t a1);
void function_100003b58(int32_t status);
int32_t function_100003b64(struct _IO_FILE * stream);
int32_t function_100003b70(struct _IO_FILE * stream);
struct _IO_FILE * function_100003b7c(char * filename, char * modes);
int32_t function_100003b88(struct _IO_FILE * stream, char * format, ...);
void function_100003b94(int64_t * ptr);
int32_t function_100003ba0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003bac(void);
struct tm * function_100003bb8(int32_t * timer);
int64_t * function_100003bc4(int32_t size);
int64_t * function_100003bd0(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003bdc(int64_t * s, int32_t c, int32_t n);
int32_t function_100003be8(struct tm * tp);
void function_100003bf4(char * s);
int32_t function_100003c00(char * format, ...);
int32_t function_100003c0c(char * s);
void function_100003c18(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003c24(char * format, ...);
int32_t function_100003c30(char * s1, char * s2);
int32_t function_100003c3c(char * s, int32_t maxsize, char * format, struct tm * tp);
int32_t function_100003c48(char * s);
char * function_100003c54(char * s, char * fmt, struct tm * tp);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _feof(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _getchar(void);
struct tm * _localtime(int32_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _mktime(struct tm * a1);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _scanf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);
int32_t _strftime(char * a1, int32_t a2, char * a3, struct tm * a4);
int32_t _strlen(char * a1);
char * _strptime(char * a1, char * a2, struct tm * a3);

// ------------------------ Functions -------------------------

// Address range: 0x100002e30 - 0x100003348
int64_t entry_point(int64_t a1) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100002e48
    int64_t v2; // bp-192, 0x100002e30
    _memcpy(&v2, (int64_t *)"<", 48);
    struct _IO_FILE * v3 = _fopen("database.csv", "a+"); // 0x100002e84
    if (v3 == NULL) {
        // 0x100002ea0
        _perror("f=fopen(DB,\"a+\")");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100002eb4
    int64_t v4; // 0x100002e30
    int32_t v5 = v4; // 0x100002e54
    int64_t v6 = (int64_t)"a+"; // 0x100002ec0
    int32_t v7; // 0x100002e30
    int64_t * v8; // 0x100002e30
    int64_t result; // 0x100002e30
    int64_t v9; // 0x100002e30
    if (v5 < 2 == (1 - v5 & v5) < 0) {
        // 0x100002f00
        v8 = (int64_t *)(v4 + 8);
        int32_t v10 = 0; // 0x100002f1c
        v7 = 0;
        v9 = (int64_t)"a+";
        result = (int64_t)v3;
        if (v2 != 0) {
            int64_t v11 = v2;
            int32_t v12 = _strcmp((char *)*v8, (char *)v11); // 0x100002f38
            v7 = v10;
            v9 = v11;
            result = 0;
            while (v12 != 0) {
                int32_t v13 = v10 + 1; // 0x100002f60
                int64_t v14 = *(int64_t *)(8 * (int64_t)v13 + (int64_t)&v2); // 0x100002f08
                v10 = v13;
                if (v14 == 0) {
                    // 0x100002f00
                    v7 = v13;
                    v9 = v11;
                    result = v12;
                    goto lab_0x100002f6c;
                }
                v11 = v14;
                v12 = _strcmp((char *)*v8, (char *)v11);
                v7 = v10;
                v9 = v11;
                result = 0;
            }
        }
        goto lab_0x100002f6c;
    } else {
        goto lab_0x100002ecc;
    }
  lab_0x100002ecc:
    // 0x100002ecc
    _printf("Usage: %s [commands]\n-c  Create new entry.\n-p  Print the latest entry.\n-t  Print all entries sorted by title.\n-d  Print all entries sorted by date.\n-a  Print all entries sorted by author.\n", (char *)v6);
    int32_t v15 = _fclose(v3); // 0x100002eec
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003330
        ___stack_chk_fail((int64_t)v15);
    }
    // 0x100002f88
    return 0;
  lab_0x100002f6c:;
    uint32_t v16 = v7;
    if (v16 >= 4 != v16 != 4) {
        // 0x100002f88
        return result;
    }
    // 0x1000032a0
    v6 = v9;
    _strlen((char *)*v8);
    _printf("Unknown command: %s.\n", (char *)v6);
    goto lab_0x100002ecc;
}

// Address range: 0x10000335c - 0x1000033a8
int64_t function_10000335c(void) {
    // 0x10000335c
    int64_t v1; // bp-80, 0x10000335c
    _memset(&v1, 0, 56);
    int64_t v2; // 0x10000335c
    _strptime((char *)v2, "%m-%d-%Y", (struct tm *)&v1);
    return _mktime((struct tm *)&v1);
}

// Address range: 0x1000033a8 - 0x1000039f4
int64_t function_1000033a8(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    // 0x1000033a8
    int64_t v1; // 0x1000033a8
    uint64_t v2 = v1 & 0xffffffff; // 0x1000033f0
    return v2 >= 8 == (v2 != 8) ? 0 : v1;
}

// Address range: 0x100003a18 - 0x100003a4c
int64_t function_100003a18(void) {
    // 0x100003a18
    int64_t v1; // 0x100003a18
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003a4c - 0x100003ac4
int64_t function_100003a4c(void) {
    // 0x100003a4c
    int64_t v1; // 0x100003a4c
    int64_t v2 = *(int64_t *)(v1 + 80); // 0x100003a60
    int64_t v3 = *(int64_t *)(v1 + 80); // 0x100003a6c
    int64_t v4 = v2 - v3; // 0x100003a70
    return v4 < 0 == ((v4 ^ v2) & (v3 ^ v2)) < 0 ? (int64_t)(v4 != 0) : 0xffffffff;
}

// Address range: 0x100003ac4 - 0x100003b00
int64_t function_100003ac4(void) {
    // 0x100003ac4
    int64_t v1; // 0x100003ac4
    return _strcmp((char *)(v1 + 52), (char *)(v1 + 52));
}

// Address range: 0x100003b00 - 0x100003b4c
int64_t function_100003b00(void) {
    // 0x100003b00
    int64_t v1; // 0x100003b00
    _strftime((char *)&g1, 255, "%m-%d-%Y", _localtime((int32_t *)v1));
    return (int64_t)&g1;
}

// Address range: 0x100003b4c - 0x100003b58
int64_t function_100003b4c(int64_t a1) {
    // 0x100003b4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003b58 - 0x100003b64
void function_100003b58(int32_t status) {
    // 0x100003b58
    _exit(status);
}

// Address range: 0x100003b64 - 0x100003b70
int32_t function_100003b64(struct _IO_FILE * stream) {
    // 0x100003b64
    return _fclose(stream);
}

// Address range: 0x100003b70 - 0x100003b7c
int32_t function_100003b70(struct _IO_FILE * stream) {
    // 0x100003b70
    return _feof(stream);
}

// Address range: 0x100003b7c - 0x100003b88
struct _IO_FILE * function_100003b7c(char * filename, char * modes) {
    // 0x100003b7c
    return _fopen(filename, modes);
}

// Address range: 0x100003b88 - 0x100003b94
int32_t function_100003b88(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003b88
    return _fprintf(stream, format);
}

// Address range: 0x100003b94 - 0x100003ba0
void function_100003b94(int64_t * ptr) {
    // 0x100003b94
    _free(ptr);
}

// Address range: 0x100003ba0 - 0x100003bac
int32_t function_100003ba0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ba0
    return _fscanf(stream, format);
}

// Address range: 0x100003bac - 0x100003bb8
int32_t function_100003bac(void) {
    // 0x100003bac
    return _getchar();
}

// Address range: 0x100003bb8 - 0x100003bc4
struct tm * function_100003bb8(int32_t * timer) {
    // 0x100003bb8
    return _localtime(timer);
}

// Address range: 0x100003bc4 - 0x100003bd0
int64_t * function_100003bc4(int32_t size) {
    // 0x100003bc4
    return _malloc(size);
}

// Address range: 0x100003bd0 - 0x100003bdc
int64_t * function_100003bd0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003bd0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003bdc - 0x100003be8
int64_t * function_100003bdc(int64_t * s, int32_t c, int32_t n) {
    // 0x100003bdc
    return _memset(s, c, n);
}

// Address range: 0x100003be8 - 0x100003bf4
int32_t function_100003be8(struct tm * tp) {
    // 0x100003be8
    return _mktime(tp);
}

// Address range: 0x100003bf4 - 0x100003c00
void function_100003bf4(char * s) {
    // 0x100003bf4
    _perror(s);
}

// Address range: 0x100003c00 - 0x100003c0c
int32_t function_100003c00(char * format, ...) {
    // 0x100003c00
    return _printf(format);
}

// Address range: 0x100003c0c - 0x100003c18
int32_t function_100003c0c(char * s) {
    // 0x100003c0c
    return _puts(s);
}

// Address range: 0x100003c18 - 0x100003c24
void function_100003c18(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003c18
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003c24 - 0x100003c30
int32_t function_100003c24(char * format, ...) {
    // 0x100003c24
    return _scanf(format);
}

// Address range: 0x100003c30 - 0x100003c3c
int32_t function_100003c30(char * s1, char * s2) {
    // 0x100003c30
    return _strcmp(s1, s2);
}

// Address range: 0x100003c3c - 0x100003c48
int32_t function_100003c3c(char * s, int32_t maxsize, char * format, struct tm * tp) {
    // 0x100003c3c
    return _strftime(s, maxsize, format, tp);
}

// Address range: 0x100003c48 - 0x100003c54
int32_t function_100003c48(char * s) {
    // 0x100003c48
    return _strlen(s);
}

// Address range: 0x100003c54 - 0x100003c60
char * function_100003c54(char * s, char * fmt, struct tm * tp) {
    // 0x100003c54
    return _strptime(s, fmt, tp);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 30

`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

char *to_base(int64_t num, int base)
{
  char *tbl = "0123456789abcdefghijklmnopqrstuvwxyz";
  char buf[66] = {'\0'};
  char *out;
  uint64_t n;
  int i, len = 0, neg = 0;
  if (base > 36) {
    fprintf(stderr, "base %d too large\n", base);
    return 0;
  }

  /* safe against most negative integer */
  n = ((neg = num < 0)) ? (~num) + 1 : num;

  do { buf[len++] = tbl[n % base]; } while(n /= base);

  out = malloc(len + neg + 1);
  for (i = neg; len > 0; i++) out[i] = buf[--len];
  if (neg) out[0] = '-';

  return out;
}

long from_base(const char *num_str, int base)
{
  char *endptr;
  /* there is also strtoul() for parsing into an unsigned long */
  /* in C99, there is also strtoll() and strtoull() for parsing into long long and
   * unsigned long long, respectively */
  int result = strtol(num_str, &endptr, base);
  return result;
}

int main()
{
  int64_t x;
  x = ~(1LL << 63) + 1;
  printf("%lld in base 2: %s\n", x, to_base(x, 2));
  x = 383;
  printf("%lld in base 16: %s\n", x, to_base(x, 16));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c0c(void);
int64_t function_100003e28(void);
int64_t function_100003efc(void);
int32_t function_100003f08(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f14(int32_t size);
int64_t * function_100003f20(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f2c(char * format, ...);
int32_t function_100003f38(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003c0c - 0x100003e28
int64_t function_100003c0c(void) {
    // 0x100003c0c
    int64_t v1; // 0x100003c0c
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c20
    int32_t v4 = v1; // 0x100003c2c
    int64_t v5; // bp-90, 0x100003c0c
    _memset(&v5, 0, 66);
    int32_t v6 = v4 - 36; // 0x100003c58
    int64_t result; // 0x100003c0c
    if (v6 == 0 || v6 < 0 != (35 - v4 & v4) < 0) {
        uint64_t v7 = 0x100000000 * v1 >> 32; // 0x100003ce8
        int64_t v8 = &v5;
        uint64_t v9 = v2 >= 0 ? v2 : -v2;
        int32_t v10 = 0;
        char v11 = *(char *)(v9 % v7 + (int64_t)"0123456789abcdefghijklmnopqrstuvwxyz"); // 0x100003cfc
        int32_t v12 = v10 + 1; // 0x100003d08
        *(char *)((int64_t)v10 + v8) = v11;
        int64_t v13 = v9 / v7; // 0x100003d38
        while (v9 >= v7) {
            // 0x100003ce0
            v9 = v13;
            v10 = v12;
            v11 = *(char *)(v9 % v7 + (int64_t)"0123456789abcdefghijklmnopqrstuvwxyz");
            v12 = v10 + 1;
            *(char *)((int64_t)v10 + v8) = v11;
            v13 = v9 / v7;
        }
        int64_t * v14 = _malloc(v12 + (v2 < 0 ? 2 : 1)); // 0x100003d58
        char * v15 = (char *)v14; // bp-136, 0x100003d5c
        if (v12 >= 1) {
            int64_t v16 = (int64_t)v12 - 1;
            char v17 = *(char *)(v16 + v8); // 0x100003d94
            int64_t v18 = v2 < 0;
            *(char *)(v18 + (int64_t)v14) = v17;
            int64_t v19 = v18; // 0x100003d78
            if (v10 != 0) {
                int64_t v20 = v16;
                int64_t v21 = v20 - 1;
                char v22 = *(char *)(v21 + v8); // 0x100003d94
                *(char *)((0x100000000 * v19 + 0x100000000 >> 32) + (int64_t)v15) = v22;
                v19++;
                while (v20 >= 2) {
                    // 0x100003d80
                    v20 = v21;
                    v21 = v20 - 1;
                    v22 = *(char *)(v21 + v8);
                    *(char *)((0x100000000 * v19 + 0x100000000 >> 32) + (int64_t)v15) = v22;
                    v19++;
                }
            }
        }
        if (v2 >= 0) {
            // 0x100003dbc
            result = (int64_t)v15;
        } else {
            // 0x100003dd0
            *v15 = 45;
            result = (int64_t)v15;
        }
    } else {
        int64_t v23 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c70
        _fprintf((struct _IO_FILE *)v23, "base %d too large\n", 66);
        result = 0;
    }
    // 0x100003dec
    if (*(int64_t *)*(int64_t *)0x100004008 != v3) {
        // 0x100003e14
        ___stack_chk_fail();
    }
    // 0x100003e18
    return result;
}

// Address range: 0x100003e28 - 0x100003e64
int64_t function_100003e28(void) {
    // 0x100003e28
    int64_t v1; // bp-40, 0x100003e28
    int64_t v2; // 0x100003e28
    int32_t result = _strtol((char *)v2, (char **)&v1, (int32_t)v2); // 0x100003e48
    return result;
}

// Address range: 0x100003e64 - 0x100003efc
int64_t entry_point(void) {
    // 0x100003e64
    function_100003c0c();
    int64_t v1; // 0x100003e64
    char * v2 = (char *)v1; // 0x100003eb0
    _printf("%lld in base 2: %s\n", 2, v2);
    function_100003c0c();
    _printf("%lld in base 16: %s\n", 16, v2);
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(void) {
    // 0x100003efc
    return ___stack_chk_fail();
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f08
    return _fprintf(stream, format);
}

// Address range: 0x100003f14 - 0x100003f20
int64_t * function_100003f14(int32_t size) {
    // 0x100003f14
    return _malloc(size);
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t * function_100003f20(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f20
    return _memset(s, c, n);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f38
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*  Constraints: input is in the form of (\+|-)?[0-9]+
 *  and without leading zero (0 itself can be as "0" or "+0", but not "-0");
 *  input pointer is realloc'able and may change;
 *  if input has leading + sign, return may or may not keep it.
 *  The constranits conform to sprintf("%+d") and this function's own output.
 */
char * incr(char *s)
{
	int i, begin, tail, len;
	int neg = (*s == '-');
	char tgt = neg ? '0' : '9';

	/* special case: "-1" */
	if (!strcmp(s, "-1")) {
		s[0] = '0', s[1] = '\0';
		return s;
	}

	len = strlen(s);
	begin = (*s == '-' || *s == '+') ? 1 : 0;

	/* find out how many digits need to be changed */
	for (tail = len - 1; tail >= begin && s[tail] == tgt; tail--);

	if (tail < begin && !neg) {
		/* special case: all 9s, string will grow */
		if (!begin) s = realloc(s, len + 2);
		s[0] = '1';
		for (i = 1; i <= len - begin; i++) s[i] = '0';
		s[len + 1] = '\0';
	} else if (tail == begin && neg && s[1] == '1') {
		/* special case: -1000..., so string will shrink */
		for (i = 1; i < len - begin; i++) s[i] = '9';
		s[len - 1] = '\0';
	} else { /* normal case; change tail to all 0 or 9, change prev digit by 1*/
		for (i = len - 1; i > tail; i--)
			s[i] = neg ? '9' : '0';
		s[tail] += neg ? -1 : 1;
	}

	return s;
}

void string_test(const char *s)
{
	char *ret = malloc(strlen(s));
	strcpy(ret, s);

	printf("text: %s\n", ret);
	printf("  ->: %s\n", ret = incr(ret));
	free(ret);
}

int main()
{
	string_test("+0");
	string_test("-1");
	string_test("-41");
	string_test("+41");
	string_test("999");
	string_test("+999");
	string_test("109999999999999999999999999999999999999999");
	string_test("-100000000000000000000000000000000000000000000");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a20(void);
int64_t function_100003dc4(void);
int64_t function_100003ecc(int64_t a1, int64_t a2, int64_t a3);
void function_100003ed8(int64_t * ptr);
int64_t * function_100003ee4(int32_t size);
int32_t function_100003ef0(char * format, ...);
int64_t * function_100003efc(int64_t * ptr, int32_t size);
int32_t function_100003f08(char * s1, char * s2);
int32_t function_100003f14(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a20 - 0x100003dc4
int64_t function_100003a20(void) {
    // 0x100003a20
    int64_t v1; // 0x100003a20
    char * v2 = (char *)v1; // 0x100003a2c
    if (_strcmp(v2, "-1") == 0) {
        // 0x100003a8c
        *v2 = 48;
        *(char *)(v1 + 1) = 0;
        // 0x100003db4
        return (int64_t)v2;
    }
    char v3 = v1;
    int32_t v4 = _strlen(v2); // 0x100003ab0
    bool v5 = v3 == 45 | v3 == 43;
    int32_t v6 = v5;
    int32_t v7 = v4; // 0x100003b18
    v7--;
    while ((v7 - v6) < 0 == (v7 & -((v7 - v6))) < 0) {
        char v8 = *(char *)(v1 + (int64_t)v7); // 0x100003b44
        if ((v3 != 45 ? 57 : 48) != (int32_t)v8) {
            goto lab_0x100003c54;
        }
        v7--;
    }
    if (v3 != 45) {
        char * v9 = v2; // 0x100003bb4
        if (!v5) {
            // 0x100003bbc
            v9 = (char *)_realloc((int64_t *)v1, v4 + 2);
        }
        // 0x100003bdc
        *v9 = 49;
        int32_t v10 = v4 - v6; // 0x100003c00
        int32_t v11 = 1 - v10; // 0x100003c04
        int64_t v12 = (int64_t)v9;
        int32_t v13 = 1; // 0x100003c0c
        if (v11 == 0 || v11 < 0 != (v11 & v10) < 0) {
            *(char *)((int64_t)v13 + v12) = 48;
            int32_t v14 = v13 + 1; // 0x100003c30
            int32_t v15 = v14 - v10; // 0x100003c04
            v13 = v14;
            while (v15 == 0 || v15 < 0 != ((v15 ^ v14) & (v14 ^ v10)) < 0) {
                // 0x100003c14
                *(char *)((int64_t)v13 + v12) = 48;
                v14 = v13 + 1;
                v15 = v14 - v10;
                v13 = v14;
            }
            // 0x100003c3c
            *(char *)(v12 + (int64_t)(v4 + 1)) = 0;
            // 0x100003db4
            return (int64_t)v9;
        }
        // 0x100003c3c
        *(char *)(v12 + (int64_t)(v4 + 1)) = 0;
        // 0x100003db4
        return (int64_t)v9;
    }
  lab_0x100003c54:
    if (v3 == 45 && v7 == v6) {
        // 0x100003c80
        if (*(char *)(v1 + 1) == 49) {
            int32_t v16 = v4 - v6; // 0x100003cb0
            int32_t v17 = 1 - v16; // 0x100003cb4
            int32_t v18 = 1; // 0x100003cbc
            if (v17 < 0 != (v17 & v16) < 0) {
                *(char *)(v1 + (int64_t)v18) = 57;
                int32_t v19 = v18 + 1; // 0x100003ce0
                int32_t v20 = v19 - v16; // 0x100003cb4
                v18 = v19;
                while (v20 < 0 != ((v20 ^ v19) & (v19 ^ v16)) < 0) {
                    // 0x100003cc4
                    *(char *)(v1 + (int64_t)v18) = 57;
                    v19 = v18 + 1;
                    v20 = v19 - v16;
                    v18 = v19;
                }
            }
            // 0x100003cec
            *(char *)(v1 + (int64_t)(v4 - 1)) = 0;
            // 0x100003db4
            return (int64_t)v2;
        }
    }
    int32_t v21 = v4 - 1;
    int32_t v22 = v21 - v7; // 0x100003d1c
    if (v22 != 0 && v22 < 0 == ((v22 ^ v21) & (v7 ^ v21)) < 0) {
        char v23 = v3 != 45 ? 48 : 57; // 0x100003d54
        int32_t v24 = v21;
        *(char *)(v1 + (int64_t)v24) = v23;
        v24--;
        while (v24 - v7 != 0 && v24 - v7 < 0 == ((v24 - v7 ^ v24) & (v24 ^ v7)) < 0) {
            // 0x100003d2c
            *(char *)(v1 + (int64_t)v24) = v23;
            v24--;
        }
    }
    char * v25 = (char *)(v1 + (int64_t)v7); // 0x100003d94
    *v25 = *v25 + (v3 != 45 ? 1 : -1);
    // 0x100003db4
    return (int64_t)v2;
}

// Address range: 0x100003dc4 - 0x100003e44
int64_t function_100003dc4(void) {
    // 0x100003dc4
    int64_t v1; // 0x100003dc4
    char * v2 = (char *)v1; // 0x100003dd8
    ___strcpy_chk((int64_t)_malloc(_strlen(v2)), v1, -1);
    _printf("text: %s\n", v2);
    int64_t v3 = function_100003a20(); // 0x100003e10
    _printf("  ->: %s\n", v2);
    _free((int64_t *)v3);
    return &g1;
}

// Address range: 0x100003e44 - 0x100003ecc
int64_t entry_point(void) {
    // 0x100003e44
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    return 0;
}

// Address range: 0x100003ecc - 0x100003ed8
int64_t function_100003ecc(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ecc
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ed8 - 0x100003ee4
void function_100003ed8(int64_t * ptr) {
    // 0x100003ed8
    _free(ptr);
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t * function_100003ee4(int32_t size) {
    // 0x100003ee4
    return _malloc(size);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(char * format, ...) {
    // 0x100003ef0
    return _printf(format);
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int64_t * ptr, int32_t size) {
    // 0x100003efc
    return _realloc(ptr, size);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * s1, char * s2) {
    // 0x100003f08
    return _strcmp(s1, s2);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * s) {
    // 0x100003f14
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>

typedef unsigned int uint;

/* the sequence, 0-th member is 0 */
uint f(uint n)
{
	return n < 2 ? n : (n&1) ? f(n/2) + f(n/2 + 1) : f(n/2);
}

uint gcd(uint a, uint b)
{
	return a ? a < b ? gcd(b%a, a) : gcd(a%b, b) : b;
}

void find(uint from, uint to)
{
	do {
		uint n;
		for (n = 1; f(n) != from ; n++);
		printf("%3u at Stern #%u.\n", from, n);
	} while (++from <= to);
}

int main(void)
{
	uint n;
	for (n = 1; n < 16; n++) printf("%u ", f(n));
	puts("are the first fifteen.");

	find(1, 10);
	find(100, 0);

	for (n = 1; n < 1000 && gcd(f(n), f(n+1)) == 1; n++);
	printf(n == 1000 ? "All GCDs are 1.\n" : "GCD of #%d and #%d is not 1", n, n+1);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bbc(void);
int64_t function_100003c74(void);
int64_t function_100003d24(void);
int32_t function_100003f34(char * format, ...);
int32_t function_100003f40(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bbc - 0x100003c74
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // 0x100003bbc
    uint32_t v2 = (int32_t)v1; // 0x100003bc8
    int64_t v3; // 0x100003bbc
    if (v2 < 2) {
        // 0x100003c64
        return v3 & 0xffffffff;
    }
    int64_t v4 = function_100003bbc();
    v3 = v4;
    if (v2 % 2 != 0) {
        // 0x100003c00
        v3 = function_100003bbc() + v4;
    }
    // 0x100003c64
    return v3 & 0xffffffff;
}

// Address range: 0x100003c74 - 0x100003d24
int64_t function_100003c74(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    int64_t v2; // 0x100003c74
    if ((int32_t)v2 != 0) {
        // 0x100003c9c
        v1 = function_100003c74();
    }
    // 0x100003d14
    return v1 & 0xffffffff;
}

// Address range: 0x100003d24 - 0x100003dd0
int64_t function_100003d24(void) {
    // 0x100003d24
    int64_t v1; // 0x100003d24
    uint32_t v2 = (int32_t)v1; // 0x100003d34
    int32_t v3 = v1; // 0x100003d38
    while (v3 != (int32_t)function_100003bbc()) {
        // continue -> 0x100003d48
    }
    int32_t result = _printf("%3u at Stern #%u.\n", v2, (int32_t)v1); // 0x100003d9c
    v3++;
    while (v3 == v2 || v3 < v2) {
        // 0x100003d3c
        while (v3 != (int32_t)function_100003bbc()) {
            // continue -> 0x100003d48
        }
        // 0x100003d78
        result = _printf("%3u at Stern #%u.\n", v2, (int32_t)v1);
        v3++;
    }
    // 0x100003dc4
    return result;
}

// Address range: 0x100003dd0 - 0x100003f34
int64_t entry_point(void) {
    for (int32_t i = 1; i < 16; i++) {
        // 0x100003e00
        function_100003bbc();
        int64_t v1; // 0x100003dd0
        _printf("%u ", (int32_t)v1);
    }
    // 0x100003e34
    _puts("are the first fifteen.");
    function_100003d24();
    function_100003d24();
    int32_t v2 = 1; // 0x100003ecc
    function_100003bbc();
    function_100003bbc();
    int32_t v3 = v2; // 0x100003ebc
    while ((int32_t)function_100003c74() == 1) {
        // 0x100003ec8
        v2++;
        v3 = 1000;
        if (v2 >= 1000) {
            // break -> 0x100003ed8
            break;
        }
        function_100003bbc();
        function_100003bbc();
        v3 = v2;
    }
    // 0x100003ed8
    _printf(v3 != 1000 ? "GCD of #%d and #%d is not 1" : "All GCDs are 1.\n");
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * s) {
    // 0x100003f40
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdbool.h>

int proper_divisors(const int n, bool print_flag)
{
    int count = 0;

    for (int i = 1; i < n; ++i) {
        if (n % i == 0) {
            count++;
            if (print_flag)
                printf("%d ", i);
        }
    }

    if (print_flag)
        printf("\n");

    return count;
}

int main(void)
{
    for (int i = 1; i <= 10; ++i) {
        printf("%d: ", i);
        proper_divisors(i, true);
    }

    int max = 0;
    int max_i = 1;

    for (int i = 1; i <= 20000; ++i) {
        int v = proper_divisors(i, false);
        if (v >= max) {
            max = v;
            max_i = i;
        }
    }

    printf("%d with %d divisors\n", max_i, max);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d74(void);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d74 - 0x100003e54
int64_t function_100003d74(void) {
    // 0x100003d74
    int64_t v1; // 0x100003d74
    int32_t v2 = v1; // 0x100003d80
    uint32_t v3 = (int32_t)v1 % 2; // 0x100003d88
    int32_t v4 = 1 - v2; // 0x100003da4
    int32_t result = 0; // 0x100003dac
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v5 = 1; // 0x100003e1c
        int32_t v6 = 0;
        int32_t v7 = v6; // 0x100003dd0
        int32_t v8; // 0x100003ddc
        if (v2 % v5 == 0) {
            // 0x100003dd8
            v8 = v6 + 1;
            v7 = v8;
            if (v3 != 0) {
                // 0x100003df0
                _printf("%d ", v1);
                v7 = v8;
            }
        }
        int32_t v9 = v7;
        v5++;
        int32_t v10 = v5 - v2; // 0x100003da4
        result = v9;
        while (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003db4
            v6 = v9;
            v7 = v6;
            if (v2 % v5 == 0) {
                // 0x100003dd8
                v8 = v6 + 1;
                v7 = v8;
                if (v3 != 0) {
                    // 0x100003df0
                    _printf("%d ", v1);
                    v7 = v8;
                }
            }
            // 0x100003e18
            v9 = v7;
            v5++;
            v10 = v5 - v2;
            result = v9;
        }
    }
    // 0x100003e28
    if (v3 != 0) {
        // 0x100003e34
        _printf("\n");
    }
    // 0x100003e44
    return result;
}

// Address range: 0x100003e54 - 0x100003f7c
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e54
    _printf("%d: ", v2);
    function_100003d74();
    int32_t v3 = v1 + 1; // 0x100003eb8
    int32_t v4 = v1 - 9; // 0x100003e74
    v2 = 1;
    while (v4 == 0 || v4 < 0 != (8 - v1 & v3) < 0) {
        // 0x100003e84
        v1 = v3;
        _printf("%d: ", v2);
        function_100003d74();
        v3 = v1 + 1;
        v4 = v1 - 9;
        v2 = 1;
    }
    int32_t v5 = 1;
    function_100003d74();
    int32_t v6 = v5 + 1; // 0x100003f38
    int32_t v7 = v5 - 0x4e1f; // 0x100003ee0
    while (v7 == 0 || v7 < 0 != (0x4e1e - v5 & v6) < 0) {
        // 0x100003ef0
        v5 = v6;
        function_100003d74();
        v6 = v5 + 1;
        v7 = v5 - 0x4e1f;
    }
    // 0x100003f44
    int64_t v8; // 0x100003e54
    _printf("%d with %d divisors\n", 0, v8);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

void recurse(unsigned int i)
{
  printf("%d\n", i);
  recurse(i+1); // 523756
}

int main()
{
  recurse(0);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f28(void);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f28 - 0x100003f6c
int64_t function_100003f28(void) {
    // 0x100003f28
    int64_t v1; // 0x100003f28
    _printf("%d\n", v1);
    return function_100003f28();
}

// Address range: 0x100003f6c - 0x100003f98
int64_t entry_point(void) {
    // 0x100003f6c
    function_100003f28();
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <arpa/inet.h>

int main()
{
  if (htonl(1) == 1)
    printf("big endian\n");
  else
    printf("little endian\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f6c - 0x100003f8c
int64_t entry_point(int64_t a1) {
    // 0x100003f6c
    _printf("little endian\n");
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>

bool damm(unsigned char *input, size_t length) {
    static const unsigned char table[10][10] = {
        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},
    };

    unsigned char interim = 0;
    for (size_t i = 0; i < length; i++) {
        interim = table[interim][input[i]];
    }
    return interim == 0;
}

int main() {
    unsigned char input[4] = {5, 7, 2, 4};
    puts(damm(input, 4) ? "Checksum correct" : "Checksum incorrect");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e18(void);
int32_t function_100003f08(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x608090507010300; // 0x100003f14

// ------- Dynamically Linked Functions Without Header --------

int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e18 - 0x100003ea4
int64_t function_100003e18(void) {
    // 0x100003e18
    int64_t v1; // 0x100003e18
    if (v1 == 0) {
        // 0x100003e8c
        return 1;
    }
    int64_t v2 = 0; // 0x100003e40
    unsigned char v3 = *(char *)(v2 + v1); // 0x100003e68
    unsigned char v4 = *(char *)((int64_t)&g1 + (int64_t)v3); // 0x100003e70
    v2++;
    int64_t v5 = v4; // 0x100003e40
    while (v2 != v1) {
        // 0x100003e48
        v3 = *(char *)(v2 + v1);
        v4 = *(char *)(10 * v5 + (int64_t)&g1 + (int64_t)v3);
        v2++;
        v5 = v4;
    }
    // 0x100003e8c
    return v4 == 0;
}

// Address range: 0x100003ea4 - 0x100003f08
int64_t entry_point(void) {
    uint64_t v1 = function_100003e18(); // 0x100003ed4
    int64_t v2 = v1 % 2 == 0 ? (int64_t)"Checksum incorrect" : (int64_t)"Checksum correct"; // 0x100003ef0
    _puts((char *)v2);
    return 0;
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * s) {
    // 0x100003f08
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include<stdio.h>
#include<string.h>
#include<stdlib.h>

int main()
{
    char str[100]="my String";
    char *cstr="Changed ";
    char *dup;
    sprintf(str,"%s%s",cstr,(dup=strdup(str)));
    free(dup);
    printf("%s\n",str);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ee8(int64_t a1, int32_t a2, int64_t a3, char * a4);
int64_t function_100003ef4(int64_t a1);
void function_100003f00(int64_t * ptr);
int64_t * function_100003f0c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f18(char * format, ...);
char * function_100003f24(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t a1, int32_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e00 - 0x100003ee8
int64_t entry_point(void) {
    // 0x100003e00
    int64_t v1; // bp-124, 0x100003e00
    _memcpy(&v1, (int64_t *)"my String", 100);
    char * v2 = _strdup((char *)&v1); // 0x100003e5c
    ___sprintf_chk((int64_t)&v1, 0, 100, "%s%s");
    _free((int64_t *)v2);
    int32_t v3 = _printf("%s\n", NULL); // 0x100003eb0
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003ec0
    if (v4 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003ed4
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003ed8
    return 0;
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(int64_t a1, int32_t a2, int64_t a3, char * a4) {
    // 0x100003ee8
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1) {
    // 0x100003ef4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f00 - 0x100003f0c
void function_100003f00(int64_t * ptr) {
    // 0x100003f00
    _free(ptr);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t * function_100003f0c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f0c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// Address range: 0x100003f24 - 0x100003f30
char * function_100003f24(char * s) {
    // 0x100003f24
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t condm = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int bang = 0;

#define WAITBANG() do { \
   pthread_mutex_lock(&condm); \
   while( bang == 0 ) \
   { \
      pthread_cond_wait(&cond, &condm); \
   } \
   pthread_mutex_unlock(&condm); } while(0);\

void *t_enjoy(void *p)
{
  WAITBANG();
  printf("Enjoy\n");
  pthread_exit(0);
}

void *t_rosetta(void *p)
{
  WAITBANG();
  printf("Rosetta\n");
  pthread_exit(0);
}

void *t_code(void *p)
{
  WAITBANG();
  printf("Code\n");
  pthread_exit(0);
}

typedef void *(*threadfunc)(void *);
int main()
{
   int i;
   pthread_t a[3];
   threadfunc p[3] = {t_enjoy, t_rosetta, t_code};

   for(i=0;i<3;i++)
   {
     pthread_create(&a[i], NULL, p[i], NULL);
   }
   sleep(1);
   bang = 1;
   pthread_cond_broadcast(&cond);
   for(i=0;i<3;i++)
   {
     pthread_join(a[i], NULL);
   }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c80(void);
int64_t function_100003f18(int64_t a1);
int32_t function_100003f24(char * format, ...);
int32_t function_100003f30(int64_t * cond);
int32_t function_100003f3c(int64_t * cond, int64_t * mutex);
int32_t function_100003f48(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
void function_100003f54(int64_t * retval);
int32_t function_100003f60(int32_t th, int64_t ** thread_return);
int32_t function_100003f6c(int64_t * mutex);
int32_t function_100003f78(int64_t * mutex);
int32_t function_100003f84(int32_t seconds);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.22507385851485347181302194380861076e-308L; // 0x100004058
int64_t g2 = 0x32aaaba7; // 0x100008000
int64_t g3 = 0x3cb0b1bb; // 0x100008040
int32_t g4 = -0x1120531; // 0x100008070
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _pthread_cond_broadcast(int64_t * a1);
int32_t _pthread_cond_wait(int64_t * a1, int64_t * a2);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
void _pthread_exit(int64_t * a1);
int32_t _pthread_join(int32_t a1, int64_t ** a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c80 - 0x100003de8
int64_t function_100003c80(void) {
    // 0x100003c80
    _pthread_mutex_lock(&g2);
    if (*(int32_t *)((int64_t)&g2 + 112) == 0) {
        _pthread_cond_wait(&g3, &g2);
        while (*(int32_t *)((int64_t)&g2 + 112) == 0) {
            // 0x100003cbc
            _pthread_cond_wait(&g3, &g2);
        }
    }
    // 0x100003cd4
    _pthread_mutex_unlock(&g2);
    _printf("Enjoy\n");
    _pthread_exit(NULL);
    _pthread_mutex_lock(&g2);
    if (g4 == 0) {
        _pthread_cond_wait(&g3, &g2);
        while (g4 == 0) {
            // 0x100003d34
            _pthread_cond_wait(&g3, &g2);
        }
    }
    // 0x100003d4c
    _pthread_mutex_unlock(&g2);
    _printf("Rosetta\n");
    _pthread_exit(NULL);
    _pthread_mutex_lock(&g2);
    if (g4 != 0) {
        // 0x100003dc4
        _pthread_mutex_unlock(&g2);
        _printf("Code\n");
        _pthread_exit(NULL);
        return &g5;
    }
    _pthread_cond_wait(&g3, &g2);
    while (g4 == 0) {
        // 0x100003dac
        _pthread_cond_wait(&g3, &g2);
    }
    // 0x100003dc4
    _pthread_mutex_unlock(&g2);
    _printf("Code\n");
    _pthread_exit(NULL);
    return &g5;
}

// Address range: 0x100003de8 - 0x100003f18
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dfc
    float128_t v2 = g1; // bp-80, 0x100003e14
    int64_t v3; // bp-48, 0x100003de8
    int64_t v4 = &v3;
    for (int64_t i = 0; i < 3; i++) {
        int64_t v5 = 8 * i; // 0x100003e44
        int64_t v6 = *(int64_t *)(v5 + (int64_t)&v2); // 0x100003e50
        _pthread_create((int32_t *)(v5 + v4), NULL, (int64_t * (*)(int64_t *))v6, NULL);
    }
    // 0x100003e74
    _sleep(1);
    g4 = 1;
    _pthread_cond_broadcast(&g3);
    int32_t v7; // 0x100003ec4
    for (int64_t i = 0; i < 3; i++) {
        // 0x100003eb4
        v7 = _pthread_join((int32_t)*(int64_t *)(8 * i + v4), NULL);
    }
    // 0x100003edc
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f04
        ___stack_chk_fail((int64_t)v7);
    }
    // 0x100003f08
    return 0;
}

// Address range: 0x100003f18 - 0x100003f24
int64_t function_100003f18(int64_t a1) {
    // 0x100003f18
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int64_t * cond) {
    // 0x100003f30
    return _pthread_cond_broadcast(cond);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(int64_t * cond, int64_t * mutex) {
    // 0x100003f3c
    return _pthread_cond_wait(cond, mutex);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003f48
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * retval) {
    // 0x100003f54
    _pthread_exit(retval);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t th, int64_t ** thread_return) {
    // 0x100003f60
    return _pthread_join(th, thread_return);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int64_t * mutex) {
    // 0x100003f6c
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int64_t * mutex) {
    // 0x100003f78
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(int32_t seconds) {
    // 0x100003f84
    return _sleep(seconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdbool.h>
#include <stdio.h>
#include <string.h>

void swap(char* p1, char* p2, size_t size) {
    for (; size-- > 0; ++p1, ++p2) {
        char tmp = *p1;
        *p1 = *p2;
        *p2 = tmp;
    }
}

void cocktail_sort(void* base, size_t count, size_t size,
                   int (*cmp)(const void*, const void*)) {
    char* begin = base;
    char* end = base + size * count;
    if (end == begin)
        return;
    bool swapped = true;
    for (end -= size; swapped; ) {
        swapped = false;
        for (char* p = begin; p < end; p += size) {
            char* q = p + size;
            if (cmp(p, q) > 0) {
                swap(p, q, size);
                swapped = true;
            }
        }
        if (!swapped)
            break;
        swapped = false;
        for (char* p = end; p > begin; p -= size) {
            char* q = p - size;
            if (cmp(q, p) > 0) {
                swap(p, q, size);
                swapped = true;
            }
        }
    }
}

int string_compare(const void* p1, const void* p2) {
    const char* const* s1 = p1;
    const char* const* s2 = p2;
    return strcmp(*s1, *s2);
}

void print(const char** a, size_t len) {
    for (size_t i = 0; i < len; ++i)
        printf("%s ", a[i]);
    printf("\n");
}

int main() {
    const char* a[] = { "one", "two", "three", "four", "five",
        "six", "seven", "eight", "nine", "ten" };
    const size_t len = sizeof(a)/sizeof(a[0]);
    printf("before: ");
    print(a, len);
    cocktail_sort(a, len, sizeof(char*), string_compare);
    printf("after: ");
    print(a, len);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b6c(void);
int64_t function_100003bec(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003da4(void);
int64_t function_100003de8(void);
int64_t function_100003f28(int64_t a1);
int64_t * function_100003f34(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f40(char * format, ...);
int32_t function_100003f4c(char * s1, char * s2);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b6c - 0x100003bec
int64_t function_100003b6c(void) {
    // 0x100003b6c
    int64_t result; // 0x100003b6c
    if (result == 0) {
        // 0x100003be4
        return result;
    }
    int64_t v1; // 0x100003b6c
    char * v2 = (char *)v1;
    int64_t v3; // 0x100003b6c
    char * v4 = (char *)v3;
    int64_t v5; // 0x100003b6c
    int64_t v6 = v5 - 1; // 0x100003b84
    *v2 = *v4;
    *v4 = *v2;
    v1++;
    v3++;
    while (v6 != 0) {
        // 0x100003b9c
        v2 = (char *)v1;
        v4 = (char *)v3;
        v6--;
        *v2 = *v4;
        *v4 = *v2;
        v1++;
        v3++;
    }
    // 0x100003be4
    return result;
}

// Address range: 0x100003bec - 0x100003da4
int64_t function_100003bec(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003bec
    int64_t result; // 0x100003bec
    return result;
}

// Address range: 0x100003da4 - 0x100003de8
int64_t function_100003da4(void) {
    // 0x100003da4
    int64_t v1; // 0x100003da4
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003de8 - 0x100003e68
int64_t function_100003de8(void) {
    // 0x100003de8
    int64_t v1; // 0x100003de8
    if (v1 == 0) {
        // 0x100003e50
        return _printf("\n");
    }
    int64_t v2 = 0; // 0x100003e44
    _printf("%s ", (char *)v1);
    while (v2 + 1 != v1) {
        // 0x100003e1c
        v2++;
        _printf("%s ", (char *)v1);
    }
    // 0x100003e50
    return _printf("\n");
}

// Address range: 0x100003e68 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003e68
    int64_t v1; // bp-104, 0x100003e68
    _memcpy(&v1, (int64_t *)"^?", 80);
    _printf("before: ");
    function_100003de8();
    function_100003bec((int64_t)&g1, (int64_t)&g1, (int64_t)&g1, (int64_t)&g1);
    _printf("after: ");
    int64_t v2 = function_100003de8(); // 0x100003ef0
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f00
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f14
        ___stack_chk_fail(v2);
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1) {
    // 0x100003f28
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f34 - 0x100003f40
int64_t * function_100003f34(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f34
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _printf(format);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * s1, char * s2) {
    // 0x100003f4c
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <math.h>
#include <string.h>

#define N 2200

int main(int argc, char **argv){
   int a,b,c,d;
   int r[N+1];
   memset(r,0,sizeof(r));	// zero solution array
   for(a=1; a<=N; a++){
      for(b=a; b<=N; b++){
	 int aabb;
	 if(a&1 && b&1) continue;  // for positive odd a and b, no solution.
	 aabb=a*a + b*b;
	 for(c=b; c<=N; c++){
	    int aabbcc=aabb + c*c;
	    d=(int)sqrt((float)aabbcc);
	    if(aabbcc == d*d && d<=N) r[d]=1;	// solution
	 }
      }
   }
   for(a=1; a<=N; a++)
      if(!r[a]) printf("%d ",a);	// print non solution
   printf("\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f7c(int64_t a1);
void function_100003f88(int64_t * s, int32_t n);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d10 - 0x100003d2c
int64_t entry_point(void) {
    // 0x100003d10
    return ___chkstk_darwin();
}

// Address range: 0x100003d2c - 0x100003f7c
int64_t function_100003d2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d2c
    int64_t v1; // 0x100003d2c
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003d40
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int64_t v3; // bp-8812, 0x100003d2c
    _bzero(&v3, 0x2264);
    int64_t v4 = &v3;
    int32_t v5 = 1;
    int32_t v6 = v5 - 2200; // 0x100003d8c
    int32_t v7; // 0x100003d2c
    int32_t v8; // 0x100003d2c
    int32_t v9; // 0x100003d2c
    int32_t v10; // 0x100003de0
    int32_t v11; // 0x100003df8
    int32_t v12; // 0x100003e9c
    int32_t v13; // 0x100003e18
    int32_t v14; // 0x100003e30
    int32_t v15; // 0x100003e5c
    int32_t v16; // 0x100003e88
    int32_t v17; // 0x100003df8
    int32_t v18; // 0x100003d2c
    if (v6 == 0 || v6 < 0 != (2199 - v5 & v5) < 0) {
        // 0x100003d9c
        v18 = v5 * v5;
        v9 = v5;
        if ((v5 % 2 & v9) == 0) {
            // 0x100003dc8
            v10 = v9 * v9 + v18;
            v11 = v9 - 2200;
            v7 = v9;
            if (v11 == 0 || v11 < 0 != (2199 - v9 & v9) < 0) {
                v8 = v7;
                v13 = v10 + v8 * v8;
                v14 = sqrt((float64_t)(float32_t)v13);
                if (v13 == v14 * v14) {
                    // 0x100003e58
                    v15 = v14 - 2200;
                    if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                        // 0x100003e6c
                        *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                    }
                }
                // 0x100003e84
                v16 = v8 + 1;
                v17 = v8 - 2199;
                while (v17 == 0 || v17 < 0 != (2198 - v8 & v16) < 0) {
                    // 0x100003e08
                    v8 = v16;
                    v13 = v10 + v8 * v8;
                    v14 = sqrt((float64_t)(float32_t)v13);
                    if (v13 == v14 * v14) {
                        // 0x100003e58
                        v15 = v14 - 2200;
                        if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                            // 0x100003e6c
                            *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                        }
                    }
                    // 0x100003e84
                    v16 = v8 + 1;
                    v17 = v8 - 2199;
                }
            }
        }
        // 0x100003e98
        v12 = v9 + 1;
        while (v9 == 2199 || v9 < 2199 != (2198 - v9 & v12) < 0) {
            // 0x100003d9c
            v9 = v12;
            if ((v5 % 2 & v9) == 0) {
                // 0x100003dc8
                v10 = v9 * v9 + v18;
                v11 = v9 - 2200;
                v7 = v9;
                if (v11 == 0 || v11 < 0 != (2199 - v9 & v9) < 0) {
                    v8 = v7;
                    v13 = v10 + v8 * v8;
                    v14 = sqrt((float64_t)(float32_t)v13);
                    if (v13 == v14 * v14) {
                        // 0x100003e58
                        v15 = v14 - 2200;
                        if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                            // 0x100003e6c
                            *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                        }
                    }
                    // 0x100003e84
                    v16 = v8 + 1;
                    v17 = v8 - 2199;
                    while (v17 == 0 || v17 < 0 != (2198 - v8 & v16) < 0) {
                        // 0x100003e08
                        v8 = v16;
                        v13 = v10 + v8 * v8;
                        v14 = sqrt((float64_t)(float32_t)v13);
                        if (v13 == v14 * v14) {
                            // 0x100003e58
                            v15 = v14 - 2200;
                            if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                                // 0x100003e6c
                                *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                            }
                        }
                        // 0x100003e84
                        v16 = v8 + 1;
                        v17 = v8 - 2199;
                    }
                }
            }
            // 0x100003e98
            v12 = v9 + 1;
        }
    }
    int32_t v19 = v5 + 1; // 0x100003eb0
    int32_t v20 = v5 - 2199; // 0x100003d6c
    while (v20 == 0 || v20 < 0 != (2198 - v5 & v19) < 0) {
        // 0x100003d88
        v5 = v19;
        v6 = v5 - 2200;
        if (v6 == 0 || v6 < 0 != (2199 - v5 & v5) < 0) {
            // 0x100003d9c
            v18 = v5 * v5;
            v9 = v5;
            if ((v5 % 2 & v9) == 0) {
                // 0x100003dc8
                v10 = v9 * v9 + v18;
                v11 = v9 - 2200;
                v7 = v9;
                if (v11 == 0 || v11 < 0 != (2199 - v9 & v9) < 0) {
                    v8 = v7;
                    v13 = v10 + v8 * v8;
                    v14 = sqrt((float64_t)(float32_t)v13);
                    if (v13 == v14 * v14) {
                        // 0x100003e58
                        v15 = v14 - 2200;
                        if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                            // 0x100003e6c
                            *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                        }
                    }
                    // 0x100003e84
                    v16 = v8 + 1;
                    v17 = v8 - 2199;
                    while (v17 == 0 || v17 < 0 != (2198 - v8 & v16) < 0) {
                        // 0x100003e08
                        v8 = v16;
                        v13 = v10 + v8 * v8;
                        v14 = sqrt((float64_t)(float32_t)v13);
                        if (v13 == v14 * v14) {
                            // 0x100003e58
                            v15 = v14 - 2200;
                            if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                                // 0x100003e6c
                                *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                            }
                        }
                        // 0x100003e84
                        v16 = v8 + 1;
                        v17 = v8 - 2199;
                    }
                }
            }
            // 0x100003e98
            v12 = v9 + 1;
            while (v9 == 2199 || v9 < 2199 != (2198 - v9 & v12) < 0) {
                // 0x100003d9c
                v9 = v12;
                if ((v5 % 2 & v9) == 0) {
                    // 0x100003dc8
                    v10 = v9 * v9 + v18;
                    v11 = v9 - 2200;
                    v7 = v9;
                    if (v11 == 0 || v11 < 0 != (2199 - v9 & v9) < 0) {
                        v8 = v7;
                        v13 = v10 + v8 * v8;
                        v14 = sqrt((float64_t)(float32_t)v13);
                        if (v13 == v14 * v14) {
                            // 0x100003e58
                            v15 = v14 - 2200;
                            if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                                // 0x100003e6c
                                *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                            }
                        }
                        // 0x100003e84
                        v16 = v8 + 1;
                        v17 = v8 - 2199;
                        while (v17 == 0 || v17 < 0 != (2198 - v8 & v16) < 0) {
                            // 0x100003e08
                            v8 = v16;
                            v13 = v10 + v8 * v8;
                            v14 = sqrt((float64_t)(float32_t)v13);
                            if (v13 == v14 * v14) {
                                // 0x100003e58
                                v15 = v14 - 2200;
                                if (v15 == 0 || v15 < 0 != (2199 - v14 & v14) < 0) {
                                    // 0x100003e6c
                                    *(int32_t *)(4 * (int64_t)v14 + v4) = 1;
                                }
                            }
                            // 0x100003e84
                            v16 = v8 + 1;
                            v17 = v8 - 2199;
                        }
                    }
                }
                // 0x100003e98
                v12 = v9 + 1;
            }
        }
        // 0x100003eac
        v19 = v5 + 1;
        v20 = v5 - 2199;
    }
    int32_t v21 = 1;
    if (*(int32_t *)(4 * (int64_t)v21 + v4) == 0) {
        // 0x100003ef8
        _printf("%d ", 0x2264);
    }
    int32_t v22 = v21 + 1; // 0x100003f20
    int32_t v23 = v21 - 2199; // 0x100003ecc
    while (v23 == 0 || v23 < 0 != (2198 - v21 & v22) < 0) {
        // 0x100003edc
        v21 = v22;
        if (*(int32_t *)(4 * (int64_t)v21 + v4) == 0) {
            // 0x100003ef8
            _printf("%d ", 0x2264);
        }
        // 0x100003f1c
        v22 = v21 + 1;
        v23 = v21 - 2199;
    }
    int32_t v24 = _printf((char *)0x100003fa4); // 0x100003f34
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003f60
        ___stack_chk_fail((int64_t)v24);
    }
    // 0x100003f64
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t function_100003f7c(int64_t a1) {
    // 0x100003f7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f88 - 0x100003f94
void function_100003f88(int64_t * s, int32_t n) {
    // 0x100003f88
    _bzero(s, n);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int longer(const char *p, const char *q) {
        while (*p && *q) p = &p[1], q = &q[1];
        return *p;
}

int main() {
        char line[100000];
        char buf[1100001];
        char *linend= &line[99999];
        char *bufend= &buf[1000000];
        char *last = buf;
        char *next = buf;

        memset(line, 1, 100000);
        memset(buf, 1, 1100001);
        buf[0]= buf[1100000]= 0;
        while (fgets(line, 100000, stdin)) {
                if (!*linend) exit(1);
                if (longer(last, line)) continue;
                if (!longer(bufend, line)) exit(1);
                if (longer(line, last)) next = buf;
                last = next;
                strcpy(next, line);
                while (*next) next = &next[1];
        }

        printf("%s", buf);
        exit(0);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ce8(void);
int64_t function_100003d88(void);
int64_t function_100003f60(int64_t a1, int64_t * a2, int64_t a3);
void function_100003f6c(int32_t status);
char * function_100003f78(char * s, int32_t n, struct _IO_FILE * stream);
int64_t * function_100003f84(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f90(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___strcpy_chk(int64_t a1, int64_t * a2, int64_t a3);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ce8 - 0x100003d68
int64_t function_100003ce8(void) {
    // 0x100003ce8
    int64_t v1; // 0x100003ce8
    char v2 = *(char *)v1; // 0x100003cfc
    if (v2 == 0) {
        // 0x100003d58
        return 0;
    }
    // 0x100003d30
    if (*(char *)v1 == 0) {
        // 0x100003d58
        return (int64_t)v2 & 0xffffffff;
    }
    int64_t v3; // 0x100003ce8
    int64_t v4 = v3 + 1; // 0x100003d40
    char v5 = *(char *)v4; // 0x100003cfc
    char v6 = 0; // 0x100003d10
    while (v5 != 0) {
        // 0x100003d30
        int64_t v7; // 0x100003ce8
        int64_t v8 = v7 + 1; // 0x100003d4c
        v7 = v8;
        v6 = v5;
        if (*(char *)v8 == 0) {
            // break -> 0x100003d58
            break;
        }
        v4++;
        v5 = *(char *)v4;
        v6 = 0;
    }
    // 0x100003d58
    return (int64_t)v6 & 0xffffffff;
}

// Address range: 0x100003d68 - 0x100003d88
int64_t entry_point(void) {
    // 0x100003d68
    return ___chkstk_darwin();
}

// Address range: 0x100003d88 - 0x100003f60
int64_t function_100003d88(void) {
    // 0x100003d88
    int64_t v1; // 0x100003d88
    *(int64_t *)(v1 - 24) = *(int64_t *)*(int64_t *)0x100004008;
    int64_t v2; // bp-100008, 0x100003d88
    _memset(&v2, 1, 0x186a0);
    int64_t v3; // bp-1200009, 0x100003d88
    _memset(&v3, 1, 0x10c8e1);
    *(char *)((int64_t)&v3 + 0x10c8e0) = 0;
    v3 = 0;
    char * v4 = (char *)&v3; // 0x100003e28
    while (true) {
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e34
        if (_fgets((char *)&v2, 0x186a0, (struct _IO_FILE *)v5) == NULL) {
            // break (via goto) -> 0x100003f40
            goto lab_0x100003f40;
        }
        // 0x100003e5c
        int64_t v6; // bp-9, 0x100003d88
        if (*(char *)&v6 == 0) {
            // 0x100003e74
            _exit(1);
            // UNREACHABLE
        }
        // 0x100003e2c
        while ((int32_t)function_100003ce8() != 0) {
            // 0x100003e2c
            v5 = *(int64_t *)*(int64_t *)0x100004010;
            if (_fgets((char *)&v2, 0x186a0, (struct _IO_FILE *)v5) == NULL) {
                // break (via goto) -> 0x100003f40
                goto lab_0x100003f40;
            }
            // 0x100003e5c
            if (*(char *)&v6 == 0) {
                // 0x100003e74
                _exit(1);
                // UNREACHABLE
            }
        }
        // 0x100003ea0
        if ((int32_t)function_100003ce8() == 0) {
            // 0x100003ec0
            _exit(1);
            // UNREACHABLE
        }
        int64_t v7 = function_100003ce8(); // 0x100003ed4
        char * v8 = (int32_t)v7 == 0 ? v4 : (char *)&v3;
        ___strcpy_chk((int64_t)v8, &v2, -1);
        v4 = v8;
        char * v9 = v8; // 0x100003f24
        if (*v8 != 0) {
            char * v10 = (char *)((int64_t)v9 + 1);
            v4 = v10;
            v9 = v10;
            while (*v10 != 0) {
                // 0x100003f2c
                v10 = (char *)((int64_t)v9 + 1);
                v4 = v10;
                v9 = v10;
            }
        }
    }
  lab_0x100003f40:
    // 0x100003f40
    _printf("%s", (char *)0x186a0);
    _exit(0);
    return &g1;
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t function_100003f60(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x100003f60
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f6c - 0x100003f78
void function_100003f6c(int32_t status) {
    // 0x100003f6c
    _exit(status);
}

// Address range: 0x100003f78 - 0x100003f84
char * function_100003f78(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f78
    return _fgets(s, n, stream);
}

// Address range: 0x100003f84 - 0x100003f90
int64_t * function_100003f84(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f84
    return _memset(s, c, n);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

char* addSuffix(int num, char* buf, size_t len)
{
    char *suffixes[4] = { "th", "st", "nd", "rd" };
    int i;

    switch (num % 10)
    {
        case 1 : i = (num % 100 == 11) ? 0 : 1;
	         break;
        case 2 : i = (num % 100 == 12) ? 0 : 2;
                 break;
        case 3 : i = (num % 100 == 13) ? 0 : 3;
                 break;
        default: i = 0;
    };

    snprintf(buf, len, "%d%s", num, suffixes[i]);
    return buf;
}

int main(void)
{
    int i;

    printf("Set [0,25]:\n");
    for (i = 0; i < 26; i++)
    {
        char s[5];
        printf("%s ", addSuffix(i, s, 5));
    }
    putchar('\n');

    printf("Set [250,265]:\n");
    for (i = 250; i < 266; i++)
    {
        char s[6];
        printf("%s ", addSuffix(i, s, 6));
    }
    putchar('\n');

    printf("Set [1000,1025]:\n");
    for (i = 1000; i < 1026; i++)
    {
        char s[7];
        printf("%s ", addSuffix(i, s, 7));
    }
    putchar('\n');

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c24(void);
int64_t function_100003f34(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int64_t function_100003f40(int64_t a1);
int32_t function_100003f4c(char * format, ...);
int32_t function_100003f58(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___snprintf_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c24 - 0x100003dd4
int64_t function_100003c24(void) {
    // 0x100003c24
    int64_t result; // 0x100003c24
    int64_t v1 = ___snprintf_chk(result, result, 0, -1, "%d%s"); // 0x100003d94
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003dac
    if (v2 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003dc0
        ___stack_chk_fail(v1);
    }
    // 0x100003dc4
    return result;
}

// Address range: 0x100003dd4 - 0x100003f34
int64_t entry_point(void) {
    // 0x100003dd4
    _printf("Set [0,25]:\n");
    for (int32_t i = 0; i < 26; i++) {
        // 0x100003e0c
        function_100003c24();
        int64_t v1; // bp-29, 0x100003dd4
        _printf("%s ", &v1);
    }
    // 0x100003e44
    _putchar(10);
    _printf("Set [250,265]:\n");
    for (int32_t i = 250; i < 266; i++) {
        // 0x100003e78
        function_100003c24();
        int64_t v2; // bp-35, 0x100003dd4
        _printf("%s ", &v2);
    }
    // 0x100003eb0
    _putchar(10);
    _printf("Set [1000,1025]:\n");
    for (int32_t i = 1000; i < 1026; i++) {
        // 0x100003ee4
        function_100003c24();
        int64_t v3; // bp-42, 0x100003dd4
        _printf("%s ", &v3);
    }
    // 0x100003f1c
    _putchar(10);
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int64_t function_100003f34(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5) {
    // 0x100003f34
    return ___snprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(int64_t a1) {
    // 0x100003f40
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(int32_t c) {
    // 0x100003f58
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <string.h>
#include <stdio.h>

int luhn(const char* cc)
{
	const int m[] = {0,2,4,6,8,1,3,5,7,9}; // mapping for rule 3
	int i, odd = 1, sum = 0;

	for (i = strlen(cc); i--; odd = !odd) {
		int digit = cc[i] - '0';
		sum += odd ? digit : m[digit];
	}

	return sum % 10 == 0;
}

int main()
{
	const char* cc[] = {
		"49927398716",
		"49927398717",
		"1234567812345678",
		"1234567812345670",
		0
	};
	int i;

	for (i = 0; cc[i]; i++)
		printf("%16s\t%s\n", cc[i], luhn(cc[i]) ? "ok" : "not ok");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc8(void);
int64_t function_100003f00(int64_t a1);
int64_t * function_100003f0c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f18(char * format, ...);
int32_t function_100003f24(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x200000000; // 0x100003f30

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cc8 - 0x100003e04
int64_t function_100003cc8(void) {
    // 0x100003cc8
    int64_t v1; // bp-64, 0x100003cc8
    _memcpy(&v1, &g1, 40);
    int64_t v2; // 0x100003cc8
    int32_t v3 = _strlen((char *)v2); // 0x100003d0c
    int64_t result = 1; // 0x100003d30
    if (v3 != 0) {
        int32_t v4 = v3;
        int32_t v5 = 1; // 0x100003cc8
        v4--;
        int32_t v6 = (int32_t)*(char *)(v2 + (int64_t)v4) - 48; // 0x100003d44
        int32_t v7 = v6; // 0x100003d58
        if (v5 == 0) {
            // 0x100003d6c
            v7 = *(int32_t *)(4 * (int64_t)v6 + (int64_t)&v1);
        }
        int32_t v8 = v7; // 0x100003d88
        int32_t v9 = v8; // 0x100003d30
        v5 = v5 == 0;
        while (v4 != 0) {
            // 0x100003d38
            v4--;
            v6 = (int32_t)*(char *)(v2 + (int64_t)v4) - 48;
            v7 = v6;
            if (v5 == 0) {
                // 0x100003d6c
                v7 = *(int32_t *)(4 * (int64_t)v6 + (int64_t)&v1);
            }
            // 0x100003d80
            v8 = v7 + v9;
            v9 = v8;
            v5 = v5 == 0;
        }
        // 0x100003d1c
        result = v8 % 10 == 0;
    }
    int64_t v10 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dd8
    if (v10 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003dec
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003df0
    return result;
}

// Address range: 0x100003e04 - 0x100003f00
int64_t entry_point(void) {
    // 0x100003e04
    int64_t v1; // bp-64, 0x100003e04
    int64_t * v2 = _memcpy(&v1, (int64_t *)"X?", 40); // 0x100003e34
    int32_t v3 = 0; // 0x100003e54
    int64_t v4 = (int64_t)v2; // 0x100003e54
    if (v1 != 0) {
        function_100003cc8();
        int32_t v5 = _printf("%16s\t%s\n", "X?", (char *)40); // 0x100003eb4
        v3++;
        while (*(int64_t *)(8 * (int64_t)v3 + (int64_t)&v1) != 0) {
            // 0x100003e5c
            function_100003cc8();
            v5 = _printf("%16s\t%s\n", "X?", (char *)40);
            v3++;
        }
        // 0x100003e40
        v4 = v5;
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ed8
    if (v6 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003eec
        ___stack_chk_fail(v4);
    }
    // 0x100003ef0
    return 0;
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t function_100003f00(int64_t a1) {
    // 0x100003f00
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t * function_100003f0c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f0c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * s) {
    // 0x100003f24
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

typedef uint64_t integer;

integer reverse(integer n) {
    integer rev = 0;
    while (n > 0) {
        rev = rev * 10 + (n % 10);
        n /= 10;
    }
    return rev;
}

typedef struct palgen_tag {
    integer power;
    integer next;
    int digit;
    bool even;
} palgen_t;

void init_palgen(palgen_t* palgen, int digit) {
    palgen->power = 10;
    palgen->next = digit * palgen->power - 1;
    palgen->digit = digit;
    palgen->even = false;
}

integer next_palindrome(palgen_t* p) {
    ++p->next;
    if (p->next == p->power * (p->digit + 1)) {
        if (p->even)
            p->power *= 10;
        p->next = p->digit * p->power;
        p->even = !p->even;
    }
    return p->next * (p->even ? 10 * p->power : p->power)
        + reverse(p->even ? p->next : p->next/10);
}

bool gapful(integer n) {
    integer m = n;
    while (m >= 10)
        m /= 10;
    return n % (n % 10 + 10 * m) == 0;
}

void print(int len, integer array[][len]) {
    for (int digit = 1; digit < 10; ++digit) {
        printf("%d: ", digit);
        for (int i = 0; i < len; ++i)
            printf(" %llu", array[digit - 1][i]);
        printf("\n");
    }
}

int main() {
    const int n1 = 20, n2 = 15, n3 = 10;
    const int m1 = 100, m2 = 1000;

    integer pg1[9][n1];
    integer pg2[9][n2];
    integer pg3[9][n3];

    for (int digit = 1; digit < 10; ++digit) {
        palgen_t pgen;
        init_palgen(&pgen, digit);
        for (int i = 0; i < m2; ) {
            integer n = next_palindrome(&pgen);
            if (!gapful(n))
                continue;
            if (i < n1)
                pg1[digit - 1][i] = n;
            else if (i < m1 && i >= m1 - n2)
                pg2[digit - 1][i - (m1 - n2)] = n;
            else if (i >= m2 - n3)
                pg3[digit - 1][i - (m2 - n3)] = n;
            ++i;
        }
    }

    printf("First %d palindromic gapful numbers ending in:\n", n1);
    print(n1, pg1);

    printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", n2, m1);
    print(n2, pg2);

    printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", n3, m2);
    print(n3, pg3);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003900(void);
int64_t function_100003964(void);
int64_t function_1000039b4(void);
int64_t function_100003b18(void);
int64_t function_100003b98(void);
int64_t function_100003efc(int64_t a1);
int32_t function_100003f08(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003900 - 0x100003964
int64_t function_100003900(void) {
    // 0x100003900
    int64_t v1; // 0x100003900
    if (v1 == 0) {
        // 0x100003958
        return 0;
    }
    int64_t result = 0; // 0x10000391c
    int64_t v2; // 0x100003900
    uint64_t v3 = v2;
    result = v3 % 10 + 10 * result;
    v2 = v3 / 10;
    while (v3 >= 10) {
        // 0x100003924
        v3 = v2;
        result = v3 % 10 + 10 * result;
        v2 = v3 / 10;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003964 - 0x1000039b4
int64_t function_100003964(void) {
    // 0x100003964
    int64_t v1; // 0x100003964
    int64_t result = v1;
    *(int64_t *)result = 10;
    *(int64_t *)(result + 8) = (0x100000000 * v1 >> 32) * result - 1;
    *(int32_t *)(result + 16) = (int32_t)v1;
    *(char *)(result + 20) = 0;
    return result;
}

// Address range: 0x1000039b4 - 0x100003b18
int64_t function_1000039b4(void) {
    // 0x1000039b4
    int64_t v1; // 0x1000039b4
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 + 8); // 0x1000039c8
    int64_t v4 = *v3 + 1; // 0x1000039cc
    *v3 = v4;
    int32_t * v5 = (int32_t *)(v2 + 16); // 0x1000039e8
    int32_t v6 = *v5; // 0x1000039e8
    char * v7 = (char *)(v2 + 20);
    unsigned char v8 = *v7;
    if (v4 != v2 * (int64_t)(v6 + 1)) {
        // 0x100003a70
        return (v8 % 2 == 0 ? v2 : 10 * v2) * v4 + function_100003900();
    }
    int32_t v9 = v6; // 0x100003a14
    if (v8 % 2 != 0) {
        // 0x100003a1c
        *(int64_t *)v2 = 10 * v2;
        v9 = *v5;
    }
    // 0x100003a34
    *v3 = v2 * (int64_t)v9;
    char v10 = *v7 % 2 ^ 1;
    *v7 = v10;
    // 0x100003a70
    return (v10 % 2 == 0 ? v2 : 10 * v2) * *v3 + function_100003900();
}

// Address range: 0x100003b18 - 0x100003b98
int64_t function_100003b18(void) {
    // 0x100003b18
    int64_t v1; // 0x100003b18
    uint64_t v2 = v1;
    if (v2 < 10) {
        // 0x100003b54
        int64_t v3; // 0x100003b18
        return v2 % (10 * v3 + v2 % 10) == 0;
    }
    int64_t v4; // 0x100003b18
    uint64_t v5 = v4;
    int64_t v6 = v5 / 10; // 0x100003b48
    while (v5 >= 100) {
        // 0x100003b40
        v5 = v6;
        v6 = v5 / 10;
    }
    // 0x100003b54
    return v2 % (10 * v6 + v2 % 10) == 0;
}

// Address range: 0x100003b98 - 0x100003c8c
int64_t function_100003b98(void) {
    // 0x100003b98
    int64_t v1; // 0x100003b98
    int32_t v2 = v1; // 0x100003ba4
    int32_t v3 = -v2;
    int32_t result; // 0x100003c68
    for (int32_t i = 1; i < 10; i++) {
        // 0x100003bd4
        _printf("%d: ", v1);
        if (v3 < 0 != (v3 & v2) < 0) {
            _printf(" %llu", v1);
            int32_t v4 = 1; // 0x100003c54
            int32_t v5 = v4 - v2; // 0x100003c00
            int32_t v6 = v4; // 0x100003c08
            while (v5 < 0 != ((v5 ^ v4) & (v4 ^ v2)) < 0) {
                // 0x100003c10
                _printf(" %llu", v1);
                v4 = v6 + 1;
                v5 = v4 - v2;
                v6 = v4;
            }
        }
        // 0x100003c60
        result = _printf("\n");
    }
    // 0x100003c80
    return result;
}

// Address range: 0x100003c8c - 0x100003efc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ca4
    int64_t v2; // bp-1472, 0x100003c8c
    int64_t v3 = &v2;
    int64_t v4; // bp-2552, 0x100003c8c
    int64_t v5 = &v4;
    int64_t v6 = 1;
    int32_t v7; // 0x100003c8c
    int32_t v8; // 0x100003c8c
    int64_t v9; // 0x100003c8c
    int64_t v10; // 0x100003d24
    while (true) {
        // 0x100003cf8
        function_100003964();
        int64_t v11 = v6 - 1;
        int64_t v12 = 160 * v11 + v3;
        int64_t v13 = 120 * v11 + v5;
        int64_t v14; // bp-3272, 0x100003c8c
        v9 = 80 * v11 + (int64_t)&v14;
        v7 = 0;
        while (true) {
          lab_0x100003d0c:
            // 0x100003d0c
            v8 = v7;
            if (v8 < 1000 == (999 - v8 & v8) < 0) {
                // break (via goto) -> 0x100003e20
                goto lab_0x100003e20;
            }
            // 0x100003d20
            v10 = function_1000039b4();
            while (function_100003b18() % 2 == 0) {
                if (v8 < 1000 == (999 - v8 & v8) < 0) {
                    // break (via goto) -> 0x100003e20
                    goto lab_0x100003e20;
                }
                // 0x100003d20
                v10 = function_1000039b4();
            }
            if (v8 < 20 == (19 - v8 & v8) < 0) {
                if (v8 < 100 == (99 - v8 & v8) < 0) {
                    goto lab_0x100003dc8;
                } else {
                    if (v8 < 85 == (84 - v8 & v8) < 0) {
                        // 0x100003da0
                        *(int64_t *)(v13 + (int64_t)(8 * v8 - 680)) = v10;
                        // 0x100003e0c
                        v7 = v8 + 1;
                        goto lab_0x100003d0c;
                    } else {
                        goto lab_0x100003dc8;
                    }
                }
            } else {
                // 0x100003d54
                *(int64_t *)(v12 + 8 * (int64_t)v8) = v10;
                // 0x100003e0c
                v7 = v8 + 1;
                goto lab_0x100003d0c;
            }
        }
      lab_0x100003e20:
        // 0x100003e20
        v6++;
        if (v6 == 10) {
            // break -> 0x100003e30
            break;
        }
    }
    // 0x100003e30
    _printf("First %d palindromic gapful numbers ending in:\n", 9);
    function_100003b98();
    int64_t v15; // 0x100003c8c
    _printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", v3, v15);
    function_100003b98();
    _printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", v5, v15);
    int64_t v16 = function_100003b98(); // 0x100003ec0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ee4
        ___stack_chk_fail(v16);
    }
    // 0x100003ee8
    return 0;
  lab_0x100003dc8:
    if (v8 < 990 == (989 - v8 & v8) < 0) {
        // 0x100003ddc
        *(int64_t *)(v9 + (int64_t)(8 * v8 - 0x1ef0)) = v10;
    }
    // 0x100003e0c
    v7 = v8 + 1;
    goto lab_0x100003d0c;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(int64_t a1) {
    // 0x100003efc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *substring(const char *s, size_t n, ptrdiff_t m)
{
  char *result;
  /* check for null s */
  if (NULL == s)
    return NULL;
  /* negative m to mean 'up to the mth char from right' */
  if (m < 0)
    m = strlen(s) + m - n + 1;

  /* n < 0 or m < 0 is invalid */
  if (n < 0 || m < 0)
    return NULL;

  /* make sure string does not end before n
   * and advance the "s" pointer to beginning of substring */
  for ( ; n > 0; s++, n--)
    if (*s == '\0')
      /* string ends before n: invalid */
      return NULL;

  result = malloc(m+1);
  if (NULL == result)
    /* memory allocation failed */
    return NULL;
  result[0]=0;
  strncat(result, s, m); /* strncat() will automatically add null terminator
                          * if string ends early or after reading m characters */
  return result;
}

char *str_wholeless1(const char *s)
{
  return substring(s, 0, strlen(s) - 1);
}

char *str_fromch(const char *s, int ch, ptrdiff_t m)
{
  return substring(s, strchr(s, ch) - s, m);
}

char *str_fromstr(const char *s, char *in, ptrdiff_t m)
{
  return substring(s, strstr(s, in) - s , m);
}


#define TEST(A) do {		\
    char *r = (A);		\
    if (NULL == r)		\
      puts("--error--");	\
    else {			\
      puts(r);			\
      free(r);			\
    }				\
  } while(0)

int main()
{
  const char *s = "hello world shortest program";

  TEST( substring(s, 12, 5) );		// get "short"
  TEST( substring(s, 6, -1) );		// get "world shortest program"
  TEST( str_wholeless1(s) );		// "... progra"
  TEST( str_fromch(s, 'w', 5) );	// "world"
  TEST( str_fromstr(s, "ro", 3) );	// "rog"

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b08(void);
int64_t function_100003c68(void);
int64_t function_100003ca8(void);
int64_t function_100003cf8(void);
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f34(int64_t * ptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * s);
char * function_100003f58(char * s, int32_t c);
int32_t function_100003f64(char * s);
char * function_100003f70(char * haystack, char * needle);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strncat_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _puts(char * a1);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);
char * _strstr(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b08 - 0x100003c68
int64_t function_100003b08(void) {
    // 0x100003b08
    int64_t v1; // 0x100003b08
    if (v1 == 0) {
        // 0x100003c58
        return 0;
    }
    char * v2 = (char *)v1; // 0x100003b14
    int64_t v3; // 0x100003b08
    if (v1 < 0) {
        int64_t v4 = v1 + 1 - v1 + (int64_t)_strlen(v2); // 0x100003b6c
        v3 = v4;
        if (v4 < 0) {
            // 0x100003c58
            return 0;
        }
    }
    char * v5 = v2; // 0x100003bb8
    char * v6 = v2; // 0x100003bb8
    int64_t result; // 0x100003b08
    if (v1 == 0) {
      lab_0x100003c00:;
        int64_t * v7 = _malloc((int32_t)v3 + 1); // 0x100003c08
        result = 0;
        if (v7 != NULL) {
            // 0x100003c30
            *(char *)v7 = 0;
            int64_t v8 = (int64_t)v7; // 0x100003c38
            ___strncat_chk(v8, (int64_t)v6, v3, -1);
            result = v8;
        }
    } else {
        result = 0;
        while (*v5 != 0) {
            // 0x100003be4
            v5 = (char *)((int64_t)v5 + 1);
            int64_t v9; // 0x100003b08
            int64_t v10 = v9 - 1; // 0x100003bf4
            v9 = v10;
            v6 = v5;
            if (v10 == 0) {
                goto lab_0x100003c00;
            }
            result = 0;
        }
    }
    // 0x100003c58
    return result;
}

// Address range: 0x100003c68 - 0x100003ca8
int64_t function_100003c68(void) {
    // 0x100003c68
    int64_t v1; // 0x100003c68
    _strlen((char *)v1);
    return function_100003b08();
}

// Address range: 0x100003ca8 - 0x100003cf8
int64_t function_100003ca8(void) {
    // 0x100003ca8
    int64_t v1; // 0x100003ca8
    _strchr((char *)v1, (int32_t)v1);
    return function_100003b08();
}

// Address range: 0x100003cf8 - 0x100003d48
int64_t function_100003cf8(void) {
    // 0x100003cf8
    int64_t v1; // 0x100003cf8
    _strstr((char *)v1, (char *)v1);
    return function_100003b08();
}

// Address range: 0x100003d48 - 0x100003f28
int64_t entry_point(void) {
    int64_t v1 = function_100003b08(); // 0x100003d74
    if (v1 == 0) {
        // 0x100003d94
        _puts("--error--");
    } else {
        // 0x100003da4
        _puts((char *)v1);
        _free((int64_t *)v1);
    }
    int64_t v2 = function_100003b08(); // 0x100003dcc
    if (v2 == 0) {
        // 0x100003dec
        _puts("--error--");
    } else {
        // 0x100003dfc
        _puts((char *)v2);
        _free((int64_t *)v2);
    }
    int64_t v3 = function_100003c68(); // 0x100003e1c
    if (v3 == 0) {
        // 0x100003e3c
        _puts("--error--");
    } else {
        // 0x100003e4c
        _puts((char *)v3);
        _free((int64_t *)v3);
    }
    int64_t v4 = function_100003ca8(); // 0x100003e74
    if (v4 == 0) {
        // 0x100003e94
        _puts("--error--");
    } else {
        // 0x100003ea4
        _puts((char *)v4);
        _free((int64_t *)v4);
    }
    int64_t v5 = function_100003cf8(); // 0x100003ed0
    if (v5 == 0) {
        // 0x100003ef0
        _puts("--error--");
    } else {
        // 0x100003f00
        _puts((char *)v5);
        _free((int64_t *)v5);
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f28
    return ___strncat_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * s) {
    // 0x100003f4c
    return _puts(s);
}

// Address range: 0x100003f58 - 0x100003f64
char * function_100003f58(char * s, int32_t c) {
    // 0x100003f58
    return _strchr(s, c);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _strlen(s);
}

// Address range: 0x100003f70 - 0x100003f7c
char * function_100003f70(char * haystack, char * needle) {
    // 0x100003f70
    return _strstr(haystack, needle);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#define _CRT_SECURE_NO_WARNINGS    // turn off panic warnings
#define _CRT_NONSTDC_NO_WARNINGS   // enable old-gold POSIX names in MSVS

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


struct StringArray
{
    size_t sizeOfArray;
    size_t numberOfElements;
    char** elements;
};
typedef struct StringArray* StringArray;

StringArray StringArray_new(size_t size)
{
    StringArray this = calloc(1, sizeof(struct StringArray));
    if (this)
    {
        this->elements = calloc(size, sizeof(int));
        if (this->elements)
            this->sizeOfArray = size;
        else
        {
            free(this);
            this = NULL;
        }
    }
    return this;
}

void StringArray_delete(StringArray* ptr_to_this)
{
    assert(ptr_to_this != NULL);
    StringArray this = (*ptr_to_this);
    if (this)
    {
        for (size_t i = 0; i < this->sizeOfArray; i++)
            free(this->elements[i]);
        free(this->elements);
        free(this);
        this = NULL;
    }
}

void StringArray_add(StringArray this, ...)
{
    char* s;
    va_list args;
    va_start(args, this);
    while (this->numberOfElements < this->sizeOfArray && (s = va_arg(args, char*)))
        this->elements[this->numberOfElements++] = strdup(s);
    va_end(args);
}


int main(int argc, char* argv[])
{
    StringArray a = StringArray_new(10);
    StringArray_add(a, "apple", "orange", NULL);

    printf(
        "There are %d elements in an array with a capacity of %d elements:\n\n",
        a->numberOfElements, a->sizeOfArray);

    for (size_t i = 0; i < a->numberOfElements; i++)
        printf("    the element %d is the string \"%s\"\n", i, a->elements[i]);

    StringArray_delete(&a);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b98(void);
int64_t function_100003c2c(void);
int64_t function_100003d14(void);
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4);
int64_t * function_100003ec8(int32_t nmemb, int32_t size);
void function_100003ed4(int64_t * ptr);
int32_t function_100003ee0(char * format, ...);
char * function_100003eec(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b98 - 0x100003c2c
int64_t function_100003b98(void) {
    int64_t * v1 = _calloc(1, 24); // 0x100003bb0
    int64_t result = (int64_t)v1; // 0x100003bb0
    if (v1 == NULL) {
        // 0x100003c1c
        return result;
    }
    // 0x100003bcc
    int64_t v2; // 0x100003b98
    int64_t * v3 = _calloc((int32_t)v2, 4); // 0x100003bd4
    *(int64_t *)(result + 16) = (int64_t)v3;
    int64_t result2; // 0x100003b98
    if (v3 == NULL) {
        // 0x100003c08
        _free(v1);
        result2 = 0;
    } else {
        // 0x100003bf8
        *v1 = 0x100000000 * v2 >> 32;
        result2 = result;
    }
    // 0x100003c1c
    return result2;
}

// Address range: 0x100003c2c - 0x100003d14
int64_t function_100003c2c(void) {
    // 0x100003c2c
    int64_t v1; // 0x100003c2c
    int64_t v2; // 0x100003c2c
    if (v1 == 0) {
        // 0x100003c5c
        v2 = ___assert_rtn("StringArray_delete", "array-length-3.c", 38, "ptr_to_this != NULL");
    }
    // 0x100003c80
    if (v2 == 0) {
        // 0x100003d08
        return 0;
    }
    int64_t * v3 = (int64_t *)(v2 + 16);
    int64_t v4 = 0; // 0x100003ce0
    _free((int64_t *)*(int64_t *)(8 * v4 + *v3));
    v4++;
    int64_t v5 = *v3;
    while (v4 < (int64_t)&g1) {
        // 0x100003cc4
        _free((int64_t *)*(int64_t *)(8 * v4 + v5));
        v4++;
        v5 = *v3;
    }
    // 0x100003cec
    _free((int64_t *)v5);
    _free((int64_t *)v2);
    // 0x100003d08
    return &g1;
}

// Address range: 0x100003d14 - 0x100003dcc
int64_t function_100003d14(void) {
    // 0x100003d14
    int64_t v1; // 0x100003d14
    uint64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 + 8); // 0x100003d38
    int64_t result; // 0x100003d14
    if (*v3 >= v2) {
        // 0x100003dc0
        return result;
    }
    if (v1 == 0) {
        // 0x100003dc0
        return result;
    }
    // 0x100003d98
    int64_t v4; // 0x100003d14
    int64_t v5 = &v4; // 0x100003d64
    int64_t v6; // 0x100003d14
    int64_t result2 = (int64_t)_strdup((char *)v6);
    int64_t v7 = *v3; // 0x100003dac
    *v3 = v7 + 1;
    *(int64_t *)(8 * v7 + *(int64_t *)(v2 + 16)) = result2;
    while (*v3 < result2) {
        // 0x100003d8c
        v5 += 8;
        int64_t v8 = *(int64_t *)v5; // 0x100003d60
        if (v8 == 0) {
            // break -> 0x100003dc0
            break;
        }
        result2 = (int64_t)_strdup((char *)v8);
        v7 = *v3;
        *v3 = v7 + 1;
        *(int64_t *)(8 * v7 + *(int64_t *)(v2 + 16)) = result2;
    }
    // 0x100003dc0
    return result2;
}

// Address range: 0x100003dcc - 0x100003ebc
int64_t entry_point(void) {
    int64_t v1 = function_100003b98(); // 0x100003de8
    function_100003d14();
    int64_t v2; // 0x100003dcc
    _printf("There are %d elements in an array with a capacity of %d elements:\n\n", v2, v2);
    for (int64_t i = 0; i < *(int64_t *)(v1 + 8); i++) {
        // 0x100003e64
        _printf("    the element %d is the string \"%s\"\n", v2, (char *)v2);
    }
    // 0x100003ea4
    function_100003c2c();
    return 0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003ebc
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int32_t nmemb, int32_t size) {
    // 0x100003ec8
    return _calloc(nmemb, size);
}

// Address range: 0x100003ed4 - 0x100003ee0
void function_100003ed4(int64_t * ptr) {
    // 0x100003ed4
    _free(ptr);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(char * format, ...) {
    // 0x100003ee0
    return _printf(format);
}

// Address range: 0x100003eec - 0x100003ef8
char * function_100003eec(char * s) {
    // 0x100003eec
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>



int number_of_digits(int x){
    int NumberOfDigits;
    for(NumberOfDigits=0;x!=0;NumberOfDigits++){
        x=x/10;
    }
    return NumberOfDigits;
}

int* convert_array(char array[], int NumberOfElements)  //converts integer arguments from char to int
{
    int *convertedArray=malloc(NumberOfElements*sizeof(int));
    int originalElement, convertedElement;

    for(convertedElement=0, originalElement=0; convertedElement<NumberOfElements; convertedElement++)
    {
       convertedArray[convertedElement]=atoi(&array[originalElement]);
       originalElement+=number_of_digits(convertedArray[convertedElement])+1; //computes where is the beginning of the next element

    }
    return convertedArray;
}



int isSorted(int array[], int numberOfElements){
    int sorted=1;
    for(int counter=0;counter<numberOfElements;counter++){
        if(counter!=0 && array[counter-1]>array[counter]) sorted--;

    }
    return sorted;
}
int main(int argc, char* argv[])
{
    int* convertedArray;


    convertedArray=convert_array(*(argv+1), argc-1);



    if(isSorted(convertedArray, argc-1)==1) printf("Did you forgot to turn on your brain?! This array is already sorted!\n");
    else if(argc-1<=10) printf("Am I really supposed to sort this? Sort it by yourself!\n");
    else printf("Am I really supposed to sort this? Bhahahaha!\n");
    free(convertedArray);
    return 0;



}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c64(void);
int64_t function_100003cb8(void);
int64_t function_100003d60(void);
int32_t function_100003eb8(char * nptr);
void function_100003ec4(int64_t * ptr);
int64_t * function_100003ed0(int32_t size);
int32_t function_100003edc(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c64 - 0x100003cb8
int64_t function_100003c64(void) {
    // 0x100003c64
    int64_t v1; // 0x100003c64
    int32_t v2 = v1; // 0x100003c68
    int32_t result = 0; // 0x100003c80
    if (v2 == 0) {
        // 0x100003cac
        return 0;
    }
    int32_t v3 = v2; // 0x100003c80
    result++;
    while (v3 >= 10) {
        // 0x100003c88
        v3 /= 10;
        result++;
    }
    // 0x100003cac
    return result;
}

// Address range: 0x100003cb8 - 0x100003d60
int64_t function_100003cb8(void) {
    // 0x100003cb8
    int64_t v1; // 0x100003cb8
    int32_t v2 = v1; // 0x100003cc8
    int64_t result = (int64_t)_malloc(4 * v2); // 0x100003cd4
    int32_t v3 = -v2; // 0x100003cf0
    int32_t v4 = 0; // 0x100003cf8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003d50
        return result;
    }
    int32_t v5 = 0; // 0x100003cf8
    int32_t v6 = _atoi((char *)(v1 + (int64_t)v5)); // 0x100003d0c
    *(int32_t *)(4 * (int64_t)v4 + result) = v6;
    v4++;
    int32_t v7 = v4 - v2; // 0x100003cf0
    v5 = v5 + 1 + (int32_t)function_100003c64();
    while (v7 < 0 != ((v7 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d00
        v6 = _atoi((char *)(v1 + (int64_t)v5));
        *(int32_t *)(4 * (int64_t)v4 + result) = v6;
        v4++;
        v7 = v4 - v2;
        v5 = v5 + 1 + (int32_t)function_100003c64();
    }
    // 0x100003d50
    return result;
}

// Address range: 0x100003d60 - 0x100003e04
int64_t function_100003d60(void) {
    // 0x100003d60
    int64_t v1; // 0x100003d60
    int32_t v2 = v1; // 0x100003d68
    int32_t v3 = -v2; // 0x100003d84
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003df8
        return 1;
    }
    int32_t v4 = 1;
    int32_t v5 = 0;
    int32_t v6 = v4; // 0x100003da0
    int32_t v7; // 0x100003dc4
    int32_t v8; // 0x100003db4
    int32_t v9; // 0x100003dc0
    if (v5 != 0) {
        // 0x100003da8
        v8 = *(int32_t *)(v1 + (int64_t)(4 * v5 - 4));
        v9 = *(int32_t *)(4 * (int64_t)v5 + v1);
        v7 = v8 - v9;
        v6 = v4 + (int32_t)(v7 != 0 == v7 < 0 == ((v7 ^ v8) & (v9 ^ v8)) < 0);
    }
    int32_t result = v6;
    int32_t v10 = v5 + 1; // 0x100003dec
    int32_t v11 = v10 - v2; // 0x100003d84
    while (v11 < 0 != ((v11 ^ v10) & (v10 ^ v2)) < 0) {
        // 0x100003d94
        v4 = result;
        v5 = v10;
        v6 = v4;
        if (v5 != 0) {
            // 0x100003da8
            v8 = *(int32_t *)(v1 + (int64_t)(4 * v5 - 4));
            v9 = *(int32_t *)(4 * (int64_t)v5 + v1);
            v7 = v8 - v9;
            v6 = v4 + (int32_t)(v7 != 0 == v7 < 0 == ((v7 ^ v8) & (v9 ^ v8)) < 0);
        }
        // 0x100003de8
        result = v6;
        v10 = v5 + 1;
        v11 = v10 - v2;
    }
    // 0x100003df8
    return result;
}

// Address range: 0x100003e04 - 0x100003eb8
int64_t entry_point(void) {
    int64_t v1 = function_100003cb8(); // 0x100003e2c
    if ((int32_t)function_100003d60() == 1) {
        // 0x100003e54
        _printf("Did you forgot to turn on your brain?! This array is already sorted!\n");
        // 0x100003ea0
        _free((int64_t *)v1);
        return 0;
    }
    // 0x100003e64
    int64_t v2; // 0x100003e04
    int32_t v3 = v2; // 0x100003e14
    int32_t v4 = v3 - 11; // 0x100003e6c
    if (v4 == 0 || v4 < 0 != (v3 - 1 & 10 - v3) < 0) {
        // 0x100003e7c
        _printf("Am I really supposed to sort this? Sort it by yourself!\n");
    } else {
        // 0x100003e8c
        _printf("Am I really supposed to sort this? Bhahahaha!\n");
    }
    // 0x100003ea0
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(char * nptr) {
    // 0x100003eb8
    return _atoi(nptr);
}

// Address range: 0x100003ec4 - 0x100003ed0
void function_100003ec4(int64_t * ptr) {
    // 0x100003ec4
    _free(ptr);
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t * function_100003ed0(int32_t size) {
    // 0x100003ed0
    return _malloc(size);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * format, ...) {
    // 0x100003edc
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

#define SIZE (1 << 4)
int main()
{
	int x, y, i;
	for (y = SIZE - 1; y >= 0; y--, putchar('\n')) {
		for (i = 0; i < y; i++) putchar(' ');
		for (x = 0; x + y < SIZE; x++)
			printf((x & y) ? "  " : "* ");
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f88(char * format, ...);
int32_t function_100003f94(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e88 - 0x100003f88
int64_t entry_point(void) {
    for (int32_t i = 15; i > -1; i--) {
        // 0x100003ec0
        if (i != 0 != (i & -i) < 0) {
            _putchar(32);
            int32_t v1 = 1; // 0x100003ee8
            int32_t v2 = v1 - i; // 0x100003ec8
            int32_t v3 = v1; // 0x100003ed0
            while (v2 < 0 != ((v2 ^ v1) & (v1 ^ i)) < 0) {
                // 0x100003ed8
                _putchar(32);
                v1 = v3 + 1;
                v2 = v1 - i;
                v3 = v1;
            }
        }
        int32_t v4 = 0; // 0x100003f10
        if ((15 - i & i) >= 0) {
            _printf((v4 & i) == 0 ? "* " : "  ");
            int32_t v5 = v4 + 1; // 0x100003f50
            int32_t v6 = v5 + i; // 0x100003f04
            v4 = v5;
            while (v6 < 16 != (15 - v6 & v6) < 0) {
                // 0x100003f18
                _printf((v4 & i) == 0 ? "* " : "  ");
                v5 = v4 + 1;
                v6 = v5 + i;
                v4 = v5;
            }
        }
        // 0x100003f60
        _putchar(10);
    }
    // 0x100003f78
    return 0;
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(int32_t c) {
    // 0x100003f94
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`# define	NUMBER_OF_POINTS	100000
# define	NUMBER_OF_CLUSTERS	11
# define	MAXIMUM_ITERATIONS	100
# define	RADIUS			10.0


#include <stdio.h>
#include <stdlib.h>
#include <math.h>


typedef struct {
	double	x;
	double	y;
	int		group;
} POINT;


/*-------------------------------------------------------
	gen_xy

	This function allocates a block of memory for data points,
	gives the data points random values and returns a pointer to them.
	The data points fall within a circle of the radius passed to
	the function. This does not create a uniform 2-dimensional
	distribution.
-------------------------------------------------------*/
POINT * gen_xy(int num_pts, double radius)
{
	int		i;
	double	ang, r;
	POINT * pts;

	pts = (POINT*) malloc(sizeof(POINT) * num_pts);
	
	for ( i = 0; i < num_pts; i++ ) {
		ang = 2.0 * M_PI * rand() / (RAND_MAX - 1.);
		r = radius * rand() / (RAND_MAX - 1.);
		pts[i].x = r * cos(ang);
		pts[i].y = r * sin(ang);
	}
	return pts;	
}

/*-------------------------------------------------------
	dist2

	This function returns the squared euclidean distance
	between two data points.
-------------------------------------------------------*/
double dist2(POINT * a, POINT * b)
{
	double x = a->x - b->x;
	double y = a->y - b->y;
	return x*x + y*y;
}

/*------------------------------------------------------
	nearest

  This function returns the index of the cluster centroid
  nearest to the data point passed to this function.
------------------------------------------------------*/
int nearest(POINT * pt, POINT * cent, int n_cluster)
{
	int i, clusterIndex;
	double d, min_d;

	min_d = HUGE_VAL;
	clusterIndex = pt->group;	
	for (i = 0; i < n_cluster; i++) {
		d = dist2(&cent[i], pt);
		if ( d < min_d ) {
			min_d = d;
			clusterIndex = i;
		}
	}	
	return clusterIndex;
}

/*------------------------------------------------------
	nearestDistance

  This function returns the distance of the cluster centroid
  nearest to the data point passed to this function.
------------------------------------------------------*/
double nearestDistance(POINT * pt, POINT * cent, int n_cluster)
{
	int i;
	double d, min_d;

	min_d = HUGE_VAL;
	for (i = 0; i < n_cluster; i++) {
		d = dist2(&cent[i], pt);
		if ( d < min_d ) {
			min_d = d;
		}
	}

	return min_d;
}

/*----------------------------------------------------------------------
  bisectionSearch

  This function makes a bisectional search of an array of values that are
  ordered in increasing order, and returns the index of the first element
  greater than the search value passed as a parameter.

  This code is adapted from code by Andy Allinger given to the public
  domain, which was in turn adapted from public domain code for spline
  evaluation by Rondall Jones (Sandia National Laboratories).

  Input:
		x	A pointer to an array of values in increasing order to be searched.
		n	The number of elements in the input array x.
		v	The search value.
  Output:
		Returns the index of the first element greater than the search value, v.
----------------------------------------------------------------------*/
int bisectionSearch(double *x, int n, double v)
{
	int il, ir, i;
	

	if (n < 1) {
		return 0;
	}
	/* If v is less than x(0) or greater than x(n-1)  */
	if (v < x[0]) {
		return 0;
	}
	else if (v > x[n-1]) {
		return n - 1;
	}
	
	/*bisection search */
	il = 0;
	ir = n - 1;

	i = (il + ir) / 2;
	while ( i != il ) {
		if (x[i] <= v) {
			il = i;
		} else {
			ir = i;
		}
		i = (il + ir) / 2;		
	}		

	if (x[i] <= v)
		i = ir;
	return i;
} /* end of bisectionSearch */

/*-------------------------------------------------------
	kppFaster
	
	This function uses the K-Means++ method to select
	the cluster centroids.
	
	This code is adapted from code by Andy Allinger given to the
	public domain.

	Input:
		pts		A pointer to an array of data points.
		num_pts		The number of points in the pts array.
		centroids	A pointer to an array to receive the centroids.
		num_clusters	The number of clusters to be found.
	
	Output:
		centroids	A pointer to the array of centroids found.	
-------------------------------------------------------*/
void kppFaster(POINT * pts, int num_pts, POINT * centroids,
		 int num_clusters)
{
	int j;
	int selectedIndex;
	int cluster;
	double sum;
	double d;
	double random;	
	double * cumulativeDistances;
	double * shortestDistance;

	
	cumulativeDistances = (double*) malloc(sizeof(double) * num_pts);
	shortestDistance = (double*) malloc(sizeof(double) * num_pts);	
	

	/* Pick the first cluster centroids at random. */
	selectedIndex = rand() % num_pts;
	centroids[0] = pts[ selectedIndex ];
	
	for (j = 0; j < num_pts; ++j)
		shortestDistance[j] = HUGE_VAL;	
		
	/* Select the centroids for the remaining clusters. */
	for (cluster = 1; cluster < num_clusters; cluster++) {
			
		/* For each point find its closest distance to any of
		   the previous cluster centers */
		for ( j = 0; j < num_pts; j++ ) {
			d = dist2(&pts[j], &centroids[cluster-1] );
			
			if (d < shortestDistance[j])
				shortestDistance[j] = d;
		}
		
		/* Create an array of the cumulative distances. */
		sum = 0.0;
		for (j = 0; j < num_pts; j++) {
			sum += shortestDistance[j];
			cumulativeDistances[j] = sum;
		}

		/* Select a point at random. Those with greater distances
		   have a greater probability of being selected. */
		random = (float) rand() / (float) RAND_MAX * sum;
		selectedIndex = bisectionSearch(cumulativeDistances, num_pts, random);
		
		/* assign the selected point as the center */
		centroids[cluster] = pts[selectedIndex];
	}

	/* Assign each point the index of it's nearest cluster centroid. */
	for (j = 0; j < num_pts; j++)
		pts[j].group = nearest(&pts[j], centroids, num_clusters);

	free(shortestDistance);
	free(cumulativeDistances);

	return;
}	/* end, kppFaster */

/*-------------------------------------------------------
	kpp
	
	This function uses the K-Means++ method to select
	the cluster centroids.
-------------------------------------------------------*/
void kpp(POINT * pts, int num_pts, POINT * centroids,
		 int num_clusters)
{
	int j;
	int cluster;
	double sum;
	double * distances;

	
	distances = (double*) malloc(sizeof(double) * num_pts);

	/* Pick the first cluster centroids at random. */
	centroids[0] = pts[ rand() % num_pts ];
	
	
	/* Select the centroids for the remaining clusters. */
	for (cluster = 1; cluster < num_clusters; cluster++) {
		
		/* For each data point find the nearest centroid, save its
		   distance in the distance array, then add it to the sum of
		   total distance. */
		sum = 0.0;
		for ( j = 0; j < num_pts; j++ ) {
			distances[j] =
				nearestDistance(&pts[j], centroids, cluster);
			sum += distances[j];
		}

		/* Find a random distance within the span of the total distance. */
		sum = sum * rand() / (RAND_MAX - 1);
		
		/* Assign the centroids. the point with the largest distance
			will have a greater probability of being selected. */
		for (j = 0; j < num_pts; j++ ) {
			sum -= distances[j];
			if ( sum <= 0)
			{
				centroids[cluster] = pts[j];
				break;
			}
		}
	}

	/* Assign each observation the index of it's nearest cluster centroid. */
	for (j = 0; j < num_pts; j++)
		pts[j].group = nearest(&pts[j], centroids, num_clusters);

	free(distances);

	return;
}	/* end, kpp */


/*-------------------------------------------------------
	lloyd
	
	This function clusters the data using Lloyd's K-Means algorithm
	after selecting the intial centroids using the K-Means++
	method.
	It returns a pointer to the memory it allocates containing
	the array of cluster centroids.
-------------------------------------------------------*/
POINT * lloyd(POINT * pts, int num_pts, int num_clusters, int maxTimes)
{
	int i, clusterIndex;
	int changes;
	int acceptable = num_pts / 1000;	/* The maximum point changes acceptable. */


	if (num_clusters == 1 || num_pts <= 0 || num_clusters > num_pts )
		return 0;


	POINT * centroids = (POINT *)malloc(sizeof(POINT) * num_clusters);

	if ( maxTimes < 1 )
		maxTimes = 1;

/*	Assign initial clustering randomly using the Random Partition method
	for (i = 0; i < num_pts; i++ ) {
		pts[i].group = i % num_clusters;
	}
*/

	/* or use the k-Means++ method */

/* Original version
	kpp(pts, num_pts, centroids, num_clusters);
*/
	/* Faster version */
	kppFaster(pts, num_pts, centroids, num_clusters);

	do {
		/* Calculate the centroid of each cluster.
		  ----------------------------------------*/
		
		/* Initialize the x, y and cluster totals. */
		for ( i = 0; i < num_clusters; i++ ) {
			centroids[i].group = 0;		/* used to count the cluster members. */
			centroids[i].x = 0;			/* used for x value totals. */
			centroids[i].y = 0;			/* used for y value totals. */
		}
		
		/* Add each observation's x and y to its cluster total. */
		for (i = 0; i < num_pts; i++) {
			clusterIndex = pts[i].group;
			centroids[clusterIndex].group++;
			centroids[clusterIndex].x += pts[i].x;
			centroids[clusterIndex].y += pts[i].y;
		}
		
		/* Divide each cluster's x and y totals by its number of data points. */
		for ( i = 0; i < num_clusters; i++ ) {
			centroids[i].x /= centroids[i].group;
			centroids[i].y /= centroids[i].group;
		}

		/* Find each data point's nearest centroid */
		changes = 0;
		for ( i = 0; i < num_pts; i++ ) {
			clusterIndex = nearest(&pts[i], centroids, num_clusters);
			if (clusterIndex != pts[i].group) {
				pts[i].group = clusterIndex;
				changes++;
			}
		}
	
		maxTimes--;
	} while ((changes > acceptable) && (maxTimes > 0));

	/* Set each centroid's group index */
	for ( i = 0; i < num_clusters; i++ )
		centroids[i].group = i;

	return centroids;
}	/* end, lloyd */

/*-------------------------------------------------------
	print_eps

	this function prints the results.
-------------------------------------------------------*/
void print_eps(POINT * pts, int num_pts, POINT * centroids, int num_clusters)
{
#	define W 400
#	define H 400

	int i, j;
	double min_x, max_x, min_y, max_y, scale, cx, cy;
	double *colors = (double *) malloc(sizeof(double) * num_clusters * 3);

	for (i = 0; i < num_clusters; i++) {
		colors[3*i + 0] = (3 * (i + 1) % 11)/11.;
		colors[3*i + 1] = (7 * i % 11)/11.;
		colors[3*i + 2] = (9 * i % 11)/11.;
	}

	max_x = max_y = - HUGE_VAL;
	min_x = min_y = HUGE_VAL;
	for (j = 0; j < num_pts; j++) {
		if (max_x < pts[j].x) max_x = pts[j].x;
		if (min_x > pts[j].x) min_x = pts[j].x;
		if (max_y < pts[j].y) max_y = pts[j].y;
		if (min_y > pts[j].y) min_y = pts[j].y;
	}

	scale = W / (max_x - min_x);
	if (scale > H / (max_y - min_y))
		scale = H / (max_y - min_y);
	cx = (max_x + min_x) / 2;
	cy = (max_y + min_y) / 2;

	printf("%%!PS-Adobe-3.0\n%%%%BoundingBox: -5 -5 %d %d\n", W + 10, H + 10);
	printf( "/l {rlineto} def /m {rmoveto} def\n"
		"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\n"
		"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath "
		"	gsave 1 setgray fill grestore gsave 3 setlinewidth"
		" 1 setgray stroke grestore 0 setgray stroke }def\n"
	);


	for (i = 0; i < num_clusters; i++) {
		printf("%g %g %g setrgbcolor\n",
			colors[3*i], colors[3*i + 1], colors[3*i + 2]);

		for (j = 0; j < num_pts; j++) {
			if (pts[j].group != i) continue;
			printf("%.3f %.3f c\n",
				(pts[j].x - cx) * scale + W / 2,
				(pts[j].y - cy) * scale + H / 2);
		}
		printf("\n0 setgray %g %g s\n",
			(centroids[i].x - cx) * scale + W / 2,
			(centroids[i].y - cy) * scale + H / 2);
	}
	printf("\n%%%%EOF");

	free(colors);

	return;
}	/* end print_eps */

/*-------------------------------------------------------
	main
-------------------------------------------------------*/
int main()
{
	int		num_pts = NUMBER_OF_POINTS;
	int		num_clusters = NUMBER_OF_CLUSTERS;
	int		maxTimes = MAXIMUM_ITERATIONS;
	double	radius = RADIUS;
	POINT * pts;
	POINT * centroids;

	/* Generate the observations */
	pts = gen_xy(num_pts, radius);

	/* Cluster using the Lloyd algorithm and K-Means++ initial centroids. */
	centroids = lloyd(pts, num_pts, num_clusters, maxTimes);

	/* Print the results */
	print_eps(pts, num_pts, centroids, num_clusters);

	free(pts);
	free(centroids);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002a30(void);
int64_t function_100002b50(void);
int64_t function_100002bac(void);
int64_t function_100002c6c(void);
int64_t function_100002d18(void);
int64_t function_100002e7c(void);
int64_t function_100003174(void);
int64_t function_1000033e4(void);
int64_t function_100003804(void);
float64_t function_100003db8(float64_t a1);
void function_100003dc4(int64_t * ptr);
int64_t * function_100003dd0(int32_t size);
int32_t function_100003ddc(char * format, ...);
int32_t function_100003de8(void);
float64_t function_100003df4(float64_t a1);

// --------------------- Global Variables ---------------------

float64_t g1 = 2147483646.0; // 0x100003e00
float64_t g2 = 6.2831853071795862; // 0x100003e08
float64_t g3 = INFINITY; // 0x100003e10
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

float64_t _cos(float64_t a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
float64_t _sin(float64_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002a30 - 0x100002b50
int64_t function_100002a30(void) {
    // 0x100002a30
    int64_t v1; // 0x100002a30
    int32_t v2 = v1; // 0x100002a3c
    int64_t result = (int64_t)_malloc(24 * v2); // 0x100002a50
    int32_t v3 = -v2; // 0x100002a68
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100002b40
        return result;
    }
    int32_t v4 = 0; // 0x100002b34
    int32_t v5 = _rand(); // 0x100002a78
    float64_t v6 = g1; // 0x100002a90
    int32_t v7 = _rand(); // 0x100002aa8
    int128_t v8; // 0x100002a30
    float64_t v9 = _cos((float64_t)(int64_t)v8); // 0x100002ad0
    float64_t v10; // 0x100002a30
    float64_t v11 = g2 * (float64_t)v5 / v6 * v10 * (float64_t)v7 / v6; // 0x100002adc
    int64_t v12 = 24 * (int64_t)v4 + result; // 0x100002af4
    *(float64_t *)v12 = v11;
    float64_t v13 = _sin(v9); // 0x100002b04
    *(float64_t *)(v12 + 8) = v11;
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100002a78
        v5 = _rand();
        v6 = g1;
        v7 = _rand();
        v9 = _cos((float64_t)(int64_t)(int32_t)(float32_t)v13);
        float64_t v14; // bp-32, 0x100002a30
        v11 = g2 * (float64_t)v5 / v6 * v14 * (float64_t)v7 / v6;
        v12 = 24 * (int64_t)v4 + result;
        *(float64_t *)v12 = v11;
        v13 = _sin(v9);
        *(float64_t *)(v12 + 8) = v11;
        v4++;
    }
    // 0x100002b40
    return result;
}

// Address range: 0x100002b50 - 0x100002bac
int64_t function_100002b50(void) {
    // 0x100002b50
    int64_t result; // 0x100002b50
    return result;
}

// Address range: 0x100002bac - 0x100002c6c
int64_t function_100002bac(void) {
    // 0x100002bac
    int64_t v1; // 0x100002bac
    int32_t v2 = v1; // 0x100002bc0
    uint32_t result = *(int32_t *)(v1 + 16); // 0x100002bd4
    int32_t v3 = -v2; // 0x100002bec
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100002c5c
        return result;
    }
    int32_t v4 = 0; // 0x100002bf4
    function_100002b50();
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100002c4c
        function_100002b50();
        v4++;
    }
    // 0x100002c5c
    return result;
}

// Address range: 0x100002c6c - 0x100002d18
int64_t function_100002c6c(void) {
    // 0x100002c6c
    int64_t v1; // 0x100002c6c
    int32_t v2 = v1; // 0x100002c80
    int32_t v3 = -v2; // 0x100002ca0
    int64_t result; // 0x100002c6c
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100002d08
        return result;
    }
    int32_t v4 = 0; // 0x100002ca8
    v4++;
    int32_t v5 = v4 - v2; // 0x100002ca0
    result = function_100002b50();
    while (v5 < 0 != ((v5 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100002cf8
        v4++;
        v5 = v4 - v2;
        result = function_100002b50();
    }
    // 0x100002d08
    return result;
}

// Address range: 0x100002d18 - 0x100002e7c
int64_t function_100002d18(void) {
    // 0x100002d18
    float64_t v1; // 0x100002d18
    float64_t v2 = v1;
    int64_t v3; // 0x100002d18
    uint32_t v4 = (int32_t)v3; // 0x100002d20
    int32_t result = v4 - 1; // 0x100002d2c
    if (v2 > (float64_t)v3 || result < 0 != (v4 & -v4) < 0) {
        // 0x100002e70
        return 0;
    }
    float64_t v5 = *(float64_t *)((8 * v3 + 0xfffffff8 & 0xfffffff8) + v3); // 0x100002d78
    if (v2 != v5) {
        if (v2 > v5 == v2 >= v5 == v2 <= v5) {
            // 0x100002e70
            return result;
        }
    }
    int32_t v6 = result / 2;
    float64_t v7 = *(float64_t *)(8 * (int64_t)v6 + v3);
    bool v8 = v7 <= v2 == (v7 != v2); // 0x100002ddc
    int32_t v9 = result; // 0x100002ddc
    int32_t v10 = 0; // 0x100002ddc
    int32_t v11 = result; // 0x100002ddc
    int32_t v12 = v6; // 0x100002ddc
    bool v13 = v7 <= v2 == (v7 != v2); // 0x100002ddc
    if (v4 >= 3) {
        v10 = v8 ? v10 : v6;
        v9 = v8 ? v6 : v9;
        int32_t v14 = (v10 + v9) / 2;
        float64_t v15 = *(float64_t *)(8 * (int64_t)v14 + v3);
        v8 = v15 <= v2 == (v15 != v2);
        v11 = v9;
        v12 = v10;
        v13 = v15 <= v2 == (v15 != v2);
        while (v14 != v10) {
            // 0x100002de4
            v10 = v8 ? v10 : v14;
            v9 = v8 ? v14 : v9;
            v14 = (v10 + v9) / 2;
            v15 = *(float64_t *)(8 * (int64_t)v14 + v3);
            v8 = v15 <= v2 == (v15 != v2);
            v11 = v9;
            v12 = v10;
            v13 = v15 <= v2 == (v15 != v2);
        }
    }
    // 0x100002e70
    return v13 ? v12 : v11;
}

// Address range: 0x100002e7c - 0x100003174
int64_t function_100002e7c(void) {
    // 0x100002e7c
    int64_t v1; // 0x100002e7c
    int32_t v2 = v1; // 0x100002e8c
    int32_t v3 = 8 * v2; // 0x100002ea8
    int64_t * v4 = _malloc(v3); // 0x100002ea8
    int64_t * v5 = _malloc(v3); // 0x100002ebc
    int64_t v6 = (int64_t)v5; // 0x100002ebc
    int64_t v7 = 24 * (int64_t)(_rand() % v2) + v1; // 0x100002ef0
    *(float128_t *)v1 = *(float128_t *)v7;
    *(int64_t *)(v1 + 16) = *(int64_t *)(v7 + 16);
    int32_t v8 = -v2;
    float64_t v9; // 0x100002e7c
    if (v8 < 0 != (v8 & v2) < 0) {
        int32_t v10 = 0; // 0x100002f40
        v9 = g3;
        *(int64_t *)(8 * (int64_t)v10 + v6) = (int64_t)g3;
        v10++;
        while (v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
            // 0x100002f24
            v9 = g3;
            *(int64_t *)(8 * (int64_t)v10 + v6) = (int64_t)g3;
            v10++;
        }
    }
    int32_t v11 = v1; // 0x100002e94
    int32_t v12 = 1 - v11; // 0x100002f60
    float64_t v13; // 0x100002e7c
    float64_t v14; // 0x100002e7c
    int32_t v15; // 0x100002e7c
    int32_t v16; // 0x100002e7c
    if (v12 < 0 != (v12 & v11) < 0) {
        // 0x100002f78
        v16 = 1;
        while (true) {
          lab_0x100002f78:;
            int32_t v17 = 0; // 0x100002f88
            v14 = 0.0;
            if (v8 < 0 != (v8 & v2) < 0) {
                while (true) {
                    // 0x100002f90
                    function_100002b50();
                    float64_t v18 = v9; // 0x100002fbc
                    int64_t v19 = 8 * (int64_t)v17 + v6; // 0x100002fcc
                    if (v18 > *(float64_t *)v19) {
                        // 0x100002fe0
                        v9 = v18;
                        *(int64_t *)v19 = (int64_t)v18;
                    }
                    int32_t v20 = v17 + 1; // 0x100002ffc
                    int32_t v21 = v20 - v2; // 0x100002f80
                    v17 = v20;
                    v15 = 0;
                    v13 = 0.0;
                    if (v21 < 0 == ((v21 ^ v20) & (v20 ^ v2)) < 0) {
                        goto lab_0x100003030;
                    }
                }
            }
            goto lab_0x10000306c;
        }
    }
  lab_0x1000030f0:
    if (v8 < 0 == (v8 & v2) < 0) {
        // 0x100003158
        _free(v5);
        _free(v4);
        return &g4;
    }
    int32_t v22 = 0; // 0x100002e7c
    int64_t v23 = function_100002bac(); // 0x100003128
    *(int32_t *)(v1 + 16 + 24 * (int64_t)v22) = (int32_t)v23;
    int32_t v24 = v22 + 1; // 0x10000314c
    int32_t v25 = v24 - v2; // 0x1000030f8
    v22 = v24;
    while (v25 < 0 != ((v25 ^ v24) & (v24 ^ v2)) < 0) {
        // 0x100003108
        v23 = function_100002bac();
        *(int32_t *)(v1 + 16 + 24 * (int64_t)v22) = (int32_t)v23;
        v24 = v22 + 1;
        v25 = v24 - v2;
        v22 = v24;
    }
    // 0x100003158
    _free(v5);
    _free(v4);
    return &g4;
  lab_0x100003030:;
    int64_t v26 = 8 * (int64_t)v15; // 0x100003038
    float64_t v27 = v13 + *(float64_t *)(v26 + v6); // 0x100003040
    *(float64_t *)(v26 + (int64_t)v4) = v27;
    int32_t v28 = v15 + 1; // 0x100003060
    int32_t v29 = v28 - v2; // 0x100003020
    v15 = v28;
    v13 = v27;
    v14 = v27;
    if (v29 < 0 == ((v29 ^ v28) & (v28 ^ v2)) < 0) {
        goto lab_0x10000306c;
    } else {
        goto lab_0x100003030;
    }
  lab_0x10000306c:;
    int32_t v30 = _rand(); // 0x10000306c
    __asm_movi(0.0f, 0x4f000000);
    float32_t v31; // 0x100002e7c
    v9 = v14 * (float64_t)((float32_t)v30 / v31);
    int64_t v32 = 24 * (int64_t)v16 + v1; // 0x1000030b0
    int64_t v33 = 24 * (0x100000000 * function_100002d18() >> 32) + v1; // 0x1000030c0
    *(float128_t *)v32 = *(float128_t *)v33;
    *(int64_t *)(v32 + 16) = *(int64_t *)(v33 + 16);
    int32_t v34 = v16 + 1; // 0x1000030dc
    int32_t v35 = v34 - v11; // 0x100002f60
    v16 = v34;
    if (v35 < 0 == ((v35 ^ v34) & (v34 ^ v11)) < 0) {
        // break -> 0x1000030f0
        goto lab_0x1000030f0;
    }
    goto lab_0x100002f78;
}

// Address range: 0x100003174 - 0x1000033e4
int64_t function_100003174(void) {
    // 0x100003174
    int64_t v1; // 0x100003174
    int32_t v2 = v1; // 0x100003184
    int32_t v3 = v1; // 0x10000318c
    int64_t * v4 = _malloc(8 * v2); // 0x10000319c
    int64_t v5 = 24 * (int64_t)(_rand() % v2) + v1; // 0x1000031d4
    *(float128_t *)v1 = *(float128_t *)v5;
    *(int64_t *)(v1 + 16) = *(int64_t *)(v5 + 16);
    int32_t v6 = 1 - v3; // 0x1000031fc
    int32_t v7 = -v2;
    int32_t v8 = v7 & v2;
    if (v6 < 0 != (v6 & v3) < 0) {
        int64_t v9 = (int64_t)v4; // 0x10000319c
        int32_t v10 = 1; // 0x100003354
        while (true) {
            int32_t v11 = v10;
            int32_t v12 = 0; // 0x10000322c
            if (v7 < 0 == v8 < 0) {
                // 0x10000328c
                _rand();
            } else {
                function_100002c6c();
                int64_t v13 = 8 * (int64_t)v12 + v9; // 0x10000325c
                *(int64_t *)v13 = 0;
                float64_t v14 = *(float64_t *)v13; // 0x100003270
                int32_t v15 = v12 + 1; // 0x100003280
                int32_t v16 = v15 - v2; // 0x100003224
                int64_t v17 = v14; // 0x10000322c
                v12 = v15;
                float64_t v18 = v14; // 0x10000322c
                while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v2)) < 0) {
                    // 0x100003234
                    function_100002c6c();
                    v13 = 8 * (int64_t)v12 + v9;
                    *(int64_t *)v13 = v17;
                    v14 = v18 + *(float64_t *)v13;
                    v15 = v12 + 1;
                    v16 = v15 - v2;
                    v17 = v14;
                    v12 = v15;
                    v18 = v14;
                }
                float64_t v19 = v14 * (float64_t)_rand() / g1; // 0x1000032e4
                int32_t v20 = 0;
                int64_t v21 = v20; // 0x1000032d8
                v19 -= *(float64_t *)(8 * v21 + v9);
                while (v19 <= 0.0 == (v19 != 0.0)) {
                    int32_t v22 = v20 + 1; // 0x100003340
                    int32_t v23 = v22 - v2; // 0x1000032c4
                    if (v23 < 0 == ((v23 ^ v22) & (v22 ^ v2)) < 0) {
                        goto lab_0x100003350;
                    }
                    v20 = v22;
                    v21 = v20;
                    v19 -= *(float64_t *)(8 * v21 + v9);
                }
                int64_t v24 = 24 * (int64_t)v11 + v1; // 0x100003310
                int64_t v25 = 24 * v21 + v1; // 0x100003320
                *(float128_t *)v24 = *(float128_t *)v25;
                *(int64_t *)(v24 + 16) = *(int64_t *)(v25 + 16);
            }
          lab_0x100003350:
            // 0x100003350
            v10 = v11 + 1;
            int32_t v26 = v10 - v3; // 0x1000031fc
            if (v26 < 0 == ((v26 ^ v10) & (v10 ^ v3)) < 0) {
                // break -> 0x100003368
                break;
            }
        }
    }
    if (v7 < 0 == v8 < 0) {
        // 0x1000033d0
        _free(v4);
        return &g4;
    }
    int32_t v27 = 0; // 0x1000033c4
    *(int32_t *)(v1 + 16 + 24 * (int64_t)v27) = (int32_t)function_100002bac();
    v27++;
    while (v27 - v2 < 0 != ((v27 - v2 ^ v27) & (v27 ^ v2)) < 0) {
        // 0x100003380
        *(int32_t *)(v1 + 16 + 24 * (int64_t)v27) = (int32_t)function_100002bac();
        v27++;
    }
    // 0x1000033d0
    _free(v4);
    return &g4;
}

// Address range: 0x1000033e4 - 0x100003804
int64_t function_1000033e4(void) {
    // 0x1000033e4
    int64_t v1; // 0x1000033e4
    int32_t v2 = v1; // 0x1000033f4
    int32_t v3 = v1; // 0x1000033f8
    if (v3 == 1 || v2 < 1) {
        // 0x1000037f4
        return 0;
    }
    int32_t v4 = v3 - v2; // 0x100003440
    if (v4 != 0 && v4 < 0 == ((v4 ^ v3) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x1000037f4
        return 0;
    }
    int32_t v5 = v1; // 0x1000033fc
    int32_t v6 = v2 / 1000; // 0x100003408
    int64_t result = (int64_t)_malloc(24 * v3); // 0x100003464
    function_100002e7c();
    int32_t v7 = -v3;
    int32_t v8 = -v2;
    int32_t v9 = v5 < 1 == (v5 & -v5) < 0 ? v5 : 1; // 0x1000034a0
    float64_t v10; // 0x1000033e4
    float64_t v11 = v10; // 0x1000034bc
    int32_t v12 = 0; // 0x1000034bc
    int64_t v13; // 0x1000034d4
    int32_t v14; // 0x10000350c
    int32_t v15; // 0x1000034b4
    if (v7 < 0 != (v7 & v3) < 0) {
        v13 = 24 * (int64_t)v12 + result;
        *(int32_t *)(v13 + 16) = 0;
        *(float64_t *)v13 = 0.0;
        *(float64_t *)(v13 + 8) = 0.0;
        v14 = v12 + 1;
        v15 = v14 - v3;
        v11 = 0.0;
        v12 = v14;
        while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v3)) < 0) {
            // 0x1000034c4
            v13 = 24 * (int64_t)v12 + result;
            *(int32_t *)(v13 + 16) = 0;
            *(float64_t *)v13 = 0.0;
            *(float64_t *)(v13 + 8) = 0.0;
            v14 = v12 + 1;
            v15 = v14 - v3;
            v11 = 0.0;
            v12 = v14;
        }
    }
    float64_t v16 = v11; // 0x100003530
    int32_t v17 = 0; // 0x100003530
    int64_t v18; // 0x100003548
    int64_t v19; // 0x100003560
    int32_t * v20; // 0x100003564
    float64_t * v21; // 0x100003590
    float64_t * v22; // 0x1000035c0
    float64_t v23; // 0x1000035c4
    int32_t v24; // 0x1000035d4
    int32_t v25; // 0x100003528
    if (v8 < 0 != (v8 & v2) < 0) {
        v18 = 24 * (int64_t)v17 + v1;
        v19 = 24 * (int64_t)*(int32_t *)(v18 + 16) + result;
        v20 = (int32_t *)(v19 + 16);
        *v20 = *v20 + 1;
        v21 = (float64_t *)v19;
        *v21 = *(float64_t *)v18 + *v21;
        v22 = (float64_t *)(v19 + 8);
        v23 = *(float64_t *)(v18 + 8) + *v22;
        *v22 = v23;
        v24 = v17 + 1;
        v25 = v24 - v2;
        v16 = v23;
        v17 = v24;
        while (v25 < 0 != ((v25 ^ v24) & (v24 ^ v2)) < 0) {
            // 0x100003538
            v18 = 24 * (int64_t)v17 + v1;
            v19 = 24 * (int64_t)*(int32_t *)(v18 + 16) + result;
            v20 = (int32_t *)(v19 + 16);
            *v20 = *v20 + 1;
            v21 = (float64_t *)v19;
            *v21 = *(float64_t *)v18 + *v21;
            v22 = (float64_t *)(v19 + 8);
            v23 = *(float64_t *)(v18 + 8) + *v22;
            *v22 = v23;
            v24 = v17 + 1;
            v25 = v24 - v2;
            v16 = v23;
            v17 = v24;
        }
    }
    float64_t v26 = v16; // 0x1000035f8
    int32_t v27 = 0; // 0x1000035f8
    float64_t v28 = v16; // 0x1000035f8
    int64_t v29; // 0x100003630
    float64_t * v30; // 0x100003634
    float64_t v31; // 0x100003638
    float64_t * v32; // 0x100003670
    float64_t v33; // 0x100003674
    int32_t v34; // 0x100003684
    int32_t v35; // 0x1000035f0
    if (v7 < 0 != (v7 & v3) < 0) {
        __asm_sshll(0.0f, 0);
        v29 = 24 * (int64_t)v27 + result;
        v30 = (float64_t *)v29;
        v31 = *v30 / v28;
        *v30 = v31;
        __asm_sshll(0.0f, 0);
        v32 = (float64_t *)(v29 + 8);
        v33 = *v32 / v31;
        *v32 = v33;
        v34 = v27 + 1;
        v35 = v34 - v3;
        v26 = v33;
        v27 = v34;
        v28 = v33;
        while (v35 < 0 != ((v35 ^ v34) & (v34 ^ v3)) < 0) {
            // 0x100003600
            __asm_sshll(0.0f, 0);
            v29 = 24 * (int64_t)v27 + result;
            v30 = (float64_t *)v29;
            v31 = *v30 / v28;
            *v30 = v31;
            __asm_sshll(0.0f, 0);
            v32 = (float64_t *)(v29 + 8);
            v33 = *v32 / v31;
            *v32 = v33;
            v34 = v27 + 1;
            v35 = v34 - v3;
            v26 = v33;
            v27 = v34;
            v28 = v33;
        }
    }
    int32_t v36 = 0; // 0x1000036ac
    int32_t v37 = 0; // 0x1000036ac
    int32_t v38; // 0x1000033e4
    int32_t v39; // 0x1000033e4
    int32_t v40; // 0x1000036dc
    int32_t * v41; // 0x1000036f4
    int32_t v42; // 0x10000373c
    int32_t v43; // 0x1000036a4
    if (v8 < 0 != (v8 & v2) < 0) {
        v38 = 0;
        v40 = function_100002bac();
        v41 = (int32_t *)(v1 + 16 + 24 * (int64_t)v36);
        v39 = v38;
        if (*v41 != v40) {
            // 0x100003708
            *v41 = v40;
            v39 = v38 + 1;
        }
        // 0x100003738
        v42 = v36 + 1;
        v43 = v42 - v2;
        v36 = v42;
        v37 = v39;
        while (v43 < 0 != ((v43 ^ v42) & (v42 ^ v2)) < 0) {
            // 0x1000036b4
            v38 = v39;
            v40 = function_100002bac();
            v41 = (int32_t *)(v1 + 16 + 24 * (int64_t)v36);
            v39 = v38;
            if (*v41 != v40) {
                // 0x100003708
                *v41 = v40;
                v39 = v38 + 1;
            }
            // 0x100003738
            v42 = v36 + 1;
            v43 = v42 - v2;
            v36 = v42;
            v37 = v39;
        }
    }
    int32_t v44 = v37;
    v9--;
    int32_t v45 = v44 - v6; // 0x100003760
    while (v9 >= 1 == v45 != 0 == v45 < 0 == ((v45 ^ v44) & (v44 ^ v6)) < 0) {
        // 0x1000034a4
        v11 = v26;
        v12 = 0;
        if (v7 < 0 != (v7 & v3) < 0) {
            v13 = 24 * (int64_t)v12 + result;
            *(int32_t *)(v13 + 16) = 0;
            *(float64_t *)v13 = 0.0;
            *(float64_t *)(v13 + 8) = 0.0;
            v14 = v12 + 1;
            v15 = v14 - v3;
            v11 = 0.0;
            v12 = v14;
            while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v3)) < 0) {
                // 0x1000034c4
                v13 = 24 * (int64_t)v12 + result;
                *(int32_t *)(v13 + 16) = 0;
                *(float64_t *)v13 = 0.0;
                *(float64_t *)(v13 + 8) = 0.0;
                v14 = v12 + 1;
                v15 = v14 - v3;
                v11 = 0.0;
                v12 = v14;
            }
        }
        // 0x100003520
        v16 = v11;
        v17 = 0;
        if (v8 < 0 != (v8 & v2) < 0) {
            v18 = 24 * (int64_t)v17 + v1;
            v19 = 24 * (int64_t)*(int32_t *)(v18 + 16) + result;
            v20 = (int32_t *)(v19 + 16);
            *v20 = *v20 + 1;
            v21 = (float64_t *)v19;
            *v21 = *(float64_t *)v18 + *v21;
            v22 = (float64_t *)(v19 + 8);
            v23 = *(float64_t *)(v18 + 8) + *v22;
            *v22 = v23;
            v24 = v17 + 1;
            v25 = v24 - v2;
            v16 = v23;
            v17 = v24;
            while (v25 < 0 != ((v25 ^ v24) & (v24 ^ v2)) < 0) {
                // 0x100003538
                v18 = 24 * (int64_t)v17 + v1;
                v19 = 24 * (int64_t)*(int32_t *)(v18 + 16) + result;
                v20 = (int32_t *)(v19 + 16);
                *v20 = *v20 + 1;
                v21 = (float64_t *)v19;
                *v21 = *(float64_t *)v18 + *v21;
                v22 = (float64_t *)(v19 + 8);
                v23 = *(float64_t *)(v18 + 8) + *v22;
                *v22 = v23;
                v24 = v17 + 1;
                v25 = v24 - v2;
                v16 = v23;
                v17 = v24;
            }
        }
        // 0x1000035e8
        v26 = v16;
        v27 = 0;
        v28 = v16;
        if (v7 < 0 != (v7 & v3) < 0) {
            __asm_sshll(0.0f, 0);
            v29 = 24 * (int64_t)v27 + result;
            v30 = (float64_t *)v29;
            v31 = *v30 / v28;
            *v30 = v31;
            __asm_sshll(0.0f, 0);
            v32 = (float64_t *)(v29 + 8);
            v33 = *v32 / v31;
            *v32 = v33;
            v34 = v27 + 1;
            v35 = v34 - v3;
            v26 = v33;
            v27 = v34;
            v28 = v33;
            while (v35 < 0 != ((v35 ^ v34) & (v34 ^ v3)) < 0) {
                // 0x100003600
                __asm_sshll(0.0f, 0);
                v29 = 24 * (int64_t)v27 + result;
                v30 = (float64_t *)v29;
                v31 = *v30 / v28;
                *v30 = v31;
                __asm_sshll(0.0f, 0);
                v32 = (float64_t *)(v29 + 8);
                v33 = *v32 / v31;
                *v32 = v33;
                v34 = v27 + 1;
                v35 = v34 - v3;
                v26 = v33;
                v27 = v34;
                v28 = v33;
            }
        }
        // 0x10000369c
        v36 = 0;
        v37 = 0;
        if (v8 < 0 != (v8 & v2) < 0) {
            v38 = 0;
            v40 = function_100002bac();
            v41 = (int32_t *)(v1 + 16 + 24 * (int64_t)v36);
            v39 = v38;
            if (*v41 != v40) {
                // 0x100003708
                *v41 = v40;
                v39 = v38 + 1;
            }
            // 0x100003738
            v42 = v36 + 1;
            v43 = v42 - v2;
            v36 = v42;
            v37 = v39;
            while (v43 < 0 != ((v43 ^ v42) & (v42 ^ v2)) < 0) {
                // 0x1000036b4
                v38 = v39;
                v40 = function_100002bac();
                v41 = (int32_t *)(v1 + 16 + 24 * (int64_t)v36);
                v39 = v38;
                if (*v41 != v40) {
                    // 0x100003708
                    *v41 = v40;
                    v39 = v38 + 1;
                }
                // 0x100003738
                v42 = v36 + 1;
                v43 = v42 - v2;
                v36 = v42;
                v37 = v39;
            }
        }
        // 0x100003748
        v44 = v37;
        v9--;
        v45 = v44 - v6;
    }
    // 0x1000037a0
    if (v7 < 0 == (v7 & v3) < 0) {
        // 0x1000037f4
        return result;
    }
    int32_t v46 = 0;
    *(int32_t *)(result + 16 + 24 * (int64_t)v46) = v46;
    int32_t v47 = v46 + 1; // 0x1000037dc
    while (v47 - v3 < 0 != ((v47 - v3 ^ v47) & (v47 ^ v3)) < 0) {
        // 0x1000037b8
        v46 = v47;
        *(int32_t *)(result + 16 + 24 * (int64_t)v46) = v46;
        v47 = v46 + 1;
    }
    // 0x1000037f4
    return result;
}

// Address range: 0x100003804 - 0x100003d20
int64_t function_100003804(void) {
    // 0x100003804
    int64_t v1; // 0x100003804
    int32_t v2 = v1; // 0x10000381c
    int64_t * v3 = _malloc(24 * v2); // 0x100003834
    int64_t v4 = (int64_t)v3; // 0x100003834
    int32_t v5 = -v2;
    int32_t v6 = 0; // 0x100003854
    if (v5 < 0 != (v5 & v2) < 0) {
        uint32_t v7 = 24 * v6; // 0x100003898
        *(float64_t *)((int64_t)v7 + v4) = (float64_t)((3 * v6 + 3) % 11) / 11.0;
        *(float64_t *)((int64_t)(v7 + 8) + v4) = (float64_t)(7 * v6 % 11) / 11.0;
        *(float64_t *)((int64_t)(v7 + 16) + v4) = (float64_t)(9 * v6 % 11) / 11.0;
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x10000385c
            v7 = 24 * v6;
            *(float64_t *)((int64_t)v7 + v4) = (float64_t)((3 * v6 + 3) % 11) / 11.0;
            *(float64_t *)((int64_t)(v7 + 8) + v4) = (float64_t)(7 * v6 % 11) / 11.0;
            *(float64_t *)((int64_t)(v7 + 16) + v4) = (float64_t)(9 * v6 % 11) / 11.0;
            v6++;
        }
    }
    int32_t v8 = v1; // 0x100003814
    int32_t v9 = -v8;
    int32_t v10 = 0; // 0x100003950
    if (v9 < 0 != (v9 & v8) < 0) {
        v10++;
        while (v10 - v8 < 0 != ((v10 - v8 ^ v10) & (v10 ^ v8)) < 0) {
            // 0x100003958
            v10++;
        }
    }
    // 0x100003a8c
    _printf("%%!PS-Adobe-3.0\n%%%%BoundingBox: -5 -5 %d %d\n", v1, v1);
    _printf("/l {rlineto} def /m {rmoveto} def\n/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\n/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \tgsave 1 setgray fill grestore gsave 3 setlinewidth 1 setgray stroke grestore 0 setgray stroke }def\n");
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003d00
        _printf("\n%%%%EOF");
        _free(v3);
        return &g4;
    }
    int32_t v11 = 0;
    int128_t v12; // 0x100003804
    _printf("%g %g %g setrgbcolor\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
    int32_t v13 = 0; // 0x100003bd0
    int32_t v14; // 0x100003bec
    int32_t v15; // 0x100003c78
    int32_t v16; // 0x100003bc8
    if (v9 < 0 != (v9 & v8) < 0) {
        v14 = *(int32_t *)(v1 + 16 + 24 * (int64_t)v13);
        if (v14 == v11) {
            // 0x100003c08
            _printf("%.3f %.3f c\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
        }
        // 0x100003c74
        v15 = v13 + 1;
        v16 = v15 - v8;
        v13 = v15;
        while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v8)) < 0) {
            // 0x100003bd8
            v14 = *(int32_t *)(v1 + 16 + 24 * (int64_t)v13);
            if (v14 == v11) {
                // 0x100003c08
                _printf("%.3f %.3f c\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
            }
            // 0x100003c74
            v15 = v13 + 1;
            v16 = v15 - v8;
            v13 = v15;
        }
    }
    // 0x100003c84
    _printf("\n0 setgray %g %g s\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
    int32_t v17 = v11 + 1; // 0x100003cf4
    while (v17 - v2 < 0 != ((v17 - v2 ^ v17) & (v17 ^ v2)) < 0) {
        // 0x100003b60
        v11 = v17;
        _printf("%g %g %g setrgbcolor\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
        v13 = 0;
        if (v9 < 0 != (v9 & v8) < 0) {
            v14 = *(int32_t *)(v1 + 16 + 24 * (int64_t)v13);
            if (v14 == v11) {
                // 0x100003c08
                _printf("%.3f %.3f c\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
            }
            // 0x100003c74
            v15 = v13 + 1;
            v16 = v15 - v8;
            v13 = v15;
            while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v8)) < 0) {
                // 0x100003bd8
                v14 = *(int32_t *)(v1 + 16 + 24 * (int64_t)v13);
                if (v14 == v11) {
                    // 0x100003c08
                    _printf("%.3f %.3f c\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
                }
                // 0x100003c74
                v15 = v13 + 1;
                v16 = v15 - v8;
                v13 = v15;
            }
        }
        // 0x100003c84
        _printf("\n0 setgray %g %g s\n", (float64_t)(int64_t)v12, (float64_t)(int64_t)v12);
        v17 = v11 + 1;
    }
    // 0x100003d00
    _printf("\n%%%%EOF");
    _free(v3);
    return &g4;
}

// Address range: 0x100003d20 - 0x100003db8
int64_t entry_point(void) {
    int64_t v1 = function_100002a30(); // 0x100003d64
    int64_t v2 = function_1000033e4(); // 0x100003d7c
    function_100003804();
    _free((int64_t *)v1);
    _free((int64_t *)v2);
    return 0;
}

// Address range: 0x100003db8 - 0x100003dc4
float64_t function_100003db8(float64_t a1) {
    // 0x100003db8
    return _cos(a1);
}

// Address range: 0x100003dc4 - 0x100003dd0
void function_100003dc4(int64_t * ptr) {
    // 0x100003dc4
    _free(ptr);
}

// Address range: 0x100003dd0 - 0x100003ddc
int64_t * function_100003dd0(int32_t size) {
    // 0x100003dd0
    return _malloc(size);
}

// Address range: 0x100003ddc - 0x100003de8
int32_t function_100003ddc(char * format, ...) {
    // 0x100003ddc
    return _printf(format);
}

// Address range: 0x100003de8 - 0x100003df4
int32_t function_100003de8(void) {
    // 0x100003de8
    return _rand();
}

// Address range: 0x100003df4 - 0x100003e00
float64_t function_100003df4(float64_t a1) {
    // 0x100003df4
    return _sin(a1);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`// This code is the implementation of Babbage Problem

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int main() {
	int current = 0, 	//the current number
	    square;		//the square of the current number

	//the strategy of take the rest of division by 1e06 is
	//to take the a number how 6 last digits are 269696
	while (((square=current*current) % 1000000 != 269696) && (square<INT_MAX)) {
		current++;
	}

        //output
	if (square>+INT_MAX)
	    printf("Condition not satisfied before INT_MAX reached.");
	else		
	    printf ("The smallest number whose square ends in 269696 is %d\n", current);
	
        //the end
	return 0 ;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e4c - 0x100003f34
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003ed0
    int32_t v2 = 0;
    int32_t v3 = v2 - 0x7fffffff;
    int32_t v4 = 0x7ffffffe - v2 & v2;
    int32_t v5 = v4; // 0x100003ec4
    int32_t v6 = v3; // 0x100003ec4
    while (v3 < 0 != v4 < 0) {
        // 0x100003e64
        v1++;
        int32_t v7 = v1 * v1; // 0x100003e6c
        if (v7 % 0xf4240 == 0x41d80) {
            // 0x100003e64
            v5 = 0x7ffffffe - v7 & v7;
            v6 = v7 - 0x7fffffff;
            goto lab_0x100003edc;
        }
        v2 = v7;
        v3 = v2 - 0x7fffffff;
        v4 = 0x7ffffffe - v2 & v2;
        v5 = v4;
        v6 = v3;
    }
    goto lab_0x100003edc;
  lab_0x100003edc:;
    int32_t v8 = v6;
    if (v8 == 0 || v8 < 0 != v5 < 0) {
        // 0x100003f04
        int64_t v9; // 0x100003e4c
        _printf("The smallest number whose square ends in 269696 is %d\n", v9);
    } else {
        // 0x100003ef4
        _printf("Condition not satisfied before INT_MAX reached.");
    }
    // 0x100003f24
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include<stdlib.h>
#include<stdio.h>

char** imageMatrix;

char blankPixel,imagePixel;

typedef struct{
	int row,col;
}pixel;

int getBlackNeighbours(int row,int col){
	
	int i,j,sum = 0;
	
	for(i=-1;i<=1;i++){
		for(j=-1;j<=1;j++){
			if(i!=0 || j!=0)
				sum+= (imageMatrix[row+i][col+j]==imagePixel);
		}
	}
	
	return sum;
}

int getBWTransitions(int row,int col){
	return 	((imageMatrix[row-1][col]==blankPixel && imageMatrix[row-1][col+1]==imagePixel)
			+(imageMatrix[row-1][col+1]==blankPixel && imageMatrix[row][col+1]==imagePixel)
			+(imageMatrix[row][col+1]==blankPixel && imageMatrix[row+1][col+1]==imagePixel)
			+(imageMatrix[row+1][col+1]==blankPixel && imageMatrix[row+1][col]==imagePixel)
			+(imageMatrix[row+1][col]==blankPixel && imageMatrix[row+1][col-1]==imagePixel)
			+(imageMatrix[row+1][col-1]==blankPixel && imageMatrix[row][col-1]==imagePixel)
			+(imageMatrix[row][col-1]==blankPixel && imageMatrix[row-1][col-1]==imagePixel)
			+(imageMatrix[row-1][col-1]==blankPixel && imageMatrix[row-1][col]==imagePixel));
}

int zhangSuenTest1(int row,int col){
	int neighbours = getBlackNeighbours(row,col);
	
	return ((neighbours>=2 && neighbours<=6)
		&& (getBWTransitions(row,col)==1)
		&& (imageMatrix[row-1][col]==blankPixel||imageMatrix[row][col+1]==blankPixel||imageMatrix[row+1][col]==blankPixel)
		&& (imageMatrix[row][col+1]==blankPixel||imageMatrix[row+1][col]==blankPixel||imageMatrix[row][col-1]==blankPixel));
}

int zhangSuenTest2(int row,int col){
	int neighbours = getBlackNeighbours(row,col);
	
	return ((neighbours>=2 && neighbours<=6)
		&& (getBWTransitions(row,col)==1)
		&& (imageMatrix[row-1][col]==blankPixel||imageMatrix[row][col+1]==blankPixel||imageMatrix[row][col-1]==blankPixel)
		&& (imageMatrix[row-1][col]==blankPixel||imageMatrix[row+1][col]==blankPixel||imageMatrix[row][col+1]==blankPixel));
}

void zhangSuen(char* inputFile, char* outputFile){
	
	int startRow = 1,startCol = 1,endRow,endCol,i,j,count,rows,cols,processed;
	
	pixel* markers;
	
	FILE* inputP = fopen(inputFile,"r");
	
	fscanf(inputP,"%d%d",&rows,&cols);
	
	fscanf(inputP,"%d%d",&blankPixel,&imagePixel);
	
	blankPixel<=9?blankPixel+='0':blankPixel;
	imagePixel<=9?imagePixel+='0':imagePixel;
	
	printf("\nPrinting original image :\n");
	
	imageMatrix = (char**)malloc(rows*sizeof(char*));
	
	for(i=0;i<rows;i++){
		imageMatrix[i] = (char*)malloc((cols+1)*sizeof(char));
		fscanf(inputP,"%s\n",imageMatrix[i]);
		printf("\n%s",imageMatrix[i]);
		
	}

	fclose(inputP);
	
	endRow = rows-2;
	endCol = cols-2;
	do{
		markers = (pixel*)malloc((endRow-startRow+1)*(endCol-startCol+1)*sizeof(pixel));
		count = 0;
		
		for(i=startRow;i<=endRow;i++){
			for(j=startCol;j<=endCol;j++){
				if(imageMatrix[i][j]==imagePixel && zhangSuenTest1(i,j)==1){
					markers[count].row = i;
					markers[count].col = j;
					count++;
				}
			}
		}
		
		processed = (count>0);
		
		for(i=0;i<count;i++){
			imageMatrix[markers[i].row][markers[i].col] = blankPixel;
		}
		
		free(markers);
		markers = (pixel*)malloc((endRow-startRow+1)*(endCol-startCol+1)*sizeof(pixel));
		count = 0;
		
		for(i=startRow;i<=endRow;i++){
			for(j=startCol;j<=endCol;j++){
				if(imageMatrix[i][j]==imagePixel && zhangSuenTest2(i,j)==1){
					markers[count].row = i;
					markers[count].col = j;
					count++;
				}
			}
		}
		
		if(processed==0)
			processed = (count>0);
		
		for(i=0;i<count;i++){
			imageMatrix[markers[i].row][markers[i].col] = blankPixel;
		}
		
		free(markers);
	}while(processed==1);
	
	FILE* outputP = fopen(outputFile,"w");
	
	printf("\n\n\nPrinting image after applying Zhang Suen Thinning Algorithm : \n\n\n");
	
	for(i=0;i<rows;i++){
		for(j=0;j<cols;j++){
			printf("%c",imageMatrix[i][j]);
			fprintf(outputP,"%c",imageMatrix[i][j]);
		}
		printf("\n");
		fprintf(outputP,"\n");
	}
	
	fclose(outputP);
	
	printf("\nImage also written to : %s",outputFile);
}

int main()
{
	char inputFile[100],outputFile[100];
	
	printf("Enter full path of input image file : ");
	scanf("%s",inputFile);
	
	printf("Enter full path of output image file : ");
	scanf("%s",outputFile);
	
	zhangSuen(inputFile,outputFile);
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002c90(void);
int64_t function_100002d90(void);
int64_t function_100003258(void);
int64_t function_100003478(void);
int64_t function_100003698(void);
int64_t function_100003e3c(int64_t a1);
int32_t function_100003e48(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e54(char * filename, char * modes);
int32_t function_100003e60(struct _IO_FILE * stream, char * format, ...);
void function_100003e6c(int64_t * ptr);
int32_t function_100003e78(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003e84(int32_t size);
int32_t function_100003e90(char * format, ...);
int32_t function_100003e9c(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1 = "\xcf\xfa\xed\xfe\f"; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
char * g3 = "\x12"; // 0x100008010

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100002c90 - 0x100002d90
int64_t function_100002c90(void) {
    char v1 = *(char *)&g3;
    int32_t v2 = -1;
    int64_t v3; // 0x100002c90
    int64_t * v4 = (int64_t *)(g2 + (int64_t)(8 * (v2 + (int32_t)v3)));
    int32_t v5 = 0;
    int32_t v6 = -1;
    int32_t v7 = v5; // 0x100002cec
    char v8; // 0x100002d30
    if ((v6 || v2) != 0) {
        // 0x100002d08
        v8 = *(char *)(*v4 + (int64_t)(v6 + (int32_t)v3));
        v7 = v5 + (int32_t)(v8 == v1);
    }
    int32_t result = v7;
    int32_t v9 = v6 + 1; // 0x100002d64
    while (v6 == 0 || v6 < 0 != (v9 & -v6) < 0) {
        // 0x100002ce0
        v5 = result;
        v6 = v9;
        v7 = v5;
        if ((v6 || v2) != 0) {
            // 0x100002d08
            v8 = *(char *)(*v4 + (int64_t)(v6 + (int32_t)v3));
            v7 = v5 + (int32_t)(v8 == v1);
        }
        // 0x100002d60
        result = v7;
        v9 = v6 + 1;
    }
    int32_t v10 = v2 + 1; // 0x100002d78
    while (v2 == 0 || v2 < 0 != (v10 & -v2) < 0) {
        // 0x100002ccc
        v2 = v10;
        v4 = (int64_t *)(g2 + (int64_t)(8 * (v2 + (int32_t)v3)));
        v5 = result;
        v6 = -1;
        v7 = v5;
        if ((v6 || v2) != 0) {
            // 0x100002d08
            v8 = *(char *)(*v4 + (int64_t)(v6 + (int32_t)v3));
            v7 = v5 + (int32_t)(v8 == v1);
        }
        // 0x100002d60
        result = v7;
        v9 = v6 + 1;
        while (v6 == 0 || v6 < 0 != (v9 & -v6) < 0) {
            // 0x100002ce0
            v5 = result;
            v6 = v9;
            v7 = v5;
            if ((v6 || v2) != 0) {
                // 0x100002d08
                v8 = *(char *)(*v4 + (int64_t)(v6 + (int32_t)v3));
                v7 = v5 + (int32_t)(v8 == v1);
            }
            // 0x100002d60
            result = v7;
            v9 = v6 + 1;
        }
        // 0x100002d74
        v10 = v2 + 1;
    }
    // 0x100002d84
    return result;
}

// Address range: 0x100002d90 - 0x100003258
int64_t function_100002d90(void) {
    // 0x100002d90
    int64_t v1; // 0x100002d90
    int64_t v2 = 8 * v1; // 0x100002dac
    int64_t v3 = *(int64_t *)(g2 + (v2 + 0xfffffff8 & 0xfffffff8)); // 0x100002db0
    int64_t v4 = 0x100000000 * v1 >> 32; // 0x100002db4
    char v5 = *(char *)(v3 + v4); // 0x100002db8
    char v6 = *(char *)&g1; // 0x100002dc4
    int64_t v7 = v1 + 1 & 0xffffffff;
    char v8 = *(char *)(v3 + v7);
    char v9 = *(char *)&g3;
    int64_t v10 = *(int64_t *)(g2 + (0x100000000 * v1 >> 29));
    char * v11 = (char *)(v10 + v7);
    int64_t v12 = 0; // 0x100002e6c
    if (v8 == v6) {
        // 0x100002e74
        v12 = *v11 == *(char *)&g3;
    }
    int64_t v13 = *(int64_t *)(g2 + (v2 + 8 & 0xfffffff8));
    char * v14 = (char *)(v13 + v7);
    int64_t v15 = 0; // 0x100002f00
    if (*v11 == v6) {
        // 0x100002f08
        v15 = *v14 == *(char *)&g3;
    }
    char v16 = *v14; // 0x100002f7c
    char v17 = *(char *)(v13 + v4);
    char v18 = *(char *)&g3;
    int64_t v19 = v1 + 0xffffffff & 0xffffffff;
    char v20 = *(char *)(v13 + v19);
    char v21 = *(char *)&g3;
    char v22 = *(char *)(v10 + v19);
    char v23 = *(char *)&g3;
    char v24 = *(char *)(v3 + v19);
    char v25 = *(char *)&g3;
    return v12 + (int64_t)(v5 == v6 == v8 == v9) + v15 + (int64_t)(v16 == v6 == v17 == v18) + (int64_t)(v17 == v6 == v20 == v21) + (int64_t)(v20 == v6 == v22 == v23) + (int64_t)(v22 == v6 == v24 == v25) + (int64_t)(v24 == v6 == v5 == v25) & 0xffffffff;
}

// Address range: 0x100003258 - 0x100003478
int64_t function_100003258(void) {
    int32_t v1 = function_100002c90(); // 0x100003278
    if (v1 < 2 != (1 - v1 & v1) < 0) {
        // 0x100003464
        return 0;
    }
    int32_t v2 = v1 - 6; // 0x10000329c
    if (v2 != 0 && v2 < 0 == (5 - v1 & v1) < 0 || (int32_t)function_100002d90() != 1) {
        // 0x100003464
        return 0;
    }
    // 0x1000032d8
    int64_t v3; // 0x100003258
    int32_t v4 = 8 * (int32_t)v3; // 0x1000032e8
    int64_t v5 = 0x100000000 * v3 >> 32; // 0x1000032f0
    char v6 = *(char *)(*(int64_t *)(g2 + (int64_t)(v4 - 8)) + v5); // 0x1000032f4
    char v7 = *(char *)&g1; // 0x100003300
    int64_t * v8 = (int64_t *)(g2 + (0x100000000 * v3 >> 29));
    char * v9; // 0x100003258
    int64_t v10; // 0x100003258
    if (v6 == v7) {
        int64_t v11 = *v8;
        v9 = (char *)(v11 + (v3 + 1 & 0xffffffff));
        v10 = v11;
    } else {
        int64_t v12 = *v8; // 0x100003324
        char * v13 = (char *)(v12 + (v3 + 1 & 0xffffffff));
        v9 = v13;
        v10 = v12;
        if (*v13 != v7) {
            // 0x100003350
            v9 = v13;
            v10 = v12;
            if (*(char *)(*(int64_t *)(g2 + (int64_t)(v4 + 8)) + v5) != v7) {
                // 0x100003464
                return 0;
            }
        }
    }
    // 0x100003394
    if (*v9 == v7) {
        // 0x100003464
        return 1;
    }
    int64_t result = 1; // 0x100003414
    if (*(char *)(*(int64_t *)(g2 + (8 * v3 + 8 & 0xfffffff8)) + v5) != v7) {
        char v14 = *(char *)(v10 + (v3 + 0xffffffff & 0xffffffff)); // 0x100003438
        result = v14 == v7;
    }
    // 0x100003464
    return result;
}

// Address range: 0x100003478 - 0x100003698
int64_t function_100003478(void) {
    int32_t v1 = function_100002c90(); // 0x100003498
    if (v1 < 2 != (1 - v1 & v1) < 0) {
        // 0x100003684
        return 0;
    }
    int32_t v2 = v1 - 6; // 0x1000034bc
    if (v2 != 0 && v2 < 0 == (5 - v1 & v1) < 0 || (int32_t)function_100002d90() != 1) {
        // 0x100003684
        return 0;
    }
    // 0x1000034f8
    int64_t v3; // 0x100003478
    int64_t v4 = 8 * v3; // 0x100003508
    int64_t v5 = 0x100000000 * v3 >> 32; // 0x100003510
    char v6 = *(char *)&g1; // 0x100003520
    if (*(char *)(*(int64_t *)(g2 + (v4 + 0xfffffff8 & 0xfffffff8)) + v5) == v6) {
        // 0x100003684
        return 1;
    }
    int64_t v7 = *(int64_t *)(g2 + (0x100000000 * v3 >> 29)); // 0x100003544
    char v8 = *(char *)(v7 + (v3 + 1 & 0xffffffff)); // 0x100003550
    char v9; // 0x100003614
    if (v8 == v6) {
        // 0x1000035f8
        v9 = *(char *)(*(int64_t *)(g2 + (v4 + 8 & 0xfffffff8)) + v5);
        return v9 == v6 | v8 == v6;
    }
    // 0x100003570
    if (*(char *)(v7 + (v3 + 0xffffffff & 0xffffffff)) != v6) {
        // 0x100003684
        return 0;
    }
    // 0x1000035f8
    v9 = *(char *)(*(int64_t *)(g2 + (v4 + 8 & 0xfffffff8)) + v5);
    return v9 == v6 | v8 == v6;
}

// Address range: 0x100003698 - 0x100003d84
int64_t function_100003698(void) {
    // 0x100003698
    int64_t v1; // 0x100003698
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x1000036c4
    int64_t * v3 = (int64_t *)v1; // 0x1000036f0
    int64_t * v4 = (int64_t *)v1; // 0x1000036f0
    _fscanf(v2, "%d%d", v3, v4);
    _fscanf(v2, "%d%d", v3, v4);
    char v5 = *(char *)&g1; // 0x100003724
    int32_t v6 = v5; // 0x100003724
    int32_t v7 = v6 - 9; // 0x100003728
    if (v7 == 0 || v7 < 0 != (8 - v6 & v6) < 0) {
        // 0x100003738
        *(char *)&g1 = v5 + 48;
    }
    char v8 = *(char *)&g3; // 0x10000375c
    int32_t v9 = v8; // 0x10000375c
    int32_t v10 = v9 - 9; // 0x100003760
    if (v10 == 0 || v10 < 0 != (8 - v9 & v9) < 0) {
        // 0x100003770
        *(char *)&g3 = v8 + 48;
    }
    // 0x10000378c
    _printf("\nPrinting original image :\n");
    int32_t v11; // 0x100003698
    g2 = (int64_t)_malloc(8 * v11);
    int32_t v12 = -v11;
    if (v12 < 0 != (v11 & v12) < 0) {
        int32_t v13 = 0; // 0x100003850
        int64_t * v14 = _malloc(v11 + 1); // 0x1000037e4
        *(int64_t *)(g2 + 8 * (int64_t)v13) = (int64_t)v14;
        _fscanf(v2, "%s\n", (char **)v1);
        _printf("\n%s", "%s\n");
        v13++;
        while (v13 - v11 < 0 != ((v13 - v11 ^ v13) & (v13 ^ v11)) < 0) {
            // 0x1000037d0
            v14 = _malloc(v11 + 1);
            *(int64_t *)(g2 + 8 * (int64_t)v13) = (int64_t)v14;
            _fscanf(v2, "%s\n", (char **)v1);
            _printf("\n%s", "%s\n");
            v13++;
        }
    }
    // 0x10000385c
    _fclose(v2);
    int32_t v15 = v11 - 2; // 0x100003868
    int32_t v16 = v11 - 2; // 0x100003874
    int32_t v17 = v15 * 8 * v16; // 0x1000038ac
    int32_t v18 = 3 - v11;
    bool v19 = v18 == 0 | v18 < 0 != (v18 & v15) < 0;
    int32_t v20 = 3 - v11;
    bool v21 = v20 == 0 | v20 < 0 != (v20 & v16) < 0;
    int64_t * v22 = _malloc(v17); // 0x1000038b0
    int64_t v23 = (int64_t)v22; // 0x1000038b0
    int32_t v24 = 0; // 0x1000038d8
    int32_t v25; // 0x100003698
    int32_t v26; // 0x100003698
    int32_t v27; // 0x100003698
    int32_t v28; // 0x100003698
    int32_t v29; // 0x100003698
    int32_t v30; // 0x100003698
    int32_t v31; // 0x100003698
    int32_t v32; // 0x1000039ac
    int32_t v33; // 0x1000038d0
    int64_t v34; // 0x100003914
    char v35; // 0x100003928
    int32_t v36; // 0x100003998
    int32_t v37; // 0x1000038f4
    int64_t v38; // 0x100003968
    if (v19) {
        v25 = 0;
        v31 = 1;
        v27 = v25;
        if (v21) {
            // 0x100003904
            v26 = v25;
            v30 = 1;
            v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
            v35 = *(char *)&g3;
            v28 = v26;
            if (*(char *)(v34 + (int64_t)v30) == v35) {
                // 0x10000393c
                v28 = v26;
                if ((int32_t)function_100003258() == 1) {
                    // 0x100003958
                    v38 = 8 * (int64_t)v26 + v23;
                    *(int32_t *)v38 = v31;
                    *(int32_t *)(v38 + 4) = v30;
                    v28 = v26 + 1;
                }
            }
            // 0x100003994
            v29 = v28;
            v36 = v30 + 1;
            v37 = v36 - v16;
            v27 = v29;
            while (v37 == 0 || v37 < 0 != ((v37 ^ v36) & (v36 ^ v16)) < 0) {
                // 0x100003904
                v26 = v29;
                v30 = v36;
                v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                v35 = *(char *)&g3;
                v28 = v26;
                if (*(char *)(v34 + (int64_t)v30) == v35) {
                    // 0x10000393c
                    v28 = v26;
                    if ((int32_t)function_100003258() == 1) {
                        // 0x100003958
                        v38 = 8 * (int64_t)v26 + v23;
                        *(int32_t *)v38 = v31;
                        *(int32_t *)(v38 + 4) = v30;
                        v28 = v26 + 1;
                    }
                }
                // 0x100003994
                v29 = v28;
                v36 = v30 + 1;
                v37 = v36 - v16;
                v27 = v29;
            }
        }
        // 0x1000039a8
        v32 = v31 + 1;
        v33 = v32 - v15;
        v24 = v27;
        while (v33 == 0 || v33 < 0 != ((v33 ^ v32) & (v32 ^ v15)) < 0) {
            // 0x1000038ec
            v25 = v27;
            v31 = v32;
            v27 = v25;
            if (v21) {
                // 0x100003904
                v26 = v25;
                v30 = 1;
                v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                v35 = *(char *)&g3;
                v28 = v26;
                if (*(char *)(v34 + (int64_t)v30) == v35) {
                    // 0x10000393c
                    v28 = v26;
                    if ((int32_t)function_100003258() == 1) {
                        // 0x100003958
                        v38 = 8 * (int64_t)v26 + v23;
                        *(int32_t *)v38 = v31;
                        *(int32_t *)(v38 + 4) = v30;
                        v28 = v26 + 1;
                    }
                }
                // 0x100003994
                v29 = v28;
                v36 = v30 + 1;
                v37 = v36 - v16;
                v27 = v29;
                while (v37 == 0 || v37 < 0 != ((v37 ^ v36) & (v36 ^ v16)) < 0) {
                    // 0x100003904
                    v26 = v29;
                    v30 = v36;
                    v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                    v35 = *(char *)&g3;
                    v28 = v26;
                    if (*(char *)(v34 + (int64_t)v30) == v35) {
                        // 0x10000393c
                        v28 = v26;
                        if ((int32_t)function_100003258() == 1) {
                            // 0x100003958
                            v38 = 8 * (int64_t)v26 + v23;
                            *(int32_t *)v38 = v31;
                            *(int32_t *)(v38 + 4) = v30;
                            v28 = v26 + 1;
                        }
                    }
                    // 0x100003994
                    v29 = v28;
                    v36 = v30 + 1;
                    v37 = v36 - v16;
                    v27 = v29;
                }
            }
            // 0x1000039a8
            v32 = v31 + 1;
            v33 = v32 - v15;
            v24 = v27;
        }
    }
    int32_t v39 = v24;
    int32_t v40 = -v39; // 0x1000039dc
    int32_t v41 = 0; // 0x1000039e4
    int64_t v42; // 0x100003a10
    int64_t v43; // 0x100003a14
    int32_t v44; // 0x100003a24
    int32_t v45; // 0x100003a38
    int32_t v46; // 0x1000039dc
    if (v40 < 0 != (v39 & v40) < 0) {
        v42 = 8 * (int64_t)v41 + v23;
        v43 = *(int64_t *)(8 * (int64_t)*(int32_t *)v42 + g2);
        v44 = *(int32_t *)(v42 + 4);
        *(char *)(v43 + (int64_t)v44) = *(char *)&g1;
        v45 = v41 + 1;
        v46 = v45 - v39;
        v41 = v45;
        while (v46 < 0 != ((v46 ^ v45) & (v45 ^ v39)) < 0) {
            // 0x1000039ec
            v42 = 8 * (int64_t)v41 + v23;
            v43 = *(int64_t *)(8 * (int64_t)*(int32_t *)v42 + g2);
            v44 = *(int32_t *)(v42 + 4);
            *(char *)(v43 + (int64_t)v44) = *(char *)&g1;
            v45 = v41 + 1;
            v46 = v45 - v39;
            v41 = v45;
        }
    }
    // 0x100003a44
    _free(v22);
    int64_t * v47 = _malloc(v17); // 0x100003a7c
    int64_t v48 = (int64_t)v47; // 0x100003a7c
    int32_t v49 = 0; // 0x100003aa4
    int32_t v50; // 0x100003698
    int32_t v51; // 0x100003698
    int32_t v52; // 0x100003698
    int32_t v53; // 0x100003698
    int32_t v54; // 0x100003698
    int32_t v55; // 0x100003698
    int32_t v56; // 0x100003698
    int32_t v57; // 0x100003b78
    int32_t v58; // 0x100003a9c
    int64_t v59; // 0x100003ae0
    char v60; // 0x100003af4
    int32_t v61; // 0x100003b64
    int32_t v62; // 0x100003ac0
    int64_t v63; // 0x100003b34
    if (v19) {
        v50 = 0;
        v56 = 1;
        v52 = v50;
        if (v21) {
            // 0x100003ad0
            v51 = v50;
            v55 = 1;
            v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
            v60 = *(char *)&g3;
            v53 = v51;
            if (*(char *)(v59 + (int64_t)v55) == v60) {
                // 0x100003b08
                v53 = v51;
                if ((int32_t)function_100003478() == 1) {
                    // 0x100003b24
                    v63 = 8 * (int64_t)v51 + v48;
                    *(int32_t *)v63 = v56;
                    *(int32_t *)(v63 + 4) = v55;
                    v53 = v51 + 1;
                }
            }
            // 0x100003b60
            v54 = v53;
            v61 = v55 + 1;
            v62 = v61 - v16;
            v52 = v54;
            while (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v61 ^ v16)) < 0) {
                // 0x100003ad0
                v51 = v54;
                v55 = v61;
                v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                v60 = *(char *)&g3;
                v53 = v51;
                if (*(char *)(v59 + (int64_t)v55) == v60) {
                    // 0x100003b08
                    v53 = v51;
                    if ((int32_t)function_100003478() == 1) {
                        // 0x100003b24
                        v63 = 8 * (int64_t)v51 + v48;
                        *(int32_t *)v63 = v56;
                        *(int32_t *)(v63 + 4) = v55;
                        v53 = v51 + 1;
                    }
                }
                // 0x100003b60
                v54 = v53;
                v61 = v55 + 1;
                v62 = v61 - v16;
                v52 = v54;
            }
        }
        // 0x100003b74
        v57 = v56 + 1;
        v58 = v57 - v15;
        v49 = v52;
        while (v58 == 0 || v58 < 0 != ((v58 ^ v57) & (v57 ^ v15)) < 0) {
            // 0x100003ab8
            v50 = v52;
            v56 = v57;
            v52 = v50;
            if (v21) {
                // 0x100003ad0
                v51 = v50;
                v55 = 1;
                v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                v60 = *(char *)&g3;
                v53 = v51;
                if (*(char *)(v59 + (int64_t)v55) == v60) {
                    // 0x100003b08
                    v53 = v51;
                    if ((int32_t)function_100003478() == 1) {
                        // 0x100003b24
                        v63 = 8 * (int64_t)v51 + v48;
                        *(int32_t *)v63 = v56;
                        *(int32_t *)(v63 + 4) = v55;
                        v53 = v51 + 1;
                    }
                }
                // 0x100003b60
                v54 = v53;
                v61 = v55 + 1;
                v62 = v61 - v16;
                v52 = v54;
                while (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v61 ^ v16)) < 0) {
                    // 0x100003ad0
                    v51 = v54;
                    v55 = v61;
                    v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                    v60 = *(char *)&g3;
                    v53 = v51;
                    if (*(char *)(v59 + (int64_t)v55) == v60) {
                        // 0x100003b08
                        v53 = v51;
                        if ((int32_t)function_100003478() == 1) {
                            // 0x100003b24
                            v63 = 8 * (int64_t)v51 + v48;
                            *(int32_t *)v63 = v56;
                            *(int32_t *)(v63 + 4) = v55;
                            v53 = v51 + 1;
                        }
                    }
                    // 0x100003b60
                    v54 = v53;
                    v61 = v55 + 1;
                    v62 = v61 - v16;
                    v52 = v54;
                }
            }
            // 0x100003b74
            v57 = v56 + 1;
            v58 = v57 - v15;
            v49 = v52;
        }
    }
    int32_t v64 = v49;
    int32_t v65 = -v64; // 0x100003bc0
    int32_t v66 = 0; // 0x100003bc8
    int64_t v67; // 0x100003bf4
    int64_t v68; // 0x100003bf8
    int32_t v69; // 0x100003c08
    int32_t v70; // 0x100003c1c
    int32_t v71; // 0x100003bc0
    if (v65 < 0 != (v64 & v65) < 0) {
        v67 = 8 * (int64_t)v66 + v48;
        v68 = *(int64_t *)(8 * (int64_t)*(int32_t *)v67 + g2);
        v69 = *(int32_t *)(v67 + 4);
        *(char *)(v68 + (int64_t)v69) = *(char *)&g1;
        v70 = v66 + 1;
        v71 = v70 - v64;
        v66 = v70;
        while (v71 < 0 != ((v71 ^ v70) & (v70 ^ v64)) < 0) {
            // 0x100003bd0
            v67 = 8 * (int64_t)v66 + v48;
            v68 = *(int64_t *)(8 * (int64_t)*(int32_t *)v67 + g2);
            v69 = *(int32_t *)(v67 + 4);
            *(char *)(v68 + (int64_t)v69) = *(char *)&g1;
            v70 = v66 + 1;
            v71 = v70 - v64;
            v66 = v70;
        }
    }
    bool v72 = v39 < 1 ? v64 >= 1 : v39 >= 1;
    _free(v47);
    while (v72) {
        // 0x100003880
        v22 = _malloc(v17);
        v23 = (int64_t)v22;
        v24 = 0;
        if (v19) {
            v25 = 0;
            v31 = 1;
            v27 = v25;
            if (v21) {
                // 0x100003904
                v26 = v25;
                v30 = 1;
                v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                v35 = *(char *)&g3;
                v28 = v26;
                if (*(char *)(v34 + (int64_t)v30) == v35) {
                    // 0x10000393c
                    v28 = v26;
                    if ((int32_t)function_100003258() == 1) {
                        // 0x100003958
                        v38 = 8 * (int64_t)v26 + v23;
                        *(int32_t *)v38 = v31;
                        *(int32_t *)(v38 + 4) = v30;
                        v28 = v26 + 1;
                    }
                }
                // 0x100003994
                v29 = v28;
                v36 = v30 + 1;
                v37 = v36 - v16;
                v27 = v29;
                while (v37 == 0 || v37 < 0 != ((v37 ^ v36) & (v36 ^ v16)) < 0) {
                    // 0x100003904
                    v26 = v29;
                    v30 = v36;
                    v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                    v35 = *(char *)&g3;
                    v28 = v26;
                    if (*(char *)(v34 + (int64_t)v30) == v35) {
                        // 0x10000393c
                        v28 = v26;
                        if ((int32_t)function_100003258() == 1) {
                            // 0x100003958
                            v38 = 8 * (int64_t)v26 + v23;
                            *(int32_t *)v38 = v31;
                            *(int32_t *)(v38 + 4) = v30;
                            v28 = v26 + 1;
                        }
                    }
                    // 0x100003994
                    v29 = v28;
                    v36 = v30 + 1;
                    v37 = v36 - v16;
                    v27 = v29;
                }
            }
            // 0x1000039a8
            v32 = v31 + 1;
            v33 = v32 - v15;
            v24 = v27;
            while (v33 == 0 || v33 < 0 != ((v33 ^ v32) & (v32 ^ v15)) < 0) {
                // 0x1000038ec
                v25 = v27;
                v31 = v32;
                v27 = v25;
                if (v21) {
                    // 0x100003904
                    v26 = v25;
                    v30 = 1;
                    v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                    v35 = *(char *)&g3;
                    v28 = v26;
                    if (*(char *)(v34 + (int64_t)v30) == v35) {
                        // 0x10000393c
                        v28 = v26;
                        if ((int32_t)function_100003258() == 1) {
                            // 0x100003958
                            v38 = 8 * (int64_t)v26 + v23;
                            *(int32_t *)v38 = v31;
                            *(int32_t *)(v38 + 4) = v30;
                            v28 = v26 + 1;
                        }
                    }
                    // 0x100003994
                    v29 = v28;
                    v36 = v30 + 1;
                    v37 = v36 - v16;
                    v27 = v29;
                    while (v37 == 0 || v37 < 0 != ((v37 ^ v36) & (v36 ^ v16)) < 0) {
                        // 0x100003904
                        v26 = v29;
                        v30 = v36;
                        v34 = *(int64_t *)(g2 + 8 * (int64_t)v31);
                        v35 = *(char *)&g3;
                        v28 = v26;
                        if (*(char *)(v34 + (int64_t)v30) == v35) {
                            // 0x10000393c
                            v28 = v26;
                            if ((int32_t)function_100003258() == 1) {
                                // 0x100003958
                                v38 = 8 * (int64_t)v26 + v23;
                                *(int32_t *)v38 = v31;
                                *(int32_t *)(v38 + 4) = v30;
                                v28 = v26 + 1;
                            }
                        }
                        // 0x100003994
                        v29 = v28;
                        v36 = v30 + 1;
                        v37 = v36 - v16;
                        v27 = v29;
                    }
                }
                // 0x1000039a8
                v32 = v31 + 1;
                v33 = v32 - v15;
                v24 = v27;
            }
        }
        // 0x1000039b8
        v39 = v24;
        v40 = -v39;
        v41 = 0;
        if (v40 < 0 != (v39 & v40) < 0) {
            v42 = 8 * (int64_t)v41 + v23;
            v43 = *(int64_t *)(8 * (int64_t)*(int32_t *)v42 + g2);
            v44 = *(int32_t *)(v42 + 4);
            *(char *)(v43 + (int64_t)v44) = *(char *)&g1;
            v45 = v41 + 1;
            v46 = v45 - v39;
            v41 = v45;
            while (v46 < 0 != ((v46 ^ v45) & (v45 ^ v39)) < 0) {
                // 0x1000039ec
                v42 = 8 * (int64_t)v41 + v23;
                v43 = *(int64_t *)(8 * (int64_t)*(int32_t *)v42 + g2);
                v44 = *(int32_t *)(v42 + 4);
                *(char *)(v43 + (int64_t)v44) = *(char *)&g1;
                v45 = v41 + 1;
                v46 = v45 - v39;
                v41 = v45;
            }
        }
        // 0x100003a44
        _free(v22);
        v47 = _malloc(v17);
        v48 = (int64_t)v47;
        v49 = 0;
        if (v19) {
            v50 = 0;
            v56 = 1;
            v52 = v50;
            if (v21) {
                // 0x100003ad0
                v51 = v50;
                v55 = 1;
                v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                v60 = *(char *)&g3;
                v53 = v51;
                if (*(char *)(v59 + (int64_t)v55) == v60) {
                    // 0x100003b08
                    v53 = v51;
                    if ((int32_t)function_100003478() == 1) {
                        // 0x100003b24
                        v63 = 8 * (int64_t)v51 + v48;
                        *(int32_t *)v63 = v56;
                        *(int32_t *)(v63 + 4) = v55;
                        v53 = v51 + 1;
                    }
                }
                // 0x100003b60
                v54 = v53;
                v61 = v55 + 1;
                v62 = v61 - v16;
                v52 = v54;
                while (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v61 ^ v16)) < 0) {
                    // 0x100003ad0
                    v51 = v54;
                    v55 = v61;
                    v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                    v60 = *(char *)&g3;
                    v53 = v51;
                    if (*(char *)(v59 + (int64_t)v55) == v60) {
                        // 0x100003b08
                        v53 = v51;
                        if ((int32_t)function_100003478() == 1) {
                            // 0x100003b24
                            v63 = 8 * (int64_t)v51 + v48;
                            *(int32_t *)v63 = v56;
                            *(int32_t *)(v63 + 4) = v55;
                            v53 = v51 + 1;
                        }
                    }
                    // 0x100003b60
                    v54 = v53;
                    v61 = v55 + 1;
                    v62 = v61 - v16;
                    v52 = v54;
                }
            }
            // 0x100003b74
            v57 = v56 + 1;
            v58 = v57 - v15;
            v49 = v52;
            while (v58 == 0 || v58 < 0 != ((v58 ^ v57) & (v57 ^ v15)) < 0) {
                // 0x100003ab8
                v50 = v52;
                v56 = v57;
                v52 = v50;
                if (v21) {
                    // 0x100003ad0
                    v51 = v50;
                    v55 = 1;
                    v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                    v60 = *(char *)&g3;
                    v53 = v51;
                    if (*(char *)(v59 + (int64_t)v55) == v60) {
                        // 0x100003b08
                        v53 = v51;
                        if ((int32_t)function_100003478() == 1) {
                            // 0x100003b24
                            v63 = 8 * (int64_t)v51 + v48;
                            *(int32_t *)v63 = v56;
                            *(int32_t *)(v63 + 4) = v55;
                            v53 = v51 + 1;
                        }
                    }
                    // 0x100003b60
                    v54 = v53;
                    v61 = v55 + 1;
                    v62 = v61 - v16;
                    v52 = v54;
                    while (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v61 ^ v16)) < 0) {
                        // 0x100003ad0
                        v51 = v54;
                        v55 = v61;
                        v59 = *(int64_t *)(g2 + 8 * (int64_t)v56);
                        v60 = *(char *)&g3;
                        v53 = v51;
                        if (*(char *)(v59 + (int64_t)v55) == v60) {
                            // 0x100003b08
                            v53 = v51;
                            if ((int32_t)function_100003478() == 1) {
                                // 0x100003b24
                                v63 = 8 * (int64_t)v51 + v48;
                                *(int32_t *)v63 = v56;
                                *(int32_t *)(v63 + 4) = v55;
                                v53 = v51 + 1;
                            }
                        }
                        // 0x100003b60
                        v54 = v53;
                        v61 = v55 + 1;
                        v62 = v61 - v16;
                        v52 = v54;
                    }
                }
                // 0x100003b74
                v57 = v56 + 1;
                v58 = v57 - v15;
                v49 = v52;
            }
        }
        // 0x100003b84
        v64 = v49;
        v65 = -v64;
        v66 = 0;
        if (v65 < 0 != (v64 & v65) < 0) {
            v67 = 8 * (int64_t)v66 + v48;
            v68 = *(int64_t *)(8 * (int64_t)*(int32_t *)v67 + g2);
            v69 = *(int32_t *)(v67 + 4);
            *(char *)(v68 + (int64_t)v69) = *(char *)&g1;
            v70 = v66 + 1;
            v71 = v70 - v64;
            v66 = v70;
            while (v71 < 0 != ((v71 ^ v70) & (v70 ^ v64)) < 0) {
                // 0x100003bd0
                v67 = 8 * (int64_t)v66 + v48;
                v68 = *(int64_t *)(8 * (int64_t)*(int32_t *)v67 + g2);
                v69 = *(int32_t *)(v67 + 4);
                *(char *)(v68 + (int64_t)v69) = *(char *)&g1;
                v70 = v66 + 1;
                v71 = v70 - v64;
                v66 = v70;
            }
        }
        // 0x100003c28
        v72 = v39 < 1 ? v64 >= 1 : v39 >= 1;
        _free(v47);
    }
    struct _IO_FILE * v73 = _fopen((char *)v1, "w"); // 0x100003c54
    _printf("\n\n\nPrinting image after applying Zhang Suen Thinning Algorithm : \n\n\n");
    if (v12 < 0 == (v11 & v12) < 0) {
        // 0x100003d58
        _fclose(v73);
        return _printf("\nImage also written to : %s", (char *)(int64_t)"w");
    }
    int32_t v74 = -v11; // 0x100003c98
    int32_t v75 = 0; // 0x100003d4c
    int32_t v76; // 0x100003698
    int32_t v77; // 0x100003d1c
    int32_t v78; // 0x100003c98
    char v79; // 0x100003698
    if (v74 < 0 != (v11 & v74) < 0) {
        _printf("%c", (char)"w");
        _fprintf(v73, "%c", (char)v1);
        v77 = 1;
        v78 = v77 - v11;
        v76 = v77;
        v79 = (char)"%c";
        while (v78 < 0 != ((v78 ^ v77) & (v77 ^ v11)) < 0) {
            // 0x100003ca8
            _printf("%c", v79);
            _fprintf(v73, "%c", (char)v1);
            v77 = v76 + 1;
            v78 = v77 - v11;
            v76 = v77;
            v79 = (char)"%c";
        }
    }
    // 0x100003d28
    _printf("\n");
    _fprintf(v73, "\n");
    v75++;
    int32_t v80 = v75 - v11; // 0x100003c78
    while (v80 < 0 != ((v80 ^ v75) & (v75 ^ v11)) < 0) {
        // 0x100003c90
        if (v74 < 0 != (v11 & v74) < 0) {
            _printf("%c", (char)"\n");
            _fprintf(v73, "%c", (char)v1);
            v77 = 1;
            v78 = v77 - v11;
            v76 = v77;
            v79 = (char)"%c";
            while (v78 < 0 != ((v78 ^ v77) & (v77 ^ v11)) < 0) {
                // 0x100003ca8
                _printf("%c", v79);
                _fprintf(v73, "%c", (char)v1);
                v77 = v76 + 1;
                v78 = v77 - v11;
                v76 = v77;
                v79 = (char)"%c";
            }
        }
        // 0x100003d28
        _printf("\n");
        _fprintf(v73, "\n");
        v75++;
        v80 = v75 - v11;
    }
    // 0x100003d58
    _fclose(v73);
    return _printf("\nImage also written to : %s", (char *)(int64_t)"\n");
}

// Address range: 0x100003d84 - 0x100003e3c
int64_t entry_point(void) {
    // 0x100003d84
    _printf("Enter full path of input image file : ");
    int64_t v1; // 0x100003d84
    char ** v2 = (char **)v1; // 0x100003dd0
    _scanf("%s", v2);
    _printf("Enter full path of output image file : ");
    _scanf("%s", v2);
    int64_t v3 = function_100003698(); // 0x100003e00
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e10
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e24
        ___stack_chk_fail(v3);
    }
    // 0x100003e28
    return 0;
}

// Address range: 0x100003e3c - 0x100003e48
int64_t function_100003e3c(int64_t a1) {
    // 0x100003e3c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e48 - 0x100003e54
int32_t function_100003e48(struct _IO_FILE * stream) {
    // 0x100003e48
    return _fclose(stream);
}

// Address range: 0x100003e54 - 0x100003e60
struct _IO_FILE * function_100003e54(char * filename, char * modes) {
    // 0x100003e54
    return _fopen(filename, modes);
}

// Address range: 0x100003e60 - 0x100003e6c
int32_t function_100003e60(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e60
    return _fprintf(stream, format);
}

// Address range: 0x100003e6c - 0x100003e78
void function_100003e6c(int64_t * ptr) {
    // 0x100003e6c
    _free(ptr);
}

// Address range: 0x100003e78 - 0x100003e84
int32_t function_100003e78(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e78
    return _fscanf(stream, format);
}

// Address range: 0x100003e84 - 0x100003e90
int64_t * function_100003e84(int32_t size) {
    // 0x100003e84
    return _malloc(size);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(char * format, ...) {
    // 0x100003e90
    return _printf(format);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(char * format, ...) {
    // 0x100003e9c
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void talk(const char *s)
{
	pid_t pid;
	int status;

	pid = fork();
	if (pid < 0) {
		perror("fork");
		exit(1);
	}

	if (pid == 0) {
		execlp("espeak", "espeak", s, (void*)0);
		perror("espeak");
		_exit(1);
	}

	waitpid(pid, &status, 0);
	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		exit(1);
}

int main()
{
	talk("This is an example of speech synthesis.");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e20(void);
void function_100003f2c(int32_t status);
int32_t function_100003f38(char * file, char * arg, ...);
void function_100003f44(int32_t status);
int32_t function_100003f50(void);
void function_100003f5c(char * s);
int32_t function_100003f68(int32_t pid, int32_t * stat_loc, int32_t options);

// ------- Dynamically Linked Functions Without Header --------

void __exit(int32_t a1);
int32_t _execlp(char * a1, char * a2, ...);
int32_t _fork(void);
void _perror(char * a1);
int32_t _waitpid(int32_t a1, int32_t * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003e20 - 0x100003ef8
int64_t function_100003e20(void) {
    int32_t v1 = _fork(); // 0x100003e30
    if (v1 < 0) {
        // 0x100003e4c
        _perror("fork");
        _exit(1);
        // UNREACHABLE
    }
    if (v1 == 0) {
        // 0x100003e74
        _execlp("espeak", "espeak");
        _perror("espeak");
        __exit(1);
    }
    // 0x100003ea8
    int32_t v2; // bp-32, 0x100003e20
    int32_t result = _waitpid(v1, &v2, 0); // 0x100003eb4
    if ((v2 & 0xff7f) == 0) {
        // 0x100003eec
        return result;
    }
    // 0x100003ee4
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003ef8 - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003ef8
    function_100003e20();
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(int32_t status) {
    // 0x100003f2c
    __exit(status);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * file, char * arg, ...) {
    // 0x100003f38
    return _execlp(file, arg);
}

// Address range: 0x100003f44 - 0x100003f50
void function_100003f44(int32_t status) {
    // 0x100003f44
    _exit(status);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(void) {
    // 0x100003f50
    return _fork();
}

// Address range: 0x100003f5c - 0x100003f68
void function_100003f5c(char * s) {
    // 0x100003f5c
    _perror(s);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t pid, int32_t * stat_loc, int32_t options) {
    // 0x100003f68
    return _waitpid(pid, stat_loc, options);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>

#define N_BUCKETS 15

pthread_mutex_t bucket_mutex[N_BUCKETS];
int buckets[N_BUCKETS];

pthread_t equalizer;
pthread_t randomizer;

void transfer_value(int from, int to, int howmuch)
{
  bool swapped = false;

  if ( (from == to) || ( howmuch < 0 ) ||
       (from < 0 ) || (to < 0) || (from >= N_BUCKETS) || (to >= N_BUCKETS) ) return;

  if ( from > to ) {
    int temp1 = from;
    from = to;
    to = temp1;
    swapped = true;
    howmuch = -howmuch;
  }

  pthread_mutex_lock(&bucket_mutex[from]);
  pthread_mutex_lock(&bucket_mutex[to]);

  if ( howmuch > buckets[from] && !swapped )
    howmuch = buckets[from];
  if ( -howmuch > buckets[to] && swapped )
    howmuch = -buckets[to];

  buckets[from] -= howmuch;
  buckets[to] += howmuch;

  pthread_mutex_unlock(&bucket_mutex[from]);
  pthread_mutex_unlock(&bucket_mutex[to]);
}

void print_buckets()
{
  int i;
  int sum=0;

  for(i=0; i < N_BUCKETS; i++) pthread_mutex_lock(&bucket_mutex[i]);
  for(i=0; i < N_BUCKETS; i++) {
    printf("%3d ", buckets[i]);
    sum += buckets[i];
  }
  printf("= %d\n", sum);
  for(i=0; i < N_BUCKETS; i++) pthread_mutex_unlock(&bucket_mutex[i]);
}

void *equalizer_start(void *t)
{
  for(;;) {
    int b1 = rand()%N_BUCKETS;
    int b2 = rand()%N_BUCKETS;
    int diff = buckets[b1] - buckets[b2];
    if ( diff < 0 )
      transfer_value(b2, b1, -diff/2);
    else
      transfer_value(b1, b2, diff/2);
  }
  return NULL;
}

void *randomizer_start(void *t)
{
  for(;;) {
    int b1 = rand()%N_BUCKETS;
    int b2 = rand()%N_BUCKETS;
    int diff = rand()%(buckets[b1]+1);
    transfer_value(b1, b2, diff);
  }
  return NULL;
}

int main()
{
  int i, total=0;

  for(i=0; i < N_BUCKETS; i++) pthread_mutex_init(&bucket_mutex[i], NULL);

  for(i=0; i < N_BUCKETS; i++) {
    buckets[i] = rand() % 100;
    total += buckets[i];
    printf("%3d ", buckets[i]);
  }
  printf("= %d\n", total);

  // we should check if these succeeded
  pthread_create(&equalizer, NULL, equalizer_start, NULL);
  pthread_create(&randomizer, NULL, randomizer_start, NULL);

  for(;;) {
    sleep(1);
    print_buckets();
  }

  // we do not provide a "good" way to stop this run, so the following
  // is never reached indeed...
  for(i=0; i < N_BUCKETS; i++) pthread_mutex_destroy(bucket_mutex+i);
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000395c(void);
int64_t function_100003b80(void);
int64_t function_100003cb4(void);
int64_t function_100003d74(void);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
int32_t function_100003f60(int64_t * mutex, int64_t * mutexattr);
int32_t function_100003f6c(int64_t * mutex);
int32_t function_100003f78(int64_t * mutex);
int32_t function_100003f84(void);
int32_t function_100003f90(int32_t seconds);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int32_t * g2 = NULL; // 0x1000083c0
int32_t * g3 = (int32_t *)100; // 0x100008408

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
int32_t _pthread_mutex_init(int64_t * a1, int64_t * a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x10000395c - 0x100003b80
int64_t function_10000395c(void) {
    // 0x10000395c
    int64_t v1; // 0x10000395c
    int32_t v2 = v1; // 0x100003968
    int32_t v3 = v1; // 0x10000396c
    int32_t v4 = v1; // 0x100003970
    int64_t result; // 0x10000395c
    if (v3 < 0 || v2 < 0 || v4 < 0 || v2 == v3) {
        // 0x100003b74
        return result;
    }
    if (v2 < 15 == (14 - v2 & v2) < 0) {
        // 0x100003b74
        return result;
    }
    if (v3 < 15 != (14 - v3 & v3) < 0) {
        int32_t v5 = v2 - v3; // 0x100003a00
        bool v6 = v5 == 0 | v5 < 0 != ((v5 ^ v2) & (int32_t)(v1 ^ v1)) < 0; // 0x100003a04
        int32_t v7 = v6 ? v4 : -v4;
        int64_t v8 = 0x100000000 * (v6 ? v1 : v1);
        int64_t * v9 = (int64_t *)((v8 >> 26) + (int64_t)&g1); // 0x100003a58
        _pthread_mutex_lock(v9);
        int64_t v10 = 0x100000000 * (v6 ? v1 : v1);
        int64_t * v11 = (int64_t *)((v10 >> 26) + (int64_t)&g1); // 0x100003a68
        _pthread_mutex_lock(v11);
        int32_t * v12 = (int32_t *)((v8 >> 30) + (int64_t)&g2); // 0x100003a7c
        int32_t v13 = *v12; // 0x100003a7c
        int32_t v14 = v7 - v13; // 0x100003a80
        int32_t v15 = v6 == v14 != 0 == v14 < 0 == ((v14 ^ v7) & (v13 ^ v7)) < 0 ? v13 : v7;
        int32_t v16 = -v15; // 0x100003abc
        int32_t * v17 = (int32_t *)((v10 >> 30) + (int64_t)&g2); // 0x100003acc
        int32_t v18 = *v17; // 0x100003acc
        int32_t v19 = v16 - v18; // 0x100003ad0
        int32_t v20 = v6 | v19 == 0 | v19 < 0 != ((v19 ^ v16) & (v18 ^ v16)) < 0 ? v15 : -v18;
        *v12 = v13 - v20;
        *v17 = v20 + *v17;
        _pthread_mutex_unlock(v9);
        result = _pthread_mutex_unlock(v11);
    }
    // 0x100003b74
    return result;
}

// Address range: 0x100003b80 - 0x100003cb4
int64_t function_100003b80(void) {
    int64_t v1 = 0;
    _pthread_mutex_lock((int64_t *)(64 * v1 + (int64_t)&g1));
    v1++;
    int32_t v2 = 0; // 0x100003ba4
    while (v1 != 15) {
        // 0x100003bac
        _pthread_mutex_lock((int64_t *)(64 * v1 + (int64_t)&g1));
        v1++;
        v2 = 0;
    }
    int64_t v3; // 0x100003b80
    _printf("%3d ", v3);
    int32_t v4 = v2 + 1; // 0x100003c3c
    v2 = v4;
    while (v4 != 15) {
        // 0x100003bf0
        _printf("%3d ", v3);
        v4 = v2 + 1;
        v2 = v4;
    }
    // 0x100003c48
    _printf("= %d\n", v3);
    int32_t result; // 0x100003c90
    for (int64_t i = 0; i < 15; i++) {
        // 0x100003c80
        result = _pthread_mutex_unlock((int64_t *)(64 * i + (int64_t)&g1));
    }
    // 0x100003ca8
    return result;
}

// Address range: 0x100003cb4 - 0x100003d74
int64_t function_100003cb4(void) {
    while (true) {
        // 0x100003cc8
        _rand();
        _rand();
        function_10000395c();
    }
}

// Address range: 0x100003d74 - 0x100003df8
int64_t function_100003d74(void) {
    while (true) {
        // 0x100003d88
        _rand();
        _rand();
        _rand();
        function_10000395c();
    }
}

// Address range: 0x100003df8 - 0x100003f48
int64_t entry_point(void) {
    int64_t v1 = 0;
    _pthread_mutex_init((int64_t *)(64 * v1 + (int64_t)&g1), NULL);
    v1++;
    int64_t v2 = 0; // 0x100003e20
    while (v1 != 15) {
        // 0x100003e28
        _pthread_mutex_init((int64_t *)(64 * v1 + (int64_t)&g1), NULL);
        v1++;
        v2 = 0;
    }
    *(int32_t *)(4 * v2 + (int64_t)&g2) = _rand() % 100;
    _printf("%3d ", 0);
    int64_t v3 = v2 + 1;
    v2 = v3;
    while (v3 != 15) {
        // 0x100003e70
        *(int32_t *)(4 * v2 + (int64_t)&g2) = _rand() % 100;
        _printf("%3d ", 0);
        v3 = v2 + 1;
        v2 = v3;
    }
    // 0x100003edc
    _printf("= %d\n", 0);
    _pthread_create((int32_t *)"/lib/dyld", NULL, (int64_t * (*)(int64_t *))0x100003cb4, NULL);
    _pthread_create((int32_t *)&g3, NULL, (int64_t * (*)(int64_t *))0x100003d74, NULL);
    while (true) {
        // 0x100003f38
        _sleep(1);
        function_100003b80();
    }
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003f54
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int64_t * mutex, int64_t * mutexattr) {
    // 0x100003f60
    return _pthread_mutex_init(mutex, mutexattr);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int64_t * mutex) {
    // 0x100003f6c
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int64_t * mutex) {
    // 0x100003f78
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(void) {
    // 0x100003f84
    return _rand();
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(int32_t seconds) {
    // 0x100003f90
    return _sleep(seconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define MAX_SIZE 100

int move_to_front(char *str,char c)
{
    char *q,*p;
    int shift=0;
    p=(char *)malloc(strlen(str)+1);
    strcpy(p,str);
    q=strchr(p,c); //returns pointer to location of char c in string str
    shift=q-p;      // no of characters from 0 to position of c in str
    strncpy(str+1,p,shift);
    str[0]=c;
    free(p);
  //  printf("\n%s\n",str);
    return shift;
}

void decode(int* pass,int size,char *sym)
{
    int i,index;
    char c;
    char table[]="abcdefghijklmnopqrstuvwxyz";
    for(i=0;i<size;i++)
    {
        c=table[pass[i]];
        index=move_to_front(table,c);
        if(pass[i]!=index) printf("there is an error");
        sym[i]=c;
    }
    sym[size]='\0';
}

void encode(char *sym,int size,int *pass)
{
    int i=0;
    char c;
    char table[]="abcdefghijklmnopqrstuvwxyz";
    for(i=0;i<size;i++)
    {
        c=sym[i];
        pass[i]=move_to_front(table,c);
    }
}

int check(char *sym,int size,int *pass)
{
    int *pass2=malloc(sizeof(int)*size);
    char *sym2=malloc(sizeof(char)*size);
    int i,val=1;

    encode(sym,size,pass2);
    i=0;
    while(i<size && pass[i]==pass2[i])i++;
    if(i!=size)val=0;

    decode(pass,size,sym2);
    if(strcmp(sym,sym2)!=0)val=0;

    free(sym2);
    free(pass2);

    return val;
}

int main()
{
    char sym[3][MAX_SIZE]={"broood","bananaaa","hiphophiphop"};
    int pass[MAX_SIZE]={0};
    int i,len,j;
    for(i=0;i<3;i++)
    {
        len=strlen(sym[i]);
        encode(sym[i],len,pass);
        printf("%s : [",sym[i]);
        for(j=0;j<len;j++)
            printf("%d ",pass[j]);
        printf("]\n");
        if(check(sym[i],len,pass))
            printf("Correct :)\n");
        else
            printf("Incorrect :(\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000037f4(void);
int64_t function_100003890(void);
int64_t function_1000039b8(void);
int64_t function_100003a90(void);
int64_t function_100003d98(int64_t a1);
int64_t function_100003da4(int64_t a1, int64_t a2);
int64_t function_100003db0(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
void function_100003dbc(int64_t * s, int32_t n);
void function_100003dc8(int64_t * ptr);
int64_t * function_100003dd4(int32_t size);
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003dec(char * format, ...);
char * function_100003df8(char * s, int32_t c);
int32_t function_100003e04(char * s1, char * s2);
int32_t function_100003e10(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2);
int64_t ___strncpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
char * _strchr(char * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000037f4 - 0x100003890
int64_t function_1000037f4(void) {
    // 0x1000037f4
    int64_t v1; // 0x1000037f4
    char * v2 = (char *)v1; // 0x100003810
    int64_t * v3 = _malloc(_strlen(v2) + 1); // 0x100003818
    int64_t v4 = (int64_t)v3; // 0x100003818
    ___strcpy_chk(v4, v1);
    int64_t v5 = (int64_t)_strchr((char *)v3, 0x1000000 * (int32_t)v1 >> 24) - v4; // 0x100003850
    ___strncpy_chk(v1 + 1, v4, (int32_t)v5, -1);
    *v2 = (char)v1;
    _free(v3);
    return v5 & 0xffffffff;
}

// Address range: 0x100003890 - 0x1000039b8
int64_t function_100003890(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000038a4
    int64_t v2; // 0x100003890
    int32_t v3 = v2; // 0x1000038b0
    int64_t v4 = (float64_t)*(float128_t *)"abcdefghijklmnopqrstuvwxyz"; // bp-64, 0x1000038c8
    int32_t v5 = -v3; // 0x1000038e4
    int64_t v6; // 0x100003890
    if (v5 < 0 != (v5 & v3) < 0) {
        int32_t v7 = 0; // 0x10000396c
        int64_t v8 = v7; // 0x1000038f8
        int32_t * v9 = (int32_t *)(4 * v8 + v2); // 0x1000038fc
        char v10 = *(char *)((int64_t)*v9 + (int64_t)&v4); // 0x10000390c
        int64_t v11 = function_1000037f4(); // 0x100003918
        int64_t v12 = v11; // 0x100003938
        if (*v9 != (int32_t)v11) {
            // 0x100003940
            v12 = _printf("there is an error");
        }
        // 0x100003950
        *(char *)(v2 + v8) = v10;
        v7++;
        int32_t v13 = v7 - v3; // 0x1000038e4
        v6 = v12;
        while (v13 < 0 != ((v13 ^ v7) & (v7 ^ v3)) < 0) {
            // 0x1000038f4
            v8 = v7;
            v9 = (int32_t *)(4 * v8 + v2);
            v10 = *(char *)((int64_t)*v9 + (int64_t)&v4);
            v11 = function_1000037f4();
            v12 = v11;
            if (*v9 != (int32_t)v11) {
                // 0x100003940
                v12 = _printf("there is an error");
            }
            // 0x100003950
            *(char *)(v2 + v8) = v10;
            v7++;
            v13 = v7 - v3;
            v6 = v12;
        }
    }
    // 0x100003978
    *(char *)((0x100000000 * v2 >> 32) + v2) = 0;
    int64_t result = v6; // 0x1000039a0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x1000039a8
        result = ___stack_chk_fail(v6);
    }
    // 0x1000039ac
    return result;
}

// Address range: 0x1000039b8 - 0x100003a90
int64_t function_1000039b8(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000039cc
    int64_t v2; // 0x1000039b8
    int32_t v3 = v2; // 0x1000039d8
    int32_t v4 = -v3; // 0x100003a10
    int64_t result; // 0x1000039b8
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a84
        return result;
    }
    int32_t v5 = 0; // 0x100003a18
    int64_t v6 = function_1000037f4(); // 0x100003a3c
    *(int32_t *)(4 * (int64_t)v5 + v2) = (int32_t)v6;
    v5++;
    while (v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x100003a20
        v6 = function_1000037f4();
        *(int32_t *)(4 * (int64_t)v5 + v2) = (int32_t)v6;
        v5++;
    }
    // 0x100003a60
    result = v6;
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003a80
        result = ___stack_chk_fail(v6);
    }
    // 0x100003a84
    return result;
}

// Address range: 0x100003a90 - 0x100003bc8
int64_t function_100003a90(void) {
    // 0x100003a90
    int64_t v1; // 0x100003a90
    int32_t v2 = v1; // 0x100003aa0
    int64_t * v3 = _malloc(4 * v2); // 0x100003ab4
    int64_t * v4 = _malloc(v2); // 0x100003ac8
    function_1000039b8();
    int32_t v5 = -v2; // 0x100003af8
    int32_t v6 = 0; // 0x100003b08
    int32_t v7 = 0; // 0x100003b08
    if (v5 < 0 != (v5 & v2) < 0) {
        int64_t v8 = 4 * (int64_t)v6; // 0x100003b18
        v7 = v6;
        while (*(int32_t *)(v8 + v1) == *(int32_t *)(v8 + (int64_t)v3)) {
            // 0x100003b44
            v6++;
            int32_t v9 = v6 - v2; // 0x100003af8
            v7 = v6;
            if (v9 < 0 == ((v9 ^ v6) & (v6 ^ v2)) < 0) {
                // break -> 0x100003b54
                break;
            }
            v8 = 4 * (int64_t)v6;
            v7 = v6;
        }
    }
    // 0x100003b54
    function_100003890();
    int32_t v10 = _strcmp((char *)v1, (char *)v4); // 0x100003b8c
    _free(v4);
    _free(v3);
    return v7 == v2 == v10 == 0;
}

// Address range: 0x100003bc8 - 0x100003d98
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003be0
    int64_t v2; // bp-332, 0x100003bc8
    _memcpy(&v2, (int64_t *)"broood", 300);
    int64_t v3; // bp-732, 0x100003bc8
    _bzero(&v3, 400);
    int32_t v4; // 0x100003bc8
    for (int64_t i = 0; i < 3; i++) {
        uint32_t v5 = _strlen((char *)(100 * i + (int64_t)&v2)); // 0x100003c44
        int64_t v6 = v5; // 0x100003c64
        function_1000039b8();
        _printf("%s : [", (char *)v6);
        int32_t v7 = -v5; // 0x100003ca8
        if (v7 < 0 != (v5 & v7) < 0) {
            _printf("%d ", v6);
            int32_t v8 = 1; // 0x100003ce4
            int32_t v9 = v8 - v5; // 0x100003ca8
            int32_t v10 = v8; // 0x100003cb0
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v5)) < 0) {
                // 0x100003cb8
                _printf("%d ", v6);
                v8 = v10 + 1;
                v9 = v8 - v5;
                v10 = v8;
            }
        }
        // 0x100003cf0
        _printf("]\n");
        if ((int32_t)function_100003a90() == 0) {
            // 0x100003d3c
            v4 = _printf("Incorrect :(\n");
        } else {
            // 0x100003d2c
            v4 = _printf("Correct :)\n");
        }
    }
    // 0x100003d60
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d80
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003d84
    return 0;
}

// Address range: 0x100003d98 - 0x100003da4
int64_t function_100003d98(int64_t a1) {
    // 0x100003d98
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003da4 - 0x100003db0
int64_t function_100003da4(int64_t a1, int64_t a2) {
    // 0x100003da4
    return ___strcpy_chk(a1, a2);
}

// Address range: 0x100003db0 - 0x100003dbc
int64_t function_100003db0(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003db0
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003dbc - 0x100003dc8
void function_100003dbc(int64_t * s, int32_t n) {
    // 0x100003dbc
    _bzero(s, n);
}

// Address range: 0x100003dc8 - 0x100003dd4
void function_100003dc8(int64_t * ptr) {
    // 0x100003dc8
    _free(ptr);
}

// Address range: 0x100003dd4 - 0x100003de0
int64_t * function_100003dd4(int32_t size) {
    // 0x100003dd4
    return _malloc(size);
}

// Address range: 0x100003de0 - 0x100003dec
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003de0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dec - 0x100003df8
int32_t function_100003dec(char * format, ...) {
    // 0x100003dec
    return _printf(format);
}

// Address range: 0x100003df8 - 0x100003e04
char * function_100003df8(char * s, int32_t c) {
    // 0x100003df8
    return _strchr(s, c);
}

// Address range: 0x100003e04 - 0x100003e10
int32_t function_100003e04(char * s1, char * s2) {
    // 0x100003e04
    return _strcmp(s1, s2);
}

// Address range: 0x100003e10 - 0x100003e1c
int32_t function_100003e10(char * s) {
    // 0x100003e10
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

uint64_t egyptian_division(uint64_t dividend, uint64_t divisor, uint64_t *remainder) {
	// remainder is an out parameter, pass NULL if you do not need the remainder
	
	static uint64_t powers[64];
	static uint64_t doublings[64];

	int i;
	
	for(i = 0; i < 64; i++) {
		powers[i] = 1 << i;
		doublings[i] = divisor << i;
		if(doublings[i] > dividend)
			break;
	}
	
	uint64_t answer = 0;
	uint64_t accumulator = 0;

	for(i = i - 1; i >= 0; i--) {
		// If the current value of the accumulator added to the
		// doublings cell would be less than or equal to the
		// dividend then add it to the accumulator
		if(accumulator + doublings[i] <= dividend) {
			accumulator += doublings[i];
			answer += powers[i];
		}
	}
	
	if(remainder)
		*remainder = dividend - accumulator;
	return answer;
}

void go(uint64_t a, uint64_t b) {
	uint64_t x, y;
	x = egyptian_division(a, b, &y);
	printf("%llu / %llu = %llu remainder %llu\n", a, b, x, y);
	assert(a == b * x + y);
}

int main(void) {
	go(580, 32);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_100003ce0(void);
int64_t function_100003e60(void);
int64_t function_100003f3c(char * a1, char * a2, int64_t a3, char * a4);
int32_t function_100003f48(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008000
int64_t g2 = 0; // 0x100008200

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ce0 - 0x100003e60
int64_t function_100003ce0(void) {
    // 0x100003ce0
    int64_t v1; // 0x100003ce0
    uint64_t v2 = v1;
    int32_t v3 = 0; // 0x100003d74
    uint64_t v4 = 0;
    int32_t v5 = v4;
    int64_t v6 = 8 * v4; // 0x100003d2c
    *(int64_t *)(v6 + (int64_t)&g1) = (int64_t)(1 << v5);
    uint64_t v7 = v1 << v4; // 0x100003d38
    *(int64_t *)(v6 + (int64_t)&g2) = v7;
    int32_t v8 = v5; // 0x100003d60
    while (v7 == v2 || v7 < v2) {
        int32_t v9 = v3;
        int64_t v10 = v4 + 1;
        v3 = v9 + 1;
        v8 = v3;
        if (v4 < 63 == (62 - v9 & (int32_t)v10) < 0) {
            // break -> 0x100003d80
            break;
        }
        v4 = v10;
        v5 = v4;
        v6 = 8 * v4;
        *(int64_t *)(v6 + (int64_t)&g1) = (int64_t)(1 << v5);
        v7 = v1 << v4;
        *(int64_t *)(v6 + (int64_t)&g2) = v7;
        v8 = v5;
    }
    int32_t v11 = v8 - 1;
    int64_t result = 0; // 0x100003da4
    int64_t v12 = 0; // 0x100003da4
    if (v11 >= 0) {
        int64_t v13 = v8;
        int32_t v14 = v11;
        int64_t v15 = 0;
        int64_t v16 = 0;
        v13--;
        int64_t v17 = 8 * v13; // 0x100003dbc
        int64_t v18 = *(int64_t *)(v17 + (int64_t)&g2); // 0x100003dbc
        int64_t v19 = v18 + v15; // 0x100003dc0
        int64_t v20 = v16; // 0x100003dd0
        int64_t v21 = v15; // 0x100003dd0
        int64_t v22; // 0x100003e00
        if (v19 >= v2 != v19 != v2) {
            // 0x100003dd8
            v22 = *(int64_t *)(v17 + (int64_t)&g1);
            v20 = v22 + v16;
            v21 = v19;
        }
        // 0x100003e18
        v15 = v21;
        int64_t v23 = v20;
        v14--;
        result = v23;
        v12 = v15;
        while (v14 >= 0) {
            // 0x100003dac
            v16 = v23;
            v13--;
            v17 = 8 * v13;
            v18 = *(int64_t *)(v17 + (int64_t)&g2);
            v19 = v18 + v15;
            v20 = v16;
            v21 = v15;
            if (v19 >= v2 != v19 != v2) {
                // 0x100003dd8
                v22 = *(int64_t *)(v17 + (int64_t)&g1);
                v20 = v22 + v16;
                v21 = v19;
            }
            // 0x100003e18
            v15 = v21;
            v23 = v20;
            v14--;
            result = v23;
            v12 = v15;
        }
    }
    // 0x100003e28
    if (v1 != 0) {
        // 0x100003e3c
        *(int64_t *)v1 = v2 - v12;
    }
    // 0x100003e54
    return result;
}

// Address range: 0x100003e60 - 0x100003f1c
int64_t function_100003e60(void) {
    int64_t v1 = function_100003ce0(); // 0x100003e80
    int64_t v2; // bp-48, 0x100003e60
    int64_t v3; // 0x100003e60
    int32_t v4 = _printf("%llu / %llu = %llu remainder %llu\n", v3, (int64_t)&v2, v3, v3); // 0x100003eb4
    int64_t result = v4; // 0x100003ee4
    if (v3 != v2 + v1 * v3) {
        // 0x100003eec
        result = ___assert_rtn("go", "egyptian-division.c", 43, "a == b * x + y");
    }
    // 0x100003f10
    return result;
}

// Address range: 0x100003f1c - 0x100003f3c
int64_t entry_point(int64_t a1) {
    // 0x100003f1c
    function_100003e60();
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003f3c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <sys/types.h>
#include <err.h>
#include <errno.h>
#include <fnmatch.h>
#include <fts.h>
#include <string.h>
#include <stdio.h>

/* Compare files by name. */
int
entcmp(const FTSENT **a, const FTSENT **b)
{
	return strcmp((*a)->fts_name, (*b)->fts_name);
}

/*
 * Print all files in the directory tree that match the glob pattern.
 * Example: pmatch("/usr/src", "*.c");
 */
void
pmatch(char *dir, const char *pattern)
{
	FTS *tree;
	FTSENT *f;
	char *argv[] = { dir, NULL };

	/*
	 * FTS_LOGICAL follows symbolic links, including links to other
	 * directories. It detects cycles, so we never have an infinite
	 * loop. FTS_NOSTAT is because we never use f->statp. It uses
	 * our entcmp() to sort files by name.
	 */
	tree = fts_open(argv, FTS_LOGICAL | FTS_NOSTAT, entcmp);
	if (tree == NULL)
		err(1, "fts_open");

	/*
	 * Iterate files in tree. This iteration always skips
	 * "." and ".." because we never use FTS_SEEDOT.
	 */
	while ((f = fts_read(tree))) {
		switch (f->fts_info) {
		case FTS_DNR:	/* Cannot read directory */
		case FTS_ERR:	/* Miscellaneous error */
		case FTS_NS:	/* stat() error */
			/* Show error, then continue to next files. */
			warn("%s", f->fts_path);
			continue;
		case FTS_DP:
			/* Ignore post-order visit to directory. */
			continue;
		}

		/*
		 * Check if name matches pattern. If so, then print
		 * path. This check uses FNM_PERIOD, so "*.c" will not
		 * match ".invisible.c".
		 */
		if (fnmatch(pattern, f->fts_name, FNM_PERIOD) == 0)
			puts(f->fts_path);

		/*
		 * A cycle happens when a symbolic link (or perhaps a
		 * hard link) puts a directory inside itself. Tell user
		 * when this happens.
		 */
		if (f->fts_info == FTS_DC)
			warnx("%s: cycle in directory tree", f->fts_path);
	}

	/* fts_read() sets errno = 0 unless it has error. */
	if (errno != 0)
		err(1, "fts_read");

	if (fts_close(tree) < 0)
		err(1, "fts_close");
}

int
main()
{
	pmatch(".", "*.c");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_FTS {
    struct _ftsent * e0;
    struct _ftsent * e1;
    struct _ftsent ** e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t (*e8)(int64_t *, int64_t *);
    int32_t e9;
};

struct _ftsent {
    struct _ftsent * e0;
    struct _ftsent * e1;
    struct _ftsent * e2;
    int32_t e3;
    int64_t * e4;
    char * e5;
    char * e6;
    int32_t e7;
    int32_t e8;
    int16_t e9;
    int16_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int16_t e14;
    int16_t e15;
    int16_t e16;
    int16_t e17;
    struct stat * e18;
    char e19[1];
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c64(void);
int64_t function_100003ca0(int64_t a1);
void function_100003ed8(int32_t status, int32_t errnum, char * format, ...);
int64_t function_100003ee4(int64_t a1);
void function_100003ef0(int32_t status, char * format, ...);
int32_t function_100003efc(char * pattern, char * name, int32_t flags);
int32_t function_100003f08(struct _TYPEDEF_FTS * a1);
struct _TYPEDEF_FTS * function_100003f14(char ** a1, int32_t a2, int32_t (*a3)(struct _ftsent **, struct _ftsent **));
struct _ftsent * function_100003f20(struct _TYPEDEF_FTS * a1);
int32_t function_100003f2c(char * s);
int32_t function_100003f38(char * s1, char * s2);
void function_100003f44(char * format, ...);
void function_100003f50(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void ___error(int32_t a1, int32_t a2, char * a3, ...);
int64_t ___stack_chk_fail(int64_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fnmatch(char * a1, char * a2, int32_t a3);
int32_t _fts_close(struct _TYPEDEF_FTS * a1);
struct _TYPEDEF_FTS * _fts_open(char ** a1, int32_t a2, int32_t (*a3)(struct _ftsent **, struct _ftsent **));
struct _ftsent * _fts_read(struct _TYPEDEF_FTS * a1);
int32_t _puts(char * a1);
int32_t _strcmp(char * a1, char * a2);
void _warn(char * a1, ...);
void _warnx(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c64 - 0x100003ca0
int64_t function_100003c64(void) {
    // 0x100003c64
    int64_t v1; // 0x100003c64
    return _strcmp((char *)(v1 + 104), (char *)(v1 + 104));
}

// Address range: 0x100003ca0 - 0x100003e80
int64_t function_100003ca0(int64_t a1) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003cb4
    int64_t v2; // bp-40, 0x100003ca0
    struct _TYPEDEF_FTS * v3 = _fts_open((char **)&v2, 10, (int32_t (*)(struct _ftsent **, struct _ftsent **))0x100003c64); // 0x100003ce0
    int64_t v4 = 10; // 0x100003cf4
    if (v3 == NULL) {
        // 0x100003cfc
        _err(1, "fts_open");
        v4 = (int64_t)"fts_open";
    }
    struct _ftsent * v5 = _fts_read(v3); // 0x100003d14
    int64_t v6 = (int64_t)v5; // 0x100003d14
    int64_t v7 = v4; // 0x100003d28
    char * v8 = (char *)0x100003c64; // 0x100003d28
    int64_t v9 = v6; // 0x100003d28
    if (v5 == NULL) {
      lab_0x100003e00:
        // 0x100003e00
        ___error((int32_t)v9, (int32_t)v7, v8);
        if (g1 != 0) {
            // 0x100003e18
            _err(1, "fts_read");
        }
        int32_t v10 = _fts_close(v3); // 0x100003e2c
        int64_t v11 = v10; // 0x100003e38
        if (v10 < 0) {
            // 0x100003e40
            _err(1, "fts_close");
            v11 = &g1;
        }
        int64_t result = v11; // 0x100003e68
        if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
            // 0x100003e70
            result = ___stack_chk_fail(v11);
        }
        // 0x100003d50
        return result;
    }
    int64_t result2 = v6;
    int16_t * v12 = (int16_t *)(result2 + 88); // 0x100003d34
    uint64_t v13 = (int64_t)*v12 + 0xfffffffc & 0xffffffff; // 0x100003d3c
    while (v13 >= 6 == (v13 != 6)) {
        int64_t v14 = result2 + 104; // 0x100003d98
        char * v15 = (char *)v14; // 0x100003da0
        int64_t v16; // 0x100003ca0
        if (_fnmatch((char *)v16, v15, 4) == 0) {
            // 0x100003db4
            _puts((char *)*(int64_t *)(result2 + 48));
        }
        // 0x100003dc4
        if (*v12 == 2) {
            // 0x100003ddc
            _warnx("%s: cycle in directory tree", v15);
        }
        struct _ftsent * v17 = _fts_read(v3); // 0x100003d14
        v7 = v14;
        v8 = (char *)4;
        v9 = 0;
        if (v17 == NULL) {
            goto lab_0x100003e00;
        }
        result2 = (int64_t)v17;
        v12 = (int16_t *)(result2 + 88);
        v13 = (int64_t)*v12 + 0xfffffffc & 0xffffffff;
    }
    // 0x100003d50
    return result2;
}

// Address range: 0x100003e9c - 0x100003ed8
int64_t entry_point(void) {
    // 0x100003e9c
    function_100003ca0(0);
    return 0;
}

// Address range: 0x100003ed8 - 0x100003ee4
void function_100003ed8(int32_t status, int32_t errnum, char * format, ...) {
    // 0x100003ed8
    ___error(status, errnum, format);
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(int64_t a1) {
    // 0x100003ee4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef0 - 0x100003efc
void function_100003ef0(int32_t status, char * format, ...) {
    // 0x100003ef0
    _err(status, format);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(char * pattern, char * name, int32_t flags) {
    // 0x100003efc
    return _fnmatch(pattern, name, flags);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(struct _TYPEDEF_FTS * a1) {
    // 0x100003f08
    return _fts_close(a1);
}

// Address range: 0x100003f14 - 0x100003f20
struct _TYPEDEF_FTS * function_100003f14(char ** a1, int32_t a2, int32_t (*a3)(struct _ftsent **, struct _ftsent **)) {
    // 0x100003f14
    return _fts_open(a1, a2, a3);
}

// Address range: 0x100003f20 - 0x100003f2c
struct _ftsent * function_100003f20(struct _TYPEDEF_FTS * a1) {
    // 0x100003f20
    return _fts_read(a1);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * s) {
    // 0x100003f2c
    return _puts(s);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * s1, char * s2) {
    // 0x100003f38
    return _strcmp(s1, s2);
}

// Address range: 0x100003f44 - 0x100003f50
void function_100003f44(char * format, ...) {
    // 0x100003f44
    _warn(format);
}

// Address range: 0x100003f50 - 0x100003f5c
void function_100003f50(char * format, ...) {
    // 0x100003f50
    _warnx(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdlib.h>
#include <stdio.h>

void
subleq(int *code)
{
	int ip = 0, a, b, c, nextIP;
	char ch;
	while(0 <= ip) {
		nextIP = ip + 3;
		a = code[ip];
		b = code[ip + 1];
		c = code[ip + 2];
		if(a == -1) {
			scanf("%c", &ch);
			code[b] = (int)ch;
		} else if(b == -1) {
			printf("%c", (char)code[a]);
		} else {
			code[b] -= code[a];
			if(code[b] <= 0)
				nextIP = c;
		}
		ip = nextIP;
	}
}

void
processFile(char *fileName)
{
	int *dataSet, i, num;
	FILE *fp = fopen(fileName, "r");
	fscanf(fp, "%d", &num);
	dataSet = (int *)malloc(num * sizeof(int));
	for(i = 0; i < num; i++)
		fscanf(fp, "%d", &dataSet[i]);
	fclose(fp);
	subleq(dataSet);
}

int
main(int argC, char *argV[])
{
	if(argC != 2)
		printf("Usage : %s <subleq code file>\n", argV[0]);
	else
		processFile(argV[1]);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca8(void);
int64_t function_100003e08(void);
int32_t function_100003f38(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f44(char * filename, char * modes);
int32_t function_100003f50(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f5c(int32_t size);
int32_t function_100003f68(char * format, ...);
int32_t function_100003f74(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca8 - 0x100003e08
int64_t function_100003ca8(void) {
    int32_t v1 = 0;
    int32_t v2 = v1 + 3; // 0x100003cdc
    int64_t v3; // 0x100003ca8
    int32_t v4 = *(int32_t *)(4 * (int64_t)v1 + v3); // 0x100003cec
    int32_t v5 = 4 * v1; // 0x100003cfc
    int32_t v6 = *(int32_t *)(v3 + (int64_t)(v5 + 4)); // 0x100003d00
    int32_t v7; // 0x100003ca8
    int32_t v8; // 0x100003d44
    int32_t v9; // 0x100003d14
    int32_t * v10; // 0x100003db4
    int32_t v11; // 0x100003db8
    int32_t v12; // 0x100003ca8
    int64_t v13; // 0x100003ca8
    if (v4 == -1) {
        // 0x100003d30
        v8 = _scanf("%c", (char *)v3);
        *(int32_t *)(4 * (int64_t)v6 + v3) = 0x1000000 * v12 >> 24;
        v7 = v2;
        v13 = v8;
    } else {
        if (v6 == -1) {
            // 0x100003d70
            v7 = v2;
            v13 = _printf("%c", (char)v3);
        } else {
            // 0x100003d9c
            v9 = *(int32_t *)(v3 + (int64_t)(v5 + 8));
            v10 = (int32_t *)(4 * (int64_t)v6 + v3);
            v11 = *v10 - *(int32_t *)(4 * (int64_t)v4 + v3);
            *v10 = v11;
            v7 = v11 < 1 ? v9 : v2;
            int64_t v14; // 0x100003ca8
            v13 = v14;
        }
    }
    int64_t result = v13;
    v1 = v7;
    int32_t v15 = -v1; // 0x100003cc8
    while (v1 == 0 || v15 < 0 != (v1 & v15) < 0) {
        // 0x100003cd8
        v2 = v1 + 3;
        v4 = *(int32_t *)(4 * (int64_t)v1 + v3);
        v5 = 4 * v1;
        v6 = *(int32_t *)(v3 + (int64_t)(v5 + 4));
        if (v4 == -1) {
            // 0x100003d30
            v8 = _scanf("%c", (char *)v3);
            *(int32_t *)(4 * (int64_t)v6 + v3) = 0x1000000 * v12 >> 24;
            v7 = v2;
            v13 = v8;
        } else {
            if (v6 == -1) {
                // 0x100003d70
                v7 = v2;
                v13 = _printf("%c", (char)v3);
            } else {
                // 0x100003d9c
                v9 = *(int32_t *)(v3 + (int64_t)(v5 + 8));
                v10 = (int32_t *)(4 * (int64_t)v6 + v3);
                v11 = *v10 - *(int32_t *)(4 * (int64_t)v4 + v3);
                *v10 = v11;
                v7 = v11 < 1 ? v9 : v2;
                v13 = result;
            }
        }
        // 0x100003df0
        result = v13;
        v1 = v7;
        v15 = -v1;
    }
    // 0x100003dfc
    return result;
}

// Address range: 0x100003e08 - 0x100003ecc
int64_t function_100003e08(void) {
    // 0x100003e08
    int64_t v1; // 0x100003e08
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x100003e24
    int64_t * v3 = (int64_t *)v1; // 0x100003e44
    _fscanf(v2, "%d", v3);
    int32_t v4; // 0x100003e08
    _malloc(4 * v4);
    int32_t v5 = -v4; // 0x100003e68
    int32_t v6 = 0; // 0x100003e70
    if (v5 < 0 == (v4 & v5) < 0) {
        // 0x100003eb0
        _fclose(v2);
        return function_100003ca8();
    }
    _fscanf(v2, "%d", v3);
    v6++;
    while (v6 - v4 < 0 != ((v6 - v4 ^ v6) & (v6 ^ v4)) < 0) {
        // 0x100003e78
        _fscanf(v2, "%d", v3);
        v6++;
    }
    // 0x100003eb0
    _fclose(v2);
    return function_100003ca8();
}

// Address range: 0x100003ecc - 0x100003f38
int64_t entry_point(void) {
    // 0x100003ecc
    int64_t v1; // 0x100003ecc
    if ((int32_t)v1 == 2) {
        // 0x100003f18
        function_100003e08();
    } else {
        // 0x100003ef8
        _printf("Usage : %s <subleq code file>\n", (char *)v1);
    }
    // 0x100003f28
    return 0;
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(struct _IO_FILE * stream) {
    // 0x100003f38
    return _fclose(stream);
}

// Address range: 0x100003f44 - 0x100003f50
struct _IO_FILE * function_100003f44(char * filename, char * modes) {
    // 0x100003f44
    return _fopen(filename, modes);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f50
    return _fscanf(stream, format);
}

// Address range: 0x100003f5c - 0x100003f68
int64_t * function_100003f5c(int32_t size) {
    // 0x100003f5c
    return _malloc(size);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

typedef struct {
    char *first, *last;
} Name;

Name whatsMyName() {
    return (Name) {
        .first = "James",
        .last = "Bond",
    };
}

int main() {
    Name me = whatsMyName();
    printf("The name's %s. %s %s.\n", me.last, me.first, me.last);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ee8(void);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ee8 - 0x100003f14
int64_t function_100003ee8(void) {
    // 0x100003ee8
    return (int64_t)"James";
}

// Address range: 0x100003f14 - 0x100003f70
int64_t entry_point(void) {
    // 0x100003f14
    function_100003ee8();
    int64_t v1; // 0x100003f14
    _printf("The name's %s. %s %s.\n", (char *)v1, (char *)v1, (char *)v1);
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`/*  Written in 2015 by Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>. */

#include <stdint.h>
#include <stdio.h>
#include <math.h>

/* This is a fixed-increment version of Java 8's SplittableRandom generator
   See http://dx.doi.org/10.1145/2714064.2660195 and
   http://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html

   It is a very fast generator passing BigCrush, and it can be useful if
   for some reason you absolutely want 64 bits of state. */

static uint64_t x; /* The state can be seeded with any value. */

uint64_t next() {
	uint64_t z = (x += 0x9e3779b97f4a7c15);
	z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
	z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
	return z ^ (z >> 31);
}

double next_float() {
    return next() / pow(2.0, 64);
}

int main() {
    int i, j;
    x = 1234567;
    for(i = 0; i < 5; ++i)
        printf("%llu\n", next()); /* needed to use %lu verb for GCC 7.5.0-3 */
    x = 987654321;
    int vec5[5] = {0, 0, 0, 0, 0};
    for(i = 0; i < 100000; ++i) {
        j = next_float() * 5.0;
        vec5[j] += 1;
    }
    for(i = 0; i < 5; ++i)
        printf("%d: %d  ", i, vec5[i]);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d0c(void);
int64_t function_100003d90(void);
int64_t function_100003f64(void);
float64_t function_100003f70(float64_t a1, float64_t a2);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d0c - 0x100003d90
int64_t function_100003d0c(void) {
    int64_t v1 = g1 - 0x61c8864680b583eb; // 0x100003d28
    g1 = v1;
    uint64_t v2 = -0x40a7b892e31b1a47 * (v1 / 0x40000000 ^ v1); // 0x100003d50
    int64_t v3 = -0x6b2fb644ecceee15 * (v2 / 0x8000000 ^ v2); // 0x100003d74
    return v3 ^ (int64_t)(v3 < 0);
}

// Address range: 0x100003d90 - 0x100003dd0
int64_t function_100003d90(void) {
    // 0x100003d90
    function_100003d0c();
    int128_t v1; // 0x100003d90
    return _pow((float64_t)(int64_t)v1, (float64_t)(int64_t)v1);
}

// Address range: 0x100003dd0 - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003de4
    g1 = 0x12d687;
    int64_t v2; // 0x100003dd0
    for (int32_t i = 0; i < 5; i++) {
        // 0x100003e1c
        function_100003d0c();
        _printf("%llu\n", v2);
    }
    // 0x100003e48
    g1 = 0x3ade68b1;
    int64_t v3 = 0; // bp-48, 0x100003e58
    int64_t v4 = &v3;
    int32_t v5 = 0;
    function_100003d90();
    float64_t v6; // 0x100003dd0
    float64_t v7 = 5.0 * v6; // 0x100003e90
    int32_t * v8 = (int32_t *)(4 * (int64_t)(int32_t)v7 + v4); // 0x100003ea8
    *v8 = *v8 + 1;
    int32_t v9 = v5 + 1; // 0x100003ebc
    int32_t v10 = 0; // 0x100003e80
    while (v5 < 0x1869f != (0x1869e - v5 & v9) < 0) {
        // 0x100003e88
        v5 = v9;
        function_100003d90();
        v7 *= 5.0;
        v8 = (int32_t *)(4 * (int64_t)(int32_t)v7 + v4);
        *v8 = *v8 + 1;
        v9 = v5 + 1;
        v10 = 0;
    }
    _printf("%d: %d  ", v2, v2);
    int32_t v11 = v10 + 1; // 0x100003f1c
    v10 = v11;
    while (v11 != 5) {
        // 0x100003ee4
        _printf("%d: %d  ", v2, v2);
        v11 = v10 + 1;
        v10 = v11;
    }
    // 0x100003f28
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f50
        ___stack_chk_fail();
    }
    // 0x100003f54
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(void) {
    // 0x100003f64
    return ___stack_chk_fail();
}

// Address range: 0x100003f70 - 0x100003f7c
float64_t function_100003f70(float64_t a1, float64_t a2) {
    // 0x100003f70
    return _pow(a1, a2);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <math.h>

int main()
{
	double a, c, s, PI2 = atan2(1, 1) * 8;
	int n, i;

	for (n = 1; n < 10; n++) for (i = 0; i < n; i++) {
		c = s = 0;
		if (!i )		c =  1;
		else if(n == 4 * i)	s =  1;
		else if(n == 2 * i)	c = -1;
		else if(3 * n == 4 * i)	s = -1;
		else
			a = i * PI2 / n, c = cos(a), s = sin(a);

		if (c) printf("%.2g", c);
		printf(s == 1 ? "i" : s == -1 ? "-i" : s ? "%+.2gi" : "", s);
		printf(i == n - 1 ?"\n":",  ");
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f60(float64_t a1, float64_t a2);
float64_t function_100003f6c(float64_t a1);
int32_t function_100003f78(char * format, ...);
float64_t function_100003f84(float64_t a1);

// --------------------- Global Variables ---------------------

char * g1 = "i"; // 0x100003f95

// ------- Dynamically Linked Functions Without Header --------

float64_t _atan2(float64_t a1, float64_t a2);
float64_t _cos(float64_t a1);
int32_t _printf(char * a1, ...);
float64_t _sin(float64_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cac - 0x100003f60
int64_t entry_point(void) {
    int32_t v1 = 1; // 0x100003f44
    int128_t v2; // 0x100003cac
    int64_t v3 = (float32_t)_atan2((float64_t)(int64_t)v2, (float64_t)(int64_t)v2); // 0x100003cac
    char * v4; // 0x100003cac
    int32_t v5; // 0x100003cac
    int32_t v6; // 0x100003cac
    int32_t v7; // 0x100003cac
    int64_t v8; // 0x100003cac
    while (true) {
        // 0x100003d14
        v5 = v1;
        int32_t v9 = 3 * v5;
        v6 = 0;
        while (true) {
          lab_0x100003d14:
            // 0x100003d14
            v8 = v3;
            v7 = v6;
            if (v7 == 0) {
                goto lab_0x100003e7c;
            } else {
                int32_t v10 = 4 * v7; // 0x100003d4c
                v4 = (char *)&g1;
                v3 = v8;
                if (v5 == v10) {
                    goto lab_0x100003ee0;
                } else {
                    if (v5 == 2 * v7) {
                        goto lab_0x100003e7c;
                    } else {
                        // 0x100003d98
                        v4 = "-i";
                        v3 = v8;
                        if (v9 != v10) {
                            int128_t v11 = __asm_sshll(0.0f, 0); // 0x100003dd4
                            __asm_sshll(0.0f, 0);
                            float64_t v12 = _cos((float64_t)(int64_t)v11); // 0x100003e00
                            v4 = (char *)0x100003fa1;
                            v3 = (float32_t)_sin(v12);
                        }
                        goto lab_0x100003ee0;
                    }
                }
            }
        }
      lab_0x100003f40:
        // 0x100003f40
        v1 = v5 + 1;
        if (v1 == 10) {
            // break -> 0x100003f50
            break;
        }
    }
    // 0x100003f50
    return 0;
  lab_0x100003e7c:
    // 0x100003e7c
    _printf("%.2g", (float64_t)v8);
    v4 = (char *)0x100003fa1;
    v3 = v8;
    goto lab_0x100003ee0;
  lab_0x100003ee0:
    // 0x100003ee0
    _printf(v4);
    _printf(v7 != v5 - 1 ? ",  " : (char *)0x100003fa2);
    int32_t v13 = v7 + 1; // 0x100003f30
    int32_t v14 = v13 - v5; // 0x100003d04
    v6 = v13;
    if (v14 < 0 == (v13 & -v14) < 0) {
        // break -> 0x100003f40
        goto lab_0x100003f40;
    }
    goto lab_0x100003d14;
}

// Address range: 0x100003f60 - 0x100003f6c
float64_t function_100003f60(float64_t a1, float64_t a2) {
    // 0x100003f60
    return _atan2(a1, a2);
}

// Address range: 0x100003f6c - 0x100003f78
float64_t function_100003f6c(float64_t a1) {
    // 0x100003f6c
    return _cos(a1);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// Address range: 0x100003f84 - 0x100003f90
float64_t function_100003f84(float64_t a1) {
    // 0x100003f84
    return _sin(a1);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdbool.h>
#include <stdio.h>
#include <string.h>

int inv(int a) {
    return a ^ -1;
}

struct Zeckendorf {
    int dVal, dLen;
};

void a(struct Zeckendorf *self, int n) {
    void b(struct Zeckendorf *, int); // forward declare

    int i = n;
    while (true) {
        if (self->dLen < i) self->dLen = i;
        int j = (self->dVal >> (i * 2)) & 3;
        switch (j) {
        case 0:
        case 1:
            return;
        case 2:
            if (((self->dVal >> ((i + 1) * 2)) & 1) != 1) return;
            self->dVal += 1 << (i * 2 + 1);
            return;
        case 3:
            self->dVal = self->dVal & inv(3 << (i * 2));
            b(self, (i + 1) * 2);
            break;
        default:
            break;
        }
        i++;
    }
}

void b(struct Zeckendorf *self, int pos) {
    void increment(struct Zeckendorf *); // forward declare

    if (pos == 0) {
        increment(self);
        return;
    }
    if (((self->dVal >> pos) & 1) == 0) {
        self->dVal += 1 << pos;
        a(self, pos / 2);
        if (pos > 1) a(self, pos / 2 - 1);
    } else {
        self->dVal = self->dVal & inv(1 << pos);
        b(self, pos + 1);
        b(self, pos - (pos > 1 ? 2 : 1));
    }
}

void c(struct Zeckendorf *self, int pos) {
    if (((self->dVal >> pos) & 1) == 1) {
        self->dVal = self->dVal & inv(1 << pos);
        return;
    }
    c(self, pos + 1);
    if (pos > 0) {
        b(self, pos - 1);
    } else {
        increment(self);
    }
}

struct Zeckendorf makeZeckendorf(char *x) {
    struct Zeckendorf z = { 0, 0 };
    int i = strlen(x) - 1;
    int q = 1;

    z.dLen = i / 2;
    while (i >= 0) {
        z.dVal += (x[i] - '0') * q;
        q *= 2;
        i--;
    }

    return z;
}

void increment(struct Zeckendorf *self) {
    self->dVal++;
    a(self, 0);
}

void addAssign(struct Zeckendorf *self, struct Zeckendorf rhs) {
    int gn;
    for (gn = 0; gn < (rhs.dLen + 1) * 2; gn++) {
        if (((rhs.dVal >> gn) & 1) == 1) {
            b(self, gn);
        }
    }
}

void subAssign(struct Zeckendorf *self, struct Zeckendorf rhs) {
    int gn;
    for (gn = 0; gn < (rhs.dLen + 1) * 2; gn++) {
        if (((rhs.dVal >> gn) & 1) == 1) {
            c(self, gn);
        }
    }
    while ((((self->dVal >> self->dLen * 2) & 3) == 0) || (self->dLen == 0)) {
        self->dLen--;
    }
}

void mulAssign(struct Zeckendorf *self, struct Zeckendorf rhs) {
    struct Zeckendorf na = rhs;
    struct Zeckendorf nb = rhs;
    struct Zeckendorf nr = makeZeckendorf("0");
    struct Zeckendorf nt;
    int i;

    for (i = 0; i < (self->dLen + 1) * 2; i++) {
        if (((self->dVal >> i) & 1) > 0) addAssign(&nr, nb);
        nt = nb;
        addAssign(&nb, na);
        na = nt;
    }

    *self = nr;
}

void printZeckendorf(struct Zeckendorf z) {
    static const char *const dig[3] = { "00", "01", "10" };
    static const char *const dig1[3] = { "", "1", "10" };

    if (z.dVal == 0) {
        printf("0");
        return;
    } else {
        int idx = (z.dVal >> (z.dLen * 2)) & 3;
        int i;

        printf(dig1[idx]);
        for (i = z.dLen - 1; i >= 0; i--) {
            idx = (z.dVal >> (i * 2)) & 3;
            printf(dig[idx]);
        }
    }
}

int main() {
    struct Zeckendorf g;

    printf("Addition:\n");
    g = makeZeckendorf("10");
    addAssign(&g, makeZeckendorf("10"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("10"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("1001"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("1000"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("10101"));
    printZeckendorf(g);
    printf("\n\n");

    printf("Subtraction:\n");
    g = makeZeckendorf("1000");
    subAssign(&g, makeZeckendorf("101"));
    printZeckendorf(g);
    printf("\n");
    g = makeZeckendorf("10101010");
    subAssign(&g, makeZeckendorf("1010101"));
    printZeckendorf(g);
    printf("\n\n");

    printf("Multiplication:\n");
    g = makeZeckendorf("1001");
    mulAssign(&g, makeZeckendorf("101"));
    printZeckendorf(g);
    printf("\n");
    g = makeZeckendorf("101010");
    addAssign(&g, makeZeckendorf("101"));
    printZeckendorf(g);
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000351c(void);
int64_t function_100003534(void);
int64_t function_1000036a4(void);
int64_t function_1000037d4(int64_t a1);
int64_t function_10000380c(void);
int64_t function_1000038c4(void);
int64_t function_100003968(void);
int64_t function_1000039f0(void);
int64_t function_100003ae4(void);
int64_t function_100003bb8(void);
int32_t function_100003f1c(char * format, ...);
int32_t function_100003f28(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000351c - 0x100003534
int64_t function_10000351c(void) {
    // 0x10000351c
    int64_t v1; // 0x10000351c
    return v1 & 0xffffffff ^ 0xffffffff;
}

// Address range: 0x100003534 - 0x1000036a4
int64_t function_100003534(void) {
    // 0x100003534
    int64_t v1; // 0x100003534
    int32_t * v2 = (int32_t *)v1; // 0x100003540
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x100003558
    int32_t v4 = v1;
    int32_t v5 = *v3; // 0x100003558
    int32_t v6 = v5 - v4; // 0x100003560
    int32_t v7 = v1; // 0x100003568
    int64_t result; // 0x100003534
    if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
        // 0x100003570
        *v3 = v4;
        v7 = *(int32_t *)&result;
    }
    int32_t v8 = v7; // 0x100003584
    uint32_t v9 = 2 * v4; // 0x10000358c
    uint32_t v10 = (v8 >> v9) % 4; // 0x100003594
    while (v10 != 1 && v10 != 0) {
        int32_t v11 = v8; // 0x100003534
        switch (v10) {
            case 2: {
                if ((v8 & 1 << v9 + 2) != 0) {
                    // 0x100003614
                    *v2 = v8 + (1 << (v9 | 1));
                }
                // 0x100003698
                return result;
            }
            case 3: {
                // 0x10000363c
                *v2 = v8 & (int32_t)function_10000351c();
                int64_t v12 = function_1000036a4(); // 0x10000367c
                result = v12;
                v11 = v12;
                // break -> 0x100003688
                break;
            }
        }
        // 0x100003688
        v4++;
        v5 = *v3;
        v6 = v5 - v4;
        v7 = v11;
        if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
            // 0x100003570
            *v3 = v4;
            v7 = *(int32_t *)&result;
        }
        // 0x100003580
        v8 = v7;
        v9 = 2 * v4;
        v10 = (v8 >> v9) % 4;
    }
    // 0x100003698
    return result;
}

// Address range: 0x1000036a4 - 0x1000037d4
int64_t function_1000036a4(void) {
    // 0x1000036a4
    int64_t v1; // 0x1000036a4
    uint32_t v2 = (int32_t)v1; // 0x1000036b4
    if (v2 == 0) {
        // 0x1000037c8
        return function_1000037d4(v1);
    }
    int32_t * v3 = (int32_t *)v1; // 0x1000036b0
    int32_t v4 = v1;
    int32_t v5 = 1 << v2;
    if ((v5 & v4) != 0) {
        // 0x10000375c
        *v3 = (int32_t)(function_10000351c() & v1);
        function_1000036a4();
        // 0x1000037c8
        return function_1000036a4();
    }
    // 0x1000036f8
    *v3 = v5 + v4;
    int32_t v6 = v2 - 1; // 0x10000372c
    int64_t result = function_100003534(); // 0x100003734
    if (v6 != 0 && v6 < 0 == (v2 & -v2) < 0) {
        // 0x10000373c
        result = function_100003534();
    }
    // 0x1000037c8
    return result;
}

// Address range: 0x1000037d4 - 0x10000380c
int64_t function_1000037d4(int64_t a1) {
    // 0x1000037d4
    int64_t v1; // 0x1000037d4
    *(int32_t *)a1 = (int32_t)v1 + 1;
    return function_100003534();
}

// Address range: 0x10000380c - 0x1000038c4
int64_t function_10000380c(void) {
    // 0x10000380c
    int64_t v1; // 0x10000380c
    int64_t v2 = v1;
    int32_t v3 = v1; // 0x10000381c
    if ((1 << v3 & (int32_t)v2) != 0) {
        int64_t result = function_10000351c(); // 0x10000385c
        *(int32_t *)v2 = (int32_t)(result & v2);
        // 0x1000038b8
        return result;
    }
    // 0x100003874
    function_10000380c();
    int64_t result2; // 0x10000380c
    if (v3 < 1) {
        // 0x1000038ac
        result2 = function_1000037d4(v2);
    } else {
        // 0x100003898
        result2 = function_1000036a4();
    }
    // 0x1000038b8
    return result2;
}

// Address range: 0x1000038c4 - 0x100003968
int64_t function_1000038c4(void) {
    // 0x1000038c4
    int64_t v1; // 0x1000038c4
    int32_t v2 = _strlen((char *)v1) - 1;
    if (v2 < 0) {
        // 0x100003958
        return 0;
    }
    int64_t v3 = v2; // 0x1000038c4
    int32_t v4 = v2;
    int32_t v5 = 1; // 0x1000038c4
    int32_t result = 0; // 0x100003934
    char v6 = *(char *)(v3 + v1); // 0x100003920
    result += ((int32_t)v6 - 48) * v5;
    v4--;
    v3--;
    v5 *= 2;
    while (v4 >= 0) {
        // 0x100003918
        v6 = *(char *)(v3 + v1);
        result += ((int32_t)v6 - 48) * v5;
        v4--;
        v3--;
        v5 *= 2;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003968 - 0x1000039f0
int64_t function_100003968(void) {
    // 0x100003968
    int32_t v1; // 0x100003968
    int32_t v2 = 2 * v1; // 0x10000398c
    int32_t v3 = v2 + 2; // 0x100003990
    int32_t v4 = -2 - v2; // 0x100003990
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x1000039e4
        int64_t result; // 0x100003968
        return result;
    }
    int32_t v5 = 0; // 0x100003998
    int64_t v6; // 0x100003968
    int64_t result2 = v6; // 0x1000039b8
    int64_t v7; // 0x100003968
    if ((1 << v5 & (int32_t)v7) != 0) {
        // 0x1000039c0
        result2 = function_1000036a4();
    }
    // 0x1000039d4
    v5++;
    int32_t v8 = v5 - v3; // 0x100003990
    while (v8 < 0 != ((v8 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x1000039a0
        if ((1 << v5 & (int32_t)v7) != 0) {
            // 0x1000039c0
            result2 = function_1000036a4();
        }
        // 0x1000039d4
        v5++;
        v8 = v5 - v3;
    }
    // 0x1000039e4
    return result2;
}

// Address range: 0x1000039f0 - 0x100003ae4
int64_t function_1000039f0(void) {
    // 0x1000039f0
    int32_t v1; // 0x1000039f0
    int32_t v2 = 2 * v1; // 0x100003a14
    int32_t v3 = v2 + 2; // 0x100003a18
    int32_t v4 = -2 - v2; // 0x100003a18
    int32_t v5 = 0; // 0x100003a20
    int64_t result; // 0x1000039f0
    int64_t v6; // 0x1000039f0
    int64_t result2; // 0x1000039f0
    if (v4 < 0 != (v4 & v3) < 0) {
        int64_t v7; // 0x1000039f0
        int64_t v8 = v7; // 0x100003a40
        if ((1 << v5 & (int32_t)v6) != 0) {
            // 0x100003a48
            v8 = function_10000380c();
        }
        int64_t v9 = v8;
        v5++;
        int32_t v10 = v5 - v3; // 0x100003a18
        while (v10 < 0 != ((v10 ^ v5) & (v5 ^ v3)) < 0) {
            // 0x100003a28
            v8 = v9;
            if ((1 << v5 & (int32_t)v6) != 0) {
                // 0x100003a48
                v8 = function_10000380c();
            }
            // 0x100003a5c
            v9 = v8;
            v5++;
            v10 = v5 - v3;
        }
        // 0x100003a0c
        result2 = v9;
        result = v9;
    }
    int32_t * v11 = (int32_t *)(v6 + 4); // 0x100003a7c
    int32_t v12 = *v11; // 0x100003a7c
    if (v12 != 0 == (((int32_t)result >> 2 * v12) % 4 != 0)) {
        // 0x100003ad8
        return result;
    }
    int32_t v13 = v12; // 0x100003a98
    v13--;
    *v11 = v13;
    while (v13 != 0 != (*(int32_t *)&result2 >> 2 * v13) % 4 != 0) {
        // 0x100003ac4
        v13--;
        *v11 = v13;
    }
    // 0x100003ad8
    return result2;
}

// Address range: 0x100003ae4 - 0x100003bb8
int64_t function_100003ae4(void) {
    int64_t result = function_1000038c4(); // 0x100003b10
    int64_t v1; // 0x100003ae4
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x100003b28
    int32_t v3 = 2 * *v2; // 0x100003b2c
    int32_t v4 = -2 - v3; // 0x100003b30
    int32_t v5 = 0; // 0x100003b38
    if (v4 < 0 == (v4 & v3 + 2) < 0) {
        // 0x100003ba0
        *(int64_t *)v1 = result;
        return result;
    }
    if ((1 << v5 & (int32_t)result) != 0) {
        // 0x100003b60
        function_100003968();
    }
    int64_t result2 = function_100003968(); // 0x100003b80
    v5++;
    int32_t v6 = 2 * *v2 + 2; // 0x100003b30
    int32_t v7 = v5 - v6; // 0x100003b30
    while (v7 < 0 != ((v7 ^ v5) & (v6 ^ v5)) < 0) {
        // 0x100003b40
        if ((1 << v5 & (int32_t)result2) != 0) {
            // 0x100003b60
            function_100003968();
        }
        // 0x100003b70
        result2 = function_100003968();
        v5++;
        v6 = 2 * *v2 + 2;
        v7 = v5 - v6;
    }
    // 0x100003ba0
    *(int64_t *)v1 = result;
    return result2;
}

// Address range: 0x100003bb8 - 0x100003c8c
int64_t function_100003bb8(void) {
    // 0x100003bb8
    int64_t v1; // 0x100003bb8
    int32_t v2 = v1; // 0x100003bc4
    if (v2 == 0) {
        // 0x100003c80
        return _printf("0");
    }
    // 0x100003bec
    int32_t v3; // 0x100003bb8
    int64_t v4 = *(int64_t *)((int64_t)(8 * (v2 >> 2 * v3) & 24) + (int64_t)"??"); // 0x100003c10
    int32_t v5 = v3 - 1;
    int32_t v6 = v5; // 0x100003c34
    int32_t result = _printf((char *)v4); // 0x100003c34
    if (v5 < 0) {
        // 0x100003c80
        return result;
    }
    int64_t v7 = *(int64_t *)((int64_t)(8 * (v2 >> 2 * v6) & 24) + (int64_t)"6?"); // 0x100003c60
    v6--;
    result = _printf((char *)v7);
    while (v6 >= 0) {
        // 0x100003c3c
        v7 = *(int64_t *)((int64_t)(8 * (v2 >> 2 * v6) & 24) + (int64_t)"6?");
        v6--;
        result = _printf((char *)v7);
    }
    // 0x100003c80
    return result;
}

// Address range: 0x100003c8c - 0x100003f1c
int64_t entry_point(void) {
    // 0x100003c8c
    _printf("Addition:\n");
    function_1000038c4();
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n\n");
    _printf("Subtraction:\n");
    function_1000038c4();
    function_1000038c4();
    function_1000039f0();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_1000038c4();
    function_1000039f0();
    function_100003bb8();
    _printf("\n\n");
    _printf("Multiplication:\n");
    function_1000038c4();
    function_1000038c4();
    function_100003ae4();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * format, ...) {
    // 0x100003f1c
    return _printf(format);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * s) {
    // 0x100003f28
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>


int main() {
    int arabic[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};

    // There is a bug: "XL\0" is translated into sequence 58 4C 00 00, i.e. it is 4-bytes long...
    // Should be "XL" without \0 etc.
    //
    char roman[13][3] = {"M\0", "CM\0", "D\0", "CD\0", "C\0", "XC\0", "L\0", "XL\0", "X\0", "IX\0", "V\0", "IV\0", "I\0"};
    int N;

    printf("Enter arabic number:\n");
    scanf("%d", &N);
    printf("\nRoman number:\n");

    for (int i = 0; i < 13; i++) {
        while (N >= arabic[i]) {
            printf("%s", roman[i]);
            N -= arabic[i];
        }
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ef0(void);
int64_t * function_100003efc(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f08(char * format, ...);
int32_t function_100003f14(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x384000003e8; // 0x100003f20
char * g2 = "M"; // 0x100003f54

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dac - 0x100003ef0
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc0
    int64_t v2; // bp-76, 0x100003dac
    _memcpy(&v2, &g1, 52);
    int64_t v3; // bp-115, 0x100003dac
    _memcpy(&v3, (int64_t *)&g2, 39);
    _printf("Enter arabic number:\n");
    _scanf("%d", (int64_t *)&g2);
    _printf("\nRoman number:\n");
    int64_t v4 = 0;
    int32_t v5; // 0x100003dac
    int32_t v6 = v5;
    int32_t * v7 = (int32_t *)(4 * v4 + (int64_t)&v2); // 0x100003e50
    int32_t v8 = *v7; // 0x100003e50
    int32_t v9 = v6 - v8; // 0x100003e54
    int32_t v10 = v6; // 0x100003e5c
    int32_t v11 = v6; // 0x100003e5c
    int32_t v12; // 0x100003dac
    int32_t v13; // 0x100003e9c
    int32_t v14; // 0x100003e54
    if (v9 < 0 == ((v9 ^ v6) & (v8 ^ v6)) < 0) {
        _printf("%s", (char *)&g2);
        v12 = *v7;
        v13 = v10 - v12;
        v14 = v13 - v12;
        v10 = v13;
        v11 = v13;
        while (v14 < 0 == ((v14 ^ v13) & (v13 ^ v12)) < 0) {
            // 0x100003e64
            _printf("%s", (char *)&g2);
            v12 = *v7;
            v13 = v10 - v12;
            v14 = v13 - v12;
            v10 = v13;
            v11 = v13;
        }
    }
    // 0x100003eac
    v4++;
    while (v4 != 13) {
        // 0x100003e44
        v6 = v11;
        v7 = (int32_t *)(4 * v4 + (int64_t)&v2);
        v8 = *v7;
        v9 = v6 - v8;
        v10 = v6;
        v11 = v6;
        if (v9 < 0 == ((v9 ^ v6) & (v8 ^ v6)) < 0) {
            _printf("%s", (char *)&g2);
            v12 = *v7;
            v13 = v10 - v12;
            v14 = v13 - v12;
            v10 = v13;
            v11 = v13;
            while (v14 < 0 == ((v14 ^ v13) & (v13 ^ v12)) < 0) {
                // 0x100003e64
                _printf("%s", (char *)&g2);
                v12 = *v7;
                v13 = v10 - v12;
                v14 = v13 - v12;
                v10 = v13;
                v11 = v13;
            }
        }
        // 0x100003eac
        v4++;
    }
    // 0x100003ebc
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003edc
        ___stack_chk_fail();
    }
    // 0x100003ee0
    return 0;
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t function_100003ef0(void) {
    // 0x100003ef0
    return ___stack_chk_fail();
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003efc
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * format, ...) {
    // 0x100003f14
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include<limits.h>
#include<stdlib.h>
#include<stdio.h>

typedef struct{
    int sourceVertex, destVertex;
    int edgeWeight;
}edge;

typedef struct{
    int vertices, edges;
    edge* edgeMatrix;
}graph;

graph loadGraph(char* fileName){
    FILE* fp = fopen(fileName,"r");

    graph G;
    int i;

    fscanf(fp,"%d%d",&G.vertices,&G.edges);

    G.edgeMatrix = (edge*)malloc(G.edges*sizeof(edge));

    for(i=0;i<G.edges;i++)
        fscanf(fp,"%d%d%d",&G.edgeMatrix[i].sourceVertex,&G.edgeMatrix[i].destVertex,&G.edgeMatrix[i].edgeWeight);

    fclose(fp);

    return G;
}

void floydWarshall(graph g){
    int processWeights[g.vertices][g.vertices], processedVertices[g.vertices][g.vertices];
    int i,j,k;

    for(i=0;i<g.vertices;i++)
        for(j=0;j<g.vertices;j++){
            processWeights[i][j] = SHRT_MAX;
            processedVertices[i][j] = (i!=j)?j+1:0;
        }

    for(i=0;i<g.edges;i++)
        processWeights[g.edgeMatrix[i].sourceVertex-1][g.edgeMatrix[i].destVertex-1] = g.edgeMatrix[i].edgeWeight;

    for(i=0;i<g.vertices;i++)
        for(j=0;j<g.vertices;j++)
            for(k=0;k<g.vertices;k++){
                if(processWeights[j][i] + processWeights[i][k] < processWeights[j][k]){
                    processWeights[j][k] = processWeights[j][i] + processWeights[i][k];
                    processedVertices[j][k] = processedVertices[j][i];
                }
            }

    printf("pair    dist   path");
    for(i=0;i<g.vertices;i++)
        for(j=0;j<g.vertices;j++){
            if(i!=j){
                printf("\n%d -> %d %3d %5d",i+1,j+1,processWeights[i][j],i+1);
                k = i+1;
                do{
                    k = processedVertices[k-1][j];
                    printf("->%d",k);
                }while(k!=j+1);
            }
        }
}

int main(int argC,char* argV[]){
    if(argC!=2)
        printf("Usage : %s <file containing graph data>");
    else
        floydWarshall(loadGraph(argV[1]));
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003810(void);
int64_t function_10000391c(int64_t a1, int64_t a2);
int64_t function_10000397c(void);
int64_t function_1000039d0(void);
int64_t function_100003efc(void);
int32_t function_100003f08(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f14(char * filename, char * modes);
int32_t function_100003f20(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f2c(int32_t size);
int32_t function_100003f38(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003810 - 0x10000391c
int64_t function_100003810(void) {
    // 0x100003810
    int64_t result; // 0x100003810
    struct _IO_FILE * v1 = _fopen((char *)result, "r"); // 0x10000382c
    int64_t * v2 = (int64_t *)result; // 0x100003858
    int64_t * v3 = (int64_t *)result; // 0x100003858
    _fscanf(v1, "%d%d", v2, v3);
    int32_t v4; // 0x100003810
    _malloc(12 * v4);
    int32_t v5 = -v4; // 0x100003880
    if (v5 < 0 == (v4 & v5) < 0) {
        // 0x100003900
        _fclose(v1);
        return result;
    }
    int32_t v6 = 0; // 0x1000038f4
    _fscanf(v1, "%d%d%d", v2, v3, (int64_t *)result);
    v6++;
    while (v6 - v4 < 0 != ((v6 - v4 ^ v6) & (v6 ^ v4)) < 0) {
        // 0x100003890
        _fscanf(v1, "%d%d%d", v2, v3, (int64_t *)result);
        v6++;
    }
    // 0x100003900
    _fclose(v1);
    return result;
}

// Address range: 0x10000391c - 0x10000397c
int64_t function_10000391c(int64_t a1, int64_t a2) {
    // 0x10000391c
    return ___chkstk_darwin();
}

// Address range: 0x10000397c - 0x1000039d0
int64_t function_10000397c(void) {
    // 0x10000397c
    int64_t v1; // 0x10000397c
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)(v2 - 136); // 0x10000397c
    int64_t v4; // 0x10000397c
    *(int64_t *)(v2 - 120) = (int64_t)&v4 - v3;
    *(int64_t *)(v2 - 40) = *(int64_t *)(v2 - 128);
    int32_t * v5 = (int32_t *)(v2 - 24); // 0x10000399c
    int64_t v6 = (int64_t)*v5; // 0x10000399c
    *(int64_t *)(v2 - 96) = v6;
    int64_t v7 = (int64_t)*v5; // 0x1000039a8
    *(int64_t *)(v2 - 112) = v7;
    *(int64_t *)(v2 - 104) = 4 * v6 * v7 + 15 & -16;
    return ___chkstk_darwin();
}

// Address range: 0x1000039d0 - 0x100003e8c
int64_t function_1000039d0(void) {
    // 0x1000039d0
    int64_t v1; // 0x1000039d0
    int64_t v2 = v1;
    int64_t v3; // 0x1000039d0
    int64_t v4 = (int64_t)&v3 - *(int64_t *)(v2 - 104); // 0x1000039dc
    int64_t * v5 = (int64_t *)(v2 - 88); // 0x1000039e4
    *v5 = v4;
    *(int64_t *)(v2 - 56) = *(int64_t *)(v2 - 96);
    int32_t * v6 = (int32_t *)(v2 - 68); // 0x1000039f0
    *v6 = 0;
    int32_t * v7 = (int32_t *)(v2 - 24); // 0x1000039fc
    int32_t v8 = *v7; // 0x1000039fc
    int32_t v9 = -v8; // 0x100003a00
    if (v9 < 0 != (v8 & v9) < 0) {
        int32_t * v10 = (int32_t *)(v2 - 72); // 0x100003a10
        *v10 = 0;
        int32_t v11 = *v7; // 0x100003a1c
        int32_t v12 = -v11; // 0x100003a20
        int32_t v13; // 0x1000039d0
        int64_t v14; // 0x100003a30
        int64_t v15; // 0x100003a34
        int32_t v16; // 0x100003a54
        int64_t v17; // 0x100003a84
        int64_t v18; // 0x100003a88
        int32_t v19; // 0x100003a90
        int32_t v20; // 0x100003a9c
        int32_t v21; // 0x100003aac
        int32_t v22; // 0x100003a1c
        int32_t v23; // 0x100003a20
        if (v12 < 0 != (v11 & v12) < 0) {
            v14 = *(int64_t *)(v2 - 120);
            v15 = *(int64_t *)(v2 - 144);
            *(int32_t *)(4 * (v15 * (int64_t)*v6 + (int64_t)0) + v14) = 0x7fff;
            v16 = *v10;
            v13 = *v6 == v16 ? 0 : v16 + 1;
            *(int32_t *)(v2 - 148) = v13;
            v17 = *v5;
            v18 = *(int64_t *)(v2 - 112);
            v19 = *v6;
            v20 = *v10;
            *(int32_t *)(4 * (v18 * (int64_t)v19 + (int64_t)v20) + v17) = v13;
            v21 = *v10 + 1;
            *v10 = v21;
            v22 = *v7;
            v23 = v21 - v22;
            while (v23 < 0 != ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                // 0x100003a30
                v14 = *(int64_t *)(v2 - 120);
                v15 = *(int64_t *)(v2 - 144);
                *(int32_t *)(4 * (v15 * (int64_t)*v6 + (int64_t)v21) + v14) = 0x7fff;
                v16 = *v10;
                v13 = *v6 == v16 ? 0 : v16 + 1;
                *(int32_t *)(v2 - 148) = v13;
                v17 = *v5;
                v18 = *(int64_t *)(v2 - 112);
                v19 = *v6;
                v20 = *v10;
                *(int32_t *)(4 * (v18 * (int64_t)v19 + (int64_t)v20) + v17) = v13;
                v21 = *v10 + 1;
                *v10 = v21;
                v22 = *v7;
                v23 = v21 - v22;
            }
        }
        int32_t v24 = *v6 + 1; // 0x100003ac0
        *v6 = v24;
        int32_t v25 = *v7; // 0x1000039fc
        while (v24 - v25 < 0 != ((v24 - v25 ^ v24) & (v25 ^ v24)) < 0) {
            // 0x100003a10
            *v10 = 0;
            v11 = *v7;
            v12 = -v11;
            if (v12 < 0 != (v11 & v12) < 0) {
                v14 = *(int64_t *)(v2 - 120);
                v15 = *(int64_t *)(v2 - 144);
                *(int32_t *)(4 * (v15 * (int64_t)*v6 + (int64_t)0) + v14) = 0x7fff;
                v16 = *v10;
                v13 = *v6 == v16 ? 0 : v16 + 1;
                *(int32_t *)(v2 - 148) = v13;
                v17 = *v5;
                v18 = *(int64_t *)(v2 - 112);
                v19 = *v6;
                v20 = *v10;
                *(int32_t *)(4 * (v18 * (int64_t)v19 + (int64_t)v20) + v17) = v13;
                v21 = *v10 + 1;
                *v10 = v21;
                v22 = *v7;
                v23 = v21 - v22;
                while (v23 < 0 != ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                    // 0x100003a30
                    v14 = *(int64_t *)(v2 - 120);
                    v15 = *(int64_t *)(v2 - 144);
                    *(int32_t *)(4 * (v15 * (int64_t)*v6 + (int64_t)v21) + v14) = 0x7fff;
                    v16 = *v10;
                    v13 = *v6 == v16 ? 0 : v16 + 1;
                    *(int32_t *)(v2 - 148) = v13;
                    v17 = *v5;
                    v18 = *(int64_t *)(v2 - 112);
                    v19 = *v6;
                    v20 = *v10;
                    *(int32_t *)(4 * (v18 * (int64_t)v19 + (int64_t)v20) + v17) = v13;
                    v21 = *v10 + 1;
                    *v10 = v21;
                    v22 = *v7;
                    v23 = v21 - v22;
                }
            }
            // 0x100003abc
            v24 = *v6 + 1;
            *v6 = v24;
            v25 = *v7;
        }
    }
    // 0x100003ad4
    *v6 = 0;
    int32_t * v26 = (int32_t *)(v2 - 20); // 0x100003ad8
    int32_t v27 = *v26; // 0x100003ad8
    int32_t v28 = -v27; // 0x100003adc
    if (v28 < 0 != (v27 & v28) < 0) {
        int64_t v29 = *(int64_t *)(v2 - 120); // 0x100003aec
        int64_t v30 = *(int64_t *)(v2 - 144); // 0x100003af0
        int64_t v31 = *(int64_t *)(v2 - 16); // 0x100003b04
        int32_t v32 = *(int32_t *)(v31 + 8); // 0x100003b08
        int32_t v33 = *(int32_t *)v31; // 0x100003b18
        int32_t v34 = *(int32_t *)(v31 + 4); // 0x100003b40
        *(int32_t *)(4 * v30 * (int64_t)(v33 - 1) + v29 + (int64_t)(4 * v34 - 4)) = v32;
        int32_t v35 = *v6 + 1; // 0x100003b54
        *v6 = v35;
        int32_t v36 = *v26; // 0x100003ad8
        while (v35 - v36 < 0 != ((v35 - v36 ^ v35) & (v36 ^ v35)) < 0) {
            // 0x100003aec
            v29 = *(int64_t *)(v2 - 120);
            v30 = *(int64_t *)(v2 - 144);
            v31 = *(int64_t *)(v2 - 16) + 12 * (int64_t)v35;
            v32 = *(int32_t *)(v31 + 8);
            v33 = *(int32_t *)v31;
            v34 = *(int32_t *)(v31 + 4);
            *(int32_t *)(4 * v30 * (int64_t)(v33 - 1) + v29 + (int64_t)(4 * v34 - 4)) = v32;
            v35 = *v6 + 1;
            *v6 = v35;
            v36 = *v26;
        }
    }
    // 0x100003b68
    *v6 = 0;
    int32_t v37 = *v7; // 0x100003b6c
    int32_t v38 = -v37; // 0x100003b70
    if (v38 < 0 != (v37 & v38) < 0) {
        int32_t * v39 = (int32_t *)(v2 - 72); // 0x100003b80
        int32_t * v40 = (int32_t *)(v2 - 76);
        *v39 = 0;
        int32_t v41 = *v7; // 0x100003b8c
        int32_t v42 = -v41; // 0x100003b90
        int32_t v43; // 0x1000039d0
        int32_t v44; // 0x1000039d0
        int64_t v45; // 0x100003bc0
        int64_t v46; // 0x1000039d0
        int64_t v47; // 0x100003bd0
        int64_t v48; // 0x100003bd4
        int64_t v49; // 0x100003bec
        int32_t v50; // 0x100003bec
        int32_t v51; // 0x100003bf0
        int32_t * v52; // 0x100003c04
        int32_t v53; // 0x100003c04
        int32_t v54; // 0x100003c08
        int32_t v55; // 0x100003c9c
        int32_t v56; // 0x100003bac
        int32_t v57; // 0x100003bb0
        int64_t v58; // 0x100003c70
        int32_t v59; // 0x100003c78
        int32_t v60; // 0x100003bac
        int32_t v61; // 0x100003bb0
        int32_t v62; // 0x100003cb0
        int32_t v63; // 0x100003b8c
        if (v42 < 0 != (v41 & v42) < 0) {
            *v40 = 0;
            v60 = *v7;
            v61 = -v60;
            v44 = 0;
            if (v61 < 0 != (v60 & v61) < 0) {
                v45 = *(int64_t *)(v2 - 120);
                v46 = 4 * *(int64_t *)(v2 - 144);
                v47 = v46 * (int64_t)*v39 + v45;
                v48 = (int64_t)*v6;
                v49 = 4 * (int64_t)v44;
                v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                v52 = (int32_t *)(v47 + v49);
                v53 = *v52;
                v54 = v51 - v53;
                v43 = v44;
                if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                    // 0x100003c18
                    *v52 = v51;
                    v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                    v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                    *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                    v43 = *v40;
                }
                // 0x100003c98
                v55 = v43 + 1;
                *v40 = v55;
                v56 = *v7;
                v57 = v55 - v56;
                v44 = v55;
                while (v57 < 0 != ((v57 ^ v55) & (v56 ^ v55)) < 0) {
                    // 0x100003bc0
                    v45 = *(int64_t *)(v2 - 120);
                    v46 = 4 * *(int64_t *)(v2 - 144);
                    v47 = v46 * (int64_t)*v39 + v45;
                    v48 = (int64_t)*v6;
                    v49 = 4 * (int64_t)v44;
                    v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                    v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                    v52 = (int32_t *)(v47 + v49);
                    v53 = *v52;
                    v54 = v51 - v53;
                    v43 = v44;
                    if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                        // 0x100003c18
                        *v52 = v51;
                        v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                        v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                        *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                        v43 = *v40;
                    }
                    // 0x100003c98
                    v55 = v43 + 1;
                    *v40 = v55;
                    v56 = *v7;
                    v57 = v55 - v56;
                    v44 = v55;
                }
            }
            // 0x100003cac
            v62 = *v39 + 1;
            *v39 = v62;
            v63 = *v7;
            while (v62 - v63 < 0 != ((v62 - v63 ^ v62) & (v63 ^ v62)) < 0) {
                // 0x100003ba0
                *v40 = 0;
                v60 = *v7;
                v61 = -v60;
                v44 = 0;
                if (v61 < 0 != (v60 & v61) < 0) {
                    v45 = *(int64_t *)(v2 - 120);
                    v46 = 4 * *(int64_t *)(v2 - 144);
                    v47 = v46 * (int64_t)*v39 + v45;
                    v48 = (int64_t)*v6;
                    v49 = 4 * (int64_t)v44;
                    v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                    v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                    v52 = (int32_t *)(v47 + v49);
                    v53 = *v52;
                    v54 = v51 - v53;
                    v43 = v44;
                    if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                        // 0x100003c18
                        *v52 = v51;
                        v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                        v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                        *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                        v43 = *v40;
                    }
                    // 0x100003c98
                    v55 = v43 + 1;
                    *v40 = v55;
                    v56 = *v7;
                    v57 = v55 - v56;
                    v44 = v55;
                    while (v57 < 0 != ((v57 ^ v55) & (v56 ^ v55)) < 0) {
                        // 0x100003bc0
                        v45 = *(int64_t *)(v2 - 120);
                        v46 = 4 * *(int64_t *)(v2 - 144);
                        v47 = v46 * (int64_t)*v39 + v45;
                        v48 = (int64_t)*v6;
                        v49 = 4 * (int64_t)v44;
                        v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                        v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                        v52 = (int32_t *)(v47 + v49);
                        v53 = *v52;
                        v54 = v51 - v53;
                        v43 = v44;
                        if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                            // 0x100003c18
                            *v52 = v51;
                            v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                            v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                            *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                            v43 = *v40;
                        }
                        // 0x100003c98
                        v55 = v43 + 1;
                        *v40 = v55;
                        v56 = *v7;
                        v57 = v55 - v56;
                        v44 = v55;
                    }
                }
                // 0x100003cac
                v62 = *v39 + 1;
                *v39 = v62;
                v63 = *v7;
            }
        }
        int32_t v64 = *v6 + 1; // 0x100003cc4
        *v6 = v64;
        int32_t v65 = *v7; // 0x100003b6c
        while (v64 - v65 < 0 != ((v64 - v65 ^ v64) & (v65 ^ v64)) < 0) {
            // 0x100003b80
            *v39 = 0;
            v41 = *v7;
            v42 = -v41;
            if (v42 < 0 != (v41 & v42) < 0) {
                *v40 = 0;
                v60 = *v7;
                v61 = -v60;
                v44 = 0;
                if (v61 < 0 != (v60 & v61) < 0) {
                    v45 = *(int64_t *)(v2 - 120);
                    v46 = 4 * *(int64_t *)(v2 - 144);
                    v47 = v46 * (int64_t)*v39 + v45;
                    v48 = (int64_t)*v6;
                    v49 = 4 * (int64_t)v44;
                    v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                    v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                    v52 = (int32_t *)(v47 + v49);
                    v53 = *v52;
                    v54 = v51 - v53;
                    v43 = v44;
                    if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                        // 0x100003c18
                        *v52 = v51;
                        v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                        v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                        *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                        v43 = *v40;
                    }
                    // 0x100003c98
                    v55 = v43 + 1;
                    *v40 = v55;
                    v56 = *v7;
                    v57 = v55 - v56;
                    v44 = v55;
                    while (v57 < 0 != ((v57 ^ v55) & (v56 ^ v55)) < 0) {
                        // 0x100003bc0
                        v45 = *(int64_t *)(v2 - 120);
                        v46 = 4 * *(int64_t *)(v2 - 144);
                        v47 = v46 * (int64_t)*v39 + v45;
                        v48 = (int64_t)*v6;
                        v49 = 4 * (int64_t)v44;
                        v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                        v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                        v52 = (int32_t *)(v47 + v49);
                        v53 = *v52;
                        v54 = v51 - v53;
                        v43 = v44;
                        if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                            // 0x100003c18
                            *v52 = v51;
                            v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                            v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                            *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                            v43 = *v40;
                        }
                        // 0x100003c98
                        v55 = v43 + 1;
                        *v40 = v55;
                        v56 = *v7;
                        v57 = v55 - v56;
                        v44 = v55;
                    }
                }
                // 0x100003cac
                v62 = *v39 + 1;
                *v39 = v62;
                v63 = *v7;
                while (v62 - v63 < 0 != ((v62 - v63 ^ v62) & (v63 ^ v62)) < 0) {
                    // 0x100003ba0
                    *v40 = 0;
                    v60 = *v7;
                    v61 = -v60;
                    v44 = 0;
                    if (v61 < 0 != (v60 & v61) < 0) {
                        v45 = *(int64_t *)(v2 - 120);
                        v46 = 4 * *(int64_t *)(v2 - 144);
                        v47 = v46 * (int64_t)*v39 + v45;
                        v48 = (int64_t)*v6;
                        v49 = 4 * (int64_t)v44;
                        v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                        v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                        v52 = (int32_t *)(v47 + v49);
                        v53 = *v52;
                        v54 = v51 - v53;
                        v43 = v44;
                        if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                            // 0x100003c18
                            *v52 = v51;
                            v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                            v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                            *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                            v43 = *v40;
                        }
                        // 0x100003c98
                        v55 = v43 + 1;
                        *v40 = v55;
                        v56 = *v7;
                        v57 = v55 - v56;
                        v44 = v55;
                        while (v57 < 0 != ((v57 ^ v55) & (v56 ^ v55)) < 0) {
                            // 0x100003bc0
                            v45 = *(int64_t *)(v2 - 120);
                            v46 = 4 * *(int64_t *)(v2 - 144);
                            v47 = v46 * (int64_t)*v39 + v45;
                            v48 = (int64_t)*v6;
                            v49 = 4 * (int64_t)v44;
                            v50 = *(int32_t *)(v49 + v45 + v46 * v48);
                            v51 = v50 + *(int32_t *)(v47 + 4 * v48);
                            v52 = (int32_t *)(v47 + v49);
                            v53 = *v52;
                            v54 = v51 - v53;
                            v43 = v44;
                            if (v54 < 0 != ((v54 ^ v51) & (v51 ^ v53)) < 0) {
                                // 0x100003c18
                                *v52 = v51;
                                v58 = 4 * *(int64_t *)(v2 - 112) * (int64_t)*v39 + *v5;
                                v59 = *(int32_t *)(v58 + 4 * (int64_t)*v6);
                                *(int32_t *)(4 * (int64_t)*v40 + v58) = v59;
                                v43 = *v40;
                            }
                            // 0x100003c98
                            v55 = v43 + 1;
                            *v40 = v55;
                            v56 = *v7;
                            v57 = v55 - v56;
                            v44 = v55;
                        }
                    }
                    // 0x100003cac
                    v62 = *v39 + 1;
                    *v39 = v62;
                    v63 = *v7;
                }
            }
            // 0x100003cc0
            v64 = *v6 + 1;
            *v6 = v64;
            v65 = *v7;
        }
    }
    int64_t v66 = _printf("pair    dist   path"); // 0x100003cd8
    *v6 = 0;
    int32_t v67 = *v7; // 0x100003ce8
    int32_t v68 = -v67; // 0x100003cec
    int64_t v69 = v66; // 0x100003cf4
    if (v68 < 0 != (v67 & v68) < 0) {
        int32_t * v70 = (int32_t *)(v2 - 72); // 0x100003cfc
        int64_t * v71 = (int64_t *)(v4 - 16);
        int32_t * v72 = (int32_t *)(v2 - 76);
        *v70 = 0;
        int32_t v73 = *v7; // 0x100003d08
        int32_t v74 = -v73; // 0x100003d0c
        int32_t v75 = *v6;
        int32_t v76 = v75; // 0x100003d14
        int64_t v77 = v66; // 0x100003d14
        int32_t v78 = v75; // 0x100003d14
        int32_t v79; // 0x1000039d0
        int32_t v80; // 0x1000039d0
        int32_t v81; // 0x1000039d0
        int32_t v82; // 0x1000039d0
        int64_t v83; // 0x100003d34
        int64_t v84; // 0x100003d38
        int64_t v85; // 0x100003d40
        uint32_t v86; // 0x100003d5c
        int32_t v87; // 0x100003da4
        int32_t v88; // 0x100003d08
        int32_t v89; // 0x100003d0c
        int32_t v90; // 0x1000039d0
        int64_t v91; // 0x100003db0
        int64_t v92; // 0x100003db4
        uint32_t v93; // 0x100003dd4
        int32_t v94; // 0x100003df8
        int32_t v95; // 0x100003e04
        int32_t v96; // 0x100003e08
        int64_t v97; // 0x1000039d0
        int64_t v98; // 0x1000039d0
        if (v74 < 0 != (v73 & v74) < 0) {
            v82 = 0;
            v81 = v76;
            if (v81 == v82) {
                // 0x100003d1c
                v79 = v81 + 1;
                v98 = v66;
            } else {
                // 0x100003d34
                v83 = *(int64_t *)(v2 - 120);
                v84 = *(int64_t *)(v2 - 144);
                v85 = v81 + 1;
                v86 = *(int32_t *)(4 * (v84 * (int64_t)v81 + (int64_t)v82) + v83);
                *(int64_t *)(v4 - 32) = v85;
                *(int64_t *)(v4 - 24) = (int64_t)(v82 + 1);
                *v71 = (int64_t)v86;
                *(int64_t *)(v4 - 8) = v85;
                _printf("\n%d -> %d %3d %5d", v1, v1, v1, v1);
                v87 = *v6 + 1;
                *v72 = v87;
                v96 = *v70;
                v91 = *v5;
                v92 = *(int64_t *)(v2 - 112);
                v93 = *(int32_t *)(4 * (v92 * (int64_t)(v87 - 1) + (int64_t)v96) + v91);
                *v72 = v93;
                *v71 = (int64_t)v93;
                v94 = _printf("->%d", v1);
                v95 = *v72;
                v96 = *v70;
                while (v95 != v96 + 1) {
                    // 0x100003db0
                    v91 = *v5;
                    v92 = *(int64_t *)(v2 - 112);
                    v93 = *(int32_t *)(4 * (v92 * (int64_t)(v95 - 1) + (int64_t)v96) + v91);
                    *v72 = v93;
                    *v71 = (int64_t)v93;
                    v94 = _printf("->%d", v1);
                    v95 = *v72;
                    v96 = *v70;
                }
                // 0x100003e28
                v79 = v95;
                v98 = v94;
            }
            // 0x100003e28
            v80 = v79;
            *v70 = v80;
            v88 = *v7;
            v89 = v80 - v88;
            v90 = *v6;
            v97 = v98;
            v77 = v98;
            v78 = v90;
            while (v89 < 0 != ((v89 ^ v80) & (v88 ^ v80)) < 0) {
                // 0x100003d1c
                v82 = v80;
                v81 = v90;
                if (v81 == v82) {
                    // 0x100003d1c
                    v79 = v81 + 1;
                    v98 = v97;
                } else {
                    // 0x100003d34
                    v83 = *(int64_t *)(v2 - 120);
                    v84 = *(int64_t *)(v2 - 144);
                    v85 = v81 + 1;
                    v86 = *(int32_t *)(4 * (v84 * (int64_t)v81 + (int64_t)v82) + v83);
                    *(int64_t *)(v4 - 32) = v85;
                    *(int64_t *)(v4 - 24) = (int64_t)(v82 + 1);
                    *v71 = (int64_t)v86;
                    *(int64_t *)(v4 - 8) = v85;
                    _printf("\n%d -> %d %3d %5d", v1, v1, v1, v1);
                    v87 = *v6 + 1;
                    *v72 = v87;
                    v96 = *v70;
                    v91 = *v5;
                    v92 = *(int64_t *)(v2 - 112);
                    v93 = *(int32_t *)(4 * (v92 * (int64_t)(v87 - 1) + (int64_t)v96) + v91);
                    *v72 = v93;
                    *v71 = (int64_t)v93;
                    v94 = _printf("->%d", v1);
                    v95 = *v72;
                    v96 = *v70;
                    while (v95 != v96 + 1) {
                        // 0x100003db0
                        v91 = *v5;
                        v92 = *(int64_t *)(v2 - 112);
                        v93 = *(int32_t *)(4 * (v92 * (int64_t)(v95 - 1) + (int64_t)v96) + v91);
                        *v72 = v93;
                        *v71 = (int64_t)v93;
                        v94 = _printf("->%d", v1);
                        v95 = *v72;
                        v96 = *v70;
                    }
                    // 0x100003e28
                    v79 = v95;
                    v98 = v94;
                }
                // 0x100003e28
                v80 = v79;
                *v70 = v80;
                v88 = *v7;
                v89 = v80 - v88;
                v90 = *v6;
                v97 = v98;
                v77 = v98;
                v78 = v90;
            }
        }
        int64_t v99 = v77;
        int32_t v100 = v78 + 1; // 0x100003e40
        *v6 = v100;
        int32_t v101 = *v7; // 0x100003ce8
        int32_t v102 = v100 - v101; // 0x100003cec
        v69 = v99;
        while (v102 < 0 != ((v102 ^ v100) & (v101 ^ v100)) < 0) {
            // 0x100003cfc
            *v70 = 0;
            v73 = *v7;
            v74 = -v73;
            v75 = *v6;
            v76 = v75;
            v97 = v99;
            v77 = v99;
            v78 = v75;
            if (v74 < 0 != (v73 & v74) < 0) {
                v82 = 0;
                v81 = v76;
                if (v81 == v82) {
                    // 0x100003d1c
                    v79 = v81 + 1;
                    v98 = v97;
                } else {
                    // 0x100003d34
                    v83 = *(int64_t *)(v2 - 120);
                    v84 = *(int64_t *)(v2 - 144);
                    v85 = v81 + 1;
                    v86 = *(int32_t *)(4 * (v84 * (int64_t)v81 + (int64_t)v82) + v83);
                    *(int64_t *)(v4 - 32) = v85;
                    *(int64_t *)(v4 - 24) = (int64_t)(v82 + 1);
                    *v71 = (int64_t)v86;
                    *(int64_t *)(v4 - 8) = v85;
                    _printf("\n%d -> %d %3d %5d", v1, v1, v1, v1);
                    v87 = *v6 + 1;
                    *v72 = v87;
                    v96 = *v70;
                    v91 = *v5;
                    v92 = *(int64_t *)(v2 - 112);
                    v93 = *(int32_t *)(4 * (v92 * (int64_t)(v87 - 1) + (int64_t)v96) + v91);
                    *v72 = v93;
                    *v71 = (int64_t)v93;
                    v94 = _printf("->%d", v1);
                    v95 = *v72;
                    v96 = *v70;
                    while (v95 != v96 + 1) {
                        // 0x100003db0
                        v91 = *v5;
                        v92 = *(int64_t *)(v2 - 112);
                        v93 = *(int32_t *)(4 * (v92 * (int64_t)(v95 - 1) + (int64_t)v96) + v91);
                        *v72 = v93;
                        *v71 = (int64_t)v93;
                        v94 = _printf("->%d", v1);
                        v95 = *v72;
                        v96 = *v70;
                    }
                    // 0x100003e28
                    v79 = v95;
                    v98 = v94;
                }
                // 0x100003e28
                v80 = v79;
                *v70 = v80;
                v88 = *v7;
                v89 = v80 - v88;
                v90 = *v6;
                v97 = v98;
                v77 = v98;
                v78 = v90;
                while (v89 < 0 != ((v89 ^ v80) & (v88 ^ v80)) < 0) {
                    // 0x100003d1c
                    v82 = v80;
                    v81 = v90;
                    if (v81 == v82) {
                        // 0x100003d1c
                        v79 = v81 + 1;
                        v98 = v97;
                    } else {
                        // 0x100003d34
                        v83 = *(int64_t *)(v2 - 120);
                        v84 = *(int64_t *)(v2 - 144);
                        v85 = v81 + 1;
                        v86 = *(int32_t *)(4 * (v84 * (int64_t)v81 + (int64_t)v82) + v83);
                        *(int64_t *)(v4 - 32) = v85;
                        *(int64_t *)(v4 - 24) = (int64_t)(v82 + 1);
                        *v71 = (int64_t)v86;
                        *(int64_t *)(v4 - 8) = v85;
                        _printf("\n%d -> %d %3d %5d", v1, v1, v1, v1);
                        v87 = *v6 + 1;
                        *v72 = v87;
                        v96 = *v70;
                        v91 = *v5;
                        v92 = *(int64_t *)(v2 - 112);
                        v93 = *(int32_t *)(4 * (v92 * (int64_t)(v87 - 1) + (int64_t)v96) + v91);
                        *v72 = v93;
                        *v71 = (int64_t)v93;
                        v94 = _printf("->%d", v1);
                        v95 = *v72;
                        v96 = *v70;
                        while (v95 != v96 + 1) {
                            // 0x100003db0
                            v91 = *v5;
                            v92 = *(int64_t *)(v2 - 112);
                            v93 = *(int32_t *)(4 * (v92 * (int64_t)(v95 - 1) + (int64_t)v96) + v91);
                            *v72 = v93;
                            *v71 = (int64_t)v93;
                            v94 = _printf("->%d", v1);
                            v95 = *v72;
                            v96 = *v70;
                        }
                        // 0x100003e28
                        v79 = v95;
                        v98 = v94;
                    }
                    // 0x100003e28
                    v80 = v79;
                    *v70 = v80;
                    v88 = *v7;
                    v89 = v80 - v88;
                    v90 = *v6;
                    v97 = v98;
                    v77 = v98;
                    v78 = v90;
                }
            }
            // 0x100003e3c
            v99 = v77;
            v100 = v78 + 1;
            *v6 = v100;
            v101 = *v7;
            v102 = v100 - v101;
            v69 = v99;
        }
    }
    // 0x100003e4c
    *(int64_t *)(v2 - 160) = *(int64_t *)(v2 - 32);
    int64_t result = v69; // 0x100003e6c
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003e74
        result = ___stack_chk_fail();
    }
    // 0x100003e78
    return result;
}

// Address range: 0x100003e8c - 0x100003efc
int64_t entry_point(void) {
    // 0x100003e8c
    int64_t v1; // 0x100003e8c
    if ((int32_t)v1 == 2) {
        // 0x100003ec8
        function_10000391c(function_100003810(), v1);
    } else {
        // 0x100003eb8
        _printf("Usage : %s <file containing graph data>", (char *)v1);
    }
    // 0x100003eec
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(void) {
    // 0x100003efc
    return ___stack_chk_fail();
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(struct _IO_FILE * stream) {
    // 0x100003f08
    return _fclose(stream);
}

// Address range: 0x100003f14 - 0x100003f20
struct _IO_FILE * function_100003f14(char * filename, char * modes) {
    // 0x100003f14
    return _fopen(filename, modes);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f20
    return _fscanf(stream, format);
}

// Address range: 0x100003f2c - 0x100003f38
int64_t * function_100003f2c(int32_t size) {
    // 0x100003f2c
    return _malloc(size);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h>

int main()
{
	int i;
	printf("<table style=\"text-align:center; border: 1px solid\"><th></th>"
		"<th>X</th><th>Y</th><th>Z</th>");
	for (i = 0; i < 4; i++) {
		printf("<tr><th>%d</th><td>%d</td><td>%d</td><td>%d</td></tr>", i,
			rand() % 10000, rand() % 10000, rand() % 10000);
	}
	printf("</table>");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003ef4(char * format, ...);
int32_t function_100003f00(void);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003e00 - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003e00
    _printf("<table style=\"text-align:center; border: 1px solid\"><th></th><th>X</th><th>Y</th><th>Z</th>");
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003e38
        _rand();
        _rand();
        _rand();
        int64_t v1; // 0x100003e00
        _printf("<tr><th>%d</th><td>%d</td><td>%d</td><td>%d</td></tr>", v1, v1, v1, v1);
    }
    // 0x100003ed8
    _printf("</table>");
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(void) {
    // 0x100003f00
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
