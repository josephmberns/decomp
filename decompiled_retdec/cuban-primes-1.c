//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039ac(void);
int64_t function_1000039e8(int64_t * a1);
int64_t function_100003a18(void);
void function_100003ed0(int32_t status);
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...);
void function_100003ee8(int64_t * ptr);
int64_t * function_100003ef4(int32_t size);
int32_t function_100003f00(char * format, ...);
int64_t * function_100003f0c(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x1000039ac - 0x1000039e8
int64_t function_1000039ac(void) {
    // 0x1000039ac
    int64_t v1; // 0x1000039ac
    *(int64_t *)(v1 + 8) = 0;
    *(int64_t *)(v1 + 16) = 10;
    int64_t result = (int64_t)_malloc(80); // 0x1000039d0
    *(int64_t *)v1 = result;
    return result;
}

// Address range: 0x1000039e8 - 0x100003a18
int64_t function_1000039e8(int64_t * a1) {
    // 0x1000039e8
    _free(a1);
    *a1 = 0;
    return &g1;
}

// Address range: 0x100003a18 - 0x100003b08
int64_t function_100003a18(void) {
    // 0x100003a18
    int64_t v1; // 0x100003a18
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x100003a30
    uint64_t v3 = *v2; // 0x100003a30
    int64_t * v4 = (int64_t *)(v1 + 16); // 0x100003a38
    uint64_t v5 = *v4; // 0x100003a38
    if (v3 < v5) {
        // 0x100003adc
        *v2 = v3 + 1;
        int64_t result; // 0x100003a18
        return result;
    }
    int64_t v6 = 3 * v5 / 2 + 1; // 0x100003a64
    int64_t * v7 = (int64_t *)v1; // 0x100003a7c
    int64_t * v8 = _realloc(v7, 8 * (int32_t)v6); // 0x100003a7c
    if (v8 == NULL) {
        int64_t v9 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003aa4
        _fprintf((struct _IO_FILE *)v9, "Failed to reallocate the prime array.");
        _exit(1);
        // UNREACHABLE
    }
    int64_t result2 = (int64_t)v8; // 0x100003a7c
    *v7 = result2;
    *v4 = v6;
    // 0x100003adc
    *v2 = *v2 + 1;
    return result2;
}

// Address range: 0x100003b08 - 0x100003ed0
int64_t entry_point(void) {
    // 0x100003b08
    function_1000039ac();
    function_100003a18();
    function_100003a18();
    _printf("The first %d cuban primes:\n", 5);
    int64_t v1 = 1; // 0x100003b08
    int64_t v2 = 5; // 0x100003b08
    int32_t v3 = 0; // 0x100003b08
    int64_t v4 = 1; // 0x100003bd0
    int64_t v5 = 0; // 0x100003bc4
    int32_t v6 = 1; // 0x100003b08
    int64_t v7; // bp-64, 0x100003b08
    int32_t v8; // 0x100003b08
    int32_t v9; // 0x100003b08
    int32_t v10; // 0x100003b08
    int64_t v11; // 0x100003b08
    int64_t v12; // 0x100003b08
    int32_t v13; // 0x100003c88
    int64_t v14; // 0x100003b08
    int64_t v15; // 0x100003b08
    while (true) {
      lab_0x100003bbc:
        // 0x100003bbc
        v9 = v6;
        int32_t v16 = v3;
        int64_t v17 = v2;
        v11 = v1;
        v5 += 6;
        v4 += v5;
        int64_t v18 = __asm_fcvtps(sqrt((float64_t)v4)); // 0x100003be0
        if (v12 != 0) {
            int64_t v19 = 0;
            int64_t v20 = *(int64_t *)(8 * v19 + v7); // 0x100003c10
            while (v20 - v18 == 0 || v20 - v18 < 0 != ((v20 - v18 ^ v20) & (v20 ^ v18)) < 0) {
                // 0x100003c2c
                v10 = v9;
                v8 = v16;
                v15 = v17;
                if (v4 % v20 == 0) {
                    goto lab_0x100003e84;
                }
                int64_t v21 = v19 + 1; // 0x100003c6c
                if (v21 >= v12) {
                    // break -> 0x100003c84
                    break;
                }
                v19 = v21;
                v20 = *(int64_t *)(8 * v19 + v7);
            }
        }
        // 0x100003c84
        v13 = v16 + 1;
        v14 = v17;
        if (v9 % 2 == 0) {
            goto lab_0x100003e2c;
        } else {
            int64_t v22 = *(int64_t *)(8 * v12 - 8 + v7) + 2;
            int64_t v23 = v4 - 2; // 0x100003cc0
            int64_t v24 = v22 - v23; // 0x100003cc4
            if (v24 == 0 || v24 < 0 != ((v24 ^ v22) & (v22 ^ v23)) < 0) {
                while (true) {
                    // 0x100003ce0
                    int64_t v25; // 0x100003b08
                    int64_t v26 = v25;
                    uint64_t v27; // 0x100003b08
                    if (v27 != 0) {
                        int64_t v28 = v7; // 0x100003cf8
                        int64_t v29 = 0; // 0x100003b08
                        int64_t v30 = v29;
                        int64_t v31 = *(int64_t *)(8 * v30 + v28); // 0x100003d00
                        while (v31 - v18 == 0 || v31 - v18 < 0 != ((v31 - v18 ^ v31) & (v31 ^ v18)) < 0) {
                            if (v26 % v31 == 0) {
                                goto lab_0x100003d88;
                            }
                            int64_t v32 = v30 + 1; // 0x100003d5c
                            v29 = v32;
                            if (v32 >= v27) {
                                // break -> 0x100003d74
                                break;
                            }
                            v30 = v29;
                            v31 = *(int64_t *)(8 * v30 + v28);
                        }
                    }
                    // 0x100003d74
                    function_100003a18();
                  lab_0x100003d88:;
                    int64_t v33 = v26 + 2;
                    int64_t v34 = v33 - v23; // 0x100003cc4
                    v25 = v33;
                    if (v34 != 0 && v34 < 0 == ((v34 ^ v33) & (v33 ^ v23)) < 0) {
                        // break -> 0x100003d98
                        break;
                    }
                }
            }
            // 0x100003d98
            function_100003a18();
            _printf("%11lld", v4);
            if (v13 % 10 == 0) {
                // 0x100003de0
                _printf("\n");
            }
            // 0x100003df0
            v14 = v4;
            if (v13 == 200) {
                // 0x100003e2c
                _printf("\nProgress to the %dth cuban prime: ", v4);
                v10 = 0;
                v8 = 200;
                v15 = v4;
                goto lab_0x100003e84;
            } else {
                goto lab_0x100003e2c;
            }
        }
    }
  lab_0x100003e94_2:;
    // 0x100003e94
    int64_t v35; // 0x100003b08
    _printf("\nThe %dth cuban prime is %lld\n", v35, v12);
    function_1000039e8(&v7);
    return 0;
  lab_0x100003e84:;
    int64_t v36 = v11 + 1; // 0x100003e88
    v1 = v36;
    v2 = v15;
    v3 = v8;
    v6 = v10;
    v35 = v15;
    if (v11 < 0x7ffffffffffffffe == (0x7ffffffffffffffd - v11 & v36) < 0) {
        // break -> 0x100003e94
        goto lab_0x100003e94_2;
    }
    goto lab_0x100003bbc;
  lab_0x100003e2c:;
    int64_t v37 = v14;
    v10 = v9;
    v8 = v13;
    v15 = v37;
    if (v13 % 2000 == 0) {
        // 0x100003e50
        _printf(".");
        v10 = v9;
        v8 = v13;
        v15 = v37;
        v35 = v37;
        if (v13 == 0x186a0) {
            // break -> 0x100003e94
            goto lab_0x100003e94_2;
        }
    }
    goto lab_0x100003e84;
}

// Address range: 0x100003ed0 - 0x100003edc
void function_100003ed0(int32_t status) {
    // 0x100003ed0
    _exit(status);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003edc
    return _fprintf(stream, format);
}

// Address range: 0x100003ee8 - 0x100003ef4
void function_100003ee8(int64_t * ptr) {
    // 0x100003ee8
    _free(ptr);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t * function_100003ef4(int32_t size) {
    // 0x100003ef4
    return _malloc(size);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * format, ...) {
    // 0x100003f00
    return _printf(format);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t * function_100003f0c(int64_t * ptr, int32_t size) {
    // 0x100003f0c
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

