//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f38(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int64_t function_100003f44(void);
int32_t function_100003f50(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003f5c(int64_t * ptr);
int32_t function_100003f68(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f74(int32_t size);
int32_t function_100003f80(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f8c(char * command, char * modes);
int64_t * function_100003f98(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
int32_t _pclose(struct _IO_FILE * a1);
struct _IO_FILE * _popen(char * a1, char * a2);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003f38
int64_t entry_point(void) {
    // 0x100003d8c
    int64_t v1; // 0x100003d8c
    int32_t v2 = v1; // 0x100003db0
    int64_t result = 1; // 0x100003dc4
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        struct _IO_FILE * v3 = _popen((char *)*(int64_t *)(v1 + 8), (char *)0x100003fa4); // 0x100003de8
        result = 1;
        if (v3 != NULL) {
            int64_t v4 = (int64_t)_malloc(256); // 0x100003e20
            int64_t v5; // bp-296, 0x100003d8c
            int32_t v6 = _fread(&v5, 1, 256, v3); // 0x100003e3c
            int32_t v7 = 0; // 0x100003e4c
            int32_t v8 = 0; // 0x100003e4c
            int64_t v9 = v4; // 0x100003e4c
            if (v6 != 0) {
                int64_t v10 = 256;
                int64_t v11 = v6;
                int64_t v12 = v7; // 0x100003e54
                int64_t v13 = v10; // 0x100003e6c
                int64_t v14 = v4; // 0x100003e6c
                int64_t * v15; // 0x100003e88
                if (v12 + v11 >= v10) {
                    // 0x100003e74
                    v13 = 2 * v10;
                    v15 = _realloc((int64_t *)v4, (int32_t)v13);
                    v14 = (int64_t)v15;
                }
                // 0x100003e94
                ___memmove_chk(v14 + v12, &v5, v11, -1);
                int32_t v16 = v7 + v6; // 0x100003ebc
                int32_t v17 = _fread(&v5, 1, 256, v3); // 0x100003e3c
                int32_t v18 = v17; // 0x100003e4c
                v7 = v16;
                v8 = v16;
                v9 = v14;
                while (v17 != 0) {
                    // 0x100003e54
                    v10 = v13;
                    int64_t v19 = v14;
                    v11 = v18;
                    v12 = v7;
                    v13 = v10;
                    v14 = v19;
                    if (v12 + v11 >= v10) {
                        // 0x100003e74
                        v13 = 2 * v10;
                        v15 = _realloc((int64_t *)v19, (int32_t)v13);
                        v14 = (int64_t)v15;
                    }
                    // 0x100003e94
                    ___memmove_chk(v14 + v12, &v5, v11, -1);
                    v16 = v7 + v18;
                    v17 = _fread(&v5, 1, 256, v3);
                    v18 = v17;
                    v7 = v16;
                    v8 = v16;
                    v9 = v14;
                }
            }
            int64_t v20 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003ed4
            int64_t * v21 = (int64_t *)v9; // 0x100003edc
            _fwrite(v21, 1, v8, (struct _IO_FILE *)v20);
            _free(v21);
            _pclose(v3);
            result = 0;
        }
    }
    int64_t v22 = *(int64_t *)0x100004010; // 0x100003f08
    if (*(int64_t *)v22 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003f20
        ___stack_chk_fail();
    }
    // 0x100003f24
    return result;
}

// Address range: 0x100003f38 - 0x100003f44
int64_t function_100003f38(int64_t a1, int64_t * a2, int64_t a3, int64_t a4) {
    // 0x100003f38
    return ___memmove_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t function_100003f44(void) {
    // 0x100003f44
    return ___stack_chk_fail();
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f50
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003f5c - 0x100003f68
void function_100003f5c(int64_t * ptr) {
    // 0x100003f5c
    _free(ptr);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f68
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f74 - 0x100003f80
int64_t * function_100003f74(int32_t size) {
    // 0x100003f74
    return _malloc(size);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(struct _IO_FILE * stream) {
    // 0x100003f80
    return _pclose(stream);
}

// Address range: 0x100003f8c - 0x100003f98
struct _IO_FILE * function_100003f8c(char * command, char * modes) {
    // 0x100003f8c
    return _popen(command, modes);
}

// Address range: 0x100003f98 - 0x100003fa4
int64_t * function_100003f98(int64_t * ptr, int32_t size) {
    // 0x100003f98
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

