//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003af4(void);
int64_t function_100003d80(int64_t a1);
int64_t function_100003dac(int64_t a1);
int64_t function_100003dd8(int64_t a1);
int64_t function_100003e04(int64_t a1);
int64_t function_100003e30(int64_t a1);
int64_t function_100003e5c(int64_t a1);
int64_t function_100003e88(void);
int64_t function_100003ea4(void);
int64_t function_100003ec0(int64_t a1);
int32_t function_100003ecc(struct _IO_FILE * stream);
int32_t function_100003ed8(struct _IO_FILE * stream);
int32_t function_100003ee4(struct _IO_FILE * stream, char * format, ...);
void function_100003ef0(int64_t * ptr);
int64_t * function_100003efc(int64_t * dest, int64_t * src, int32_t n);
struct _IO_FILE * function_100003f08(char ** bufloc, int32_t * sizeloc);
int32_t function_100003f14(char * format, ...);
int64_t function_100003f20(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
struct _IO_FILE * _open_memstream(char ** a1, int32_t * a2);
int32_t _printf(char * a1, ...);
int64_t _strtoumax(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000039e4 - 0x100003af4
int64_t entry_point(void) {
    // 0x1000039e4
    int64_t v1; // 0x1000039e4
    int32_t v2 = v1; // 0x1000039f4
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003a10
        _printf("usage: %s #seconds\n", (char *)v1);
        // 0x100003ae4
        return 1;
    }
    // 0x100003a38
    int64_t result; // 0x1000039e4
    if (_strtoumax((char *)*(int64_t *)(v1 + 8), NULL, 10) == 0) {
        // 0x100003a64
        _printf("Bad input: %s\n", NULL);
        _printf("usage: %s #seconds\n", NULL);
        result = 1;
    } else {
        // 0x100003aa8
        _printf("Number entered: %ju\n", 0);
        int64_t v3 = function_100003af4(); // 0x100003ac4
        _printf((char *)v3);
        _free((int64_t *)v3);
        result = 0;
    }
    // 0x100003ae4
    return result;
}

// Address range: 0x100003af4 - 0x100003d80
int64_t function_100003af4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b08
    int64_t v2; // bp-136, 0x100003af4
    int64_t v3 = &v2; // bp-64, 0x100003b1c
    int64_t v4; // bp-104, 0x100003af4
    _memcpy(&v4, (int64_t *)"d?", 40);
    int64_t v5; // 0x100003af4
    int64_t v6 = function_100003d80(v5); // 0x100003b54
    v2 = v6;
    int64_t v7 = v5 - function_100003dac(v6); // 0x100003b70
    int64_t v8 = function_100003e04(function_100003dd8(v7)); // 0x100003b90
    function_100003e5c(function_100003e30(v7 - v8));
    function_100003e88();
    function_100003ea4();
    int64_t v9; // bp-168, 0x100003af4
    int64_t v10; // bp-184, 0x100003af4
    struct _IO_FILE * v11 = _open_memstream((char **)&v9, (int32_t *)&v10); // 0x100003bf8
    int64_t result; // 0x100003af4
    int32_t v12; // 0x100003af4
    if (v11 == NULL) {
        int64_t v13 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c1c
        v12 = _fprintf((struct _IO_FILE *)v13, "Unable to allocate memory");
        result = 0;
    } else {
        char * v14 = (char *)v5;
        int32_t v15 = 1;
        for (int64_t i = 0; i < 5; i++) {
            int32_t v16 = v15;
            int64_t v17 = *(int64_t *)(8 * i + (int64_t)&v3); // 0x100003c60
            int32_t v18 = v16; // 0x100003c70
            if (*(int64_t *)v17 != 0) {
                if (v16 % 2 == 0) {
                    // 0x100003c84
                    _fprintf(v11, ", %ju %s", 40, v14);
                } else {
                    // 0x100003cc0
                    _fprintf(v11, "%ju %s", 40, v14);
                }
                // 0x100003cfc
                _fflush(v11);
                v18 = 0;
            }
            // 0x100003d10
            v15 = v18;
        }
        // 0x100003d20
        _fprintf(v11, (char *)0x100003f9e);
        v12 = _fclose(v11);
        result = v9;
    }
    // 0x100003d44
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d6c
        ___stack_chk_fail((int64_t)v12);
    }
    // 0x100003d70
    return result;
}

// Address range: 0x100003d80 - 0x100003dac
int64_t function_100003d80(int64_t a1) {
    // 0x100003d80
    return (uint64_t)function_100003dd8(a1) / 7;
}

// Address range: 0x100003dac - 0x100003dd8
int64_t function_100003dac(int64_t a1) {
    // 0x100003dac
    return function_100003e04(7 * a1);
}

// Address range: 0x100003dd8 - 0x100003e04
int64_t function_100003dd8(int64_t a1) {
    // 0x100003dd8
    return (uint64_t)function_100003e30(a1) / 24;
}

// Address range: 0x100003e04 - 0x100003e30
int64_t function_100003e04(int64_t a1) {
    // 0x100003e04
    return function_100003e5c(24 * a1);
}

// Address range: 0x100003e30 - 0x100003e5c
int64_t function_100003e30(int64_t a1) {
    // 0x100003e30
    return (uint64_t)function_100003e88() / 60;
}

// Address range: 0x100003e5c - 0x100003e88
int64_t function_100003e5c(int64_t a1) {
    // 0x100003e5c
    return function_100003ea4();
}

// Address range: 0x100003e88 - 0x100003ea4
int64_t function_100003e88(void) {
    // 0x100003e88
    int64_t v1; // 0x100003e88
    return (uint64_t)v1 / 60;
}

// Address range: 0x100003ea4 - 0x100003ec0
int64_t function_100003ea4(void) {
    // 0x100003ea4
    int64_t v1; // 0x100003ea4
    return 60 * v1;
}

// Address range: 0x100003ec0 - 0x100003ecc
int64_t function_100003ec0(int64_t a1) {
    // 0x100003ec0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ecc - 0x100003ed8
int32_t function_100003ecc(struct _IO_FILE * stream) {
    // 0x100003ecc
    return _fclose(stream);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(struct _IO_FILE * stream) {
    // 0x100003ed8
    return _fflush(stream);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ee4
    return _fprintf(stream, format);
}

// Address range: 0x100003ef0 - 0x100003efc
void function_100003ef0(int64_t * ptr) {
    // 0x100003ef0
    _free(ptr);
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003efc
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f08 - 0x100003f14
struct _IO_FILE * function_100003f08(char ** bufloc, int32_t * sizeloc) {
    // 0x100003f08
    return _open_memstream(bufloc, sizeloc);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * format, ...) {
    // 0x100003f14
    return _printf(format);
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f20
    return _strtoumax(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 19

