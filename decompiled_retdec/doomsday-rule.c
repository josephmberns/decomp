//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b04(void);
int64_t function_100003ba4(int32_t a1);
int64_t function_100003e8c(int64_t a1);
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ea4(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x104060204070104; // 0x100003eb0
int64_t g2 = 0x104060204070703; // 0x100003ebc
float128_t g3 = 6.30259672903973202393650155816711604e-169L; // 0x100003ec8
int64_t g4 = 0x10000000003ee4; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b04 - 0x100003ba4
int64_t function_100003b04(void) {
    // 0x100003b04
    int64_t v1; // 0x100003b04
    uint16_t v2 = (int16_t)v1;
    if (4 * v2 / 4 != v2) {
        // 0x100003b94
        return 0;
    }
    int64_t result = 1; // 0x100003b5c
    if (v2 % 100 == 0) {
        // 0x100003b64
        result = v2 % 400 == 0;
    }
    // 0x100003b94
    return result;
}

// Address range: 0x100003ba4 - 0x100003ce0
int64_t function_100003ba4(int32_t a1) {
    uint16_t v1 = (int16_t)a1;
    uint16_t v2 = v1 % 100;
    uint16_t v3 = v2 % 12;
    uint64_t v4 = function_100003b04(); // 0x100003c70
    int64_t v5 = v4 % 2 == 0 ? (int64_t)&g2 : (int64_t)&g1; // 0x100003c90
    int32_t v6; // 0x100003ba4
    unsigned char v7 = *(char *)(v5 + (int64_t)(v6 % 256 - 1)); // 0x100003c9c
    int64_t result = *(int64_t *)((int64_t)(8 * ((((5 * ((int32_t)(v1 / 100) - (int32_t)(4 * v1 / 400)) + 2) % 7 + (int32_t)(v2 / 12 + v3 + v3 / 4)) % 7 + 7 + (uint32_t)v6 % 256 - (int32_t)v7) % 7)) + (int64_t)&g4); // 0x100003cd0
    return result;
}

// Address range: 0x100003ce0 - 0x100003e8c
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cf8
    int64_t v2; // bp-144, 0x100003ce0
    _memcpy(&v2, (int64_t *)")?", 104);
    int64_t v3 = (float64_t)g3; // bp-176, 0x100003d40
    int32_t v4; // 0x100003e3c
    for (int64_t i = 0; i < 7; i++) {
        // 0x100003d68
        function_100003ba4(*(int32_t *)(4 * i + (int64_t)&v3));
        int64_t v5; // 0x100003ce0
        v4 = _printf("%s %d, %d %s on a %s.\n", ")?", 104, v5, (char *)v5, (char *)v5);
    }
    // 0x100003e54
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e74
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003e78
    return 0;
}

// Address range: 0x100003e8c - 0x100003e98
int64_t function_100003e8c(int64_t a1) {
    // 0x100003e8c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e98
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

