//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b44(void);
int64_t function_100003ed4(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003ee0(void);
int32_t function_100003eec(struct _IO_FILE * stream);
int32_t function_100003ef8(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003f04(char * command, char * modes);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(char * s, char * format, ...);
char * function_100003f28(char * haystack, char * needle);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(void);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
struct _IO_FILE * _popen(char * a1, char * a2);
int32_t _printf(char * a1, ...);
int32_t _sscanf(char * a1, char * a2, ...);
char * _strstr(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b44 - 0x100003da8
int64_t function_100003b44(void) {
    // 0x100003b44
    int64_t v1; // bp-1056, 0x100003b44
    ___sprintf_chk(&v1, 0, 1024, "ncal -m %d -M %d");
    struct _IO_FILE * v2 = _popen((char *)&v1, "r"); // 0x100003bb8
    int64_t result = 0xffffffff; // 0x100003bcc
    if (v2 != NULL) {
        int32_t v3 = _fread(&v1, 1, 1024, v2); // 0x100003bf4
        _fclose(v2);
        *(char *)((int64_t)v3 + (int64_t)&v1) = 0;
        char * v4 = _strstr((char *)&v1, "Fr"); // 0x100003c24
        int64_t v5; // 0x100003b44
        int64_t * v6 = (int64_t *)v5; // 0x100003c64
        int64_t * v7 = (int64_t *)v5; // 0x100003c64
        int64_t * v8 = (int64_t *)v5; // 0x100003c64
        result = 0;
        if (_sscanf(v4, "Fr %d %d %d %d %d", (int64_t *)1024, v2, v6, v7, v8) == 5) {
            char * v9 = _strstr((char *)&v1, "Sa"); // 0x100003c90
            result = 0;
            if (_sscanf(v9, "Sa %d %d %d %d %d", (int64_t *)1024, v2, v6, v7, v8) == 5) {
                char * v10 = _strstr((char *)&v1, "Su"); // 0x100003cfc
                result = _sscanf(v10, "Su %d %d %d %d %d", (int64_t *)1024, v2, v6, v7, v8) == 5;
            }
        }
    }
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d7c
    if (v11 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003d90
        ___stack_chk_fail();
    }
    // 0x100003d94
    return result;
}

// Address range: 0x100003da8 - 0x100003ed4
int64_t entry_point(void) {
    int32_t v1 = 1900;
    int32_t v2 = 0;
    uint32_t v3 = 1;
    int64_t v4 = v3; // 0x100003e00
    int32_t v5 = v2; // 0x100003e10
    int64_t v6; // 0x100003da8
    int32_t v7; // 0x100003e48
    if ((int32_t)function_100003b44() >= 1) {
        // 0x100003e1c
        _printf("%d-%02d ", v4, v6);
        v7 = v2 + 1;
        v5 = v7;
        if (v7 == 16 * v7 / 16) {
            // 0x100003e70
            _printf("\n");
            v5 = v7;
        }
    }
    int32_t v8 = v3 + 1; // 0x100003e88
    while (v3 == 11 || v3 < 11 != (10 - v3 & v8) < 0) {
        // 0x100003dfc
        v2 = v5;
        v3 = v8;
        v4 = v3;
        v5 = v2;
        if ((int32_t)function_100003b44() >= 1) {
            // 0x100003e1c
            _printf("%d-%02d ", v4, v6);
            v7 = v2 + 1;
            v5 = v7;
            if (v7 == 16 * v7 / 16) {
                // 0x100003e70
                _printf("\n");
                v5 = v7;
            }
        }
        // 0x100003e84
        v8 = v3 + 1;
    }
    int32_t v9 = v1 + 1; // 0x100003e9c
    while (v1 == 2099 || v1 < 2099 != (2098 - v1 & v9) < 0) {
        // 0x100003de8
        v1 = v9;
        v2 = v5;
        v3 = 1;
        v4 = v3;
        v5 = v2;
        if ((int32_t)function_100003b44() >= 1) {
            // 0x100003e1c
            _printf("%d-%02d ", v4, v6);
            v7 = v2 + 1;
            v5 = v7;
            if (v7 == 16 * v7 / 16) {
                // 0x100003e70
                _printf("\n");
                v5 = v7;
            }
        }
        // 0x100003e84
        v8 = v3 + 1;
        while (v3 == 11 || v3 < 11 != (10 - v3 & v8) < 0) {
            // 0x100003dfc
            v2 = v5;
            v3 = v8;
            v4 = v3;
            v5 = v2;
            if ((int32_t)function_100003b44() >= 1) {
                // 0x100003e1c
                _printf("%d-%02d ", v4, v6);
                v7 = v2 + 1;
                v5 = v7;
                if (v7 == 16 * v7 / 16) {
                    // 0x100003e70
                    _printf("\n");
                    v5 = v7;
                }
            }
            // 0x100003e84
            v8 = v3 + 1;
        }
        // 0x100003e98
        v9 = v1 + 1;
    }
    // 0x100003ea8
    _printf("\nTotal: %d\n", v4);
    return 0;
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t function_100003ed4(int64_t * a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003ed4
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t function_100003ee0(void) {
    // 0x100003ee0
    return ___stack_chk_fail();
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(struct _IO_FILE * stream) {
    // 0x100003eec
    return _fclose(stream);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ef8
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003f04 - 0x100003f10
struct _IO_FILE * function_100003f04(char * command, char * modes) {
    // 0x100003f04
    return _popen(command, modes);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * s, char * format, ...) {
    // 0x100003f1c
    return _sscanf(s, format);
}

// Address range: 0x100003f28 - 0x100003f34
char * function_100003f28(char * haystack, char * needle) {
    // 0x100003f28
    return _strstr(haystack, needle);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

