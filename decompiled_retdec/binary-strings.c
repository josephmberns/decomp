//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036c4(void);
int64_t function_100003734(void);
int64_t function_1000037b8(void);
int64_t function_1000037e8(void);
int64_t function_1000038ac(void);
int64_t function_10000390c(void);
int64_t function_10000399c(void);
int64_t function_100003a0c(void);
int64_t function_100003b50(void);
int64_t function_100003bf4(void);
int64_t function_100003c80(void);
int64_t function_100003e04(void);
int64_t function_100003f2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f38(int64_t * ptr);
int64_t * function_100003f44(int32_t size);
int32_t function_100003f50(int64_t * s1, int64_t * s2, int32_t n);
int32_t function_100003f5c(char * format, ...);
int64_t * function_100003f68(int64_t * ptr, int32_t size);
int32_t function_100003f74(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _memcmp(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000036c4 - 0x100003734
int64_t function_1000036c4(void) {
    // 0x1000036c4
    int64_t v1; // 0x1000036c4
    uint64_t v2 = v1;
    int64_t * v3 = _malloc(24); // 0x1000036d8
    int64_t result = (int64_t)v3; // 0x1000036d8
    int64_t v4 = v2 > 8 ? v2 : 8;
    *(int64_t *)(result + 8) = 0x100000000 * v4 >> 32;
    *(int64_t *)(result + 16) = (int64_t)_malloc((int32_t)v4);
    *v3 = 0;
    return result;
}

// Address range: 0x100003734 - 0x1000037b8
int64_t function_100003734(void) {
    // 0x100003734
    int64_t v1; // 0x100003734
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x100003748
    int64_t v3 = *v2;
    int32_t v4 = v3;
    int32_t v5 = 2 * v4; // 0x100003750
    uint64_t v6 = (int64_t)v5 - v3; // 0x100003760
    int32_t v7 = v6 == 1024 | v6 < 1024 ? v5 : v4 + 1024;
    int64_t * v8 = (int64_t *)(v1 + 16); // 0x10000378c
    int64_t result = (int64_t)_realloc((int64_t *)*v8, v7); // 0x100003794
    *v8 = result;
    *v2 = (int64_t)v7;
    return result;
}

// Address range: 0x1000037b8 - 0x1000037e8
int64_t function_1000037b8(void) {
    // 0x1000037b8
    int64_t v1; // 0x1000037b8
    _free((int64_t *)*(int64_t *)(v1 + 16));
    _free((int64_t *)v1);
    return &g1;
}

// Address range: 0x1000037e8 - 0x1000038ac
int64_t function_1000037e8(void) {
    // 0x1000037e8
    int64_t v1; // 0x1000037e8
    uint64_t v2 = v1;
    uint64_t v3 = 0x100000000 * v1 >> 32; // 0x100003808
    int64_t v4 = v3 == v2 | v3 < v2 ? v1 : v2;
    int64_t v5 = *(int64_t *)(v1 + 16); // 0x100003838
    uint64_t v6 = *(int64_t *)(v2 + 16); // 0x100003840
    int32_t v7 = _memcmp((int64_t *)v5, (int64_t *)v6, (int32_t)v4); // 0x100003848
    int32_t result = v7; // 0x100003858
    if (v7 == 0) {
        uint64_t v8 = (int64_t)v7; // 0x100003848
        result = v6 <= v8 != v6 != v8 ? -1 : 1;
    }
    // 0x10000389c
    return result;
}

// Address range: 0x1000038ac - 0x10000390c
int64_t function_1000038ac(void) {
    int64_t result = function_1000036c4(); // 0x1000038c4
    int64_t v1 = *(int64_t *)(result + 16); // 0x1000038d0
    int64_t v2; // 0x1000038ac
    *(int64_t *)result = ___memcpy_chk(v1, *(int64_t *)(v2 + 16), v1, -1);
    return result;
}

// Address range: 0x10000390c - 0x10000399c
int64_t function_10000390c(void) {
    // 0x10000390c
    int64_t result; // 0x10000390c
    int64_t v1; // 0x10000390c
    if (v1 == 0) {
        // 0x100003930
        result = function_1000036c4();
    } else {
        int64_t v2 = _strlen((char *)v1); // 0x100003944
        int64_t v3 = function_1000036c4(); // 0x100003954
        *(int64_t *)v3 = v2;
        ___memcpy_chk(*(int64_t *)(v3 + 16), v1, v2, -1);
        result = v3;
    }
    // 0x10000398c
    return result;
}

// Address range: 0x10000399c - 0x100003a0c
int64_t function_10000399c(void) {
    // 0x10000399c
    int64_t v1; // 0x10000399c
    uint64_t v2 = v1;
    int64_t result; // 0x10000399c
    if (v2 >= *(int64_t *)(v2 + 8)) {
        // 0x1000039d0
        result = function_100003734();
    }
    // 0x1000039dc
    *(int64_t *)v2 = result + 1;
    *(char *)(*(int64_t *)(v2 + 16) + result) = (char)v1;
    return result;
}

// Address range: 0x100003a0c - 0x100003b50
int64_t function_100003a0c(void) {
    // 0x100003a0c
    int64_t v1; // 0x100003a0c
    int32_t v2 = v1; // 0x100003a1c
    int32_t v3 = v1;
    int32_t v4 = (v2 < 0 ? v3 : 0) + v2;
    uint64_t v5 = (int64_t)v4; // 0x100003a88
    int64_t result = 0; // 0x100003a80
    if (v4 > -1 == v1 > v5) {
        int32_t v6 = v1; // 0x100003a20
        int32_t v7 = v6 == 0 ? v3 : v6;
        int32_t v8 = v7 - v4; // 0x100003ab4
        int32_t v9 = v8 < 0 == ((v8 ^ v7) & (v4 ^ v7)) < 0 ? v7 : v4 + 1;
        result = function_1000036c4();
        int64_t v10 = v9 - v4; // 0x100003b00
        *(int64_t *)result = v10;
        ___memcpy_chk(*(int64_t *)(result + 16), *(int64_t *)(v1 + 16) + v5, v10, -1);
    }
    // 0x100003b40
    return result;
}

// Address range: 0x100003b50 - 0x100003bf4
int64_t function_100003b50(void) {
    // 0x100003b50
    int64_t result; // 0x100003b50
    int64_t * v1 = (int64_t *)(result + 8); // 0x100003b6c
    int64_t v2; // 0x100003b50
    if (*v1 < 2 * result) {
        int64_t v3 = function_100003734(); // 0x100003b98
        v2 = v3;
        while (*v1 < v3 + result) {
            // 0x100003b94
            v3 = function_100003734();
            v2 = v3;
        }
    }
    int64_t v4 = *(int64_t *)(result + 16); // 0x100003ba4
    int64_t v5 = *(int64_t *)(result + 16); // 0x100003bb8
    *(int64_t *)result = ___memcpy_chk(v4 + v2, v5, v5, -1) + v5;
    return result;
}

// Address range: 0x100003bf4 - 0x100003c80
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t result; // 0x100003bf4
    int64_t * v1 = (int64_t *)(result + 8); // 0x100003c04
    int64_t * v2 = (int64_t *)(result + 8); // 0x100003c10
    *v1 = *v2;
    *v2 = *v1;
    int64_t * v3 = (int64_t *)(result + 16); // 0x100003c54
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003c60
    *v3 = *v4;
    *v4 = *v3;
    return result;
}

// Address range: 0x100003c80 - 0x100003e04
int64_t function_100003c80(void) {
    // 0x100003c80
    int64_t result; // 0x100003c80
    uint64_t v1 = result;
    int64_t v2 = function_1000036c4(); // 0x100003c9c
    int32_t v3 = 0; // 0x100003ccc
    int64_t v4 = v2; // 0x100003ccc
    if (v1 >= v2 != v1 != v2) {
        int64_t * v5 = (int64_t *)(result + 16); // 0x100003cd8
        int32_t v6 = 0;
        int64_t v7 = 0;
        int64_t v8 = *v5; // 0x100003cd8
        int64_t v9 = *(int64_t *)(v1 + 16); // 0x100003ce8
        int32_t v10; // 0x100003c80
        int32_t v11; // 0x100003d4c
        int64_t v12; // 0x100003c80
        int64_t v13; // 0x100003c80
        if (_memcmp((int64_t *)(v8 + v7), (int64_t *)v9, (int32_t)v9) == 0) {
            // 0x100003d30
            v11 = v6 + (int32_t)result;
            v10 = v11;
            v12 = function_100003b50();
            if (result == 0) {
                // 0x100003d68
                v10 = v11 + 1;
                v12 = function_10000399c();
                v13 = (int64_t)*(char *)(*v5 + (int64_t)v11);
            }
        } else {
            // 0x100003d08
            v10 = v6 + 1;
            v12 = function_10000399c();
            v13 = (int64_t)*(char *)(*v5 + v7);
        }
        int64_t v14 = v12;
        int32_t v15 = v10;
        int64_t v16 = v15; // 0x100003cac
        uint64_t v17 = v13 + v16; // 0x100003cb8
        v3 = v15;
        v4 = v14;
        while (v17 >= v14 != v17 != v14) {
            // 0x100003cd4
            v6 = v15;
            v7 = v16;
            v8 = *v5;
            v9 = *(int64_t *)(v1 + 16);
            if (_memcmp((int64_t *)(v8 + v7), (int64_t *)v9, (int32_t)v9) == 0) {
                // 0x100003d30
                v11 = v6 + (int32_t)result;
                v10 = v11;
                v12 = function_100003b50();
                if (result == 0) {
                    // 0x100003d68
                    v10 = v11 + 1;
                    v12 = function_10000399c();
                    v13 = (int64_t)*(char *)(*v5 + (int64_t)v11);
                }
            } else {
                // 0x100003d08
                v10 = v6 + 1;
                v12 = function_10000399c();
                v13 = (int64_t)*(char *)(*v5 + v7);
            }
            // 0x100003d94
            v14 = v12;
            v15 = v10;
            v16 = v15;
            v17 = v13 + v16;
            v3 = v15;
            v4 = v14;
        }
    }
    int32_t v18 = v3; // 0x100003db0
    if (v4 <= (int64_t)v3) {
        // 0x100003de0
        function_100003bf4();
        function_1000037b8();
        return result;
    }
    v18++;
    while (function_10000399c() > (int64_t)v18) {
        // 0x100003db8
        v18++;
    }
    // 0x100003de0
    function_100003bf4();
    function_1000037b8();
    return result;
}

// Address range: 0x100003e04 - 0x100003e84
int64_t function_100003e04(void) {
    // 0x100003e04
    int64_t v1; // 0x100003e04
    uint64_t v2 = v1;
    int64_t v3; // 0x100003e54
    int64_t result; // 0x100003e64
    if (v1 >= v2) {
        // 0x100003e48
        v3 = *(int64_t *)(v2 + 16);
        result = ___memcpy_chk(*(int64_t *)(v1 + 16), v3, v3, -1);
        *(int64_t *)v1 = v3;
        return result;
    }
    while (function_100003734() < v2) {
        // continue -> 0x100003e3c
    }
    // 0x100003e48
    v3 = *(int64_t *)(v2 + 16);
    result = ___memcpy_chk(*(int64_t *)(v1 + 16), v3, v3, -1);
    *(int64_t *)v1 = v3;
    return result;
}

// Address range: 0x100003e84 - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003e84
    function_10000390c();
    int64_t v1 = function_10000390c(); // 0x100003eb4
    int64_t v2 = function_10000390c(); // 0x100003ec4
    function_100003c80();
    _printf("%.*s\n", v2, (char *)v1);
    function_1000037b8();
    function_1000037b8();
    function_1000037b8();
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
int64_t function_100003f2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f2c
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int64_t * ptr) {
    // 0x100003f38
    _free(ptr);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int32_t size) {
    // 0x100003f44
    return _malloc(size);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int64_t * s1, int64_t * s2, int32_t n) {
    // 0x100003f50
    return _memcmp(s1, s2, n);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// Address range: 0x100003f68 - 0x100003f74
int64_t * function_100003f68(int64_t * ptr, int32_t size) {
    // 0x100003f68
    return _realloc(ptr, size);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * s) {
    // 0x100003f74
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 20

