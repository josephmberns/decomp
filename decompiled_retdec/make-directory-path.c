//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
char * function_100003f2c(char * filename);
void function_100003f38(int32_t status);
int32_t function_100003f44(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f50(char * path, int32_t mode);
int32_t function_100003f5c(char * file, struct stat * buf);
char * function_100003f68(char * s, char * delim);

// ------- Dynamically Linked Functions Without Header --------

char * _basename(char * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _mkdir(char * a1, int32_t a2);
int32_t _stat(char * a1, struct stat * a2);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003dc4 - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003dc4
    int64_t v1; // 0x100003dc4
    if ((int32_t)v1 != 2) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003df8
        _basename((char *)v1);
        _fprintf((struct _IO_FILE *)v2, "usage: %s <path>\n", (char *)v1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t * v3 = (int64_t *)(v1 + 8); // 0x100003e34
    char * v4 = (char *)*v3; // 0x100003e38
    char * v5 = _strtok(v4, "/"); // 0x100003e4c
    if (v5 == NULL) {
        // 0x100003f1c
        return 0;
    }
    // 0x100003e68
    if (v5 != v4) {
        // 0x100003e80
        *(char *)((int64_t)v5 - 1) = 47;
    }
    // 0x100003e94
    int64_t v6; // bp-192, 0x100003dc4
    int32_t v7; // 0x100003dc4
    if (_stat((char *)*v3, (struct stat *)&v6) == -1) {
        // 0x100003eb4
        _mkdir((char *)*v3, 0);
    } else {
        if ((v7 & 0xf000) != 0x4000) {
            // break -> 0x100003ee0
            break;
        }
    }
    char * v8 = _strtok(NULL, "/"); // 0x100003e4c
    while (v8 != NULL) {
        char * v9 = v8;
        if (v9 != NULL) {
            // 0x100003e80
            *(char *)((int64_t)v9 - 1) = 47;
        }
        // 0x100003e94
        if (_stat((char *)*v3, (struct stat *)&v6) == -1) {
            // 0x100003eb4
            _mkdir((char *)*v3, 0);
        } else {
            if ((v7 & 0xf000) != 0x4000) {
                // break -> 0x100003ee0
                break;
            }
        }
        // 0x100003f14
        v8 = _strtok(NULL, "/");
    }
    // 0x100003f1c
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
char * function_100003f2c(char * filename) {
    // 0x100003f2c
    return _basename(filename);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t status) {
    // 0x100003f38
    _exit(status);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f44
    return _fprintf(stream, format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * path, int32_t mode) {
    // 0x100003f50
    return _mkdir(path, mode);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * file, struct stat * buf) {
    // 0x100003f5c
    return _stat(file, buf);
}

// Address range: 0x100003f68 - 0x100003f74
char * function_100003f68(char * s, char * delim) {
    // 0x100003f68
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

