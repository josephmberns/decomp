//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b20(void);
int64_t function_100003b64(void);
int64_t function_100003ef8(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003f04(int64_t a1);
int32_t function_100003f10(char * nptr);
void function_100003f1c(int64_t * ptr);
float64_t function_100003f28(float64_t a1);
int64_t * function_100003f34(int32_t size);
int32_t function_100003f40(char * format, ...);
void function_100003f4c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003f58(char * s1, char * s2);

// --------------------- Global Variables ---------------------

float128_t g1 = 1.06099789548263615755569110743160442e-313L; // 0x100003f94
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _atoi(char * a1);
void _free(int64_t * a1);
float64_t _log10(float64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b20 - 0x100003b64
int64_t function_100003b20(void) {
    // 0x100003b20
    int64_t v1; // 0x100003b20
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003b64 - 0x100003d70
int64_t function_100003b64(void) {
    // 0x100003b64
    int64_t v1; // 0x100003b64
    int32_t v2 = v1; // 0x100003b70
    int32_t v3 = v2 < 1 == (v2 & -v2) < 0 ? 1 : v2;
    int32_t v4 = v2 < 1 == (v2 & -v2) < 0 ? v2 : 1;
    int32_t v5 = v2 < 1 == (v2 & -v2) < 0 ? v2 : 2 - v2;
    int64_t * v6 = _malloc(8 * v5); // 0x100003bd0
    int64_t v7 = (int64_t)v6; // 0x100003bd0
    int32_t v8 = v3 - v4; // 0x100003bec
    if (v8 == 0 || v8 < 0 != ((v8 ^ v3) & (v3 ^ v4)) < 0) {
        int32_t v9 = v3;
        int32_t v10 = -v9;
        float64_t v11; // 0x100003b64
        float64_t v12; // 0x100003b64
        int32_t v13; // 0x100003b64
        int64_t v14; // 0x100003b64
        int64_t v15; // 0x100003b64
        int128_t v16; // 0x100003c18
        if (v9 < 1 == (v9 & v10) < 0) {
            // 0x100003c10
            v16 = __asm_sshll(0.0f, 0);
            v15 = (float32_t)_log10((float64_t)(int64_t)v16);
            v12 = v11;
            v13 = (int32_t)v11 + 2;
        } else {
            // 0x100003c34
            int128_t v17; // 0x100003b64
            v14 = v17;
            v15 = v14;
            v12 = v11;
            v13 = 2;
            if (v9 != 0) {
                // 0x100003c54
                v15 = (float32_t)_log10((float64_t)v14);
                v12 = v10;
                v13 = 3 - v9;
            }
        }
        int64_t v18 = (int64_t)_malloc(v13); // 0x100003c80
        *(int64_t *)((int64_t)(8 * (v9 - v3)) + v7) = v18;
        ___sprintf_chk(v18, 0, -1, "%d");
        int32_t v19 = v9 + 1; // 0x100003cd8
        int32_t v20 = v19 - v4; // 0x100003bec
        while (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v19 ^ v4)) < 0) {
            float64_t v21 = v12;
            v9 = v19;
            v10 = -v9;
            if (v9 < 1 == (v9 & v10) < 0) {
                // 0x100003c10
                v16 = __asm_sshll(0.0f, 0);
                v15 = (float32_t)_log10((float64_t)(int64_t)v16);
                v12 = v21;
                v13 = (int32_t)v21 + 2;
            } else {
                // 0x100003c34
                v14 = v15;
                v15 = v14;
                v12 = v21;
                v13 = 2;
                if (v9 != 0) {
                    // 0x100003c54
                    v15 = (float32_t)_log10((float64_t)v14);
                    v12 = v10;
                    v13 = 3 - v9;
                }
            }
            // 0x100003c7c
            v18 = (int64_t)_malloc(v13);
            *(int64_t *)((int64_t)(8 * (v9 - v3)) + v7) = v18;
            ___sprintf_chk(v18, 0, -1, "%d");
            v19 = v9 + 1;
            v20 = v19 - v4;
        }
    }
    // 0x100003ce4
    _qsort(v6, v5, 8, (int32_t (*)(int64_t *, int64_t *))0x100003b20);
    int32_t v22 = -v5; // 0x100003d0c
    int32_t v23 = 0; // 0x100003d14
    if (v22 < 0 == (v5 & v22) < 0) {
        // 0x100003d5c
        _free(v6);
        return &g2;
    }
    int64_t v24 = v23; // 0x100003d20
    int64_t * v25 = (int64_t *)(8 * v24 + v7); // 0x100003d24
    *(int32_t *)(4 * v24 + v1) = _atoi((char *)*v25);
    _free((int64_t *)*v25);
    v23++;
    while (v23 - v5 < 0 != ((v23 - v5 ^ v23) & (v23 ^ v5)) < 0) {
        // 0x100003d1c
        v24 = v23;
        v25 = (int64_t *)(8 * v24 + v7);
        *(int32_t *)(4 * v24 + v1) = _atoi((char *)*v25);
        _free((int64_t *)*v25);
        v23++;
    }
    // 0x100003d5c
    _free(v6);
    return &g2;
}

// Address range: 0x100003d70 - 0x100003ef8
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d84
    float128_t v2 = g1; // bp-48, 0x100003d9c
    _printf("In lexicographical order:\n\n");
    for (int64_t i = 0; i < 5; i++) {
        int32_t v3 = *(int32_t *)(4 * i + (int64_t)&v2); // 0x100003dd8
        int32_t v4 = v3 < 1 == (v3 & -v3) < 0 ? v3 : 2 - v3;
        int64_t * v5 = _malloc(4 * v4); // 0x100003e14
        int64_t v6 = (int64_t)v5; // 0x100003e14
        function_100003b64();
        _printf("%3d: [", v6);
        int32_t v7 = -v4; // 0x100003e54
        if (v7 < 0 != (v4 & v7) < 0) {
            _printf("%d ", v6);
            int32_t v8 = 1; // 0x100003e90
            int32_t v9 = v8 - v4; // 0x100003e54
            int32_t v10 = v8; // 0x100003e5c
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v4)) < 0) {
                // 0x100003e64
                _printf("%d ", v6);
                v8 = v10 + 1;
                v9 = v8 - v4;
                v10 = v8;
            }
        }
        // 0x100003e9c
        _printf("\b]\n");
        _free(v5);
    }
    // 0x100003ec4
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003ee4
        ___stack_chk_fail((int64_t)&g2);
    }
    // 0x100003ee8
    return 0;
}

// Address range: 0x100003ef8 - 0x100003f04
int64_t function_100003ef8(int64_t a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003ef8
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f04 - 0x100003f10
int64_t function_100003f04(int64_t a1) {
    // 0x100003f04
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * nptr) {
    // 0x100003f10
    return _atoi(nptr);
}

// Address range: 0x100003f1c - 0x100003f28
void function_100003f1c(int64_t * ptr) {
    // 0x100003f1c
    _free(ptr);
}

// Address range: 0x100003f28 - 0x100003f34
float64_t function_100003f28(float64_t a1) {
    // 0x100003f28
    return _log10(a1);
}

// Address range: 0x100003f34 - 0x100003f40
int64_t * function_100003f34(int32_t size) {
    // 0x100003f34
    return _malloc(size);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _printf(format);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f4c
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * s1, char * s2) {
    // 0x100003f58
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

