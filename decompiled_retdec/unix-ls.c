//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd8(void);
int64_t function_100003ec4(int64_t a1);
int32_t function_100003ed0(struct __dirstream * dirp);
void function_100003edc(int64_t * ptr);
char * function_100003ee8(char * buf, int32_t size);
int64_t * function_100003ef4(int32_t size);
struct __dirstream * function_100003f00(char * name);
void function_100003f0c(char * s);
int32_t function_100003f18(char * format, ...);
void function_100003f24(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
struct dirent * function_100003f30(struct __dirstream * dirp);
int64_t * function_100003f3c(int64_t * ptr, int32_t size);
int32_t function_100003f48(char * s1, char * s2);
char * function_100003f54(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _closedir(struct __dirstream * a1);
void _free(int64_t * a1);
char * _getcwd(char * a1, int32_t a2);
int64_t * _malloc(int32_t a1);
struct __dirstream * _opendir(char * a1);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
struct dirent * _readdir(struct __dirstream * a1);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bd8 - 0x100003c0c
int64_t function_100003bd8(void) {
    // 0x100003bd8
    int64_t v1; // 0x100003bd8
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003c0c - 0x100003ec4
int64_t entry_point(void) {
    int64_t * v1 = _malloc(1024); // 0x100003c44
    int64_t result; // 0x100003c0c
    int64_t v2; // 0x100003c0c
    if (v1 == NULL) {
        // 0x100003c60
        _perror("malloc error:");
        result = 1;
        v2 = &g1;
    } else {
        // 0x100003c78
        int64_t v3; // bp-1056, 0x100003c0c
        if (_getcwd((char *)&v3, 1024) == NULL) {
            // 0x100003c94
            _perror("getcwd error:");
            result = 1;
            v2 = &g1;
        } else {
            struct __dirstream * v4 = _opendir((char *)&v3); // 0x100003cb0
            if (v4 == NULL) {
                // 0x100003ccc
                _perror("opendir error:");
                result = 1;
                v2 = &g1;
            } else {
                int64_t v5 = (int64_t)v1; // 0x100003c44
                struct dirent * v6 = _readdir(v4); // 0x100003cec
                struct dirent * v7 = v6; // 0x100003d00
                int64_t v8 = v5; // 0x100003d00
                int64_t v9 = 0; // 0x100003d00
                int32_t v10 = 128; // 0x100003d00
                int64_t v11 = 0; // 0x100003d00
                int64_t v12 = v5; // 0x100003d00
                if (v6 == NULL) {
                  lab_0x100003d98:;
                    int64_t v13 = 0x100000000 * v11 >> 32; // 0x100003d9c
                    int64_t * v14 = (int64_t *)v12; // 0x100003dac
                    _qsort(v14, (int32_t)v13, 8, (int32_t (*)(int64_t *, int64_t *))0x100003bd8);
                    int32_t v15 = v11; // 0x100003dbc
                    int32_t v16 = -v15;
                    if (v16 < 0 != (v16 & v15) < 0) {
                        int32_t v17 = 0; // 0x100003e1c
                        int64_t v18 = *(int64_t *)(8 * (int64_t)v17 + v12); // 0x100003dd8
                        if (*(char *)v18 != 46) {
                            // 0x100003df0
                            _printf("%s\n", (char *)v13);
                        }
                        // 0x100003e18
                        v17++;
                        int32_t v19 = v17 - v15; // 0x100003dc0
                        int32_t v20 = 0; // 0x100003dc8
                        while (v19 < 0 != ((v19 ^ v17) & (v17 ^ v15)) < 0) {
                            // 0x100003dd0
                            v18 = *(int64_t *)(8 * (int64_t)v17 + v12);
                            if (*(char *)v18 != 46) {
                                // 0x100003df0
                                _printf("%s\n", (char *)v13);
                            }
                            // 0x100003e18
                            v17++;
                            v19 = v17 - v15;
                            v20 = 0;
                        }
                        int64_t v21 = *(int64_t *)(8 * (int64_t)v20 + v12); // 0x100003e50
                        _free((int64_t *)v21);
                        int32_t v22 = v20 + 1; // 0x100003e60
                        int32_t v23 = v22 - v15; // 0x100003e38
                        v20 = v22;
                        while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v15)) < 0) {
                            // 0x100003e48
                            v21 = *(int64_t *)(8 * (int64_t)v20 + v12);
                            _free((int64_t *)v21);
                            v22 = v20 + 1;
                            v23 = v22 - v15;
                            v20 = v22;
                        }
                    }
                    // 0x100003e6c
                    _free(v14);
                    result = 0;
                    v2 = _closedir(v4);
                } else {
                    while (true) {
                        int32_t v24 = v10;
                        int64_t v25 = v8;
                        int32_t v26 = v9; // 0x100003d08
                        int32_t v27 = v26 - v24; // 0x100003d10
                        int32_t v28 = v24; // 0x100003d18
                        int64_t v29 = v25; // 0x100003d18
                        if (v27 < 0 == ((v27 ^ v26) & (v24 ^ v26)) < 0) {
                            int64_t * v30 = _realloc((int64_t *)v25, 16 * v24); // 0x100003d38
                            v28 = 2 * v24;
                            v29 = (int64_t)v30;
                            if (v30 == NULL) {
                                // break -> 0x100003d54
                                break;
                            }
                        }
                        char * v31 = _strdup((char *)((int64_t)v7 + 21)); // 0x100003d78
                        int64_t v32 = v9 + 1 & 0xffffffff;
                        *(int64_t *)(v29 + (0x100000000 * v9 >> 29)) = (int64_t)v31;
                        struct dirent * v33 = _readdir(v4); // 0x100003cec
                        v7 = v33;
                        v8 = v29;
                        v9 = v32;
                        v10 = v28;
                        v11 = v32;
                        v12 = v29;
                        if (v33 == NULL) {
                            goto lab_0x100003d98;
                        }
                    }
                    // 0x100003d54
                    _perror("realloc error:");
                    result = 1;
                    v2 = &g1;
                }
            }
        }
    }
    int64_t v34 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e98
    if (v34 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003eac
        ___stack_chk_fail(v2);
    }
    // 0x100003eb0
    return result;
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t function_100003ec4(int64_t a1) {
    // 0x100003ec4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(struct __dirstream * dirp) {
    // 0x100003ed0
    return _closedir(dirp);
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(int64_t * ptr) {
    // 0x100003edc
    _free(ptr);
}

// Address range: 0x100003ee8 - 0x100003ef4
char * function_100003ee8(char * buf, int32_t size) {
    // 0x100003ee8
    return _getcwd(buf, size);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t * function_100003ef4(int32_t size) {
    // 0x100003ef4
    return _malloc(size);
}

// Address range: 0x100003f00 - 0x100003f0c
struct __dirstream * function_100003f00(char * name) {
    // 0x100003f00
    return _opendir(name);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(char * s) {
    // 0x100003f0c
    _perror(s);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// Address range: 0x100003f24 - 0x100003f30
void function_100003f24(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f24
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f30 - 0x100003f3c
struct dirent * function_100003f30(struct __dirstream * dirp) {
    // 0x100003f30
    return _readdir(dirp);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * ptr, int32_t size) {
    // 0x100003f3c
    return _realloc(ptr, size);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * s1, char * s2) {
    // 0x100003f48
    return _strcmp(s1, s2);
}

// Address range: 0x100003f54 - 0x100003f60
char * function_100003f54(char * s) {
    // 0x100003f54
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

