//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000398c(void);
int64_t function_100003bc0(void);
int64_t * function_100003eac(int32_t size);
int32_t function_100003eb8(char * format, ...);
int32_t function_100003ec4(char * s);

// --------------------- Global Variables ---------------------

char * g1 = "\xcf\xfa\xed\xfe\f"; // 0x100008000
char * g2; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000398c - 0x100003bc0
int64_t function_10000398c(void) {
    // 0x10000398c
    int64_t v1; // 0x10000398c
    int32_t v2 = 0x1000000 * (int32_t)v1 >> 24; // 0x100003998
    int32_t v3 = v1; // 0x10000399c
    if (g2 == NULL) {
        int64_t * v4 = _malloc(24); // 0x1000039c4
        *(int64_t *)&g2 = (int64_t)v4;
        *(char *)v4 = (char)v2;
        *(int32_t *)((int64_t)g2 + 4) = 0;
        int64_t result = (int64_t)_malloc(16); // 0x1000039f0
        *(int64_t *)((int64_t)g2 + 8) = result;
        *(int32_t *)*(int64_t *)((int64_t)g2 + 8) = v3;
        *(int64_t *)(*(int64_t *)((int64_t)g2 + 8) + 8) = 0;
        *(int64_t *)((int64_t)g2 + 16) = 0;
        // 0x100003bb4
        return result;
    }
    // 0x100003a50
    char * v5; // bp-40, 0x10000398c
    *(int64_t *)&v5 = (int64_t)g2;
    char * v6; // 0x10000398c
    int32_t v7; // 0x10000398c
    int32_t v8; // 0x10000398c
    int64_t v9; // 0x10000398c
    int32_t * v10; // 0x100003a80
    int64_t * v11; // 0x10000398c
    int64_t * v12; // 0x100003ac8
    int64_t v13; // 0x100003ac8
    int64_t v14; // 0x10000398c
    if (v2 == (int32_t)*g2) {
        // 0x100003a6c
        *(char *)&g1 = 1;
        v10 = (int32_t *)((int64_t)g2 + 4);
        *v10 = *v10 + 1;
        v9 = (int64_t)v5;
        v9 += 8;
        v11 = (int64_t *)(v9 + 8);
        while (*v11 != 0) {
            // 0x100003a9c
            v9 += 8;
            v11 = (int64_t *)(v9 + 8);
        }
        // 0x100003af4
        v12 = _malloc(16);
        v13 = (int64_t)v12;
        *(int32_t *)v12 = v3;
        *(int64_t *)(v13 + 8) = 0;
        *v11 = v13;
        v6 = v5;
        v14 = v13;
        v8 = 1;
    } else {
        // 0x100003af4
        v7 = 0;
        v6 = g2;
        int64_t v15; // 0x10000398c
        v14 = v15;
        v8 = v7;
        if (v7 % 2 == 0) {
            // 0x100003b08
            v6 = g2;
            v14 = v15;
            v8 = v7;
            if (*(int64_t *)((int64_t)g2 + 16) == 0) {
                // break -> 0x100003b38
                break;
            }
        }
    }
    int64_t v16 = *(int64_t *)((int64_t)v6 + 16); // 0x100003b28
    char * v17 = (char *)v16; // 0x100003b2c
    v5 = v17;
    int32_t v18 = v8; // 0x100003a48
    int64_t v19 = v14; // 0x100003a48
    while (v16 != 0) {
        char * v20 = v17;
        if (v2 == (int32_t)*v20) {
            // 0x100003a6c
            *(char *)&g1 = 1;
            v10 = (int32_t *)((int64_t)v20 + 4);
            *v10 = *v10 + 1;
            v9 = (int64_t)v5;
            v9 += 8;
            v11 = (int64_t *)(v9 + 8);
            while (*v11 != 0) {
                // 0x100003a9c
                v9 += 8;
                v11 = (int64_t *)(v9 + 8);
            }
            // 0x100003af4
            v12 = _malloc(16);
            v13 = (int64_t)v12;
            *(int32_t *)v12 = v3;
            *(int64_t *)(v13 + 8) = 0;
            *v11 = v13;
            v6 = v5;
            v14 = v13;
            v8 = 1;
        } else {
            // 0x100003af4
            v7 = v8;
            int64_t v21 = v14;
            v6 = v20;
            v14 = v21;
            v8 = v7;
            if (v7 % 2 == 0) {
                // 0x100003b08
                v6 = v20;
                v14 = v21;
                v8 = v7;
                v18 = v7;
                v19 = v21;
                if (*(int64_t *)((int64_t)v20 + 16) == 0) {
                    // break -> 0x100003b38
                    break;
                }
            }
        }
        // 0x100003b24
        v16 = *(int64_t *)((int64_t)v6 + 16);
        v17 = (char *)v16;
        v5 = v17;
        v18 = v8;
        v19 = v14;
    }
    int64_t result2 = v19; // 0x100003b44
    if (v18 % 2 == 0) {
        int64_t * v22 = _malloc(24); // 0x100003b50
        int64_t v23 = (int64_t)v22; // 0x100003b50
        *(char *)v22 = (char)v2;
        *(int32_t *)(v23 + 4) = 0;
        int64_t * v24 = _malloc(16); // 0x100003b70
        result2 = (int64_t)v24;
        int64_t * v25 = (int64_t *)(v23 + 8); // 0x100003b78
        *v25 = result2;
        *(int32_t *)v24 = v3;
        *(int64_t *)(*v25 + 8) = 0;
        *(int64_t *)(v23 + 16) = 0;
        *(int64_t *)((int64_t)v5 + 16) = v23;
    }
    // 0x100003bb4
    return result2;
}

// Address range: 0x100003bc0 - 0x100003cc0
int64_t function_100003bc0(void) {
    // 0x100003bc0
    if (g2 == NULL) {
        // 0x100003ca8
        return _printf("\n");
    }
    int64_t v1 = (int64_t)g2;
    int64_t v2; // 0x100003bc0
    int64_t v3; // 0x100003bc0
    int64_t v4; // 0x100003bc0
    int64_t v5; // 0x100003bc0
    if (*(int32_t *)(v1 + 4) >= 1) {
        // 0x100003c0c
        _printf("\n'%c' (0x%x) at positions :", (char)v5, (int32_t)v5);
        v3 = *(int64_t *)(v1 + 8);
        v4 = v3;
        if (v3 != 0) {
            _printf("%3d", v5);
            v2 = *(int64_t *)(v4 + 8);
            v4 = v2;
            while (v2 != 0) {
                // 0x100003c60
                _printf("%3d", v5);
                v2 = *(int64_t *)(v4 + 8);
                v4 = v2;
            }
        }
    }
    int64_t v6 = *(int64_t *)(v1 + 16); // 0x100003c9c
    while (v6 != 0) {
        // 0x100003bf4
        v1 = v6;
        if (*(int32_t *)(v1 + 4) >= 1) {
            // 0x100003c0c
            _printf("\n'%c' (0x%x) at positions :", (char)v5, (int32_t)v5);
            v3 = *(int64_t *)(v1 + 8);
            v4 = v3;
            if (v3 != 0) {
                _printf("%3d", v5);
                v2 = *(int64_t *)(v4 + 8);
                v4 = v2;
                while (v2 != 0) {
                    // 0x100003c60
                    _printf("%3d", v5);
                    v2 = *(int64_t *)(v4 + 8);
                    v4 = v2;
                }
            }
        }
        // 0x100003c98
        v6 = *(int64_t *)(v1 + 16);
    }
    // 0x100003ca8
    return _printf("\n");
}

// Address range: 0x100003cc0 - 0x100003eac
int64_t entry_point(void) {
    // 0x100003cc0
    int64_t v1; // 0x100003cc0
    int32_t v2 = v1; // 0x100003cd0
    int32_t v3 = v2 - 2; // 0x100003cdc
    if (v3 != 0 && v3 < 0 == (1 - v2 & v2) < 0) {
        // 0x100003cec
        _printf("Usage : %s <Test string>\n", (char *)v1);
        // 0x100003e9c
        return 0;
    }
    if (v2 == 1) {
        // 0x100003d40
        _printf("\"%s\" - Length %d - Contains only unique characters.\n", (char *)v1, v1);
        // 0x100003e9c
        return 0;
    }
    int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003d28
    if (_strlen((char *)*v4) == 1) {
        // 0x100003d40
        _printf("\"%s\" - Length %d - Contains only unique characters.\n", (char *)v1, v1);
        // 0x100003e9c
        return 0;
    }
    int32_t v5 = _strlen((char *)*v4); // 0x100003dbc
    int32_t v6 = -v5; // 0x100003dd8
    int64_t v7; // 0x100003cc0
    if (v6 < 0 != (v5 & v6) < 0) {
        int64_t v8 = 0;
        function_10000398c();
        int64_t v9 = v8 + 1; // 0x100003e08
        int32_t v10 = v9; // 0x100003dd0
        int32_t v11 = v10 - v5; // 0x100003dd8
        v7 = v8;
        while (v11 < 0 != ((v11 ^ v10) & (v5 ^ v10)) < 0) {
            // 0x100003de8
            v8 = v9 & 0xffffffff;
            function_10000398c();
            v9 = v8 + 1;
            v10 = v9;
            v11 = v10 - v5;
            v7 = v8;
        }
    }
    // 0x100003e14
    _printf("\"%s\" - Length %d - %s", (char *)v7, v1, (char *)v1);
    if (*(char *)&g1 % 2 != 0) {
        // 0x100003e8c
        function_100003bc0();
    }
    // 0x100003e9c
    return 0;
}

// Address range: 0x100003eac - 0x100003eb8
int64_t * function_100003eac(int32_t size) {
    // 0x100003eac
    return _malloc(size);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(char * format, ...) {
    // 0x100003eb8
    return _printf(format);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(char * s) {
    // 0x100003ec4
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

