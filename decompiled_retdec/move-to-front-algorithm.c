//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000037f4(void);
int64_t function_100003890(void);
int64_t function_1000039b8(void);
int64_t function_100003a90(void);
int64_t function_100003d98(int64_t a1);
int64_t function_100003da4(int64_t a1, int64_t a2);
int64_t function_100003db0(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
void function_100003dbc(int64_t * s, int32_t n);
void function_100003dc8(int64_t * ptr);
int64_t * function_100003dd4(int32_t size);
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003dec(char * format, ...);
char * function_100003df8(char * s, int32_t c);
int32_t function_100003e04(char * s1, char * s2);
int32_t function_100003e10(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2);
int64_t ___strncpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
char * _strchr(char * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000037f4 - 0x100003890
int64_t function_1000037f4(void) {
    // 0x1000037f4
    int64_t v1; // 0x1000037f4
    char * v2 = (char *)v1; // 0x100003810
    int64_t * v3 = _malloc(_strlen(v2) + 1); // 0x100003818
    int64_t v4 = (int64_t)v3; // 0x100003818
    ___strcpy_chk(v4, v1);
    int64_t v5 = (int64_t)_strchr((char *)v3, 0x1000000 * (int32_t)v1 >> 24) - v4; // 0x100003850
    ___strncpy_chk(v1 + 1, v4, (int32_t)v5, -1);
    *v2 = (char)v1;
    _free(v3);
    return v5 & 0xffffffff;
}

// Address range: 0x100003890 - 0x1000039b8
int64_t function_100003890(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000038a4
    int64_t v2; // 0x100003890
    int32_t v3 = v2; // 0x1000038b0
    int64_t v4 = (float64_t)*(float128_t *)"abcdefghijklmnopqrstuvwxyz"; // bp-64, 0x1000038c8
    int32_t v5 = -v3; // 0x1000038e4
    int64_t v6; // 0x100003890
    if (v5 < 0 != (v5 & v3) < 0) {
        int32_t v7 = 0; // 0x10000396c
        int64_t v8 = v7; // 0x1000038f8
        int32_t * v9 = (int32_t *)(4 * v8 + v2); // 0x1000038fc
        char v10 = *(char *)((int64_t)*v9 + (int64_t)&v4); // 0x10000390c
        int64_t v11 = function_1000037f4(); // 0x100003918
        int64_t v12 = v11; // 0x100003938
        if (*v9 != (int32_t)v11) {
            // 0x100003940
            v12 = _printf("there is an error");
        }
        // 0x100003950
        *(char *)(v2 + v8) = v10;
        v7++;
        int32_t v13 = v7 - v3; // 0x1000038e4
        v6 = v12;
        while (v13 < 0 != ((v13 ^ v7) & (v7 ^ v3)) < 0) {
            // 0x1000038f4
            v8 = v7;
            v9 = (int32_t *)(4 * v8 + v2);
            v10 = *(char *)((int64_t)*v9 + (int64_t)&v4);
            v11 = function_1000037f4();
            v12 = v11;
            if (*v9 != (int32_t)v11) {
                // 0x100003940
                v12 = _printf("there is an error");
            }
            // 0x100003950
            *(char *)(v2 + v8) = v10;
            v7++;
            v13 = v7 - v3;
            v6 = v12;
        }
    }
    // 0x100003978
    *(char *)((0x100000000 * v2 >> 32) + v2) = 0;
    int64_t result = v6; // 0x1000039a0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x1000039a8
        result = ___stack_chk_fail(v6);
    }
    // 0x1000039ac
    return result;
}

// Address range: 0x1000039b8 - 0x100003a90
int64_t function_1000039b8(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000039cc
    int64_t v2; // 0x1000039b8
    int32_t v3 = v2; // 0x1000039d8
    int32_t v4 = -v3; // 0x100003a10
    int64_t result; // 0x1000039b8
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a84
        return result;
    }
    int32_t v5 = 0; // 0x100003a18
    int64_t v6 = function_1000037f4(); // 0x100003a3c
    *(int32_t *)(4 * (int64_t)v5 + v2) = (int32_t)v6;
    v5++;
    while (v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x100003a20
        v6 = function_1000037f4();
        *(int32_t *)(4 * (int64_t)v5 + v2) = (int32_t)v6;
        v5++;
    }
    // 0x100003a60
    result = v6;
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003a80
        result = ___stack_chk_fail(v6);
    }
    // 0x100003a84
    return result;
}

// Address range: 0x100003a90 - 0x100003bc8
int64_t function_100003a90(void) {
    // 0x100003a90
    int64_t v1; // 0x100003a90
    int32_t v2 = v1; // 0x100003aa0
    int64_t * v3 = _malloc(4 * v2); // 0x100003ab4
    int64_t * v4 = _malloc(v2); // 0x100003ac8
    function_1000039b8();
    int32_t v5 = -v2; // 0x100003af8
    int32_t v6 = 0; // 0x100003b08
    int32_t v7 = 0; // 0x100003b08
    if (v5 < 0 != (v5 & v2) < 0) {
        int64_t v8 = 4 * (int64_t)v6; // 0x100003b18
        v7 = v6;
        while (*(int32_t *)(v8 + v1) == *(int32_t *)(v8 + (int64_t)v3)) {
            // 0x100003b44
            v6++;
            int32_t v9 = v6 - v2; // 0x100003af8
            v7 = v6;
            if (v9 < 0 == ((v9 ^ v6) & (v6 ^ v2)) < 0) {
                // break -> 0x100003b54
                break;
            }
            v8 = 4 * (int64_t)v6;
            v7 = v6;
        }
    }
    // 0x100003b54
    function_100003890();
    int32_t v10 = _strcmp((char *)v1, (char *)v4); // 0x100003b8c
    _free(v4);
    _free(v3);
    return v7 == v2 == v10 == 0;
}

// Address range: 0x100003bc8 - 0x100003d98
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003be0
    int64_t v2; // bp-332, 0x100003bc8
    _memcpy(&v2, (int64_t *)"broood", 300);
    int64_t v3; // bp-732, 0x100003bc8
    _bzero(&v3, 400);
    int32_t v4; // 0x100003bc8
    for (int64_t i = 0; i < 3; i++) {
        uint32_t v5 = _strlen((char *)(100 * i + (int64_t)&v2)); // 0x100003c44
        int64_t v6 = v5; // 0x100003c64
        function_1000039b8();
        _printf("%s : [", (char *)v6);
        int32_t v7 = -v5; // 0x100003ca8
        if (v7 < 0 != (v5 & v7) < 0) {
            _printf("%d ", v6);
            int32_t v8 = 1; // 0x100003ce4
            int32_t v9 = v8 - v5; // 0x100003ca8
            int32_t v10 = v8; // 0x100003cb0
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v5)) < 0) {
                // 0x100003cb8
                _printf("%d ", v6);
                v8 = v10 + 1;
                v9 = v8 - v5;
                v10 = v8;
            }
        }
        // 0x100003cf0
        _printf("]\n");
        if ((int32_t)function_100003a90() == 0) {
            // 0x100003d3c
            v4 = _printf("Incorrect :(\n");
        } else {
            // 0x100003d2c
            v4 = _printf("Correct :)\n");
        }
    }
    // 0x100003d60
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d80
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003d84
    return 0;
}

// Address range: 0x100003d98 - 0x100003da4
int64_t function_100003d98(int64_t a1) {
    // 0x100003d98
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003da4 - 0x100003db0
int64_t function_100003da4(int64_t a1, int64_t a2) {
    // 0x100003da4
    return ___strcpy_chk(a1, a2);
}

// Address range: 0x100003db0 - 0x100003dbc
int64_t function_100003db0(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003db0
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003dbc - 0x100003dc8
void function_100003dbc(int64_t * s, int32_t n) {
    // 0x100003dbc
    _bzero(s, n);
}

// Address range: 0x100003dc8 - 0x100003dd4
void function_100003dc8(int64_t * ptr) {
    // 0x100003dc8
    _free(ptr);
}

// Address range: 0x100003dd4 - 0x100003de0
int64_t * function_100003dd4(int32_t size) {
    // 0x100003dd4
    return _malloc(size);
}

// Address range: 0x100003de0 - 0x100003dec
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003de0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dec - 0x100003df8
int32_t function_100003dec(char * format, ...) {
    // 0x100003dec
    return _printf(format);
}

// Address range: 0x100003df8 - 0x100003e04
char * function_100003df8(char * s, int32_t c) {
    // 0x100003df8
    return _strchr(s, c);
}

// Address range: 0x100003e04 - 0x100003e10
int32_t function_100003e04(char * s1, char * s2) {
    // 0x100003e04
    return _strcmp(s1, s2);
}

// Address range: 0x100003e10 - 0x100003e1c
int32_t function_100003e10(char * s) {
    // 0x100003e10
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

