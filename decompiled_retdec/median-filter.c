//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003374(void);
int64_t function_100003444(void);
int64_t function_100003544(void);
int64_t function_100003620(void);
int64_t function_100003794(void);
int64_t function_100003908(void);
int64_t function_100003a7c(void);
int64_t function_100003b34(void);
int64_t function_100003bc8(void);
int64_t function_100003c38(void);
int64_t function_100003ea4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003eb0(char * nptr);
int32_t function_100003ebc(struct _IO_FILE * stream);
int32_t function_100003ec8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ed4(char * filename, char * modes);
int32_t function_100003ee0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003eec(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003ef8(int64_t * ptr);
int32_t function_100003f04(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f10(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_100003f1c(int32_t c);
int64_t * function_100003f28(int32_t size);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _atoi(char * a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003374 - 0x100003444
int64_t function_100003374(void) {
    // 0x100003374
    int64_t v1; // 0x100003374
    int64_t v2 = v1;
    struct _IO_FILE * v3 = _fopen((char *)v1, "w"); // 0x100003394
    int64_t result = 0; // 0x1000033a8
    if (v3 != NULL) {
        // 0x1000033b8
        _fprintf(v3, "P6\n%d %d\n255\n", v1, v1);
        int64_t v4 = *(int64_t *)*(int64_t *)(v2 + 8); // 0x1000033f4
        _fwrite((int64_t *)v4, 1, 3 * (int32_t)v2 * *(int32_t *)(v2 + 4), v3);
        _fclose(v3);
        result = 1;
    }
    // 0x100003434
    return result;
}

// Address range: 0x100003444 - 0x100003544
int64_t function_100003444(void) {
    // 0x100003444
    int64_t v1; // 0x100003444
    int32_t v2 = v1; // 0x100003454
    int64_t v3 = 3 * (0x100000000 * v1 >> 32); // 0x10000346c
    int64_t v4 = 0x100000000 * v1;
    int64_t * v5 = _malloc((int32_t)(8 * v1 + 16 + v3 * (v4 >> 32))); // 0x10000347c
    int64_t result = (int64_t)v5; // 0x10000347c
    *(int32_t *)v5 = (int32_t)v1;
    *(int32_t *)(result + 4) = v2;
    int64_t v6 = result + 16; // 0x1000034a4
    int64_t * v7 = (int64_t *)(result + 8); // 0x1000034a8
    *v7 = v6;
    *(int64_t *)v6 = v6 + (v4 >> 29);
    int32_t v8 = 1 - v2; // 0x1000034dc
    if (v8 < 0 == (v8 & v2) < 0) {
        // 0x100003534
        return result;
    }
    int32_t v9 = 1; // 0x1000034e4
    int64_t v10 = *v7; // 0x1000034f0
    int64_t v11 = *(int64_t *)(v10 + (int64_t)(8 * v9 - 8)); // 0x1000034fc
    *(int64_t *)(8 * (int64_t)v9 + v10) = v11 + v3;
    v9++;
    while (v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
        // 0x1000034ec
        v10 = *v7;
        v11 = *(int64_t *)(v10 + (int64_t)(8 * v9 - 8));
        *(int64_t *)(8 * (int64_t)v9 + v10) = v11 + v3;
        v9++;
    }
    // 0x100003534
    return result;
}

// Address range: 0x100003544 - 0x100003620
int64_t function_100003544(void) {
    // 0x100003544
    int64_t v1; // 0x100003544
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003550
    int32_t result; // 0x100003544
    if (_fscanf(v2, "%d ", (int64_t *)v1) != 0) {
        // 0x100003610
        return result;
    }
    while (true) {
        // 0x100003584
        if (_fgetc(v2) != 35) {
            // break -> 0x100003610
            break;
        }
        int32_t v3; // 0x1000035a8
        while (true) {
          lab_0x1000035a4:
            // 0x1000035a4
            v3 = _fgetc(v2);
            switch (v3) {
                case -1: {
                    goto lab_0x100003558;
                }
                case 10: {
                    goto lab_0x100003558;
                }
                default: {
                    goto lab_0x1000035a4;
                }
            }
        }
      lab_0x100003558:
        // 0x100003558
        result = v3;
        if (_fscanf(v2, "%d ", (int64_t *)v1) != 0) {
            return result;
        }
    }
    // 0x100003610
    return 0;
}

// Address range: 0x100003620 - 0x100003794
int64_t function_100003620(void) {
    // 0x100003620
    int64_t v1; // 0x100003620
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x10000363c
    if (v2 == NULL) {
        // 0x100003784
        return 0;
    }
    // 0x100003664
    if (_fgetc(v2) != 80 || _fgetc(v2) != 54 || _isspace(_fgetc(v2)) == 0) {
        // 0x10000376c
        _fclose(v2);
        // 0x100003784
        return 0;
    }
    int32_t v3 = function_100003544(); // 0x1000036bc
    int32_t v4 = function_100003544(); // 0x1000036c8
    int64_t result = 0; // 0x1000036e4
    if (!((v3 == 0 | v4 == 0 | (int32_t)function_100003544() == 0))) {
        // 0x100003718
        result = function_100003444();
        int64_t v5 = *(int64_t *)*(int64_t *)(result + 8); // 0x100003730
        _fread((int64_t *)v5, 1, 3 * v3 * v4, v2);
    }
    // 0x10000376c
    _fclose(v2);
    // 0x100003784
    return result;
}

// Address range: 0x100003794 - 0x100003908
int64_t function_100003794(void) {
    // 0x100003794
    int64_t result; // 0x100003794
    int32_t v1 = result; // 0x1000037a0
    if (v1 < 0) {
        // 0x100003900
        return result;
    }
    int32_t v2 = v1 - (int32_t)result; // 0x1000037cc
    if (v2 < 0 == ((v2 ^ v1) & (int32_t)(result ^ result)) < 0) {
        // 0x100003900
        return result;
    }
    int32_t v3 = result; // 0x10000379c
    int32_t v4 = result; // 0x1000037a4
    int32_t v5 = v3 - v4; // 0x1000037e8
    int32_t v6 = v3 + v4; // 0x100003800
    int32_t v7 = v5 - v6; // 0x100003804
    if (v7 != 0 && v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0) {
        // 0x100003900
        return result;
    }
    int32_t * v8 = (int32_t *)(result + 3072);
    int32_t v9 = v5;
    int32_t v10 = *(int32_t *)(result + 4); // 0x100003824
    while (v9 - v10 < 0 != ((v9 - v10 ^ v9) & (v10 ^ v9)) < 0) {
        if (v9 >= 0) {
            int64_t v11 = *(int64_t *)(*(int64_t *)(result + 8) + 8 * (int64_t)v9); // 0x100003868
            int64_t v12 = v11 + 3 * (0x100000000 * result >> 32); // 0x100003878
            int32_t * v13 = (int32_t *)(4 * (int64_t)*(char *)v12 + result); // 0x100003890
            *v13 = *v13 - 1;
            int32_t * v14 = (int32_t *)(result + 1024 + 4 * (int64_t)*(char *)(v12 + 1)); // 0x1000038b0
            *v14 = *v14 - 1;
            int32_t * v15 = (int32_t *)(result + 2048 + 4 * (int64_t)*(char *)(v12 + 2)); // 0x1000038d0
            *v15 = *v15 - 1;
            *v8 = *v8 - 1;
        }
        int32_t v16 = v9 + 1; // 0x1000038f4
        int32_t v17 = v16 - v6; // 0x100003804
        if (v17 != 0 && v17 < 0 == ((v17 ^ v16) & (v16 ^ v6)) < 0) {
            // break -> 0x100003900
            break;
        }
        v9 = v16;
        v10 = *(int32_t *)(result + 4);
    }
    // 0x100003900
    return result;
}

// Address range: 0x100003908 - 0x100003a7c
int64_t function_100003908(void) {
    // 0x100003908
    int64_t result; // 0x100003908
    int32_t v1 = result; // 0x100003914
    if (v1 < 0) {
        // 0x100003a74
        return result;
    }
    int32_t v2 = v1 - (int32_t)result; // 0x100003940
    if (v2 < 0 == ((v2 ^ v1) & (int32_t)(result ^ result)) < 0) {
        // 0x100003a74
        return result;
    }
    int32_t v3 = result; // 0x100003910
    int32_t v4 = result; // 0x100003918
    int32_t v5 = v3 - v4; // 0x10000395c
    int32_t v6 = v3 + v4; // 0x100003974
    int32_t v7 = v5 - v6; // 0x100003978
    if (v7 != 0 && v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0) {
        // 0x100003a74
        return result;
    }
    int32_t * v8 = (int32_t *)(result + 3072);
    int32_t v9 = v5;
    int32_t v10 = *(int32_t *)(result + 4); // 0x100003998
    while (v9 - v10 < 0 != ((v9 - v10 ^ v9) & (v10 ^ v9)) < 0) {
        if (v9 >= 0) {
            int64_t v11 = *(int64_t *)(*(int64_t *)(result + 8) + 8 * (int64_t)v9); // 0x1000039dc
            int64_t v12 = v11 + 3 * (0x100000000 * result >> 32); // 0x1000039ec
            int32_t * v13 = (int32_t *)(4 * (int64_t)*(char *)v12 + result); // 0x100003a04
            *v13 = *v13 + 1;
            int32_t * v14 = (int32_t *)(result + 1024 + 4 * (int64_t)*(char *)(v12 + 1)); // 0x100003a24
            *v14 = *v14 + 1;
            int32_t * v15 = (int32_t *)(result + 2048 + 4 * (int64_t)*(char *)(v12 + 2)); // 0x100003a44
            *v15 = *v15 + 1;
            *v8 = *v8 + 1;
        }
        int32_t v16 = v9 + 1; // 0x100003a68
        int32_t v17 = v16 - v6; // 0x100003978
        if (v17 != 0 && v17 < 0 == ((v17 ^ v16) & (v16 ^ v6)) < 0) {
            // break -> 0x100003a74
            break;
        }
        v9 = v16;
        v10 = *(int32_t *)(result + 4);
    }
    // 0x100003a74
    return result;
}

// Address range: 0x100003a7c - 0x100003b34
int64_t function_100003a7c(void) {
    // 0x100003a7c
    int64_t v1; // 0x100003a7c
    int32_t v2 = v1; // 0x100003a90
    int64_t result = ___memset_chk(v1, 0, 3076, -1); // 0x100003aa8
    int32_t v3 = -v2; // 0x100003abc
    int64_t result2 = result; // 0x100003acc
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003b28
        return result;
    }
    int32_t v4 = 0; // 0x100003b1c
    int32_t v5 = result2; // 0x100003adc
    while (v4 - v5 < 0 != ((v4 - v5 ^ v4) & (v4 ^ v5)) < 0) {
        // 0x100003afc
        result2 = function_100003908();
        v4++;
        int32_t v6 = v4 - v2; // 0x100003abc
        if (v6 < 0 == ((v6 ^ v4) & (v4 ^ v2)) < 0) {
            // break -> 0x100003b28
            break;
        }
        v5 = result2;
    }
    // 0x100003b28
    return result2;
}

// Address range: 0x100003b34 - 0x100003bc8
int64_t function_100003b34(void) {
    // 0x100003b34
    int64_t v1; // 0x100003b34
    int32_t v2 = (int32_t)v1 / 2; // 0x100003b84
    int32_t v3 = 0;
    v2 -= *(int32_t *)(4 * (int64_t)v3 + v1);
    int32_t result = v3; // 0x100003ba0
    while (v2 >= 1) {
        int32_t v4 = v3 + 1; // 0x100003bb0
        result = v4;
        if (v3 < 255 == (254 - v3 & v4) < 0) {
            // break -> 0x100003bbc
            break;
        }
        v3 = v4;
        v2 -= *(int32_t *)(4 * (int64_t)v3 + v1);
        result = v3;
    }
    // 0x100003bbc
    return result;
}

// Address range: 0x100003bc8 - 0x100003c38
int64_t function_100003bc8(void) {
    // 0x100003bc8
    int64_t v1; // 0x100003bc8
    *(char *)v1 = (char)function_100003b34();
    *(char *)(v1 + 1) = (char)function_100003b34();
    int64_t result = function_100003b34(); // 0x100003c20
    *(char *)(v1 + 2) = (char)result;
    return result;
}

// Address range: 0x100003c38 - 0x100003db0
int64_t function_100003c38(void) {
    int64_t result = function_100003444(); // 0x100003c68
    int64_t result2 = result; // bp-56, 0x100003c70
    int64_t * v1 = (int64_t *)((int64_t)&result2 + 24); // 0x100003c84
    int64_t v2 = *v1; // 0x100003c84
    int32_t v3 = *(int32_t *)(v2 + 4); // 0x100003c88
    int32_t v4 = -v3; // 0x100003c8c
    if (v4 < 0 == (v3 & v4) < 0) {
        // 0x100003d98
        return result;
    }
    int32_t v5 = 0; // 0x100003c94
    int32_t v6 = *(int32_t *)v2; // 0x100003cb0
    int32_t v7 = -v6; // 0x100003cb4
    int32_t v8 = 0; // 0x100003cbc
    int64_t v9 = v2; // 0x100003cbc
    int32_t v10; // 0x100003d78
    int64_t v11; // 0x100003cac
    int32_t v12; // 0x100003cb0
    int32_t v13; // 0x100003cb4
    if (v7 < 0 != (v6 & v7) < 0) {
        if (v8 == 0) {
            // 0x100003cd8
            function_100003a7c();
        } else {
            // 0x100003cf4
            function_100003794();
            function_100003908();
        }
        // 0x100003d44
        function_100003bc8();
        v10 = v8 + 1;
        v11 = *v1;
        v12 = *(int32_t *)v11;
        v13 = v10 - v12;
        v8 = v10;
        v9 = v11;
        while (v13 < 0 != ((v13 ^ v10) & (v12 ^ v10)) < 0) {
            // 0x100003cc4
            if (v8 == 0) {
                // 0x100003cd8
                function_100003a7c();
            } else {
                // 0x100003cf4
                function_100003794();
                function_100003908();
            }
            // 0x100003d44
            function_100003bc8();
            v10 = v8 + 1;
            v11 = *v1;
            v12 = *(int32_t *)v11;
            v13 = v10 - v12;
            v8 = v10;
            v9 = v11;
        }
    }
    int64_t v14 = v9; // 0x100003c84
    v5++;
    int32_t v15 = *(int32_t *)(v14 + 4); // 0x100003c88
    while (v5 - v15 < 0 != ((v5 - v15 ^ v5) & (v15 ^ v5)) < 0) {
        // 0x100003ca4
        v6 = *(int32_t *)v14;
        v7 = -v6;
        v8 = 0;
        v9 = v14;
        if (v7 < 0 != (v6 & v7) < 0) {
            if (v8 == 0) {
                // 0x100003cd8
                function_100003a7c();
            } else {
                // 0x100003cf4
                function_100003794();
                function_100003908();
            }
            // 0x100003d44
            function_100003bc8();
            v10 = v8 + 1;
            v11 = *v1;
            v12 = *(int32_t *)v11;
            v13 = v10 - v12;
            v8 = v10;
            v9 = v11;
            while (v13 < 0 != ((v13 ^ v10) & (v12 ^ v10)) < 0) {
                // 0x100003cc4
                if (v8 == 0) {
                    // 0x100003cd8
                    function_100003a7c();
                } else {
                    // 0x100003cf4
                    function_100003794();
                    function_100003908();
                }
                // 0x100003d44
                function_100003bc8();
                v10 = v8 + 1;
                v11 = *v1;
                v12 = *(int32_t *)v11;
                v13 = v10 - v12;
                v8 = v10;
                v9 = v11;
            }
        }
        // 0x100003d88
        v14 = v9;
        v5++;
        v15 = *(int32_t *)(v14 + 4);
    }
    // 0x100003d98
    return result2;
}

// Address range: 0x100003db0 - 0x100003ea4
int64_t entry_point(void) {
    // 0x100003db0
    int64_t v1; // 0x100003db0
    int32_t v2 = v1; // 0x100003dc0
    int32_t v3 = v2 - 3; // 0x100003dcc
    if (v3 == 0 || v3 < 0 != (2 - v2 & v2) < 0) {
        // 0x100003ddc
        _printf("Usage: %s size ppm_in ppm_out\n", (char *)v1);
    } else {
        // 0x100003e00
        _atoi((char *)*(int64_t *)(v1 + 8));
        _printf("filter size %d\n", v1);
        int64_t v4 = function_100003620(); // 0x100003e54
        int64_t v5 = function_100003c38(); // 0x100003e64
        function_100003374();
        _free((int64_t *)v4);
        _free((int64_t *)v5);
    }
    // 0x100003e94
    return 0;
}

// Address range: 0x100003ea4 - 0x100003eb0
int64_t function_100003ea4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ea4
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * nptr) {
    // 0x100003eb0
    return _atoi(nptr);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(struct _IO_FILE * stream) {
    // 0x100003ebc
    return _fclose(stream);
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(struct _IO_FILE * stream) {
    // 0x100003ec8
    return _fgetc(stream);
}

// Address range: 0x100003ed4 - 0x100003ee0
struct _IO_FILE * function_100003ed4(char * filename, char * modes) {
    // 0x100003ed4
    return _fopen(filename, modes);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ee0
    return _fprintf(stream, format);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003eec
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003ef8 - 0x100003f04
void function_100003ef8(int64_t * ptr) {
    // 0x100003ef8
    _free(ptr);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f04
    return _fscanf(stream, format);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f10
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(int32_t c) {
    // 0x100003f1c
    return _isspace(c);
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int32_t size) {
    // 0x100003f28
    return _malloc(size);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 24

