//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000381c(void);
int64_t function_1000038c0(void);
int64_t function_1000038e0(void);
int64_t function_100003978(void);
int64_t function_100003a00(void);
int64_t function_100003bf8(void);
int64_t function_100003e58(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int64_t function_100003e64(int64_t a1);
void function_100003e70(int64_t * ptr);
int32_t function_100003e7c(int32_t af, char * cp, int64_t * buf);
int32_t function_100003e88(char * format, ...);
char * function_100003e94(char * s);
char * function_100003ea0(char * s, int32_t c);
int32_t function_100003eac(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int32_t _inet_pton(int32_t a1, char * a2, int64_t * a3);
int32_t _printf(char * a1, ...);
char * _strrchr(char * a1, int32_t a2);
int32_t _strtoul(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x10000381c - 0x1000038c0
int64_t function_10000381c(void) {
    // 0x10000381c
    int64_t v1; // bp-44, 0x10000381c
    int64_t v2; // 0x10000381c
    int32_t v3 = _inet_pton(2, (char *)v2, &v1); // 0x10000383c
    int64_t result = 0; // 0x100003848
    if (v3 == 1) {
        // 0x100003850
        *(int16_t *)(v2 + 16) = 2;
        *(int32_t *)v2 = (int32_t)function_1000038c0();
        *(int16_t *)(v2 + 18) = 0;
        result = 1;
    }
    // 0x1000038ac
    return result;
}

// Address range: 0x1000038c0 - 0x1000038e0
int64_t function_1000038c0(void) {
    // 0x1000038c0
    int64_t v1; // 0x1000038c0
    return llvm_bswap_i32((int32_t)v1);
}

// Address range: 0x1000038e0 - 0x100003978
int64_t function_1000038e0(void) {
    // 0x1000038e0
    int64_t v1; // bp-56, 0x1000038e0
    int64_t v2; // 0x1000038e0
    int32_t v3 = _inet_pton(30, (char *)v2, &v1); // 0x100003900
    int64_t result = 0; // 0x10000390c
    if (v3 == 1) {
        // 0x100003914
        *(int16_t *)(v2 + 16) = 30;
        ___memcpy_chk(v2, &v1, 16, -1);
        *(int16_t *)(v2 + 18) = 0;
        result = 1;
    }
    // 0x100003964
    return result;
}

// Address range: 0x100003978 - 0x100003a00
int64_t function_100003978(void) {
    // 0x100003978
    char * v1; // bp-40, 0x100003978
    int64_t v2; // 0x100003978
    uint32_t v3 = _strtoul((char *)v2, &v1, 10); // 0x100003994
    if (v3 == 0) {
        // 0x1000039f0
        return 0;
    }
    int64_t result = 0; // 0x1000039c0
    if (v3 < 0x10000 == *v1 == 0) {
        // 0x1000039dc
        result = v3 % 0x10000;
    }
    // 0x1000039f0
    return result;
}

// Address range: 0x100003a00 - 0x100003bf8
int64_t function_100003a00(void) {
    // 0x100003a00
    int64_t v1; // 0x100003a00
    uint64_t v2 = v1;
    char * v3 = (char *)v2; // 0x100003a0c
    char * v4 = _strrchr(v3, 58); // 0x100003a1c
    char * v5; // 0x100003a7c
    uint64_t v6; // 0x100003a58
    if (v4 == NULL) {
        goto lab_0x100003ba0;
    } else {
        uint64_t v7 = (int64_t)v4; // 0x100003a1c
        if (v2 == v7 || v2 > v7) {
            goto lab_0x100003ba0;
        } else {
            // 0x100003a50
            v6 = function_100003978();
            if (v6 % 0x10000 == 0) {
                goto lab_0x100003ba0;
            } else {
                // 0x100003a74
                v5 = _strdup(v3);
                if (v5 == NULL) {
                    // 0x100003be4
                    return 0;
                }
                int64_t v8 = (int64_t)v5; // 0x100003a7c
                int64_t v9 = v7 - v2; // 0x100003ab4
                int64_t v10 = 0x100000000 * v9;
                *(char *)((v10 >> 32) + v8) = 0;
                if (*(char *)((v9 + 0xffffffff & 0xffffffff) + v8) == 93) {
                    // 0x100003aec
                    if (*v5 == 91) {
                        // 0x100003b04
                        *(char *)((v10 - 0x100000000 >> 32) + v8) = 0;
                        uint64_t v11 = function_1000038e0(); // 0x100003b24
                        _free((int64_t *)v5);
                        if (v11 % 2 != 0) {
                            // 0x100003b78
                            *(int16_t *)(v1 + 18) = (int16_t)v6;
                            // 0x100003be4
                            return 1;
                        }
                        goto lab_0x100003ba0;
                    } else {
                        goto lab_0x100003b64;
                    }
                } else {
                    goto lab_0x100003b64;
                }
            }
        }
    }
  lab_0x100003ba0:;
    int64_t result = 1; // 0x100003bb4
    if (function_1000038e0() % 2 == 0) {
        // 0x100003bbc
        result = function_10000381c() % 2;
    }
    // 0x100003be4
    return result;
  lab_0x100003b64:;
    uint64_t v12 = function_10000381c(); // 0x100003b48
    _free((int64_t *)v5);
    if (v12 % 2 != 0) {
        // 0x100003b78
        *(int16_t *)(v1 + 18) = (int16_t)v6;
        // 0x100003be4
        return 1;
    }
    goto lab_0x100003ba0;
}

// Address range: 0x100003bf8 - 0x100003dd0
int64_t function_100003bf8(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c0c
    int64_t v2; // 0x100003bf8
    _printf("input: %s\n", (char *)v2);
    if (function_100003a00() % 2 == 0) {
        // 0x100003d84
        _printf("Parsing failed.\n");
    } else {
        // 0x100003c44
        int32_t v3; // bp-44, 0x100003bf8
        int64_t v4 = &v3; // 0x100003c34
        _printf("address family: %s\n", &v3);
        int32_t v5; // 0x100003bf8
        switch ((int16_t)v5) {
            case 2: {
                // 0x100003c94
                _printf("address: %X", (int32_t)v4);
                // break -> 0x100003d30
                break;
            }
            case 30: {
                // 0x100003cc8
                _printf("address: ");
                for (int32_t i = 0; i < 16; i++) {
                    // 0x100003cf0
                    _printf("%02X", (int32_t)v4);
                }
                // break -> 0x100003d30
                break;
            }
        }
        // 0x100003d30
        _printf("\n");
        int32_t v6; // 0x100003bf8
        if (v6 % 0x10000 == 0) {
            // 0x100003d70
            _printf("port not specified\n");
        } else {
            // 0x100003d50
            _printf("port: %hu\n", (int16_t)v4);
        }
    }
    int64_t v7 = _printf("\n"); // 0x100003d9c
    int64_t result = v7; // 0x100003db8
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003dc0
        result = ___stack_chk_fail(v7);
    }
    // 0x100003dc4
    return result;
}

// Address range: 0x100003dd0 - 0x100003e58
int64_t entry_point(void) {
    // 0x100003dd0
    function_100003bf8();
    function_100003bf8();
    function_100003bf8();
    function_100003bf8();
    function_100003bf8();
    function_100003bf8();
    function_100003bf8();
    function_100003bf8();
    return 0;
}

// Address range: 0x100003e58 - 0x100003e64
int64_t function_100003e58(int64_t a1, int64_t * a2, int64_t a3, int64_t a4) {
    // 0x100003e58
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e64 - 0x100003e70
int64_t function_100003e64(int64_t a1) {
    // 0x100003e64
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e70 - 0x100003e7c
void function_100003e70(int64_t * ptr) {
    // 0x100003e70
    _free(ptr);
}

// Address range: 0x100003e7c - 0x100003e88
int32_t function_100003e7c(int32_t af, char * cp, int64_t * buf) {
    // 0x100003e7c
    return _inet_pton(af, cp, buf);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(char * format, ...) {
    // 0x100003e88
    return _printf(format);
}

// Address range: 0x100003e94 - 0x100003ea0
char * function_100003e94(char * s) {
    // 0x100003e94
    return _strdup(s);
}

// Address range: 0x100003ea0 - 0x100003eac
char * function_100003ea0(char * s, int32_t c) {
    // 0x100003ea0
    return _strrchr(s, c);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(char * nptr, char ** endptr, int32_t base) {
    // 0x100003eac
    return _strtoul(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

