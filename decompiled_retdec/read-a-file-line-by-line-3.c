//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bbc(void);
int64_t function_100003dd0(int64_t a1);
int64_t function_100003e60(void);
int32_t function_100003f14(int32_t fd);
void function_100003f20(int32_t status, char * format, ...);
int32_t function_100003f2c(struct _IO_FILE * stream);
int32_t function_100003f38(int32_t fd, struct stat * buf);
int64_t * function_100003f44(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003f50(int64_t * addr, int32_t len);
int32_t function_100003f5c(char * file, int32_t oflag, ...);
int32_t function_100003f68(int32_t fd, int64_t * buf, int32_t n);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fileno(struct _IO_FILE * a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bbc - 0x100003dd0
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // bp-184, 0x100003bbc
    int64_t v2 = &v1; // 0x100003bcc
    int64_t v3; // 0x100003bbc
    int32_t v4 = _open((char *)v3, 0); // 0x100003be0
    int32_t * v5 = (int32_t *)(v2 + 148); // 0x100003be8
    *v5 = v4;
    int32_t v6 = v4; // 0x100003bf8
    if (v4 == -1) {
        // 0x100003c00
        _err(1, "open: %s", (char *)v3);
        v6 = *v5;
    }
    // 0x100003c20
    if (_fstat(v6, (struct stat *)&v1) == -1) {
        // 0x100003c40
        _err(1, "stat: %s", (char *)v3);
    }
    int64_t * v7 = (int64_t *)(v2 + 96); // 0x100003c64
    int64_t * v8 = _mmap(NULL, (int32_t)*v7, 1, 1, *v5, 0); // 0x100003c7c
    if (v8 == (int64_t *)-1) {
        // 0x100003c98
        _err(1, "mmap: %s", (char *)1);
    }
    int64_t result = (int64_t)v8; // 0x100003c7c
    uint64_t v9 = (char *)v8; // 0x100003cd8
    char * v10; // 0x100003bbc
    switch (*v10) {
        case 13: {
        }
        case 10: {
            // 0x100003d38
            return result;
        }
    }
    while (v9 < *v7 + result) {
        // 0x100003cdc
        v9 = (char *)v9;
        switch (*v10) {
            case 13: {
            }
            case 10: {
                // 0x100003d38
                return result;
            }
        }
    }
    // 0x100003d38
    return result;
}

// Address range: 0x100003dd0 - 0x100003e60
int64_t function_100003dd0(int64_t a1) {
    // 0x100003dd0
    int64_t v1; // 0x100003dd0
    int64_t result; // 0x100003dd0
    if ((int32_t)v1 == 0) {
        // 0x100003de0
        _err(1, "[callback] %s", (char *)v1);
        result = &g1;
    }
    if (v1 + 1 < v1) {
        // 0x100003e30
        return result;
    }
    // 0x100003e34
    _munmap((int64_t *)v1, (int32_t)*(int64_t *)(a1 + 96));
    _close(*(int32_t *)(a1 + 148));
    return 1;
}

// Address range: 0x100003e60 - 0x100003ed0
int64_t function_100003e60(void) {
    // 0x100003e60
    int64_t v1; // 0x100003e60
    int64_t v2 = v1;
    int32_t v3 = _fileno((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000); // 0x100003e80
    return _write(v3, (int64_t *)v2, (int32_t)(v1 - v2) + 1) != -1;
}

// Address range: 0x100003ed0 - 0x100003f14
int64_t entry_point(void) {
    // 0x100003ed0
    return (int32_t)function_100003bbc() == 0;
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(int32_t fd) {
    // 0x100003f14
    return _close(fd);
}

// Address range: 0x100003f20 - 0x100003f2c
void function_100003f20(int32_t status, char * format, ...) {
    // 0x100003f20
    _err(status, format);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(struct _IO_FILE * stream) {
    // 0x100003f2c
    return _fileno(stream);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(int32_t fd, struct stat * buf) {
    // 0x100003f38
    return _fstat(fd, buf);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003f44
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int64_t * addr, int32_t len) {
    // 0x100003f50
    return _munmap(addr, len);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * file, int32_t oflag, ...) {
    // 0x100003f5c
    return _open(file, oflag);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t fd, int64_t * buf, int32_t n) {
    // 0x100003f68
    return _write(fd, buf, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

