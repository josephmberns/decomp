//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a0c(void);
int64_t function_100003acc(void);
int64_t function_100003ce8(int64_t a1);
int64_t function_100003dd0(char * a1, char * a2, int64_t a3, char * a4);
int32_t function_100003ddc(void);
void function_100003de8(int32_t status);
char * function_100003df4(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003e00(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003e0c(void);
int32_t function_100003e18(char * format, ...);
int32_t function_100003e24(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int32_t _clock(void);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _getchar(void);
int32_t _printf(char * a1, ...);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003a0c - 0x100003acc
int64_t function_100003a0c(void) {
    // 0x100003a0c
    int64_t v1; // 0x100003a0c
    int32_t v2 = v1; // 0x100003a18
    if (v2 < 1) {
        int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003a38
        _fprintf((struct _IO_FILE *)v3, "Illegal Argument Is Passed!\n");
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = 0; // 0x100003a0c
    switch (v2) {
        case 2: {
            // 0x100003a80
            result = 1;
        }
        case 1: {
            // 0x100003abc
            return result;
        }
        default: {
            int64_t v4 = function_100003a0c(); // 0x100003a94
            result = function_100003a0c() + v4 & 0xffffffff;
            return result;
        }
    }
}

// Address range: 0x100003acc - 0x100003c28
int64_t function_100003acc(void) {
    // 0x100003acc
    int32_t v1; // 0x100003acc
    int32_t v2; // bp-27, 0x100003acc
    char * v3; // bp-40, 0x100003acc
    while (true) {
      lab_0x100003adc:
        // 0x100003adc
        _printf("Please enter a valid number:");
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003af0
        _fgets((char *)&v2, 3, (struct _IO_FILE *)v4);
        int32_t v5; // 0x100003acc
        if ((uint32_t)v5 % 256 == 10 || v5 % 256 == 10 || v2 % 256 == 10) {
            // 0x100003b6c
            v1 = _strtol((char *)&v2, &v3, 10);
            goto lab_0x100003b98;
        } else {
            int32_t v6 = 0;
            int32_t v7 = v6 + 1; // 0x100003b50
            while (_getchar() != 10) {
                // 0x100003b44
                v6 = v7;
                v7 = v6 + 1;
            }
            // 0x100003b6c
            v1 = _strtol((char *)&v2, &v3, 10);
            if (v6 < 1) {
                goto lab_0x100003b98;
            } else {
                goto lab_0x100003adc;
            }
        }
    }
  lab_0x100003b98:;
    int32_t v8 = v1;
    int32_t v9 = v8 - 48; // 0x100003b9c
    if (v9 == 0 || v9 < 0 != (47 - v8 & v8) < 0) {
        // 0x100003bac
        char * v10; // 0x100003bac
        switch (*v10) {
            case 0: {
            }
            case 10: {
                if (v3 != (char *)&v2) {
                    // break -> 0x100003bfc
                    break;
                }
                // break -> 0x100003bf4
                break;
            }
        }
    }
    goto lab_0x100003adc;
}

// Address range: 0x100003c28 - 0x100003ce8
int64_t entry_point(void) {
    // 0x100003c28
    function_100003ce8(0);
    _printf("Tests passed...\n");
    _printf("Enter n to find nth fibonacci element...\nNote: You would be asked to enter input until valid number ( less than or equal to 48 ) is entered.\n");
    function_100003acc();
    _clock();
    function_100003a0c();
    int64_t v1; // 0x100003c28
    _printf("Fibonacci element %d is %u ", v1, (int32_t)v1);
    _clock();
    int128_t v2; // 0x100003c28
    _printf("in %.3f seconds.\n", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003ce8 - 0x100003dd0
int64_t function_100003ce8(int64_t a1) {
    // 0x100003ce8
    if ((int32_t)function_100003a0c() != 3) {
        // 0x100003d14
        ___assert_rtn("test", "fibonacci.c", 94, "fib(5) == 3");
    }
    // 0x100003d38
    if ((int32_t)function_100003a0c() != 1) {
        // 0x100003d5c
        ___assert_rtn("test", "fibonacci.c", 95, "fib(2) == 1");
    }
    int64_t v1 = function_100003a0c(); // 0x100003d84
    int64_t result = v1; // 0x100003d9c
    if ((int32_t)v1 != 21) {
        // 0x100003da4
        result = ___assert_rtn("test", "fibonacci.c", 96, "fib(9) == 21");
    }
    // 0x100003dc8
    return result;
}

// Address range: 0x100003dd0 - 0x100003ddc
int64_t function_100003dd0(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003dd0
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003ddc - 0x100003de8
int32_t function_100003ddc(void) {
    // 0x100003ddc
    return _clock();
}

// Address range: 0x100003de8 - 0x100003df4
void function_100003de8(int32_t status) {
    // 0x100003de8
    _exit(status);
}

// Address range: 0x100003df4 - 0x100003e00
char * function_100003df4(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003df4
    return _fgets(s, n, stream);
}

// Address range: 0x100003e00 - 0x100003e0c
int32_t function_100003e00(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e00
    return _fprintf(stream, format);
}

// Address range: 0x100003e0c - 0x100003e18
int32_t function_100003e0c(void) {
    // 0x100003e0c
    return _getchar();
}

// Address range: 0x100003e18 - 0x100003e24
int32_t function_100003e18(char * format, ...) {
    // 0x100003e18
    return _printf(format);
}

// Address range: 0x100003e24 - 0x100003e30
int32_t function_100003e24(char * nptr, char ** endptr, int32_t base) {
    // 0x100003e24
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

