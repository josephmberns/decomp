//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <windows.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000037f4(void);
int64_t function_1000038d4(void);
int64_t * function_100003e88(int32_t nmemb, int32_t size);
int32_t function_100003e94(int32_t fd);
void function_100003ea0(int64_t * ptr);
int32_t function_100003eac(int32_t fd, struct stat * buf);
int64_t * function_100003eb8(int32_t size);
int32_t function_100003ec4(char * file, int32_t oflag, ...);
int32_t function_100003ed0(char * format, ...);
void function_100003edc(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003ee8(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_100003ef4(char * s, char * format, ...);
int32_t function_100003f00(char * s);
int32_t function_100003f0c(char * s1, char * s2, int32_t n);
float64_t function_100003f18(char * nptr, char ** endptr);
int32_t function_100003f24(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _close(int32_t a1);
void _free(int64_t * a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _sscanf(char * a1, char * a2, ...);
int32_t _strlen(char * a1);
int32_t _strncmp(char * a1, char * a2, int32_t a3);
float64_t _strtod(char * a1, char ** a2);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000037f4 - 0x1000038d4
int64_t function_1000037f4(void) {
    // 0x1000038c4
    return 0;
    // 0x100003844
    int64_t v1; // 0x1000037f4
    if (v1 == 0) {
        // 0x1000038c4
        return 1;
    }
    int64_t result = 0xffffffff; // 0x100003878
    if (v1 != 0) {
        // 0x10000388c
        result = _strncmp((char *)v1, (char *)v1, 10);
    }
    // 0x1000038c4
    return result;
}

// Address range: 0x1000038d4 - 0x100003e54
int64_t function_1000038d4(void) {
    // 0x1000038d4
    int64_t v1; // 0x1000038d4
    int32_t v2 = _open((char *)v1, 0); // 0x1000038f0
    if (v2 == -1) {
        // 0x100003e40
        return 0;
    }
    // 0x100003914
    int64_t v3; // bp-200, 0x1000038d4
    _fstat(v2, (struct stat *)&v3);
    char * v4; // 0x1000038d4
    int64_t v5 = (int64_t)v4; // 0x100003920
    int32_t v6 = v5; // 0x100003924
    int64_t * v7 = _malloc(v6); // 0x100003924
    int64_t v8 = (int64_t)v7; // 0x100003924
    _read(v2, v7, v6);
    _close(v2);
    int64_t v9 = -v5; // 0x10000395c
    int32_t v10 = 0; // 0x100003964
    int32_t v11 = 0; // 0x100003964
    if (v9 < 0 != (v9 & v5) < 0) {
        int32_t v12 = 0;
        char * v13 = (char *)v8; // 0x100003974
        int32_t v14 = v12; // 0x100003980
        if (*v13 == 10) {
            // 0x100003988
            *v13 = 0;
            v14 = v12 + 1;
        }
        int32_t v15 = v14;
        v10++;
        int64_t v16 = v10; // 0x100003954
        int64_t v17 = v16 - v5; // 0x10000395c
        v11 = v15;
        while (v17 < 0 != ((v17 ^ v16) & (v16 ^ v5)) < 0) {
            // 0x10000396c
            v12 = v15;
            v13 = (char *)(v16 + v8);
            v14 = v12;
            if (*v13 == 10) {
                // 0x100003988
                *v13 = 0;
                v14 = v12 + 1;
            }
            // 0x1000039ac
            v15 = v14;
            v10++;
            v16 = v10;
            v17 = v16 - v5;
            v11 = v15;
        }
    }
    int64_t * v18 = _calloc(16, v11); // 0x1000039c4
    int64_t v19 = (int64_t)v18; // 0x1000039c4
    *v18 = v8;
    *(int32_t *)(v19 + 8) = 1;
    int32_t v20 = -v11; // 0x1000039f4
    int64_t * v21; // 0x1000038d4
    int32_t v22; // 0x1000038d4
    int32_t v23; // 0x100003a08
    int32_t v24; // 0x1000038d4
    int32_t v25; // 0x100003bf0
    int64_t v26; // 0x1000038d4
    int64_t v27; // 0x1000038d4
    int64_t v28; // 0x1000038d4
    int64_t v29; // 0x1000038d4
    if (v20 < 0 != (v11 & v20) < 0) {
        // 0x100003a04
        char * v30; // bp-256, 0x1000038d4
        v26 = (int64_t)&v30;
        v22 = 0;
        v27 = v5;
        while (true) {
          lab_0x100003a04:;
            int64_t v31 = v27;
            int32_t v32 = v22;
            v23 = v32 + 1;
            v24 = v23 - v11;
            int64_t v33 = 16 * (int64_t)v32 + v19;
            v21 = (int64_t *)v33;
            if (v24 < 0 != ((v24 ^ v23) & (v23 ^ v11)) < 0) {
                int64_t v34 = *v21; // 0x100003a2c
                int32_t v35 = _strlen((char *)v34); // 0x100003a44
                int64_t v36 = 16 * (int64_t)v23 + v19; // 0x100003a6c
                *(int64_t *)v36 = v34 + 1 + (int64_t)v35;
                *(int32_t *)(v36 + 8) = v32 + 2;
            }
            int64_t v37 = *v21; // 0x100003a9c
            if (_sscanf((char *)v37, "%4d-%2d-%2d", (int64_t *)v31, (int64_t *)v1, (int64_t *)v1) == 3) {
                char * v38 = (char *)(*v21 + 10); // 0x100003b34
                char * v39 = v38; // bp-248, 0x100003b34
                int32_t * v40 = (int32_t *)(v33 + 12);
                _strtod(v38, &v30);
                int32_t v41 = 0; // 0x100003b64
                int32_t v42 = 0; // 0x100003b64
                v28 = v31;
                float64_t v43; // 0x1000038d4
                if (v43 == 0.0 != (v30 == v38)) {
                    while (true) {
                        uint32_t v44 = v42;
                        int32_t v45 = v41;
                        v39 = v30;
                        int32_t v46 = _strtol(v30, &v30, 10); // 0x100003bb0
                        if (v46 == 0) {
                            // 0x100003bd0
                            v28 = 10;
                            if (v30 == v30) {
                                // break -> 0x100003c54
                                break;
                            }
                        }
                        // 0x100003bec
                        *(int64_t *)&v39 = (int64_t)v30;
                        if (v46 < 1 != (v46 & -v46) < 0) {
                            // 0x100003c14
                            *v40 = 1;
                        }
                        // 0x100003c30
                        v25 = v45 + 2;
                        if (v44 >= 24) {
                            goto lab_0x100003c40_2;
                        }
                        // 0x100003c30
                        _strtod(v39, &v30);
                        v41 = v25;
                        v42 = v44 + 1;
                        if (v43 == 0.0 == v30 == v39) {
                            goto lab_0x100003c40_2;
                        }
                    }
                }
                goto lab_0x100003c54;
            } else {
                // 0x100003ad8
                _printf("bad line %d: %s\n", (int64_t)"%4d-%2d-%2d", (char *)v31);
                *v21 = 0;
                v29 = v31;
                goto lab_0x100003ca0;
            }
        }
    }
  lab_0x100003cb0:;
    int64_t v47 = v11; // 0x100003cb4
    _qsort(v18, v11, 16, (int32_t (*)(int64_t *, int64_t *))0x1000037f4);
    int32_t v48 = 1 - v11; // 0x100003cec
    int64_t v49 = v47; // 0x100003cfc
    int64_t v50 = 16; // 0x100003cfc
    if (v48 < 0 != (v48 & v11) < 0) {
        int64_t v51 = *(int64_t *)(v19 + 16); // 0x100003d10
        int32_t v52 = 1; // 0x100003d28
        v49 = v47;
        v50 = 16;
        if (v51 != 0) {
            int32_t v53 = 0;
            int64_t v54 = *(int64_t *)(16 * (int64_t)v53 + v19); // 0x100003d7c
            int32_t v55 = v52; // 0x100003d90
            if (_strncmp((char *)v51, (char *)v54, 10) == 0) {
                // 0x100003da4
                _printf("dup line %d: %.10s\n", v54, (char *)10);
                v55 = v53;
            }
            int32_t v56 = v52 + 1; // 0x100003dec
            int32_t v57 = v56 - v11; // 0x100003cec
            v49 = v54;
            v50 = 10;
            while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v11)) < 0) {
                int64_t v58 = *(int64_t *)(16 * (int64_t)v56 + v19); // 0x100003d10
                v49 = v54;
                v50 = 10;
                if (v58 == 0) {
                    // break -> 0x100003df8
                    break;
                }
                v53 = v55;
                v54 = *(int64_t *)(16 * (int64_t)v53 + v19);
                v55 = v56;
                if (_strncmp((char *)v58, (char *)v54, 10) == 0) {
                    // 0x100003da4
                    _printf("dup line %d: %.10s\n", v54, (char *)10);
                    v55 = v53;
                }
                // 0x100003de8
                v56++;
                v57 = v56 - v11;
                v49 = v54;
                v50 = 10;
            }
        }
    }
    // 0x100003df8
    _free(v18);
    _free(v7);
    _printf("\n%d out %d lines good\n", v49, v50);
    // 0x100003e40
    return 0;
  lab_0x100003c40_2:
    // 0x100003c40
    v28 = 10;
    v29 = 10;
    if (v25 == 48) {
        goto lab_0x100003ca0;
    } else {
        goto lab_0x100003c54;
    }
  lab_0x100003c54:
    // 0x100003c54
    _printf("bad format at line %d: %s\n", v26, (char *)v28);
    *v21 = 0;
    v29 = v28;
    goto lab_0x100003ca0;
  lab_0x100003ca0:
    // 0x100003ca0
    v22 = v23;
    v27 = v29;
    if (v24 < 0 == ((v24 ^ v23) & (v23 ^ v11)) < 0) {
        // break -> 0x100003cb0
        goto lab_0x100003cb0;
    }
    goto lab_0x100003a04;
}

// Address range: 0x100003e54 - 0x100003e88
int64_t entry_point(void) {
    // 0x100003e54
    function_1000038d4();
    return 0;
}

// Address range: 0x100003e88 - 0x100003e94
int64_t * function_100003e88(int32_t nmemb, int32_t size) {
    // 0x100003e88
    return _calloc(nmemb, size);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(int32_t fd) {
    // 0x100003e94
    return _close(fd);
}

// Address range: 0x100003ea0 - 0x100003eac
void function_100003ea0(int64_t * ptr) {
    // 0x100003ea0
    _free(ptr);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(int32_t fd, struct stat * buf) {
    // 0x100003eac
    return _fstat(fd, buf);
}

// Address range: 0x100003eb8 - 0x100003ec4
int64_t * function_100003eb8(int32_t size) {
    // 0x100003eb8
    return _malloc(size);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(char * file, int32_t oflag, ...) {
    // 0x100003ec4
    return _open(file, oflag);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(char * format, ...) {
    // 0x100003ed0
    return _printf(format);
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003edc
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003ee8
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * s, char * format, ...) {
    // 0x100003ef4
    return _sscanf(s, format);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * s) {
    // 0x100003f00
    return _strlen(s);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * s1, char * s2, int32_t n) {
    // 0x100003f0c
    return _strncmp(s1, s2, n);
}

// Address range: 0x100003f18 - 0x100003f24
float64_t function_100003f18(char * nptr, char ** endptr) {
    // 0x100003f18
    return _strtod(nptr, endptr);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f24
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

