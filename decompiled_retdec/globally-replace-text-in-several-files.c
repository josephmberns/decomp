//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039f4(void);
int64_t function_100003adc(void);
int64_t function_100003e88(void);
int32_t function_100003e94(int32_t fd);
void function_100003ea0(int64_t * ptr);
int32_t function_100003eac(int32_t fd, struct stat * buf);
int32_t function_100003eb8(int32_t fd, int32_t length);
int32_t function_100003ec4(int32_t fd, int32_t offset, int32_t whence);
int64_t * function_100003ed0(int32_t size);
int32_t function_100003edc(char * file, int32_t oflag, ...);
int32_t function_100003ee8(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_100003ef4(char * s);
void function_100003f00(char * format, ...);
int32_t function_100003f0c(int32_t fd, int64_t * buf, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _close(int32_t a1);
void _free(int64_t * a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int32_t _ftruncate(int32_t a1, int32_t a2);
int32_t _lseek(int32_t a1, int32_t a2, int32_t a3);
int64_t * _malloc(int32_t a1);
int32_t _strlen(char * a1);
void _warn(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039f4 - 0x100003adc
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    uint64_t v2 = v1;
    if (v1 + v2 >= v1) {
        // 0x100003ad0
        return 0;
    }
    int64_t v3; // 0x1000039f4
    int64_t v4 = v3;
    int64_t v5 = 0; // 0x100003a4c
    int64_t v6; // 0x1000039f4
    int64_t v7; // 0x1000039f4
    char v8; // 0x100003a68
    int64_t v9; // 0x100003a88
    if (v2 != 0) {
        v7 = 0;
        v8 = *(char *)(v7 + v1);
        v5 = v7;
        while (*(char *)(v7 + v4) == v8) {
            // 0x100003a84
            v9 = v7 + 1;
            v6 = v9;
            v5 = v9;
            if (v9 >= v2) {
                // break -> 0x100003a94
                break;
            }
            v7 = v6;
            v8 = *(char *)(v7 + v1);
            v5 = v7;
        }
    }
    int64_t result = v4; // 0x100003aa4
    while (v5 != v2) {
        int64_t v10 = v4 + 1; // 0x100003abc
        result = 0;
        if (v10 + v2 >= v1) {
            // break -> 0x100003ad0
            break;
        }
        v4 = v10;
        v5 = 0;
        if (v2 != 0) {
            v7 = 0;
            v8 = *(char *)(v7 + v1);
            v5 = v7;
            while (*(char *)(v7 + v4) == v8) {
                // 0x100003a84
                v9 = v7 + 1;
                v6 = v9;
                v5 = v9;
                if (v9 >= v2) {
                    // break -> 0x100003a94
                    break;
                }
                v7 = v6;
                v8 = *(char *)(v7 + v1);
                v5 = v7;
            }
        }
        // 0x100003a94
        result = v4;
    }
    // 0x100003ad0
    return result;
}

// Address range: 0x100003adc - 0x100003dbc
int64_t function_100003adc(void) {
    // 0x100003adc
    int64_t v1; // bp-200, 0x100003adc
    int64_t v2 = &v1; // 0x100003af0
    int64_t v3; // 0x100003adc
    int32_t v4 = _strlen((char *)v3); // 0x100003b0c
    int64_t * v5 = (int64_t *)(v2 + 152); // 0x100003b18
    int32_t v6 = _strlen((char *)*v5); // 0x100003b1c
    int32_t v7 = _open((char *)*(int64_t *)(v2 + 144), 2); // 0x100003b30
    if (v7 == -1) {
        // 0x100003d88
        _warn("Can't open '%s'", (char *)2);
        // 0x100003da8
        return 0;
    }
    // 0x100003b6c
    if (_fstat(v7, (struct stat *)&v1) == -1) {
        // 0x100003d88
        _warn("Can't stat '%s'", &v1);
        _close(v7);
        // 0x100003da8
        return 0;
    }
    int64_t * v8 = (int64_t *)(v2 + 96); // 0x100003bac
    int64_t * v9 = _malloc((int32_t)*v8); // 0x100003bb0
    if (v9 == NULL) {
        // 0x100003d88
        _warn("Can't alloc '%s'", &v1);
        _close(v7);
        // 0x100003da8
        return 0;
    }
    // 0x100003bec
    if (*v8 != (int64_t)_read(v7, v9, (int32_t)*v8)) {
        // 0x100003c18
        _warn("Bad read '%s'", v9);
        // 0x100003d88
        _close(v7);
        // 0x100003d9c
        _free(v9);
        // 0x100003da8
        return 0;
    }
    int64_t v10 = function_1000039f4(); // 0x100003c5c
    if (v10 == 0) {
        // 0x100003d88
        _close(v7);
        // 0x100003d9c
        _free(v9);
        // 0x100003da8
        return 0;
    }
    int64_t v11 = (int64_t)v9; // 0x100003c3c
    _ftruncate(v7, 0);
    _lseek(v7, 0, 0);
    int64_t v12 = v11;
    _write(v7, (int64_t *)v12, (int32_t)(v10 - v12));
    _write(v7, (int64_t *)*v5, v6);
    int64_t v13 = v10 + (int64_t)v4; // 0x100003cd8
    int64_t v14 = function_1000039f4(); // 0x100003cf8
    while (v14 != 0) {
        // 0x100003ca0
        v12 = v13;
        _write(v7, (int64_t *)v12, (int32_t)(v14 - v12));
        _write(v7, (int64_t *)*v5, v6);
        v13 = v14 + (int64_t)v4;
        v14 = function_1000039f4();
    }
    uint64_t v15 = *v8 + v11; // 0x100003d28
    if (v15 > v13) {
        // 0x100003d3c
        _write(v7, (int64_t *)v13, (int32_t)(v15 - v13));
    }
    // 0x100003d88
    _close(v7);
    // 0x100003d9c
    _free(v9);
    // 0x100003da8
    return 0;
}

// Address range: 0x100003dbc - 0x100003e88
int64_t entry_point(void) {
    for (int32_t i = 0; i < 3; i++) {
        // 0x100003e28
        function_100003adc();
    }
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e60
    if (v1 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e74
        ___stack_chk_fail();
    }
    // 0x100003e78
    return 0;
}

// Address range: 0x100003e88 - 0x100003e94
int64_t function_100003e88(void) {
    // 0x100003e88
    return ___stack_chk_fail();
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(int32_t fd) {
    // 0x100003e94
    return _close(fd);
}

// Address range: 0x100003ea0 - 0x100003eac
void function_100003ea0(int64_t * ptr) {
    // 0x100003ea0
    _free(ptr);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(int32_t fd, struct stat * buf) {
    // 0x100003eac
    return _fstat(fd, buf);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(int32_t fd, int32_t length) {
    // 0x100003eb8
    return _ftruncate(fd, length);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(int32_t fd, int32_t offset, int32_t whence) {
    // 0x100003ec4
    return _lseek(fd, offset, whence);
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t * function_100003ed0(int32_t size) {
    // 0x100003ed0
    return _malloc(size);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * file, int32_t oflag, ...) {
    // 0x100003edc
    return _open(file, oflag);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003ee8
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * s) {
    // 0x100003ef4
    return _strlen(s);
}

// Address range: 0x100003f00 - 0x100003f0c
void function_100003f00(char * format, ...) {
    // 0x100003f00
    _warn(format);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(int32_t fd, int64_t * buf, int32_t n) {
    // 0x100003f0c
    return _write(fd, buf, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

