//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c80(void);
int64_t function_100003f18(int64_t a1);
int32_t function_100003f24(char * format, ...);
int32_t function_100003f30(int64_t * cond);
int32_t function_100003f3c(int64_t * cond, int64_t * mutex);
int32_t function_100003f48(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
void function_100003f54(int64_t * retval);
int32_t function_100003f60(int32_t th, int64_t ** thread_return);
int32_t function_100003f6c(int64_t * mutex);
int32_t function_100003f78(int64_t * mutex);
int32_t function_100003f84(int32_t seconds);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.22507385851485347181302194380861076e-308L; // 0x100004058
int64_t g2 = 0x32aaaba7; // 0x100008000
int64_t g3 = 0x3cb0b1bb; // 0x100008040
int32_t g4 = -0x1120531; // 0x100008070
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _pthread_cond_broadcast(int64_t * a1);
int32_t _pthread_cond_wait(int64_t * a1, int64_t * a2);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
void _pthread_exit(int64_t * a1);
int32_t _pthread_join(int32_t a1, int64_t ** a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c80 - 0x100003de8
int64_t function_100003c80(void) {
    // 0x100003c80
    _pthread_mutex_lock(&g2);
    if (*(int32_t *)((int64_t)&g2 + 112) == 0) {
        _pthread_cond_wait(&g3, &g2);
        while (*(int32_t *)((int64_t)&g2 + 112) == 0) {
            // 0x100003cbc
            _pthread_cond_wait(&g3, &g2);
        }
    }
    // 0x100003cd4
    _pthread_mutex_unlock(&g2);
    _printf("Enjoy\n");
    _pthread_exit(NULL);
    _pthread_mutex_lock(&g2);
    if (g4 == 0) {
        _pthread_cond_wait(&g3, &g2);
        while (g4 == 0) {
            // 0x100003d34
            _pthread_cond_wait(&g3, &g2);
        }
    }
    // 0x100003d4c
    _pthread_mutex_unlock(&g2);
    _printf("Rosetta\n");
    _pthread_exit(NULL);
    _pthread_mutex_lock(&g2);
    if (g4 != 0) {
        // 0x100003dc4
        _pthread_mutex_unlock(&g2);
        _printf("Code\n");
        _pthread_exit(NULL);
        return &g5;
    }
    _pthread_cond_wait(&g3, &g2);
    while (g4 == 0) {
        // 0x100003dac
        _pthread_cond_wait(&g3, &g2);
    }
    // 0x100003dc4
    _pthread_mutex_unlock(&g2);
    _printf("Code\n");
    _pthread_exit(NULL);
    return &g5;
}

// Address range: 0x100003de8 - 0x100003f18
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dfc
    float128_t v2 = g1; // bp-80, 0x100003e14
    int64_t v3; // bp-48, 0x100003de8
    int64_t v4 = &v3;
    for (int64_t i = 0; i < 3; i++) {
        int64_t v5 = 8 * i; // 0x100003e44
        int64_t v6 = *(int64_t *)(v5 + (int64_t)&v2); // 0x100003e50
        _pthread_create((int32_t *)(v5 + v4), NULL, (int64_t * (*)(int64_t *))v6, NULL);
    }
    // 0x100003e74
    _sleep(1);
    g4 = 1;
    _pthread_cond_broadcast(&g3);
    int32_t v7; // 0x100003ec4
    for (int64_t i = 0; i < 3; i++) {
        // 0x100003eb4
        v7 = _pthread_join((int32_t)*(int64_t *)(8 * i + v4), NULL);
    }
    // 0x100003edc
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f04
        ___stack_chk_fail((int64_t)v7);
    }
    // 0x100003f08
    return 0;
}

// Address range: 0x100003f18 - 0x100003f24
int64_t function_100003f18(int64_t a1) {
    // 0x100003f18
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int64_t * cond) {
    // 0x100003f30
    return _pthread_cond_broadcast(cond);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(int64_t * cond, int64_t * mutex) {
    // 0x100003f3c
    return _pthread_cond_wait(cond, mutex);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003f48
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * retval) {
    // 0x100003f54
    _pthread_exit(retval);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t th, int64_t ** thread_return) {
    // 0x100003f60
    return _pthread_join(th, thread_return);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int64_t * mutex) {
    // 0x100003f6c
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int64_t * mutex) {
    // 0x100003f78
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(int32_t seconds) {
    // 0x100003f84
    return _sleep(seconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

