//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b70(void);
int64_t function_100003ef0(int64_t a1);
int32_t function_100003efc(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f08(char * filename, char * modes);
int32_t function_100003f14(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f20(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b70 - 0x100003d64
int64_t function_100003b70(void) {
    int64_t v1 = 0;
    int32_t v2 = 0; // 0x100003d1c
    int64_t v3; // 0x100003b70
    int32_t v4; // 0x100003b70
    int32_t v5; // 0x100003b70
    int32_t v6; // 0x100003b70
    char v7; // 0x100003ba0
    int32_t v8; // 0x100003b70
    while (true) {
      lab_0x100003b98:
        // 0x100003b98
        v5 = v4;
        v3 = v1;
        int64_t v9; // 0x100003b70
        v7 = *(char *)(v3 + v9);
        v8 = v7;
        if (v7 < 48 == (47 - v8 & v8) < 0) {
            int32_t v10 = v8 - 57; // 0x100003bc0
            if (v10 == 0 || v10 < 0 != (56 - v8 & v8) < 0) {
                // 0x100003bd0
                v6 = v8 - 48;
                goto lab_0x100003cc4;
            } else {
                goto lab_0x100003be8;
            }
        } else {
            goto lab_0x100003be8;
        }
    }
    // 0x100003d38
    return (10 - v2 % 10) % 10;
  lab_0x100003be8:
    if (v7 < 65 == (64 - v8 & v8) < 0) {
        int32_t v11 = v8 - 90; // 0x100003c10
        if (v11 == 0 || v11 < 0 != (89 - v8 & v8) < 0) {
            // 0x100003c20
            v6 = v8 - 55;
            goto lab_0x100003cc4;
        } else {
            goto lab_0x100003c3c;
        }
    } else {
        goto lab_0x100003c3c;
    }
  lab_0x100003c3c:
    // 0x100003c3c
    v6 = 36;
    switch (v7) {
        case 42: {
            goto lab_0x100003cc4;
        }
        case 64: {
            // 0x100003c80
            v6 = 37;
            goto lab_0x100003cc4;
        }
        case 35: {
            // 0x100003ca8
            v6 = 38;
            goto lab_0x100003cc4;
        }
        default: {
            // 0x100003cc4
            v6 = v5;
            goto lab_0x100003cc4;
        }
    }
  lab_0x100003cc4:;
    int32_t v12 = v6 << (int32_t)(v3 != (int64_t)(2 * (int32_t)v3 / 2));
    v2 = v12 % 10 + v2 + v12 / 10;
    v1 = v3 + 1;
    v4 = v12;
    if (v1 == 8) {
        return (10 - v2 % 10) % 10;
    }
    goto lab_0x100003b98;
}

// Address range: 0x100003d64 - 0x100003ef0
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d78
    int32_t v2; // 0x100003d64
    int64_t v3; // 0x100003d64
    if ((int32_t)v3 == 1) {
        // 0x100003da0
        v2 = _printf("Usage : %s <full path of CUSIP Data file>", (char *)v3);
    } else {
        struct _IO_FILE * v4 = _fopen((char *)*(int64_t *)(v3 + 8), "r"); // 0x100003dd0
        _fscanf(v4, "%d", (int64_t *)v3);
        _printf("CUSIP       Verdict\n");
        _printf("-------------------");
        int32_t v5; // 0x100003d64
        int32_t v6 = -v5; // 0x100003e1c
        if (v6 < 0 != (v5 & v6) < 0) {
            int32_t v7 = 0; // 0x100003ea4
            _fscanf(v4, "%s", (char **)v3);
            function_100003b70();
            _printf("\n%s : %s", "%s", (char *)v3);
            v7++;
            while (v7 - v5 < 0 != ((v7 - v5 ^ v7) & (v7 ^ v5)) < 0) {
                // 0x100003e2c
                _fscanf(v4, "%s", (char **)v3);
                function_100003b70();
                _printf("\n%s : %s", "%s", (char *)v3);
                v7++;
            }
        }
        // 0x100003eb0
        v2 = _fclose(v4);
    }
    // 0x100003ebc
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003edc
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003ee0
    return 0;
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t function_100003ef0(int64_t a1) {
    // 0x100003ef0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(struct _IO_FILE * stream) {
    // 0x100003efc
    return _fclose(stream);
}

// Address range: 0x100003f08 - 0x100003f14
struct _IO_FILE * function_100003f08(char * filename, char * modes) {
    // 0x100003f08
    return _fopen(filename, modes);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f14
    return _fscanf(stream, format);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * format, ...) {
    // 0x100003f20
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

