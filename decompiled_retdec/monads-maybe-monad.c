//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b1c(void);
int64_t function_100003bc0(void);
int64_t function_100003ca0(int64_t result, int64_t a2);
int64_t function_100003ccc(int64_t result, int64_t a2);
int64_t function_100003d64(void);
int64_t function_100003dc8(void);
int64_t * function_100003f48(int32_t size);
int32_t function_100003f54(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b1c - 0x100003bc0
int64_t function_100003b1c(void) {
    // 0x100003b1c
    int32_t result; // 0x100003b1c
    int64_t v1; // 0x100003b1c
    switch (*(int32_t *)(v1 + 16)) {
        case 0: {
            // 0x100003b44
            result = _printf("Just %d : INT\n", v1);
            // break -> 0x100003bb4
            break;
        }
        case 1: {
            // 0x100003b80
            result = _printf("Just \"%s\" : STRING\n", (char *)v1);
            // break -> 0x100003bb4
            break;
        }
        default: {
            // 0x100003ba0
            result = _printf("Nothing\n");
            // break -> 0x100003bb4
            break;
        }
    }
    // 0x100003bb4
    return result;
}

// Address range: 0x100003bc0 - 0x100003ca0
int64_t function_100003bc0(void) {
    // 0x100003bc0
    int64_t v1; // 0x100003bc0
    int32_t v2 = v1; // 0x100003bd0
    int64_t * v3 = _malloc(24); // 0x100003bd8
    if (v2 == 0) {
        // 0x100003bf4
        *(int32_t *)v3 = (int32_t)v1;
        int64_t result = (int64_t)v3;
        *(int64_t *)(result + 8) = 0;
        *(int32_t *)(result + 16) = 0;
        *(char *)(result + 20) = 1;
        // 0x100003c90
        return result;
    }
    // 0x100003c24
    *(int32_t *)v3 = 0;
    int64_t result2 = (int64_t)v3;
    if (v2 == 1) {
        // 0x100003c38
        *(int32_t *)(result2 + 16) = 1;
        *(char *)(result2 + 20) = 1;
    } else {
        // 0x100003c68
        *(int64_t *)(result2 + 8) = 0;
        *(int32_t *)(result2 + 16) = 0;
        *(char *)(result2 + 20) = 0;
    }
    // 0x100003c90
    return result2;
}

// Address range: 0x100003ca0 - 0x100003ccc
int64_t function_100003ca0(int64_t result, int64_t a2) {
    // 0x100003ca0
    _malloc(24);
    return result;
}

// Address range: 0x100003ccc - 0x100003d64
int64_t function_100003ccc(int64_t result, int64_t a2) {
    // 0x100003ccc
    int64_t v1; // 0x100003ccc
    if (*(char *)(v1 + 20) % 2 != 0) {
        // 0x100003cd8
        return *(int64_t *)(v1 - 8);
    }
    // 0x100003d30
    *(int32_t *)result = 0;
    *(int64_t *)(result + 8) = 0;
    *(int32_t *)(result + 16) = 0;
    *(char *)(result + 20) = 0;
    return result;
}

// Address range: 0x100003d64 - 0x100003dc8
int64_t function_100003d64(void) {
    int64_t * v1 = _malloc(24); // 0x100003d78
    int64_t v2; // 0x100003d64
    int32_t v3 = v2;
    *(int32_t *)v1 = v3 * v3;
    int64_t result = (int64_t)v1; // 0x100003d9c
    *(int64_t *)(result + 8) = 0;
    *(int32_t *)(result + 16) = 0;
    *(char *)(result + 20) = 1;
    return result;
}

// Address range: 0x100003dc8 - 0x100003e9c
int64_t function_100003dc8(void) {
    int64_t * v1 = _malloc(24); // 0x100003ddc
    int64_t result = (int64_t)v1; // 0x100003ddc
    *(int32_t *)v1 = 0;
    int64_t v2; // 0x100003dc8
    int64_t v3 = (int64_t)_malloc((int32_t)v2 + 1);
    int64_t * v4 = (int64_t *)(result + 8); // 0x100003e04
    *v4 = v3;
    int64_t v5; // 0x100003dc8
    int32_t v6 = *(int32_t *)&v5; // 0x100003e18
    int32_t v7 = -v6; // 0x100003e1c
    int32_t v8 = 0; // 0x100003e24
    int32_t v9 = v6; // 0x100003e24
    int64_t v10 = v3; // 0x100003e24
    if (v7 < 0 != (v6 & v7) < 0) {
        *(char *)(v3 + (int64_t)v8) = 120;
        v8++;
        int32_t v11 = *(int32_t *)&v5; // 0x100003e18
        int32_t v12 = v8 - v11; // 0x100003e1c
        int64_t v13 = *v4;
        v9 = v11;
        v10 = v13;
        while (v12 < 0 != ((v12 ^ v8) & (v11 ^ v8)) < 0) {
            // 0x100003e2c
            *(char *)(v13 + (int64_t)v8) = 120;
            v8++;
            v11 = *(int32_t *)&v5;
            v12 = v8 - v11;
            v13 = *v4;
            v9 = v11;
            v10 = v13;
        }
    }
    // 0x100003e58
    *(char *)(v10 + (int64_t)(v9 + 1)) = 0;
    *(int32_t *)(result + 16) = 1;
    *(char *)(result + 20) = 1;
    return result;
}

// Address range: 0x100003e9c - 0x100003f48
int64_t entry_point(void) {
    int64_t v1 = function_100003bc0(); // 0x100003ec8
    function_100003bc0();
    function_100003b1c();
    function_100003b1c();
    function_100003ca0(v1, 0x100003d64);
    function_100003b1c();
    function_100003ca0(v1, 0x100003dc8);
    function_100003b1c();
    function_100003ca0(function_100003ca0(v1, 0x100003d64), 0x100003dc8);
    function_100003b1c();
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int32_t size) {
    // 0x100003f48
    return _malloc(size);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

