//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038e4(void);
int64_t function_1000039bc(void);
int64_t function_100003b20(void);
int64_t function_100003ee8(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ef4(void);
int32_t function_100003f00(char * nptr);
int32_t function_100003f0c(struct _IO_FILE * stream, char * format, ...);
void function_100003f18(int64_t * ptr);
int64_t * function_100003f24(int32_t size);
int32_t function_100003f30(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
int32_t _atoi(char * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000038e4 - 0x1000039bc
int64_t function_1000038e4(void) {
    // 0x1000038e4
    int64_t v1; // 0x1000038e4
    char * v2 = (char *)v1; // 0x1000038ec
    uint32_t v3 = (int32_t)v1; // 0x1000038f8
    int64_t v4 = (int64_t)v2 + 1; // 0x100003914
    char * v5 = (char *)v4;
    *v2 = (char)(v3 % 20);
    while (v3 >= 20) {
        // 0x1000038fc
        v3 /= 20;
        char * v6 = v5;
        v4 = (int64_t)v6 + 1;
        v5 = (char *)v4;
        *v6 = (char)(v3 % 20);
    }
    char * v7 = v5; // 0x100003968
    if (v5 == v2 || v5 < v2) {
        // 0x1000039b0
        return v4 - v1;
    }
    v7 = (char *)((int64_t)v7 - 1);
    *v7 = *v2;
    char * v8 = (char *)((int64_t)v2 + 1); // 0x1000039a4
    *v2 = *v7;
    while (v7 != v8 && v7 >= v8) {
        char * v9 = v8;
        v7 = (char *)((int64_t)v7 - 1);
        *v7 = *v9;
        v8 = (char *)((int64_t)v9 + 1);
        *v9 = *v7;
    }
    // 0x1000039b0
    return v4 - v1;
}

// Address range: 0x1000039bc - 0x100003b20
int64_t function_1000039bc(void) {
    int64_t v1 = 4;
    int64_t v2; // 0x1000039bc
    int32_t v3 = v2;
    int32_t v4 = 5 - v3; // 0x100003a14
    int32_t v5 = v4 < 0 == (v4 & v3) < 0 ? v3 : 5;
    int32_t v6 = -v5; // 0x100003a44
    int64_t * v7 = v5 == 0 | v6 < 0 != (v5 & v6) < 0 ? (int64_t *)((int64_t)(8 * v5) + (int64_t)"<?") : (int64_t *)"<?"; // 0x100003aac
    int64_t result = ___memcpy_chk(v1 * v2 + v2, *v7, 4, -1); // 0x100003ab8
    v1--;
    int32_t v8 = v3 - 5; // 0x100003ad0
    while (v1 != 0) {
        // 0x1000039f4
        v3 = v8;
        v4 = 5 - v3;
        v5 = v4 < 0 == (v4 & v3) < 0 ? v3 : 5;
        v6 = -v5;
        v7 = v5 == 0 | v6 < 0 != (v5 & v6) < 0 ? (int64_t *)((int64_t)(8 * v5) + (int64_t)"<?") : (int64_t *)"<?";
        result = ___memcpy_chk(v1 * v2 + v2, *v7, 4, -1);
        v1--;
        v8 = v3 - 5;
    }
    if (v8 == -20) {
        // 0x100003af0
        *(char *)((4 * v2 | 1) + v2) = 64;
    }
    // 0x100003b14
    return result;
}

// Address range: 0x100003b20 - 0x100003e0c
int64_t function_100003b20(void) {
    int64_t result = 0; // 0x100003b4c
    int64_t v1; // 0x100003b20
    if ((int32_t)v1 != 0) {
        uint64_t v2 = function_1000038e4(); // 0x100003b64
        uint64_t v3 = 5 * v2 + 2; // 0x100003b78
        int64_t * v4 = _malloc(6 * (int32_t)v3 | 1); // 0x100003b90
        result = 0;
        if (v4 != NULL) {
            int64_t v5 = (int64_t)v4; // 0x100003b90
            *(char *)(6 * v3 + v5) = 0;
            int64_t v6 = v5; // 0x100003bec
            if (v3 != 0) {
                ___memcpy_chk(v5, (int64_t)"+----", 5, -1);
                int32_t v7 = 5; // 0x100003c14
                int64_t v8 = v5 + 5; // 0x100003c20
                int32_t v9 = v7; // 0x100003bec
                int64_t v10 = v8; // 0x100003bec
                v6 = v8;
                while (v3 > (int64_t)v7) {
                    // 0x100003bf4
                    ___memcpy_chk(v10, (int64_t)"+----", 5, -1);
                    v7 = v9 + 5;
                    v8 = v10 + 5;
                    v9 = v7;
                    v10 = v8;
                    v6 = v8;
                }
            }
            // 0x100003c2c
            ___memcpy_chk(v6 - 5, (int64_t)"+\n", 2, -1);
            ___memcpy_chk(5 * v3 + v5, v5, v3, -1);
            int64_t v11 = v3 + v5; // 0x100003c78
            int64_t v12 = v11; // 0x100003c98
            if (v3 != 0) {
                ___memcpy_chk(v11, (int64_t)"|    ", 5, -1);
                int32_t v13 = 5; // 0x100003cc0
                int64_t v14 = v11 + 5; // 0x100003ccc
                int32_t v15 = v13; // 0x100003c98
                int64_t v16 = v14; // 0x100003c98
                v12 = v14;
                while (v3 > (int64_t)v13) {
                    // 0x100003ca0
                    ___memcpy_chk(v16, (int64_t)"|    ", 5, -1);
                    v13 = v15 + 5;
                    v14 = v16 + 5;
                    v15 = v13;
                    v16 = v14;
                    v12 = v14;
                }
            }
            // 0x100003cd8
            ___memcpy_chk(v12 - 5, (int64_t)"|\n", 2, -1);
            int64_t v17 = 2 * v3; // 0x100003d0c
            ___memcpy_chk(v17 + v5, v11, v3, -1);
            ___memcpy_chk(3 * v3 + v5, v11, v17, -1);
            result = v5;
            if (v2 != 0) {
                function_1000039bc();
                int32_t v18 = 1; // 0x100003db8
                int32_t v19 = v18; // 0x100003d74
                result = v5;
                while (v2 > (int64_t)v18) {
                    // 0x100003d7c
                    function_1000039bc();
                    v18 = v19 + 1;
                    v19 = v18;
                    result = v5;
                }
            }
        }
    }
    int64_t v20 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003de4
    if (v20 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003df8
        ___stack_chk_fail();
    }
    // 0x100003dfc
    return result;
}

// Address range: 0x100003e0c - 0x100003ee8
int64_t entry_point(void) {
    // 0x100003e0c
    int64_t v1; // 0x100003e0c
    if ((int32_t)v1 != 2) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003e40
        _fprintf((struct _IO_FILE *)v2, "usage: mayan <number>\n");
        // 0x100003ed8
        return 1;
    }
    // 0x100003e5c
    int64_t result; // 0x100003e0c
    if (_atoi((char *)*(int64_t *)(v1 + 8)) < 1) {
        int64_t v3 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003e88
        _fprintf((struct _IO_FILE *)v3, "number must be positive\n");
        result = 1;
    } else {
        int64_t v4 = function_100003b20(); // 0x100003ea8
        _printf("%s", (char *)v1);
        _free((int64_t *)v4);
        result = 0;
    }
    // 0x100003ed8
    return result;
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ee8
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(void) {
    // 0x100003ef4
    return ___stack_chk_fail();
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * nptr) {
    // 0x100003f00
    return _atoi(nptr);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f0c
    return _fprintf(stream, format);
}

// Address range: 0x100003f18 - 0x100003f24
void function_100003f18(int64_t * ptr) {
    // 0x100003f18
    _free(ptr);
}

// Address range: 0x100003f24 - 0x100003f30
int64_t * function_100003f24(int32_t size) {
    // 0x100003f24
    return _malloc(size);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * format, ...) {
    // 0x100003f30
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

