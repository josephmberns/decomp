//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000397c(void);
int64_t function_100003a10(void);
int64_t function_100003b48(void);
int64_t function_100003c80(void);
int32_t function_100003f28(int32_t x);
int32_t function_100003f34(char * nptr);
int64_t * function_100003f40(int32_t nmemb, int32_t size);
void function_100003f4c(int64_t * ptr);
float64_t function_100003f58(float64_t a1);
float64_t function_100003f64(float64_t a1, float64_t a2);
int32_t function_100003f70(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _abs(int32_t a1);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
float64_t _log10(float64_t a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000397c - 0x100003a10
int64_t function_10000397c(void) {
    // 0x10000397c
    int64_t v1; // 0x10000397c
    uint64_t v2 = v1;
    uint32_t v3 = (int32_t)v2; // 0x100003984
    int64_t result = 0; // 0x100003994
    if (v3 >= 2 && v3 != 2 != (v3 % 2 == 0)) {
        int32_t v4 = *(int32_t *)((v2 / 16 & 0xffffffc) + v1); // 0x1000039d8
        result = (v4 & 1 << v3 / 2 % 32) == 0;
    }
    // 0x100003a04
    return result;
}

// Address range: 0x100003a10 - 0x100003b48
int64_t function_100003a10(void) {
    // 0x100003a10
    float64_t v1; // 0x100003a10
    float64_t v2 = v1;
    int64_t v3; // 0x100003a10
    uint32_t v4 = (int32_t)v3; // 0x100003a1c
    int64_t result = (int64_t)_calloc(v4 / 64 + 1, 4); // 0x100003a38
    float64_t v5 = sqrt(v1); // 0x100003a64
    float64_t v6 = v5; // 0x100003a70
    if (v2 <= v5 == (v2 != v5)) {
        // 0x100003b38
        return result;
    }
    uint32_t v7 = 3;
    int32_t v8 = *(int32_t *)((int64_t)(4 * v7 / 64) + result); // 0x100003a84
    int32_t v9; // 0x100003ab4
    int32_t * v10; // 0x100003afc
    if ((1 << v7 / 2 % 32 & v8) == 0) {
        // 0x100003aac
        v9 = v7 * v7;
        if (v9 < v4) {
            for (int32_t i = v9; i < v4; i += 2 * v7) {
                // 0x100003ad8
                v10 = (int32_t *)((int64_t)(4 * i / 64) + result);
                *v10 = 1 << i / 2 % 32 | *v10;
            }
        }
    }
    // 0x100003b28
    v6 = sqrt(v6);
    int32_t v11 = v7 + 2; // 0x100003a70
    while (v2 <= v6 != v2 != v6) {
        // 0x100003a78
        v7 = v11;
        v8 = *(int32_t *)((int64_t)(4 * v7 / 64) + result);
        if ((1 << v7 / 2 % 32 & v8) == 0) {
            // 0x100003aac
            v9 = v7 * v7;
            if (v9 < v4) {
                for (int32_t i = v9; i < v4; i += 2 * v7) {
                    // 0x100003ad8
                    v10 = (int32_t *)((int64_t)(4 * i / 64) + result);
                    *v10 = 1 << i / 2 % 32 | *v10;
                }
            }
        }
        // 0x100003b28
        v6 = sqrt(v6);
        v11 = v7 + 2;
    }
    // 0x100003b38
    return result;
}

// Address range: 0x100003b48 - 0x100003c80
int64_t function_100003b48(void) {
    // 0x100003b48
    int64_t v1; // 0x100003b48
    int32_t v2 = v1; // 0x100003b5c
    int32_t v3 = _abs((int32_t)v1 - (v2 - 1) / 2); // 0x100003b94
    int32_t v4 = _abs((int32_t)v1 - v2 / 2); // 0x100003ba0
    int32_t v5 = v3 - v4; // 0x100003bb0
    int32_t v6 = v5 == 0 | v5 < 0 != ((v5 ^ v3) & (v4 ^ v3)) < 0 ? v4 : v3;
    int128_t v7; // 0x100003b48
    _pow((float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
    __asm_sshll(0.0f, 0);
    return (float64_t)(2 * v6 - 1) + 2.0;
}

// Address range: 0x100003c80 - 0x100003e90
int64_t function_100003c80(void) {
    // 0x100003c80
    int64_t v1; // 0x100003c80
    int32_t v2 = v1; // 0x100003c9c
    int64_t v3 = v1 - (int64_t)(2 * v2 / 2 == v2); // 0x100003cc4
    int128_t v4; // 0x100003c80
    _log10((float64_t)(int64_t)v4);
    int64_t v5 = function_100003a10(); // 0x100003d0c
    int32_t v6 = v3; // 0x100003d20
    int32_t v7 = -v6;
    if (v7 < 0 == (v7 & v6) < 0) {
        // 0x100003e7c
        _free((int64_t *)v5);
        return &g1;
    }
    int64_t v8 = v3 & 0xffffffff;
    int32_t v9 = 0; // 0x100003e70
    int32_t v10 = 0; // 0x100003e50
    int64_t v11 = 0x100000000000000 * function_100003b48() >> 56;
    int64_t v12 = function_10000397c();
    int64_t v13; // 0x100003c80
    if ((uint64_t)v1 % 256 == 0) {
        // 0x100003d7c
        v13 = v11 & 0xffffffff;
        if ((int32_t)v12 == 0) {
            // 0x100003dc4
            _printf("%.*s ", v13, (char *)v8);
        } else {
            // 0x100003d98
            _printf("%*d ", v13, v8);
        }
    } else {
        // 0x100003df0
        _printf("%c", (char)v11);
    }
    // 0x100003e4c
    v10++;
    while (v10 - v6 < 0 != ((v10 - v6 ^ v10) & (v10 ^ v6)) < 0) {
        // 0x100003d54
        v11 = 0x100000000000000 * function_100003b48() >> 56;
        v12 = function_10000397c();
        if ((uint64_t)v1 % 256 == 0) {
            // 0x100003d7c
            v13 = v11 & 0xffffffff;
            if ((int32_t)v12 == 0) {
                // 0x100003dc4
                _printf("%.*s ", v13, (char *)v8);
            } else {
                // 0x100003d98
                _printf("%*d ", v13, v8);
            }
        } else {
            // 0x100003df0
            _printf("%c", (char)v11);
        }
        // 0x100003e4c
        v10++;
    }
    // 0x100003e5c
    _printf((char *)0x100003f9c);
    v9++;
    while (v9 - v6 < 0 != ((v9 - v6 ^ v9) & (v9 ^ v6)) < 0) {
        // 0x100003d54
        v10 = 0;
        v11 = 0x100000000000000 * function_100003b48() >> 56;
        v12 = function_10000397c();
        if ((uint64_t)v1 % 256 == 0) {
            // 0x100003d7c
            v13 = v11 & 0xffffffff;
            if ((int32_t)v12 == 0) {
                // 0x100003dc4
                _printf("%.*s ", v13, (char *)v8);
            } else {
                // 0x100003d98
                _printf("%*d ", v13, v8);
            }
        } else {
            // 0x100003df0
            _printf("%c", (char)v11);
        }
        // 0x100003e4c
        v10++;
        while (v10 - v6 < 0 != ((v10 - v6 ^ v10) & (v10 ^ v6)) < 0) {
            // 0x100003d54
            v11 = 0x100000000000000 * function_100003b48() >> 56;
            v12 = function_10000397c();
            if ((uint64_t)v1 % 256 == 0) {
                // 0x100003d7c
                v13 = v11 & 0xffffffff;
                if ((int32_t)v12 == 0) {
                    // 0x100003dc4
                    _printf("%.*s ", v13, (char *)v8);
                } else {
                    // 0x100003d98
                    _printf("%*d ", v13, v8);
                }
            } else {
                // 0x100003df0
                _printf("%c", (char)v11);
            }
            // 0x100003e4c
            v10++;
        }
        // 0x100003e5c
        _printf((char *)0x100003f9c);
        v9++;
    }
    // 0x100003e7c
    _free((int64_t *)v5);
    return &g1;
}

// Address range: 0x100003e90 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003e90
    int64_t v1; // 0x100003e90
    int32_t v2 = v1; // 0x100003ea0
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        // 0x100003ec8
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    // 0x100003edc
    function_100003c80();
    _printf("\n");
    function_100003c80();
    _printf("\n");
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(int32_t x) {
    // 0x100003f28
    return _abs(x);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * nptr) {
    // 0x100003f34
    return _atoi(nptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t nmemb, int32_t size) {
    // 0x100003f40
    return _calloc(nmemb, size);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * ptr) {
    // 0x100003f4c
    _free(ptr);
}

// Address range: 0x100003f58 - 0x100003f64
float64_t function_100003f58(float64_t a1) {
    // 0x100003f58
    return _log10(a1);
}

// Address range: 0x100003f64 - 0x100003f70
float64_t function_100003f64(float64_t a1, float64_t a2) {
    // 0x100003f64
    return _pow(a1, a2);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

