//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003704(void);
int64_t function_1000037c0(void);
int64_t function_1000038ac(void);
int64_t function_1000039e0(void);
int64_t function_100003f00(char * a1, char * a2, int64_t a3, char * a4);
int32_t function_100003f0c(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1 = "\xcf\xfa\xed\xfe\f"; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003704 - 0x1000037c0
int64_t function_100003704(void) {
    int64_t v1 = 0;
    int32_t v2 = 0; // 0x100003704
    int64_t v3 = 0;
    int32_t v4 = 0; // 0x100003704
    int64_t v5 = 8 * (v3 + 10 * v1); // 0x100003760
    *(char *)(v5 + (int64_t)&g1) = (char)v2;
    *(char *)(v5 + (int64_t)&g1 + 1) = (char)v4;
    *(int32_t *)(v5 + (int64_t)&g1 + 4) = 0;
    v3++;
    v4++;
    while (v3 != 10) {
        // 0x100003740
        v5 = 8 * (v3 + 10 * v1);
        *(char *)(v5 + (int64_t)&g1) = (char)v2;
        *(char *)(v5 + (int64_t)&g1 + 1) = (char)v4;
        *(int32_t *)(v5 + (int64_t)&g1 + 4) = 0;
        v3++;
        v4++;
    }
    // 0x1000037a8
    v1++;
    v2++;
    while (v1 != 10) {
        // 0x10000372c
        v3 = 0;
        v4 = 0;
        v5 = 8 * (v3 + 10 * v1);
        *(char *)(v5 + (int64_t)&g1) = (char)v2;
        *(char *)(v5 + (int64_t)&g1 + 1) = (char)v4;
        *(int32_t *)(v5 + (int64_t)&g1 + 4) = 0;
        v3++;
        v4++;
        while (v3 != 10) {
            // 0x100003740
            v5 = 8 * (v3 + 10 * v1);
            *(char *)(v5 + (int64_t)&g1) = (char)v2;
            *(char *)(v5 + (int64_t)&g1 + 1) = (char)v4;
            *(int32_t *)(v5 + (int64_t)&g1 + 4) = 0;
            v3++;
            v4++;
        }
        // 0x1000037a8
        v1++;
        v2++;
    }
    // 0x1000037b8
    int64_t result; // 0x100003704
    return result;
}

// Address range: 0x1000037c0 - 0x1000038ac
int64_t function_1000037c0(void) {
    // 0x1000037c0
    int64_t result; // 0x1000037c0
    char v1 = (int32_t)result % 10;
    int32_t v2 = 0;
    uint64_t v3 = 0;
    int64_t v4 = 8 * v3; // 0x10000381c
    char v5 = *(char *)(v4 + (int64_t)&g1); // 0x100003828
    if (v5 == (char)((int32_t)result % 10)) {
        // 0x100003840
        if (*(char *)(v4 + (int64_t)&g1 + 1) == v1) {
            // break -> 0x10000386c
            break;
        }
    }
    int64_t v6 = v3 + 1;
    int32_t v7 = v2 + 1; // 0x10000380c
    while (v3 < 99 != (98 - v2 & (int32_t)v6) < 0) {
        // 0x100003814
        v2 = v7;
        v3 = v6;
        v4 = 8 * v3;
        v5 = *(char *)(v4 + (int64_t)&g1);
        if (v5 == (char)((int32_t)result % 10)) {
            // 0x100003840
            if (*(char *)(v4 + (int64_t)&g1 + 1) == v1) {
                // break -> 0x10000386c
                break;
            }
        }
        // 0x100003894
        v6 = v3 + 1;
        v7 = v2 + 1;
    }
    // 0x1000038a4
    return result;
}

// Address range: 0x1000038ac - 0x1000039e0
int64_t function_1000038ac(void) {
    int64_t v1; // 0x1000038ac
    int64_t result = _printf("%d primes, last prime considered: %d\n", v1, v1);
    for (int64_t i = 0; i < 100; i++) {
        int64_t v2 = result; // 0x100003920
        if (*(int32_t *)(8 * i + (int64_t)&g1 + 4) != 0) {
            // 0x100003928
            __asm_sshll(0.0f, 0);
            int128_t v3; // 0x1000038ac
            v2 = _printf("%d->%d  count: %5d  frequency: %.2f\n", v1, v1, v1, (float64_t)(int64_t)v3);
        }
        // 0x1000039c4
        result = v2;
    }
    // 0x1000039d4
    return result;
}

// Address range: 0x1000039e0 - 0x100003ddc
int64_t function_1000039e0(void) {
    // 0x1000039e0
    int64_t v1; // 0x1000039e0
    int32_t v2 = v1; // 0x1000039ec
    if (2 * v2 / 2 == v2) {
        // 0x100003dc8
        return v2 == 2;
    }
    if (v2 % 3 == 0) {
        // 0x100003dc8
        return v2 == 3;
    }
    if (v2 % 5 == 0) {
        // 0x100003dc8
        return v2 == 5;
    }
    if (v2 % 7 == 0) {
        // 0x100003dc8
        return v2 == 7;
    }
    if (v2 % 11 == 0) {
        // 0x100003dc8
        return v2 == 11;
    }
    if (v2 % 13 == 0) {
        // 0x100003dc8
        return v2 == 13;
    }
    if (v2 % 17 == 0) {
        // 0x100003dc8
        return v2 == 17;
    }
    if (v2 % 19 == 0) {
        // 0x100003dc8
        return v2 == 19;
    }
    int32_t v3 = 529 - v2; // 0x100003c24
    int32_t v4 = 529; // 0x100003c2c
    int32_t v5 = 216; // 0x100003c2c
    int32_t v6 = 96; // 0x100003c2c
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003dc8
        return true;
    }
    int32_t v7 = 23;
    bool result = false; // 0x100003c50
    while (v2 % v7 != 0) {
        int32_t v8 = v5;
        int32_t v9 = v6 + v4; // 0x100003c74
        int32_t v10 = v7 + 2; // 0x100003c80
        if (v10 * v10 != v9) {
            // 0x100003cc0
            ___assert_rtn("isPrime", "prime-conspiracy.c", 77, "t * t == s");
        }
        int32_t v11 = v9 - v2; // 0x100003cec
        int32_t v12 = v10; // 0x100003cf4
        v5 = v8;
        int32_t v13 = v9; // 0x100003cf4
        if (v11 == 0 || v11 < 0 != ((v11 ^ v9) & (v9 ^ v2)) < 0) {
            // 0x100003cfc
            result = false;
            if (v2 % v10 == 0) {
                // break -> 0x100003dc8
                break;
            }
            int32_t v14 = v9 + v8; // 0x100003d3c
            int32_t v15 = v7 + 6; // 0x100003d48
            int32_t v16 = v8 + 48; // 0x100003d54
            v12 = v15;
            v5 = v16;
            v13 = v14;
            if (v15 * v15 != v14) {
                // 0x100003d88
                ___assert_rtn("isPrime", "prime-conspiracy.c", 86, "t * t == s");
                v12 = v15;
                v5 = v16;
                v13 = v14;
            }
        }
        // 0x100003db0
        v4 = v13;
        int32_t v17 = v4 - v2; // 0x100003c24
        v6 += 24;
        result = true;
        if (v17 != 0 && v17 < 0 == ((v17 ^ v4) & (v4 ^ v2)) < 0) {
            // break -> 0x100003dc8
            break;
        }
        v7 = v12;
        result = false;
    }
    // 0x100003dc8
    return result;
}

// Address range: 0x100003ddc - 0x100003f00
int64_t entry_point(void) {
    // 0x100003ddc
    function_100003704();
    function_1000037c0();
    int32_t v1 = 2;
    int32_t v2 = v1; // 0x100003e4c
    if (function_1000039e0() % 2 != 0) {
        // 0x100003e54
        function_1000037c0();
        v2 = v1 + 1;
    }
    int32_t v3 = v2;
    int32_t v4 = v3 - 0xf4240;
    int32_t v5 = 0xf423f - v3 & v3;
    int32_t v6 = v5; // 0x100003e94
    int32_t v7 = v4; // 0x100003e94
    int32_t v8 = v3; // 0x100003e94
    int32_t v9; // 0x100003ec4
    if (v4 < 0 != v5 < 0) {
        // 0x100003e9c
        v6 = v5;
        v7 = v4;
        v8 = v3;
        if (function_1000039e0() % 2 != 0) {
            // 0x100003eac
            function_1000037c0();
            v9 = v3 + 1;
            v6 = 0xf423e - v3 & v9;
            v7 = v3 - 0xf423f;
            v8 = v9;
        }
    }
    while (v7 < 0 != v6 < 0) {
        // 0x100003e44
        v1 = v8;
        v2 = v1;
        if (function_1000039e0() % 2 != 0) {
            // 0x100003e54
            function_1000037c0();
            v2 = v1 + 1;
        }
        // 0x100003e78
        v3 = v2;
        v4 = v3 - 0xf4240;
        v5 = 0xf423f - v3 & v3;
        v6 = v5;
        v7 = v4;
        v8 = v3;
        if (v4 < 0 != v5 < 0) {
            // 0x100003e9c
            v6 = v5;
            v7 = v4;
            v8 = v3;
            if (function_1000039e0() % 2 != 0) {
                // 0x100003eac
                function_1000037c0();
                v9 = v3 + 1;
                v6 = 0xf423e - v3 & v9;
                v7 = v3 - 0xf423f;
                v8 = v9;
            }
        }
    }
    // 0x100003ee4
    function_1000038ac();
    return 0;
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t function_100003f00(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003f00
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * format, ...) {
    // 0x100003f0c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

