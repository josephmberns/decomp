//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c80(void);
int64_t function_100003d58(void);
int64_t function_100003f20(void);
int64_t function_100003f5c(int64_t a1);
int32_t function_100003f68(char * format, ...);
int32_t function_100003f74(void);
void function_100003f80(int32_t seed);
int32_t function_100003f8c(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b40 - 0x100003c80
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b54
    _srand(_time(NULL));
    for (int64_t i = 0; i < 16; i++) {
        // 0x100003b88
        int64_t v2; // bp-88, 0x100003b40
        *(int32_t *)(4 * i + (int64_t)&v2) = _rand() / 0x800000 - 128;
    }
    // 0x100003bb8
    function_100003c80();
    int32_t v3; // 0x100003c2c
    for (int64_t i = 0; i < 16; i++) {
        // 0x100003be0
        int64_t v4; // 0x100003b40
        v3 = _printf("%d%c", 16, (char)v4);
    }
    // 0x100003c44
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003c6c
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003c70
    return 0;
}

// Address range: 0x100003c80 - 0x100003d58
int64_t function_100003c80(void) {
    // 0x100003c80
    int64_t v1; // 0x100003c80
    if (v1 == 0) {
        // 0x100003d4c
        return function_100003d58();
    }
    int64_t v2 = 0; // 0x100003cb4
    int32_t * v3 = (int32_t *)(4 * v2 + v1); // 0x100003cc8
    *v3 = -*v3;
    v2++;
    while (v2 != v1) {
        // 0x100003cbc
        v3 = (int32_t *)(4 * v2 + v1);
        *v3 = -*v3;
        v2++;
    }
    int64_t result = function_100003d58(); // 0x100003cfc
    int64_t v4 = 0; // 0x100003d40
    int32_t * v5 = (int32_t *)(4 * v4 + v1); // 0x100003d2c
    *v5 = -*v5;
    v4++;
    while (v4 != v1) {
        // 0x100003d20
        v5 = (int32_t *)(4 * v4 + v1);
        *v5 = -*v5;
        v4++;
    }
    // 0x100003d4c
    return result;
}

// Address range: 0x100003d58 - 0x100003f20
int64_t function_100003d58(void) {
    // 0x100003d58
    int64_t v1; // 0x100003d58
    int32_t v2 = v1; // 0x100003d6c
    if (v2 == 0 || v1 < v1 + 4) {
        // 0x100003f14
        int64_t result; // 0x100003d58
        return result;
    }
    int32_t * v3 = (int32_t *)v1; // 0x100003da8
    int32_t * v4 = (int32_t *)(v1 - 4); // 0x100003db4
    int32_t * v5 = v4; // 0x100003dd8
    int32_t * v6 = v3; // 0x100003dd8
    int32_t * v7; // 0x100003d58
    if (v3 < v4) {
        while (true) {
          lab_0x100003dfc:;
            int32_t * v8 = v5;
            int32_t * v9 = v6; // 0x100003e10
            while (true) {
                // 0x100003dfc
                v6 = v9;
                v7 = v8;
                if ((*v6 & v2) != 0) {
                    goto lab_0x100003e58;
                }
                // 0x100003e08
                v9 = (int32_t *)((int64_t)v6 + 4);
                if (v8 <= v9) {
                    // break (via goto) -> 0x100003ea0
                    goto lab_0x100003ea0_2;
                }
            }
            goto lab_0x100003e90;
        }
    }
  lab_0x100003ea0_2:
    // 0x100003ea0
    function_100003d58();
    // 0x100003f14
    return function_100003d58();
  lab_0x100003e58:
    // 0x100003e58
    v5 = v7;
    if ((*v5 & v2) == 0) {
        goto lab_0x100003e90;
    } else {
        int32_t * v10 = (int32_t *)((int64_t)v5 - 4); // 0x100003e6c
        v7 = v10;
        if (v6 < v10) {
            goto lab_0x100003e58;
        } else {
            goto lab_0x100003ea0_2;
        }
    }
  lab_0x100003e90:
    // 0x100003e90
    function_100003f20();
    if (v6 >= v5) {
        // break -> 0x100003ea0
        goto lab_0x100003ea0_2;
    }
    goto lab_0x100003dfc;
}

// Address range: 0x100003f20 - 0x100003f5c
int64_t function_100003f20(void) {
    // 0x100003f20
    int64_t result; // 0x100003f20
    *(int32_t *)result = (int32_t)result;
    *(int32_t *)result = (int32_t)result;
    return result;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(int64_t a1) {
    // 0x100003f5c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(void) {
    // 0x100003f74
    return _rand();
}

// Address range: 0x100003f80 - 0x100003f8c
void function_100003f80(int32_t seed) {
    // 0x100003f80
    _srand(seed);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t * timer) {
    // 0x100003f8c
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

