//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c14(void);
int64_t function_100003f20(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int32_t function_100003f2c(int32_t fd);
void function_100003f38(int32_t status, char * format, ...);
int32_t function_100003f44(int32_t fd, struct stat * buf);
int64_t * function_100003f50(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003f5c(int64_t * addr, int32_t len);
int32_t function_100003f68(char * file, int32_t oflag, ...);
int32_t function_100003f74(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c14 - 0x100003cdc
int64_t function_100003c14(void) {
    // 0x100003c14
    int64_t v1; // 0x100003c14
    char * v2 = (char *)v1;
    uint32_t result = 1;
    int64_t v3 = (int64_t)v2 + 1; // 0x100003c30
    char * v4 = (char *)v3; // 0x100003c34
    char v5 = *v4; // 0x100003c38
    switch (v5) {
        case 10: {
        }
        case 13: {
            // 0x100003cc4
            *(int64_t *)v1 = v3;
            return result;
        }
    }
    while (v5 != 0) {
        int32_t v6 = v5; // 0x100003c9c
        char v7 = *v2; // 0x100003ca4
        int32_t v8 = v6 - (int32_t)v7; // 0x100003ca8
        int32_t v9 = v8 < 0 == ((v8 ^ v6) & (int32_t)(v7 ^ v5)) < 0 ? result : 0;
        v2 = v4;
        result = v9;
        v3 = (int64_t)v2 + 1;
        v4 = (char *)v3;
        v5 = *v4;
        switch (v5) {
            case 10: {
            }
            case 13: {
                // 0x100003cc4
                *(int64_t *)v1 = v3;
                return result;
            }
        }
    }
    // 0x100003cc4
    *(int64_t *)v1 = v3;
    return result;
}

// Address range: 0x100003cdc - 0x100003f20
int64_t entry_point(void) {
    int32_t v1 = _open("unixdict.txt", 0); // 0x100003d04
    if (v1 == -1) {
        // 0x100003d1c
        _err(1, "read error");
    }
    // 0x100003d2c
    int64_t v2; // bp-56, 0x100003cdc
    int64_t v3 = &v2; // 0x100003cec
    int64_t v4; // bp-200, 0x100003cdc
    _fstat(v1, (struct stat *)&v4);
    int32_t v5; // 0x100003cdc
    int64_t * v6 = _mmap(NULL, v5, 3, 2, v1, 0); // 0x100003d50
    int64_t v7 = (int64_t)v6; // 0x100003d50
    int64_t * v8 = (int64_t *)(v3 + 24); // 0x100003d5c
    *v8 = v7;
    int64_t v9 = v7; // 0x100003d68
    if (v6 == NULL) {
        // 0x100003d70
        _err(1, "mmap");
        v9 = *v8;
    }
    int64_t * v10 = (int64_t *)(v3 + 8); // 0x100003d88
    *v10 = v9;
    int64_t * v11 = (int64_t *)(v3 + 16); // 0x100003d8c
    *v11 = v9;
    int64_t v12 = *v8; // 0x100003d9c
    int64_t v13 = v5; // 0x100003da0
    int64_t v14 = v12; // 0x100003db0
    if (*v10 < v12 + v13) {
        int32_t v15 = 0;
        char v16 = *(char *)v9; // 0x100003dc4
        int64_t v17; // 0x100003cdc
        int64_t v18; // 0x100003e10
        char v19; // 0x100003dc4
        if (v16 != 13 != v16 != 10) {
            v18 = v9 + 1;
            *v11 = v18;
            v19 = *(char *)v18;
            v17 = v18;
            while (v19 != 13 != v19 != 10) {
                // 0x100003e08
                v18 = v17 + 1;
                *v11 = v18;
                v19 = *(char *)v18;
                v17 = v18;
            }
        }
        int32_t v20 = v15; // 0x100003e34
        int64_t v21; // 0x100003cdc
        int64_t v22; // 0x100003cdc
        int32_t v23; // 0x100003cdc
        int64_t v24; // 0x100003e48
        int32_t v25; // 0x100003e58
        int32_t v26; // 0x100003e60
        int64_t v27; // 0x100003e90
        int64_t v28; // 0x100003ec8
        if ((int32_t)function_100003c14() != 0) {
            // 0x100003e40
            v24 = *v11;
            v25 = (int32_t)(*v10 - v24) + 1;
            v26 = v25 - v15;
            v20 = v15;
            if (v26 < 0 == ((v26 ^ v25) & (v25 ^ v15)) < 0) {
                if (v26 == 0) {
                    // 0x100003e74
                    v21 = v24;
                    v22 = v2;
                    v23 = v15;
                } else {
                    // 0x100003e8c
                    v27 = *v8;
                    v2 = v27;
                    v21 = *v11;
                    v22 = v27;
                    v23 = v25;
                }
                // 0x100003ea4
                ___memcpy_chk(v22, v21, v25, -1);
                v28 = v2 + (int64_t)v25;
                v2 = v28;
                *(char *)v28 = 0;
                v20 = v23;
            }
        }
        int64_t v29 = *v10; // 0x100003ee0
        *v11 = v29;
        int64_t v30 = *v8; // 0x100003d9c
        v14 = v30;
        while (*v10 < v30 + v13) {
            // 0x100003dbc
            v15 = v20;
            v16 = *(char *)v29;
            v17 = v29;
            if (v16 != 13 != v16 != 10) {
                v18 = v17 + 1;
                *v11 = v18;
                v19 = *(char *)v18;
                v17 = v18;
                while (v19 != 13 != v19 != 10) {
                    // 0x100003e08
                    v18 = v17 + 1;
                    *v11 = v18;
                    v19 = *(char *)v18;
                    v17 = v18;
                }
            }
            // 0x100003e1c
            v20 = v15;
            if ((int32_t)function_100003c14() != 0) {
                // 0x100003e40
                v24 = *v11;
                v25 = (int32_t)(*v10 - v24) + 1;
                v26 = v25 - v15;
                v20 = v15;
                if (v26 < 0 == ((v26 ^ v25) & (v25 ^ v15)) < 0) {
                    if (v26 == 0) {
                        // 0x100003e74
                        v21 = v24;
                        v22 = v2;
                        v23 = v15;
                    } else {
                        // 0x100003e8c
                        v27 = *v8;
                        v2 = v27;
                        v21 = *v11;
                        v22 = v27;
                        v23 = v25;
                    }
                    // 0x100003ea4
                    ___memcpy_chk(v22, v21, v25, -1);
                    v28 = v2 + (int64_t)v25;
                    v2 = v28;
                    *(char *)v28 = 0;
                    v20 = v23;
                }
            }
            // 0x100003edc
            v29 = *v10;
            *v11 = v29;
            v30 = *v8;
            v14 = v30;
        }
    }
    // 0x100003eec
    _printf((char *)v14);
    _munmap((int64_t *)*v8, v5);
    _close(v1);
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003f20
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t fd) {
    // 0x100003f2c
    return _close(fd);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t status, char * format, ...) {
    // 0x100003f38
    _err(status, format);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(int32_t fd, struct stat * buf) {
    // 0x100003f44
    return _fstat(fd, buf);
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t * function_100003f50(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003f50
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(int64_t * addr, int32_t len) {
    // 0x100003f5c
    return _munmap(addr, len);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * file, int32_t oflag, ...) {
    // 0x100003f68
    return _open(file, oflag);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

