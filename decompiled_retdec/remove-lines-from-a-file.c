//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e7c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003e88(char * nptr);
int32_t function_100003e94(struct _IO_FILE * stream);
int32_t function_100003ea0(struct _IO_FILE * stream);
struct _IO_FILE * function_100003eac(char * filename, char * modes);
int32_t function_100003eb8(struct _IO_FILE * stream, char * format, ...);
void function_100003ec4(int64_t * ptr);
struct _IO_FILE * function_100003ed0(char * filename, char * modes, struct _IO_FILE * stream);
int32_t function_100003edc(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003ee8(struct _IO_FILE * stream);
int32_t function_100003ef4(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f00(int32_t size);
void function_100003f0c(struct _IO_FILE * stream);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _atoi(char * a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
struct _IO_FILE * _freopen(char * a1, char * a2, struct _IO_FILE * a3);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _ftell(struct _IO_FILE * a1);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
void _rewind(struct _IO_FILE * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b3c - 0x100003e7c
int64_t entry_point(void) {
    // 0x100003b3c
    int32_t result; // 0x100003b3c
    int64_t v1; // 0x100003b3c
    if ((int32_t)v1 != 4) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b88
        result = _fprintf((struct _IO_FILE *)v2, "Usage: %s <file> <start> <count>\n", (char *)v1);
        // 0x100003e6c
        return result;
    }
    int32_t v3 = _atoi((char *)*(int64_t *)(v1 + 24)); // 0x100003bb8
    if (v3 < 1 != (v3 & -v3) < 0) {
        // 0x100003e6c
        return 0;
    }
    int32_t v4 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003be0
    if (v4 < 1 != (v4 & -v4) < 0) {
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c00
        // 0x100003e6c
        return _fprintf((struct _IO_FILE *)v5, "Error: <start> (%d) must be positive\n", v1);
    }
    int64_t * v6 = (int64_t *)(v1 + 8); // 0x100003c2c
    struct _IO_FILE * v7 = _fopen((char *)*v6, "r"); // 0x100003c38
    if (v7 == NULL) {
        int64_t v8 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c5c
        // 0x100003e6c
        return _fprintf((struct _IO_FILE *)v8, "No such file: %s\n", (char *)v1);
    }
    // 0x100003c84
    _fseek(v7, 0, 2);
    int64_t * v9 = _malloc(_ftell(v7) + 1); // 0x100003ca8
    int64_t v10 = (int64_t)v9; // 0x100003ca8
    _rewind(v7);
    uint32_t v11 = _fgetc(v7); // 0x100003cc0
    *(char *)v9 = (char)v11;
    int32_t v12 = v4 + v3;
    int32_t v13 = 1; // 0x100003ce4
    int32_t v14 = 0; // 0x100003ce4
    int32_t v15 = 0; // 0x100003ce4
    int32_t v16 = 0; // 0x100003ce4
    if (v11 % 256 != 255) {
        int32_t v17 = 1;
        int32_t v18 = 0;
        int32_t v19 = 0;
        int32_t v20 = 0;
        int32_t v21 = v17; // 0x100003d00
        int32_t v22 = v18; // 0x100003d00
        int32_t v23 = v19; // 0x100003d00
        int32_t v24; // 0x100003b3c
        if (*(char *)((int64_t)v20 + v10) == 10) {
            // 0x100003d08
            v21 = v17 + 1;
            v24 = 1;
            v22 = v21 == v4 ? v24 : v18;
            v23 = v21 == v12 ? v24 : v19;
        }
        int32_t v25 = v23;
        int32_t v26 = v22;
        int32_t v27 = v21;
        uint32_t v28 = _fgetc(v7); // 0x100003cc0
        int32_t v29 = v20 + 1; // 0x100003ccc
        *(char *)((int64_t)v29 + v10) = (char)v28;
        int32_t v30 = v20; // 0x100003ce4
        v13 = v27;
        v14 = v26;
        v15 = v25;
        v16 = v29;
        while (v28 % 256 != 255) {
            // 0x100003cec
            v17 = v27;
            v18 = v26;
            v19 = v25;
            v20 = v29;
            v21 = v17;
            v22 = v18;
            v23 = v19;
            if (*(char *)((int64_t)v20 + v10) == 10) {
                // 0x100003d08
                v21 = v17 + 1;
                v24 = v30 + 2;
                v22 = v21 == v4 ? v24 : v18;
                v23 = v21 == v12 ? v24 : v19;
            }
            // 0x100003d70
            v25 = v23;
            v26 = v22;
            v27 = v21;
            v28 = _fgetc(v7);
            v29 = v20 + 1;
            *(char *)((int64_t)v29 + v10) = (char)v28;
            v30 = v20;
            v13 = v27;
            v14 = v26;
            v15 = v25;
            v16 = v29;
        }
    }
    int32_t v31 = v12 - v13; // 0x100003d84
    if (v31 == 0 || v31 < 0 != ((v31 ^ v12) & (v13 ^ v12)) < 0) {
        int32_t v32 = v16 - v15; // 0x100003dfc
        ___memmove_chk((int64_t)v14 + v10, (int64_t)v15 + v10, (int64_t)v32, -1);
        _freopen((char *)*v6, (char *)0x100003fa6, v7);
        _fwrite(v9, v32 + v14, 1, v7);
        _free(v9);
        _fclose(v7);
        result = 0;
    } else {
        // 0x100003d94
        _free(v9);
        _fclose(v7);
        int64_t v33 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dac
        result = _fprintf((struct _IO_FILE *)v33, "Error: invalid parameters for file with %d lines\n", 2);
    }
    // 0x100003e6c
    return result;
}

// Address range: 0x100003e7c - 0x100003e88
int64_t function_100003e7c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e7c
    return ___memmove_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(char * nptr) {
    // 0x100003e88
    return _atoi(nptr);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(struct _IO_FILE * stream) {
    // 0x100003e94
    return _fclose(stream);
}

// Address range: 0x100003ea0 - 0x100003eac
int32_t function_100003ea0(struct _IO_FILE * stream) {
    // 0x100003ea0
    return _fgetc(stream);
}

// Address range: 0x100003eac - 0x100003eb8
struct _IO_FILE * function_100003eac(char * filename, char * modes) {
    // 0x100003eac
    return _fopen(filename, modes);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003eb8
    return _fprintf(stream, format);
}

// Address range: 0x100003ec4 - 0x100003ed0
void function_100003ec4(int64_t * ptr) {
    // 0x100003ec4
    _free(ptr);
}

// Address range: 0x100003ed0 - 0x100003edc
struct _IO_FILE * function_100003ed0(char * filename, char * modes, struct _IO_FILE * stream) {
    // 0x100003ed0
    return _freopen(filename, modes, stream);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003edc
    return _fseek(stream, off, whence);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(struct _IO_FILE * stream) {
    // 0x100003ee8
    return _ftell(stream);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003ef4
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t * function_100003f00(int32_t size) {
    // 0x100003f00
    return _malloc(size);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(struct _IO_FILE * stream) {
    // 0x100003f0c
    _rewind(stream);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

