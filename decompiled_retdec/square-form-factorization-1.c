//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000386c(void);
int64_t function_1000038e8(void);
int64_t function_100003dd4(int64_t a1);
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003dec(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 1; // 0x100003df8
int64_t g2 = 2501; // 0x100003e78

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000386c - 0x1000038e8
int64_t function_10000386c(void) {
    // 0x10000386c
    int64_t v1; // 0x10000386c
    if (v1 == 0) {
        // 0x1000038dc
        int64_t result; // 0x10000386c
        return result;
    }
    int64_t v2; // 0x10000386c
    int64_t result2 = v2;
    int64_t v3; // 0x10000386c
    int64_t v4 = v3 % result2;
    v3 = result2;
    while (v4 != 0) {
        // 0x100003890
        result2 = v4;
        v4 = v3 % result2;
        v3 = result2;
    }
    // 0x1000038dc
    return result2;
}

// Address range: 0x1000038e8 - 0x100003c9c
int64_t function_1000038e8(void) {
    // 0x1000038e8
    int64_t v1; // 0x1000038e8
    uint64_t v2 = v1;
    int64_t result = sqrt((float64_t)v2) + 0.5; // 0x10000390c
    if (result * result == v2) {
        // 0x100003c8c
        return result;
    }
    uint64_t v3 = 3 * (int64_t)(2.0 * sqrt((float64_t)(2 * result)));
    int64_t v4 = 0;
    int64_t result2; // 0x1000038e8
    while (true) {
        uint64_t v5 = *(int64_t *)(8 * v4 + (int64_t)&g1); // 0x100003974
        uint64_t v6 = 0xffffffffffffffff / v5; // 0x10000397c
        result2 = 0;
        if (v2 != v6 && v2 >= v6) {
            // break -> 0x100003c8c
            break;
        }
        if (v3 > 2) {
            int64_t v7 = v5 * v2; // 0x1000039b0
            int64_t v8 = sqrt((float64_t)v7); // 0x1000039c4
            int64_t v9 = v7 - v8 * v8;
            uint64_t v10 = 2;
            uint64_t v11 = 2 * v8 / v9; // 0x100003a58
            int64_t v12 = v11 * v9 - v8; // 0x100003a70
            int64_t v13 = (v8 - v12) * v11 + 1; // 0x100003a98
            uint64_t v14 = (int64_t)(sqrt((float64_t)v13) + 0.5); // 0x100003ab4
            while (v10 % 2 == 0 != (v14 * v14 == v13)) {
                int64_t v15 = v10 + 1; // 0x100003b0c
                int64_t v16 = v12; // 0x100003a40
                if (v15 >= v3) {
                    goto lab_0x100003c74;
                }
                int64_t v17 = v9;
                v9 = v13;
                v10 = v15;
                v11 = (v16 + v8) / v9;
                v12 = v11 * v9 - v16;
                v13 = (v16 - v12) * v11 + v17;
                v14 = (int64_t)(sqrt((float64_t)v13) + 0.5);
            }
            uint64_t v18 = v8 - v12; // 0x100003b3c
            int64_t v19 = v18 - v18 % v14 + v12; // 0x100003b5c
            int64_t v20 = (v7 - v19 * v19) / v14; // 0x100003b94
            int64_t v21 = v19;
            uint64_t v22 = (v21 + v8) / v20; // 0x100003ba8
            int64_t v23 = v22 * v20 - v21; // 0x100003bc8
            int64_t v24 = v20; // 0x100003c20
            v20 = (v21 - v23) * v22 + v14;
            while (v21 != v23) {
                int64_t v25 = v24;
                v21 = v23;
                v22 = (v21 + v8) / v20;
                v23 = v22 * v20 - v21;
                v24 = v20;
                v20 = (v21 - v23) * v22 + v25;
            }
            int64_t v26 = function_10000386c(); // 0x100003c30
            result2 = v26;
            if (v26 != 1 && v26 != v2) {
                // break -> 0x100003c8c
                break;
            }
        }
      lab_0x100003c74:
        // 0x100003c74
        v4++;
        result2 = 0;
        if (v4 >= 16) {
            // break -> 0x100003c8c
            break;
        }
    }
    // 0x100003c8c
    return result2;
}

// Address range: 0x100003c9c - 0x100003dd4
int64_t entry_point(void) {
    // 0x100003c9c
    int64_t v1; // bp-264, 0x100003c9c
    _memcpy(&v1, &g2, 224);
    int32_t v2; // 0x100003c9c
    for (int32_t i = 0; i < 28; i++) {
        // 0x100003cf8
        if (function_1000038e8() == 0) {
            // 0x100003d28
            v2 = _printf("%llu was not factored.\n", (int64_t)&g2);
        } else {
            // 0x100003d44
            int64_t v3; // 0x100003c9c
            int32_t v4 = _printf("Integer %llu has factors %llu and %llu\n", (int64_t)&g2, 224, v3); // 0x100003d78
            v2 = v4;
        }
    }
    int64_t v5 = *(int64_t *)0x100004008; // 0x100003da4
    if (*(int64_t *)v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003dbc
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003dc0
    return 0;
}

// Address range: 0x100003dd4 - 0x100003de0
int64_t function_100003dd4(int64_t a1) {
    // 0x100003dd4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003de0 - 0x100003dec
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003de0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dec - 0x100003df8
int32_t function_100003dec(char * format, ...) {
    // 0x100003dec
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

