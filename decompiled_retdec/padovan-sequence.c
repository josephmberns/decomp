//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003814(void);
int64_t function_100003980(int32_t a1);
int64_t function_1000039dc(void);
int64_t function_100003adc(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003e2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003e38(int64_t a1);
int64_t function_100003e44(int64_t * a1, int64_t * a2, int64_t a3);
float64_t function_100003e50(float64_t a1, float64_t a2);
int32_t function_100003e5c(char * format, ...);
int64_t * function_100003e68(int64_t * ptr, int32_t size);
int32_t function_100003e74(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x3ff0b9c80b7abcac; // 0x100003e80
float64_t g2 = 1.3247179572447461; // 0x100003e88
char * g3 = "A"; // 0x100003f2c
int64_t g4 = 0; // 0x100008000
int64_t g5 = 0; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t * a1, int64_t * a2, int64_t a3);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003814 - 0x100003980
int64_t function_100003814(void) {
    int64_t v1 = g5; // 0x100003828
    int64_t v2; // 0x100003814
    int64_t v3 = 0x100000000 * v2;
    uint64_t v4 = v3 >> 32; // 0x10000382c
    int64_t v5 = v1; // 0x100003838
    if (v1 >= v4 != v1 != v4) {
        v5 += 0x1000;
        while (v5 >= v4 != v5 != v4) {
            // 0x10000386c
            v5 += 0x1000;
        }
        // 0x100003880
        g5 = v5;
        int64_t v6 = (int64_t)_realloc((int64_t *)g4, 4 * (int32_t)v5); // 0x10000389c
        g4 = v6;
        ___memset_chk(4 * v1 + v6, 0, 4 * (g5 - v1), -1);
    }
    int64_t v7 = v3 >> 30; // 0x1000038e4
    int32_t * v8 = (int32_t *)(g4 + v7); // 0x1000038e4
    if (*v8 != 0) {
        // 0x100003964
        return (int64_t)*(int32_t *)(g4 + v7);
    }
    int32_t v9 = v2; // 0x100003820
    int32_t v10 = v9 - 2; // 0x1000038fc
    if (v10 == 0 || v10 < 0 != (1 - v9 & v9) < 0) {
        // 0x10000390c
        *v8 = 1;
        // 0x100003964
        return (int64_t)*(int32_t *)(g4 + v7);
    }
    int64_t v11 = function_100003814(); // 0x10000392c
    int64_t v12 = function_100003814(); // 0x10000393c
    *(int32_t *)(g4 + v7) = (int32_t)v12 + (int32_t)v11;
    // 0x100003964
    return (int64_t)*(int32_t *)(g4 + v7);
}

// Address range: 0x100003980 - 0x1000039dc
int64_t function_100003980(int32_t a1) {
    // 0x100003980
    int128_t v1; // 0x100003980
    _pow((float64_t)(int64_t)v1, (float64_t)(int64_t)v1);
    return g2 / (float64_t)g1 + 0.5;
}

// Address range: 0x1000039dc - 0x100003ac0
int64_t function_1000039dc(void) {
    // 0x1000039dc
    int64_t result; // 0x1000039dc
    char * v1 = (char *)result; // 0x1000039e4
    char v2 = *(char *)result; // 0x1000039f0
    if (v2 == 0) {
        // 0x100003ab0
        *v1 = 0;
        return result;
    }
    char * v3 = v1; // 0x1000039dc
    int64_t v4; // 0x100003a80
    switch (v2) {
        case 65: {
            // 0x100003a50
            *v1 = 66;
            v3 = (char *)((int64_t)v1 + 1);
            // break -> 0x100003aac
            break;
        }
        case 66: {
            // 0x100003a68
            *v1 = 67;
            v3 = (char *)((int64_t)v1 + 1);
            // break -> 0x100003aac
            break;
        }
        case 67: {
            // 0x100003a80
            v4 = (int64_t)v1;
            *v1 = 65;
            *(char *)(v4 + 1) = 66;
            v3 = (char *)(v4 + 2);
            // break -> 0x100003aac
            break;
        }
    }
    // 0x100003aac
    int64_t v5; // 0x1000039dc
    int64_t v6 = v5 + 1; // 0x100003a08
    char * v7 = v3;
    char v8 = *(char *)v6; // 0x1000039f0
    while (v8 != 0) {
        char * v9 = v7;
        v3 = v9;
        switch (v8) {
            case 65: {
                // 0x100003a50
                *v9 = 66;
                v3 = (char *)((int64_t)v9 + 1);
                // break -> 0x100003aac
                break;
            }
            case 66: {
                // 0x100003a68
                *v9 = 67;
                v3 = (char *)((int64_t)v9 + 1);
                // break -> 0x100003aac
                break;
            }
            case 67: {
                // 0x100003a80
                v4 = (int64_t)v9;
                *v9 = 65;
                *(char *)(v4 + 1) = 66;
                v3 = (char *)(v4 + 2);
                // break -> 0x100003aac
                break;
            }
        }
        // 0x100003aac
        v6++;
        v7 = v3;
        v8 = *(char *)v6;
    }
    // 0x100003ab0
    *v7 = 0;
    return result;
}

// Address range: 0x100003ac0 - 0x100003adc
int64_t entry_point(void) {
    // 0x100003ac0
    return ___chkstk_darwin();
}

// Address range: 0x100003adc - 0x100003e2c
int64_t function_100003adc(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003adc
    int64_t v1; // 0x100003adc
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003af0
    *v2 = *(int64_t *)*(int64_t *)0x100004018;
    _printf("P_0 .. P_19: ");
    for (int32_t i = 0; i < 20; i++) {
        // 0x100003b20
        function_100003814();
        _printf("%d ", v1);
    }
    // 0x100003b54
    _printf("\n");
    _printf("The floor- and recurrence-based functions ");
    int32_t v3 = 0;
    int64_t v4 = function_100003814(); // 0x100003b8c
    int32_t v5; // 0x100003adc
    while ((int32_t)v4 == (int32_t)function_100003980(v3)) {
        int32_t v6 = v3 + 1; // 0x100003c0c
        v5 = v6;
        if (v3 >= 63) {
            goto lab_0x100003c18;
        }
        v3 = v6;
        v4 = function_100003814();
    }
    // 0x100003bb4
    function_100003814();
    function_100003980(v3);
    _printf("do not match at %d: %d != %d.\n", v1, v1, v1);
    v5 = v3;
  lab_0x100003c18:
    // 0x100003c18
    if (v5 == 64) {
        // 0x100003c2c
        _printf("match from P_0 to P_63.\n");
    }
    // 0x100003c3c
    _printf("\nThe first 10 L-system strings are:\n");
    int64_t v7; // bp-8200, 0x100003adc
    ___strcpy_chk(&v7, (int64_t *)&g3, 0x2000);
    int64_t v8 = &v7;
    _printf("%s\n", (char *)(int64_t)&g3);
    int64_t v9; // bp-16392, 0x100003adc
    ___strcpy_chk(&v9, &v7, 0x2000);
    function_1000039dc();
    int32_t v10 = 1; // 0x100003cc4
    int32_t v11 = v10; // 0x100003c74
    int64_t v12 = v8; // 0x100003c74
    while (v10 != 10) {
        // 0x100003c7c
        _printf("%s\n", (char *)v12);
        ___strcpy_chk(&v9, &v7, 0x2000);
        function_1000039dc();
        v10 = v11 + 1;
        v11 = v10;
        v12 = v8;
    }
    // 0x100003cd0
    _printf("\nThe floor- and L-system-based functions ");
    ___strcpy_chk(&v7, (int64_t *)&g3, 0x2000);
    int32_t v13 = _strlen((char *)&v7); // 0x100003d18
    int64_t v14 = function_100003980(0); // 0x100003d28
    int32_t v15 = 0; // 0x100003d38
    int64_t v16 = (int64_t)&g3; // 0x100003d38
    int32_t v17 = 0; // 0x100003d38
    int32_t v18; // 0x100003adc
    int64_t v19; // 0x100003adc
    if (v13 == (int32_t)v14) {
        ___strcpy_chk(&v9, &v7, 0x2000);
        int32_t v20 = v17 + 1; // 0x100003dc0
        v18 = v20;
        v19 = function_1000039dc();
        while (v17 < 31) {
            int32_t v21 = _strlen((char *)&v7); // 0x100003d18
            int64_t v22 = function_100003980(v20); // 0x100003d28
            v15 = v20;
            v16 = v8;
            v17 = v20;
            if (v21 != (int32_t)v22) {
                goto lab_0x100003d40;
            }
            ___strcpy_chk(&v9, &v7, 0x2000);
            v20 = v17 + 1;
            v18 = v20;
            v19 = function_1000039dc();
        }
    } else {
      lab_0x100003d40:
        // 0x100003d40
        _strlen((char *)&v7);
        function_100003980(v15);
        v18 = v15;
        v19 = _printf("do not match at %d: %d != %d\n", v16, 0x2000, v1);
    }
    int64_t v23 = v19; // 0x100003dd8
    if (v18 == 32) {
        // 0x100003de0
        v23 = _printf("match from P_0 to P_31.\n");
    }
    // 0x100003df0
    if (*(int64_t *)*(int64_t *)0x100004018 != *v2) {
        // 0x100003e10
        ___stack_chk_fail(v23);
    }
    // 0x100003e14
    return 0;
}

// Address range: 0x100003e2c - 0x100003e38
int64_t function_100003e2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e2c
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e38 - 0x100003e44
int64_t function_100003e38(int64_t a1) {
    // 0x100003e38
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e44 - 0x100003e50
int64_t function_100003e44(int64_t * a1, int64_t * a2, int64_t a3) {
    // 0x100003e44
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e50 - 0x100003e5c
float64_t function_100003e50(float64_t a1, float64_t a2) {
    // 0x100003e50
    return _pow(a1, a2);
}

// Address range: 0x100003e5c - 0x100003e68
int32_t function_100003e5c(char * format, ...) {
    // 0x100003e5c
    return _printf(format);
}

// Address range: 0x100003e68 - 0x100003e74
int64_t * function_100003e68(int64_t * ptr, int32_t size) {
    // 0x100003e68
    return _realloc(ptr, size);
}

// Address range: 0x100003e74 - 0x100003e80
int32_t function_100003e74(char * s) {
    // 0x100003e74
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

