//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000379c(void);
int64_t function_100003824(int64_t a1);
int64_t function_100003840(char a1);
int64_t function_1000038a0(void);
int64_t function_10000393c(void);
int64_t function_100003e1c(int64_t a1);
int32_t function_100003e28(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e34(char * filename, char * modes);
int32_t function_100003e40(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003e4c(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_100003e58(char * format, ...);
int32_t function_100003e64(void);
void function_100003e70(int32_t seed);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000379c - 0x100003824
int64_t function_10000379c(void) {
    // 0x10000379c
    int64_t v1; // 0x10000379c
    uint32_t v2 = (int32_t)v1; // 0x1000037a8
    int32_t v3 = 1; // 0x1000037c8
    int32_t v4 = 1; // 0x1000037c8
    if (v2 > 1) {
        v4 = 2 * v4 | 1;
        v3 = v4;
        while (v4 < v2) {
            // 0x1000037d0
            v4 = 2 * v4 | 1;
            v3 = v4;
        }
    }
    uint32_t result = _rand() & v3; // 0x1000037f0
    // 0x1000037e8
    while (result >= v2) {
        // 0x1000037e8
        result = _rand() & v3;
    }
    // 0x100003814
    return result;
}

// Address range: 0x100003824 - 0x100003840
int64_t function_100003824(int64_t a1) {
    // 0x100003824
    return (uint64_t)function_10000379c() % 256;
}

// Address range: 0x100003840 - 0x1000038a0
int64_t function_100003840(char a1) {
    // 0x100003840
    int64_t v1; // 0x100003840
    return _printf(" %s%c", (char *)v1, (char)v1);
}

// Address range: 0x1000038a0 - 0x10000393c
int64_t function_1000038a0(void) {
    uint64_t result; // 0x1000038cc
    for (int64_t i = 0; i < 52; i++) {
        // 0x1000038cc
        result = function_100003824(i);
        int64_t v1; // 0x1000038a0
        char * v2 = (char *)(i + v1); // 0x1000038e0
        char * v3 = (char *)(result % 256 + v1); // 0x1000038f4
        *v2 = *v3;
        *v3 = *v2;
    }
    // 0x100003930
    return result;
}

// Address range: 0x10000393c - 0x100003cb8
int64_t function_10000393c(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003950
    int64_t v2; // bp-76, 0x10000393c
    int64_t v3 = &v2;
    uint32_t v4 = 0;
    *(char *)((int64_t)(v4 % 256) + v3) = (char)v4;
    int32_t v5 = 0x1000000 * v4 + 0x1000000;
    while (v5 < 0x34000000) {
        // 0x100003984
        v4 = v5 >> 24;
        *(char *)((int64_t)(v4 % 256) + v3) = (char)v4;
        v5 = 0x1000000 * v4 + 0x1000000;
    }
    // 0x1000039b0
    function_1000038a0();
    _printf("Discarded:");
    int64_t v6; // bp-89, 0x10000393c
    int64_t v7 = &v6;
    int64_t v8; // bp-102, 0x10000393c
    int64_t v9 = &v8;
    int32_t v10 = 0; // 0x10000393c
    int32_t v11 = 0;
    int32_t v12 = 0;
    uint32_t v13 = v10 % 256; // 0x1000039e0
    unsigned char v14 = *(char *)((int64_t)v13 + v3); // 0x1000039f0
    char v15 = *(char *)((int64_t)(v13 + 1) + v3);
    int32_t v16; // 0x10000393c
    int32_t v17; // 0x10000393c
    if (v14 % 2 == 0) {
        // 0x100003a40
        *(char *)((int64_t)v12 + v9) = v15;
        v16 = v11;
        v17 = v12 + 1;
    } else {
        // 0x100003a0c
        *(char *)((int64_t)v11 + v7) = v15;
        v16 = v11 + 1;
        v17 = v12;
    }
    int32_t v18 = v17;
    int32_t v19 = v16;
    function_100003840(v14);
    int32_t v20 = 0x1000000 * v10 + 0x2000000;
    v10 = v20 >> 24;
    while (v20 < 0x34000000) {
        // 0x1000039e0
        v11 = v19;
        v12 = v18;
        v13 = v10 % 256;
        v14 = *(char *)((int64_t)v13 + v3);
        v15 = *(char *)((int64_t)(v13 + 1) + v3);
        if (v14 % 2 == 0) {
            // 0x100003a40
            *(char *)((int64_t)v12 + v9) = v15;
            v16 = v11;
            v17 = v12 + 1;
        } else {
            // 0x100003a0c
            *(char *)((int64_t)v11 + v7) = v15;
            v16 = v11 + 1;
            v17 = v12;
        }
        // 0x100003a74
        v18 = v17;
        v19 = v16;
        function_100003840(v14);
        v20 = 0x1000000 * v10 + 0x2000000;
        v10 = v20 >> 24;
    }
    // 0x100003a90
    _printf("\n");
    uint32_t v21 = (int32_t)function_10000379c() % 256;
    int32_t v22 = 0; // 0x100003af0
    if (v21 != 0) {
        int64_t v23 = function_10000379c(); // 0x100003afc
        int64_t v24 = function_10000379c(); // 0x100003b08
        char * v25 = (char *)((0x100000000 * v23 >> 32) + v7); // 0x100003b20
        char * v26 = (char *)((0x100000000 * v24 >> 32) + v9); // 0x100003b38
        *v25 = *v26;
        *v26 = *v25;
        v22 = 0x1000000 * v22 + 0x1000000 >> 24;
        while (v22 % 256 < v21) {
            // 0x100003af8
            v23 = function_10000379c();
            v24 = function_10000379c();
            v25 = (char *)((0x100000000 * v23 >> 32) + v7);
            v26 = (char *)((0x100000000 * v24 >> 32) + v9);
            *v25 = *v26;
            *v26 = *v25;
            v22 = 0x1000000 * v22 + 0x1000000 >> 24;
        }
    }
    int32_t v27 = -v19; // 0x100003b80
    int32_t v28 = 0; // 0x100003b88
    int32_t v29 = 0; // 0x100003b88
    int32_t v30 = 0; // 0x100003b88
    if (v27 < 0 != (v19 & v27) < 0) {
        v30 += (int32_t)(*(char *)((int64_t)0 + v7) % 2 != 0);
        v29 = 0x1000000 * v29 + 0x1000000 >> 24;
        int32_t v31 = v29 % 256; // 0x100003b78
        int32_t v32 = v31 - v19; // 0x100003b80
        v28 = v30;
        while (v32 < 0 != (v32 & v19) < 0) {
            // 0x100003b90
            v30 += (int32_t)(*(char *)((int64_t)v31 + v7) % 2 != 0);
            v29 = 0x1000000 * v29 + 0x1000000 >> 24;
            v31 = v29 % 256;
            v32 = v31 - v19;
            v28 = v30;
        }
    }
    int32_t v33 = -v18; // 0x100003be0
    int32_t v34 = 0; // 0x100003be8
    int32_t v35 = v28; // 0x100003be8
    int32_t v36 = v28; // 0x100003be8
    if (v33 < 0 != (v18 & v33) < 0) {
        v35 -= (int32_t)(*(char *)((int64_t)0 + v9) % 2 == 0);
        v34 = 0x1000000 * v34 + 0x1000000 >> 24;
        int32_t v37 = v34 % 256; // 0x100003bd8
        int32_t v38 = v37 - v18; // 0x100003be0
        v36 = v35;
        while (v38 < 0 != (v38 & v18) < 0) {
            // 0x100003bf0
            v35 -= (int32_t)(*(char *)((int64_t)v37 + v9) % 2 == 0);
            v34 = 0x1000000 * v34 + 0x1000000 >> 24;
            v37 = v34 % 256;
            v38 = v37 - v18;
            v36 = v35;
        }
    }
    // 0x100003c2c
    int64_t v39; // 0x10000393c
    int32_t v40 = _printf("The number of black cards in the 'black' pile %s the number of red cards in the 'red' pile.\n", (char *)v39); // 0x100003c78
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ca4
        ___stack_chk_fail((int64_t)v40);
    }
    // 0x100003ca8
    return v36 == 0;
}

// Address range: 0x100003cb8 - 0x100003e1c
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("/dev/urandom", "r"); // 0x100003cdc
    if (v1 == NULL) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d00
        _fprintf((struct _IO_FILE *)v2, "cannot open /dev/urandom\n");
        // 0x100003e0c
        return 255;
    }
    // 0x100003d1c
    int64_t v3; // bp-24, 0x100003cb8
    if (_fread(&v3, 4, 1, v1) != 1) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d48
        _fprintf((struct _IO_FILE *)v4, "failed to read from /dev/urandom\n");
        // 0x100003e0c
        return 255;
    }
    // 0x100003d64
    _fclose(v1);
    _srand((int32_t)v3);
    for (int32_t i = 1; i < 6; i++) {
        // 0x100003d94
        _printf("Simulation %d\n", 4);
        function_10000393c();
        _printf("\n");
    }
    // 0x100003de0
    _printf("Result: %d successes out of %d simulations\n", 4, 1);
    // 0x100003e0c
    return 0;
}

// Address range: 0x100003e1c - 0x100003e28
int64_t function_100003e1c(int64_t a1) {
    // 0x100003e1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e28 - 0x100003e34
int32_t function_100003e28(struct _IO_FILE * stream) {
    // 0x100003e28
    return _fclose(stream);
}

// Address range: 0x100003e34 - 0x100003e40
struct _IO_FILE * function_100003e34(char * filename, char * modes) {
    // 0x100003e34
    return _fopen(filename, modes);
}

// Address range: 0x100003e40 - 0x100003e4c
int32_t function_100003e40(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e40
    return _fprintf(stream, format);
}

// Address range: 0x100003e4c - 0x100003e58
int32_t function_100003e4c(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003e4c
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003e58 - 0x100003e64
int32_t function_100003e58(char * format, ...) {
    // 0x100003e58
    return _printf(format);
}

// Address range: 0x100003e64 - 0x100003e70
int32_t function_100003e64(void) {
    // 0x100003e64
    return _rand();
}

// Address range: 0x100003e70 - 0x100003e7c
void function_100003e70(int32_t seed) {
    // 0x100003e70
    _srand(seed);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

