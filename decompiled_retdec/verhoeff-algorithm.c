//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_1000035e4(void);
int64_t function_100003b44(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003b50(void);
int64_t function_100003b5c(void);
int32_t function_100003b68(char * format, ...);
int32_t function_100003b74(char * s);
int32_t function_100003b80(char * s);

// --------------------- Global Variables ---------------------

char * g1 = " i  n\xe1\xb5\xa2  p[i,n\xe1\xb5\xa2]  c"; // 0x100003bbf
int64_t g2 = 0x100000000; // 0x100003cb0
int64_t g3 = 0x100000000; // 0x100003df0
int32_t * g4 = (int32_t *)0x400000000; // 0x100003f80

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int64_t ___strncpy_chk(void);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000035e4 - 0x1000038e8
int64_t function_1000035e4(void) {
    // 0x1000035e4
    int64_t v1; // 0x1000035e4
    uint32_t v2 = (int32_t)v1 % 2; // 0x100003600
    if (v2 != 0) {
        // 0x100003614
        _printf("%s calculations for '%s':\n\n", (char *)v1, (char *)v1);
        _puts((char *)&g1);
        _puts("------------------");
    }
    uint32_t v3 = _strlen((char *)v1) + (int32_t)(v1 % 2 != 0);
    int32_t v4 = 0; // 0x1000036bc
    int64_t v5; // 0x1000035e4
    int64_t v6; // 0x1000035e4
    int32_t v7; // 0x1000035e4
    int32_t v8; // 0x1000035e4
    int32_t v9; // 0x1000035e4
    int64_t v10; // 0x1000035e4
    int64_t v11; // 0x1000035e4
    int64_t v12; // 0x1000035e4
    int64_t v13; // 0x1000035e4
    int64_t v14; // 0x1000035e4
    int64_t v15; // 0x1000035e4
    if (v3 >= 0) {
        // 0x1000036c4
        v5 = v3;
        v7 = 0;
        while (true) {
          lab_0x1000036c4:
            // 0x1000036c4
            v11 = v10;
            v13 = v12;
            v15 = v14;
            v6 = v5;
            v8 = 0;
            if (v1 % 2 == 0 == v6 == (int64_t)v3) {
                goto lab_0x100003744;
            } else {
                int32_t v16 = (int32_t)*(char *)(v6 + v1) - 48; // 0x100003700
                v8 = v16;
                v9 = v16;
                if (v16 < 0) {
                    goto lab_0x100003760;
                } else {
                    goto lab_0x100003744;
                }
            }
        }
    }
  lab_0x10000384c:;
    // 0x10000384c
    int64_t v17; // 0x1000035e4
    int64_t v18; // 0x1000035e4
    if (v2 != 0 == v1 % 2 == 0) {
        // 0x100003864
        _printf("\ninv[%d] = %d\n", v17, v18);
    }
    int32_t result; // 0x1000035e4
    if (v1 % 2 == 0) {
        int32_t v19 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g4); // 0x1000038cc
        result = v19;
    } else {
        // 0x1000038a8
        result = v4 == 0;
    }
    // 0x1000038d8
    return result;
  lab_0x100003744:;
    int32_t v20 = v8;
    v9 = v20;
    int32_t v21 = v20; // 0x100003758
    int64_t v22 = v11; // 0x100003758
    int64_t v23 = v13; // 0x100003758
    int64_t v24 = v15; // 0x100003758
    if (v20 < 10 == (9 - v20 & v20) < 0) {
        goto lab_0x100003760;
    } else {
        goto lab_0x100003784;
    }
  lab_0x100003760:
    // 0x100003760
    ___assert_rtn("verhoeff", "verhoeff-algorithm.c", 36, "ni >= 0 && ni < 10");
    v21 = v9;
    v22 = (int64_t)"verhoeff-algorithm.c";
    v23 = 36;
    v24 = (int64_t)"ni >= 0 && ni < 10";
    goto lab_0x100003784;
  lab_0x100003784:;
    int64_t v25 = v24;
    int64_t v26 = v23;
    int64_t v27 = v22;
    int32_t v28 = v3 - (int32_t)v6;
    int32_t v29 = *(int32_t *)(40 * (int64_t)(v28 - 8 * v28 / 8) + (int64_t)&g2 + 4 * (int64_t)v21); // 0x1000037b8
    int32_t v30 = *(int32_t *)(40 * (int64_t)v7 + (int64_t)&g3 + 4 * (int64_t)v29); // 0x1000037d8
    if (v2 != 0) {
        // 0x1000037ec
        _printf("%2d  %d      %d     %d\n", v27, v26, v25, v1);
    }
    // 0x10000383c
    v5 = v6 - 1;
    v14 = v25;
    v12 = v26;
    v10 = v27;
    v7 = v30;
    v4 = v30;
    v17 = v27;
    v18 = v26;
    if (v6 < 1) {
        // break -> 0x10000384c
        goto lab_0x10000384c;
    }
    goto lab_0x1000036c4;
}

// Address range: 0x1000038e8 - 0x100003b44
int64_t entry_point(int64_t a1) {
    // 0x1000038e8
    function_1000035e4();
    _printf("\nThe check digit for '%s' is '%d'.\n", NULL, 1);
    _strlen((char *)(int64_t)(int32_t)(float32_t)*(float128_t *)"A<");
    return ___chkstk_darwin();
}

// Address range: 0x100003b44 - 0x100003b50
int64_t function_100003b44(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003b44
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003b50 - 0x100003b5c
int64_t function_100003b50(void) {
    // 0x100003b50
    return ___stack_chk_fail();
}

// Address range: 0x100003b5c - 0x100003b68
int64_t function_100003b5c(void) {
    // 0x100003b5c
    return ___strncpy_chk();
}

// Address range: 0x100003b68 - 0x100003b74
int32_t function_100003b68(char * format, ...) {
    // 0x100003b68
    return _printf(format);
}

// Address range: 0x100003b74 - 0x100003b80
int32_t function_100003b74(char * s) {
    // 0x100003b74
    return _puts(s);
}

// Address range: 0x100003b80 - 0x100003b8c
int32_t function_100003b80(char * s) {
    // 0x100003b80
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

