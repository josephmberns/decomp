//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039e8(void);
int64_t function_100003b00(void);
int64_t function_100003bcc(void);
int64_t function_100003c9c(void);
int64_t function_100003cec(int64_t a1);
int64_t function_100003d28(void);
int64_t function_100003db8(void);
int64_t function_100003e1c(int64_t a1);
int64_t function_100003e4c(void);
int64_t function_100003e84(void);
int64_t function_100003ee4(int64_t a1);
int64_t function_100003ef0(int64_t a1, char * a2, int64_t a3);
int64_t * function_100003efc(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f08(char * format, ...);
int32_t function_100003f14(void);
void function_100003f20(int32_t seed);
int32_t function_100003f2c(int32_t * timer);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcat_chk(int64_t a1, char * a2, int64_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003984 - 0x1000039e8
int64_t entry_point(void) {
    // 0x100003984
    _srand(_time(NULL));
    function_1000039e8();
    function_1000039e8();
    function_1000039e8();
    function_1000039e8();
    return 0;
}

// Address range: 0x1000039e8 - 0x100003b00
int64_t function_1000039e8(void) {
    // 0x1000039e8
    int64_t v1; // bp-65, 0x1000039e8
    _memset(&v1, 0, 41);
    int32_t v2 = 0;
    function_100003b00();
    int32_t v3 = v2 + 1; // 0x100003a68
    while (v2 < 0x1869f != (0x1869e - v2 & v3) < 0) {
        // 0x100003a4c
        v2 = v3;
        function_100003b00();
        v3 = v2 + 1;
    }
    // 0x100003a74
    function_100003bcc();
    int128_t v4 = __asm_sshll(0.0f, 0); // 0x100003a90
    int32_t v5 = _printf("%-40s produces %6.3f%% deaths.\n", &v1, (float64_t)(int64_t)v4); // 0x100003acc
    int64_t v6 = v5; // 0x100003acc
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003adc
    int64_t result = v6; // 0x100003ae8
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003af0
        result = ___stack_chk_fail(v6);
    }
    // 0x100003af4
    return result;
}

// Address range: 0x100003b00 - 0x100003bcc
int64_t function_100003b00(void) {
    // 0x100003b00
    function_100003c9c();
    while (true) {
        // 0x100003b18
        int64_t v1; // 0x100003b00
        switch (*(char *)v1) {
            case 0: {
                // 0x100003bbc
                return 0;
            }
            case 70: {
                // 0x100003b84
                if (function_100003e4c() % 2 != 0) {
                    // break -> 0x100003bbc
                    break;
                }
                // break -> 0x100003ba4
                break;
            }
            case 76: {
                // 0x100003b74
                function_100003cec(76);
                // break -> 0x100003ba4
                break;
            }
            case 83: {
                // 0x100003b7c
                function_100003db8();
                // break -> 0x100003ba4
                break;
            }
        }
        // 0x100003ba4
        int64_t v2; // 0x100003b00
        v2++;
    }
    // 0x100003bbc
    return 0;
}

// Address range: 0x100003bcc - 0x100003c9c
int64_t function_100003bcc(void) {
    int64_t result; // 0x100003bcc
    while (true) {
        // 0x100003be4
        int64_t v1; // 0x100003bcc
        result = v1;
        int64_t v2 = result; // 0x100003bcc
        int64_t v3; // 0x100003bcc
        switch (*(char *)v3) {
            case 0: {
                // 0x100003c90
                return result;
            }
            case 70: {
                // 0x100003c68
                v2 = function_100003e84();
                // break -> 0x100003c80
                break;
            }
            case 76: {
                // 0x100003c40
                v2 = function_100003e84();
                // break -> 0x100003c80
                break;
            }
            case 83: {
                // 0x100003c54
                v2 = function_100003e84();
                // break -> 0x100003c80
                break;
            }
        }
        // 0x100003c80
        v1 = v2;
        int64_t v4; // 0x100003bcc
        v4++;
    }
    // 0x100003c90
    return result;
}

// Address range: 0x100003c9c - 0x100003cec
int64_t function_100003c9c(void) {
    for (int64_t i = 0; i < 6; i++) {
        // 0x100003cbc
        *(char *)(i + (int64_t)&g1) = 0;
    }
    // 0x100003ce4
    int64_t result; // 0x100003c9c
    return result;
}

// Address range: 0x100003cec - 0x100003d28
int64_t function_100003cec(int64_t a1) {
    // 0x100003cec
    if (*(char *)&g1 % 2 == 0) {
        // 0x100003d10
        *(char *)&g1 = 1;
        return function_100003d28();
    }
    function_100003d28();
    while (*(char *)&g1 % 2 != 0) {
        // 0x100003d08
        function_100003d28();
    }
    // 0x100003d10
    *(char *)&g1 = 1;
    return function_100003d28();
}

// Address range: 0x100003d28 - 0x100003db8
int64_t function_100003d28(void) {
    unsigned char v1 = *(char *)((int64_t)&g1 + 5); // 0x100003d34
    for (int64_t i = 4; i > -1; i--) {
        unsigned char v2 = *(char *)(i + (int64_t)&g1); // 0x100003d74
        *(char *)(i + (int64_t)&g1 + 1) = v2 % 2;
    }
    // 0x100003da0
    *(char *)&g1 = v1 % 2;
    int64_t result; // 0x100003d28
    return result;
}

// Address range: 0x100003db8 - 0x100003e1c
int64_t function_100003db8(void) {
    int64_t result = function_100003e1c(6); // 0x100003dc8
    int32_t v1 = result; // 0x100003dd0
    int32_t v2 = v1 + 1; // 0x100003dd0
    int32_t v3 = -v1; // 0x100003de8
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003e10
        return result;
    }
    int32_t v4 = 1; // 0x100003df0
    v4++;
    int32_t v5 = v4 - v2; // 0x100003de8
    int64_t result2 = function_100003d28(); // 0x100003df0
    while (v5 < 0 != ((v5 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003df8
        v4++;
        v5 = v4 - v2;
        result2 = function_100003d28();
    }
    // 0x100003e10
    return result2;
}

// Address range: 0x100003e1c - 0x100003e4c
int64_t function_100003e1c(int64_t a1) {
    // 0x100003e1c
    return _rand() % (int32_t)a1;
}

// Address range: 0x100003e4c - 0x100003e84
int64_t function_100003e4c(void) {
    // 0x100003e4c
    function_100003d28();
    return (int64_t)(*(char *)&g1 % 2);
}

// Address range: 0x100003e84 - 0x100003ee4
int64_t function_100003e84(void) {
    // 0x100003e84
    int64_t v1; // 0x100003e84
    if ((char)v1 != 0) {
        // 0x100003eb0
        ___strcat_chk(v1, ", ", -1);
    }
    // 0x100003ec8
    return ___strcat_chk(v1, (char *)v1, -1);
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(int64_t a1) {
    // 0x100003ee4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t function_100003ef0(int64_t a1, char * a2, int64_t a3) {
    // 0x100003ef0
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int64_t * s, int32_t c, int32_t n) {
    // 0x100003efc
    return _memset(s, c, n);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(void) {
    // 0x100003f14
    return _rand();
}

// Address range: 0x100003f20 - 0x100003f2c
void function_100003f20(int32_t seed) {
    // 0x100003f20
    _srand(seed);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t * timer) {
    // 0x100003f2c
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 18

