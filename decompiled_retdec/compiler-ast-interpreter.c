//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002d94(void);
int64_t function_100002e00(void);
int64_t function_100002e5c(int32_t a1, int32_t a2);
int64_t function_100002ea8(int64_t a1, int64_t a2);
int64_t function_10000343c(void);
int64_t function_1000034dc(void);
int64_t function_100003598(void);
int64_t function_100003700(void);
int64_t function_1000037a8(void);
int64_t function_1000039e0(void);
int64_t function_100003ba4(void);
int64_t function_100003de4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t * function_100003df0(int32_t nmemb, int32_t size);
void function_100003dfc(int32_t status);
int32_t function_100003e08(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e14(char * filename, char * modes);
int32_t function_100003e20(int32_t c);
int32_t function_100003e2c(char * format, ...);
int64_t * function_100003e38(int64_t * ptr, int32_t size);
int32_t function_100003e44(char * s1, char * s2);
char * function_100003e50(char * s);
int32_t function_100003e5c(char * s);
char * function_100003e68(char * s, char * delim);
int32_t function_100003e74(char * nptr, char ** endptr, int32_t base);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x20000000003e80; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008190
int32_t g3 = 0; // 0x100008198
int32_t g4 = 2; // 0x10000819c
int64_t g5 = 0x55800000012; // 0x1000081a0
int32_t g6 = 0x200085; // 0x1000081a8
int32_t g7 = 0; // 0x1000081ac
int64_t g8 = 0x4800000019; // 0x1000081b0
char g9[11] = "__PAGEZERO"; // 0x1000081b8
char g10[7] = "GEZERO"; // 0x1000081bc
char g11[3] = "RO"; // 0x1000081c0
int64_t g12 = 0; // 0x1000081c8
int32_t g13 = 0; // 0x1000081d0
int32_t g14;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100002d94 - 0x100002e00
int64_t function_100002d94(void) {
    // 0x100002d94
    int64_t v1; // 0x100002d94
    int64_t v2; // bp-1032, 0x100002d94
    int64_t v3; // 0x100002d94
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("error: %s\n", NULL);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100002e00 - 0x100002e5c
int64_t function_100002e00(void) {
    int64_t * v1 = _calloc(32, 1); // 0x100002e20
    int64_t v2; // 0x100002e00
    *(int32_t *)v1 = (int32_t)v2;
    return (int64_t)v1;
}

// Address range: 0x100002e5c - 0x100002ea8
int64_t function_100002e5c(int32_t a1, int32_t a2) {
    int64_t * v1 = _calloc(32, 1); // 0x100002e78
    *(int32_t *)v1 = a1;
    int64_t result = (int64_t)v1; // 0x100002e90
    *(int32_t *)(result + 24) = a2;
    return result;
}

// Address range: 0x100002ea8 - 0x1000033d8
int64_t function_100002ea8(int64_t a1, int64_t a2) {
    // 0x100002ea8
    int64_t result; // 0x100002ea8
    if (result == 0) {
        // 0x100002ecc
        return result;
    }
    uint32_t v1 = (int32_t)result;
    if (v1 >= 24 != v1 != 24) {
        // 0x100002ecc
        return result;
    }
    // 0x10000339c
    function_100002d94();
    // UNREACHABLE
}

// Address range: 0x10000343c - 0x1000034dc
int64_t function_10000343c(void) {
    // 0x10000343c
    int64_t v1; // 0x10000343c
    if ((char)v1 == 0) {
        // 0x100003464
        *(int64_t *)&g11 = *(int64_t *)*(int64_t *)0x100004008;
        // 0x1000034d0
        int64_t result; // 0x10000343c
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x10000348c
    int64_t result2 = (int64_t)v2; // 0x10000348c
    *(int64_t *)&g11 = result2;
    if (v2 != NULL) {
        // 0x1000034d0
        return result2;
    }
    // 0x1000034b0
    function_100002d94();
    // UNREACHABLE
}

// Address range: 0x1000034dc - 0x100003598
int64_t function_1000034dc(void) {
    int64_t v1 = 0; // 0x100003558
    int64_t v2 = 16 * v1; // 0x10000350c
    int64_t v3 = *(int64_t *)(v2 + (int64_t)&g1); // 0x100003518
    int64_t v4; // 0x1000034dc
    while (_strcmp((char *)v3, (char *)v4) != 0) {
        // 0x1000034f4
        v1++;
        if (v1 >= 25) {
            // 0x100003564
            function_100002d94();
            // UNREACHABLE
        }
        v2 = 16 * v1;
        v3 = *(int64_t *)(v2 + (int64_t)&g1);
    }
    // 0x100003534
    return (int64_t)*(int32_t *)(v2 + (int64_t)&g1 + 8);
}

// Address range: 0x100003598 - 0x100003700
int64_t function_100003598(void) {
    int32_t v1 = 0; // 0x1000035b0
    int64_t result; // 0x1000036e4
    int32_t v2; // 0x100003598
    while (true) {
        // 0x1000035b4
        int64_t v3; // 0x100003598
        *(int32_t *)v3 = v1;
        int32_t v4 = _fgetc((struct _IO_FILE *)*(int64_t *)&g11); // 0x1000035c0
        int64_t v5; // 0x100003598
        v2 = *(int32_t *)&v5;
        switch (v4) {
            case -1: {
            }
            case 10: {
                // 0x1000035f0
                result = 0;
                if (v2 != 0) {
                    // 0x1000036cc
                    *(char *)(g12 + (int64_t)v2) = 0;
                    result = g12;
                }
                // 0x1000036f0
                return result;
            }
        }
        int32_t v6 = v2 + 1; // 0x10000361c
        int32_t v7 = *(int32_t *)((int64_t)&g1 + 464); // 0x100003624
        int32_t v8 = v6 - v7; // 0x100003628
        int64_t v9; // 0x100003598
        if (v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            int32_t v10 = g13; // 0x10000363c
            int32_t v11 = v10 == 0 ? 128 : 2 * v10;
            g13 = v11;
            int64_t v12 = (int64_t)_realloc((int64_t *)g12, v11); // 0x10000368c
            g12 = v12;
            v9 = v12;
        } else {
            // 0x100003614
            v9 = g12;
        }
        // 0x10000369c
        *(char *)(v9 + (int64_t)v2) = (char)v4;
        v1 = *(int32_t *)&v5 + 1;
    }
    // 0x1000035f0
    result = 0;
    if (v2 != 0) {
        // 0x1000036cc
        *(char *)(g12 + (int64_t)v2) = 0;
        result = g12;
    }
    // 0x1000036f0
    return result;
}

// Address range: 0x100003700 - 0x1000037a8
int64_t function_100003700(void) {
    // 0x100003700
    int64_t result; // 0x100003700
    int32_t v1 = result;
    if (v1 < 1) {
        // 0x100003784
        *(char *)(result + (int64_t)v1) = 0;
        return result;
    }
    uint32_t v2 = v1 - 1; // 0x100003744
    char v3 = *(char *)(result + (int64_t)v2); // 0x100003748
    int32_t v4 = v1; // 0x100003764
    while (_isspace((int32_t)v3) != 0) {
        // 0x100003770
        *(int32_t *)result = v2;
        int64_t v5; // 0x100003700
        int32_t v6 = *(int32_t *)&v5; // 0x10000371c
        v4 = v6;
        if (v6 < 1) {
            // break -> 0x100003784
            break;
        }
        v2 = v6 - 1;
        v3 = *(char *)(result + (int64_t)v2);
        v4 = v6;
    }
    // 0x100003784
    *(char *)(result + (int64_t)v4) = 0;
    return result;
}

// Address range: 0x1000037a8 - 0x1000039e0
int64_t function_1000037a8(void) {
    // 0x1000037a8
    int64_t v1; // 0x1000037a8
    int64_t v2 = v1;
    *(char *)(v2 + (int64_t)(_strlen((char *)v2) - 1)) = 0;
    int64_t v3 = v2 + 1; // 0x1000037e0
    char * v4 = (char *)v3; // 0x1000037e4
    char v5 = *v4; // 0x100003804
    int64_t v6; // 0x1000037a8
    int64_t v7; // 0x1000037a8
    char v8; // 0x1000037a8
    int64_t v9; // 0x1000037a8
    char v10; // 0x1000037a8
    char * v11; // 0x1000037a8
    char * v12; // 0x1000037a8
    char * v13; // 0x1000037a8
    if (v5 != 0) {
        int64_t v14 = v2 + 2;
        v8 = v5;
        v7 = v14;
        v6 = v14;
        v9 = v3;
        v11 = v4;
        while (true) {
          lab_0x100003828:;
            char * v15 = (char *)v6;
            v12 = v15;
            if (v8 == 92) {
                int64_t v16 = v9;
                char v17 = *v15;
                v10 = v17;
                v13 = v15;
                switch (v17) {
                    case 110: {
                        // 0x100003858
                        *v11 = 10;
                        v12 = (char *)(v16 + 2);
                        goto lab_0x1000038a8;
                    }
                    case 92: {
                        // 0x100003890
                        v12 = (char *)(v16 + 2);
                        goto lab_0x1000038a8;
                    }
                    default: {
                        goto lab_0x1000038a8_2;
                    }
                }
            } else {
                goto lab_0x1000038a8;
            }
        }
    }
  lab_0x1000038b4:;
    int32_t v18 = -g3; // 0x1000038c0
    int32_t v19 = 0; // 0x1000038c8
    if (v18 < 0 != (g3 & v18) < 0) {
        int64_t v20 = *(int64_t *)(8 * (int64_t)v19 + g2); // 0x1000038e0
        int32_t result = v19; // 0x1000038f0
        while (_strcmp(v4, (char *)v20) != 0) {
            int32_t v21 = v19 + 1; // 0x10000390c
            int32_t v22 = v21 - g3; // 0x1000038c0
            v19 = v21;
            if (v22 < 0 == ((v22 ^ v21) & (g3 ^ v21)) < 0) {
                goto lab_0x100003920;
            }
            v20 = *(int64_t *)(8 * (int64_t)v19 + g2);
            result = v19;
        }
        // 0x1000039d0
        return result;
    }
  lab_0x100003920:;
    int32_t v23 = g3;
    int32_t v24 = v23 - g4; // 0x100003930
    int32_t v25 = v23; // 0x100003938
    if (v24 < 0 == ((v24 ^ v23) & (g4 ^ v23)) < 0) {
        int32_t v26 = g4 + 32; // 0x100003954
        g4 = v26;
        g2 = (int64_t)_realloc((int64_t *)g2, 8 * v26);
        v25 = g3;
    }
    // 0x10000397c
    g3 = v25 + 1;
    char * v27 = _strdup(v4); // 0x1000039a8
    *(int64_t *)(g2 + 8 * (int64_t)v25) = (int64_t)v27;
    // 0x1000039d0
    return g3 - 1;
  lab_0x1000038a8:
    // 0x1000038a8
    v10 = *v12;
    v13 = v12;
    goto lab_0x1000038a8_2;
  lab_0x1000038a8_2:;
    char * v28 = (char *)v7;
    *v28 = v10;
    if (v10 == 0) {
        // break -> 0x1000038b4
        goto lab_0x1000038b4;
    }
    int64_t v29 = (int64_t)v13; // 0x1000037f8
    v8 = *v13;
    v7++;
    v6 = v29 + 1;
    v9 = v29;
    v11 = v28;
    goto lab_0x100003828;
}

// Address range: 0x1000039e0 - 0x100003ba4
int64_t function_1000039e0(void) {
    // 0x1000039e0
    int64_t v1; // 0x1000039e0
    char * v2 = (char *)v1; // 0x1000039ec
    int32_t v3 = -g6; // 0x100003a04
    int32_t v4 = 0; // 0x100003a0c
    if (v3 < 0 != (g6 & v3) < 0) {
        int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + g5); // 0x100003a24
        int32_t result = v4; // 0x100003a34
        while (_strcmp(v2, (char *)v5) != 0) {
            // 0x100003a4c
            v4++;
            int32_t v6 = v4 - g6; // 0x100003a04
            if (v6 < 0 == ((v6 ^ v4) & (g6 ^ v4)) < 0) {
                goto lab_0x100003a64;
            }
            v5 = *(int64_t *)(8 * (int64_t)v4 + g5);
            result = v4;
        }
        // 0x100003b94
        return result;
    }
  lab_0x100003a64:;
    int32_t v7 = g6;
    int32_t v8 = v7 - g7; // 0x100003a74
    int32_t result2 = v7; // 0x100003a7c
    if (v8 < 0 == ((v8 ^ v7) & (g7 ^ v7)) < 0) {
        int32_t v9 = g7 + 32; // 0x100003a98
        g7 = v9;
        g5 = (int64_t)_realloc((int64_t *)g5, 8 * v9);
        result2 = g6;
    }
    // 0x100003ac0
    g6 = result2 + 1;
    char * v10 = _strdup(v2); // 0x100003ae8
    *(int64_t *)(g5 + 8 * (int64_t)result2) = (int64_t)v10;
    int32_t v11 = *(int32_t *)&g9; // 0x100003b08
    int32_t v12 = *(int32_t *)&g10; // 0x100003b10
    int32_t v13 = v11 - v12; // 0x100003b14
    int32_t v14 = v11; // 0x100003b1c
    int64_t v15 = g8; // 0x100003b1c
    if (v13 < 0 == ((v13 ^ v11) & (v12 ^ v11)) < 0) {
        int32_t v16 = v12 + 32; // 0x100003b38
        *(int32_t *)&g10 = v16;
        int64_t v17 = (int64_t)_realloc((int64_t *)g8, 4 * v16); // 0x100003b4c
        g8 = v17;
        v14 = *(int32_t *)&g9;
        v15 = v17;
    }
    // 0x100003b60
    *(int32_t *)&g9 = v14 + 1;
    *(int32_t *)(4 * (int64_t)v14 + v15) = 0;
    // 0x100003b94
    return result2;
}

// Address range: 0x100003ba4 - 0x100003d70
int64_t function_100003ba4(void) {
    // 0x100003ba4
    function_100003598();
    int64_t v1 = function_100003700(); // 0x100003bc8
    char * v2 = _strtok((char *)v1, " "); // 0x100003bdc
    if (*v2 == 59) {
        // 0x100003d60
        return 0;
    }
    int64_t v3 = function_1000034dc(); // 0x100003c08
    int64_t v4 = (int64_t)_strlen(v2) + (int64_t)v2; // 0x100003c24
    int32_t v5; // 0x100003ba4
    if (v4 == v1 + (int64_t)v5) {
        // 0x100003d38
        function_100003ba4();
        function_100003ba4();
        // 0x100003d60
        return 0x100000000 * v3 >> 32;
    }
    int32_t v6 = v3; // 0x100003c0c
    char * v7 = (char *)v4; // 0x100003c58
    v7 = (char *)((int64_t)v7 + 1);
    while (_isspace((int32_t)*v7) != 0) {
        // 0x100003c5c
        v7 = (char *)((int64_t)v7 + 1);
    }
    int32_t v8; // 0x100003ba4
    switch (v6) {
        case 0: {
            // 0x100003ccc
            v8 = function_1000039e0();
            // break -> 0x100003d24
            break;
        }
        case 1: {
            // 0x100003cf8
            v8 = function_1000037a8();
            // break -> 0x100003d24
            break;
        }
        case 2: {
            // 0x100003cdc
            v8 = _strtol(v7, NULL, 0);
            // break -> 0x100003d24
            break;
        }
        default: {
            // 0x100003d08
            function_100002d94();
            // UNREACHABLE
        }
    }
    // 0x100003d60
    return 0x100000000 * function_100002e5c(v6, v8) >> 32;
}

// Address range: 0x100003d70 - 0x100003de4
int64_t entry_point(void) {
    // 0x100003d70
    function_10000343c();
    function_100003ba4();
    function_100002ea8((int64_t)&g14, (int64_t)&g14);
    return 0;
}

// Address range: 0x100003de4 - 0x100003df0
int64_t function_100003de4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003de4
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003df0 - 0x100003dfc
int64_t * function_100003df0(int32_t nmemb, int32_t size) {
    // 0x100003df0
    return _calloc(nmemb, size);
}

// Address range: 0x100003dfc - 0x100003e08
void function_100003dfc(int32_t status) {
    // 0x100003dfc
    _exit(status);
}

// Address range: 0x100003e08 - 0x100003e14
int32_t function_100003e08(struct _IO_FILE * stream) {
    // 0x100003e08
    return _fgetc(stream);
}

// Address range: 0x100003e14 - 0x100003e20
struct _IO_FILE * function_100003e14(char * filename, char * modes) {
    // 0x100003e14
    return _fopen(filename, modes);
}

// Address range: 0x100003e20 - 0x100003e2c
int32_t function_100003e20(int32_t c) {
    // 0x100003e20
    return _isspace(c);
}

// Address range: 0x100003e2c - 0x100003e38
int32_t function_100003e2c(char * format, ...) {
    // 0x100003e2c
    return _printf(format);
}

// Address range: 0x100003e38 - 0x100003e44
int64_t * function_100003e38(int64_t * ptr, int32_t size) {
    // 0x100003e38
    return _realloc(ptr, size);
}

// Address range: 0x100003e44 - 0x100003e50
int32_t function_100003e44(char * s1, char * s2) {
    // 0x100003e44
    return _strcmp(s1, s2);
}

// Address range: 0x100003e50 - 0x100003e5c
char * function_100003e50(char * s) {
    // 0x100003e50
    return _strdup(s);
}

// Address range: 0x100003e5c - 0x100003e68
int32_t function_100003e5c(char * s) {
    // 0x100003e5c
    return _strlen(s);
}

// Address range: 0x100003e68 - 0x100003e74
char * function_100003e68(char * s, char * delim) {
    // 0x100003e68
    return _strtok(s, delim);
}

// Address range: 0x100003e74 - 0x100003e80
int32_t function_100003e74(char * nptr, char ** endptr, int32_t base) {
    // 0x100003e74
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 25

