//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003aa4(void);
int64_t function_100003b0c(void);
int64_t function_100003b74(void);
int64_t function_100003f24(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f30(int64_t a1);
int32_t function_100003f3c(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003f54(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f60(void);
void function_100003f6c(int32_t seed);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _rand(void);
void _srand(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003aa4 - 0x100003b0c
int64_t function_100003aa4(void) {
    // 0x100003aa4
    int64_t v1; // 0x100003aa4
    uint64_t v2 = v1;
    return v2 % 256 < 127 == ((v2 & 224) != 0);
}

// Address range: 0x100003b0c - 0x100003b74
int64_t function_100003b0c(void) {
    // 0x100003b0c
    int64_t v1; // 0x100003b0c
    return (v1 & 128) != 0;
}

// Address range: 0x100003b74 - 0x100003d4c
int64_t function_100003b74(void) {
    // 0x100003b74
    int64_t result; // 0x100003b74
    uint64_t v1 = result;
    int64_t v2; // bp-296, 0x100003b74
    _memset(&v2, 0, 256);
    uint64_t v3 = v1 < 255 ? v1 : 255;
    int64_t v4; // 0x100003b74
    int64_t v5; // 0x100003b74
    int64_t v6; // 0x100003b74
    int64_t v7; // 0x100003b74
    int64_t v8; // 0x100003b74
    int64_t v9; // 0x100003b74
    int64_t v10; // 0x100003b74
    int64_t v11; // 0x100003b74
    if (v3 == 0) {
        // 0x100003c98
        v4 = ___memset_chk(result, 0, 0, -1);
        v9 = 0;
    } else {
        // 0x100003c08
        v11 = &v2;
        v7 = 0;
        v5 = 0;
        while (true) {
          lab_0x100003c08:
            // 0x100003c08
            v6 = v5;
            v8 = v7;
            if ((int32_t)result == 0) {
                goto lab_0x100003c3c;
            } else {
                // 0x100003c1c
                if ((int32_t)function_100003b0c() == 0) {
                    goto lab_0x100003c3c;
                } else {
                    goto lab_0x100003c5c;
                }
            }
        }
      lab_0x100003c98:;
        int64_t v12 = ___memset_chk(result, 0, v3, -1); // 0x100003ca8
        v4 = v12;
        v9 = 0;
        if (v10 != 0) {
            int64_t v13 = 0;
            *(char *)(v13 + result) = *(char *)(v13 + v11);
            int64_t v14 = v13 + 1; // 0x100003cf0
            v4 = v12;
            v9 = v10;
            while (v14 != v10) {
                // 0x100003ccc
                v13 = v14;
                *(char *)(v13 + result) = *(char *)(v13 + v11);
                v14 = v13 + 1;
                v4 = v12;
                v9 = v10;
            }
        }
    }
    // 0x100003cfc
    *(char *)(v9 + result) = 0;
    int64_t v15 = *(int64_t *)0x100004010; // 0x100003d1c
    if (*(int64_t *)v15 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003d34
        ___stack_chk_fail(v4);
    }
    // 0x100003d38
    return result;
  lab_0x100003c3c:;
    int64_t v16 = v8; // 0x100003c54
    if ((int32_t)function_100003aa4() == 0) {
        goto lab_0x100003c88;
    } else {
        goto lab_0x100003c5c;
    }
  lab_0x100003c88:
    // 0x100003c88
    v10 = v16;
    int64_t v17 = v6 + 1; // 0x100003c8c
    v7 = v10;
    v5 = v17;
    if (v17 >= v3) {
        // break -> 0x100003c98
        goto lab_0x100003c98;
    }
    goto lab_0x100003c08;
  lab_0x100003c5c:;
    char v18 = *(char *)(v6 + result); // 0x100003c68
    *(char *)(v8 + v11) = v18;
    v16 = v8 + 1;
    goto lab_0x100003c88;
}

// Address range: 0x100003d4c - 0x100003f24
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d68
    int64_t v2; // bp-140, 0x100003d4c
    _memset(&v2, 0, 100);
    int64_t v3; // bp-240, 0x100003d4c
    _memset(&v3, 0, 100);
    _srand(0x20d81);
    _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004018, "Original:\t");
    for (int64_t i = 0; i < 100; i++) {
        // 0x100003df8
        *(char *)(i + (int64_t)&v2) = (char)_rand();
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004018, "%c", 100);
    }
    int64_t * v4 = (int64_t *)*(int64_t *)0x100004018; // 0x100003e58
    _fprintf((struct _IO_FILE *)*v4, "\n");
    _memcpy(&v3, &v2, 100);
    function_100003b74();
    _fprintf((struct _IO_FILE *)*v4, "\nEXT:\t%s\n", (char *)1);
    function_100003b74();
    int32_t v5 = _fprintf((struct _IO_FILE *)*v4, "\nASCII:\t%s\n", NULL); // 0x100003ee8
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003f0c
        ___stack_chk_fail((int64_t)v5);
    }
    // 0x100003f10
    return 0;
}

// Address range: 0x100003f24 - 0x100003f30
int64_t function_100003f24(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f24
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(int64_t a1) {
    // 0x100003f30
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f3c
    return _fprintf(stream, format);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f48
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f54
    return _memset(s, c, n);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(void) {
    // 0x100003f60
    return _rand();
}

// Address range: 0x100003f6c - 0x100003f78
void function_100003f6c(int32_t seed) {
    // 0x100003f6c
    _srand(seed);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

