//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b60(void);
int64_t function_100003c28(void);
int64_t function_100003d9c(void);
int64_t function_100003e10(void);
int64_t * function_100003f74(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003f80(int64_t * addr, int32_t len);
int32_t function_100003f8c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b60 - 0x100003c28
int64_t function_100003b60(void) {
    int64_t result = (int64_t)_mmap(NULL, 24, 3, 0x1002, -1, 0); // 0x100003b8c
    int64_t v1 = g2; // 0x100003b98
    int64_t v2; // 0x100003b60
    if (v1 == 0) {
        // 0x100003bcc
        g1 = result;
        v2 = result;
    } else {
        // 0x100003bac
        *(int64_t *)(v1 + 16) = result;
        v2 = *(int64_t *)(g2 + 16);
    }
    // 0x100003be8
    *(int64_t *)(v2 + 16) = 0;
    g2 = v2;
    return result;
}

// Address range: 0x100003c28 - 0x100003d9c
int64_t function_100003c28(void) {
    int64_t v1 = g1; // 0x100003c3c
    if (v1 == 0) {
        // 0x100003d8c
        return 0;
    }
    int64_t * v2 = (int64_t *)v1; // 0x100003c64
    int64_t v3; // 0x100003c28
    if (*v2 == v3) {
        int64_t v4 = *(int64_t *)(v1 + 16); // 0x100003c80
        g1 = v4;
        if (v4 == 0) {
            // 0x100003cac
            g2 = 0;
        }
        // 0x100003cb8
        _munmap(v2, 24);
        // 0x100003d8c
        return *(int64_t *)(v1 + 8);
    }
    int64_t v5 = v1;
    int64_t * v6 = (int64_t *)(v5 + 16);
    int64_t v7 = *v6; // 0x100003cd8
    int64_t result = 0; // 0x100003ce4
    int64_t * v8; // 0x100003c28
    while (v7 != 0) {
        // 0x100003cec
        v8 = (int64_t *)v7;
        if (*v8 == v3) {
            // 0x100003d14
            if (v7 == g2) {
                // 0x100003d40
                g2 = v5;
                goto lab_0x100003d50;
            } else {
                goto lab_0x100003d50;
            }
        }
        v5 = v7;
        v6 = (int64_t *)(v5 + 16);
        v7 = *v6;
        result = 0;
    }
    // 0x100003d8c
    return result;
  lab_0x100003d50:
    // 0x100003d50
    *v6 = *(int64_t *)(v7 + 16);
    _munmap(v8, 24);
    result = *(int64_t *)(v7 + 8);
    return result;
}

// Address range: 0x100003d9c - 0x100003e10
int64_t function_100003d9c(void) {
    int64_t result = 0; // 0x100003db8
    int64_t v1; // 0x100003d9c
    if (v1 != 0) {
        int64_t * v2 = _mmap(NULL, (int32_t)v1, 3, 0x1002, -1, 0); // 0x100003de0
        function_100003b60();
        result = (int64_t)v2;
    }
    // 0x100003e00
    return result;
}

// Address range: 0x100003e10 - 0x100003e44
int64_t function_100003e10(void) {
    // 0x100003e10
    int64_t v1; // 0x100003e10
    return _munmap((int64_t *)v1, (int32_t)function_100003c28());
}

// Address range: 0x100003e44 - 0x100003f74
int64_t entry_point(void) {
    int64_t v1 = function_100003d9c(); // 0x100003e64
    function_100003d9c();
    function_100003d9c();
    int64_t v2 = 0; // 0x100003e98
    if (v1 == 0) {
        // 0x100003f4c
        function_100003e10();
        function_100003e10();
        function_100003e10();
        return 0;
    }
    int32_t v3 = v2;
    *(int32_t *)(4 * v2 + v1) = v3 * v3;
    v2++;
    int32_t v4 = 0; // 0x100003eb4
    while (v2 != 4) {
        // 0x100003ebc
        v3 = v2;
        *(int32_t *)(4 * v2 + v1) = v3 * v3;
        v2++;
        v4 = 0;
    }
    int64_t v5; // 0x100003e44
    _printf("p1[%d] == %d\n", v5, v5);
    int32_t v6 = v4 + 1; // 0x100003f3c
    v4 = v6;
    while (v6 != 4) {
        // 0x100003f04
        _printf("p1[%d] == %d\n", v5, v5);
        v6 = v4 + 1;
        v4 = v6;
    }
    // 0x100003f4c
    function_100003e10();
    function_100003e10();
    function_100003e10();
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int64_t * function_100003f74(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003f74
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(int64_t * addr, int32_t len) {
    // 0x100003f80
    return _munmap(addr, len);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

