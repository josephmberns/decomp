//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000341c(void);
int64_t function_1000034bc(int64_t a1);
int64_t function_1000034ec(void);
int64_t function_1000035cc(void);
int64_t function_10000367c(void);
int64_t function_1000037e0(int64_t * a1);
int64_t function_100003808(void);
int64_t function_100003930(void);
int64_t function_100003984(void);
int64_t function_100003a48(void);
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003e68(int64_t a1);
int64_t * function_100003e74(int32_t nmemb, int32_t size);
int32_t function_100003e80(struct _IO_FILE * stream, char * format, ...);
void function_100003e8c(int64_t * ptr);
int64_t * function_100003e98(int64_t * s, int32_t c, int32_t n);
int32_t function_100003ea4(char * format, ...);
char * function_100003eb0(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f15
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x10000341c - 0x1000034bc
int64_t function_10000341c(void) {
    // 0x10000341c
    int64_t v1; // 0x10000341c
    int32_t v2 = v1; // 0x10000342c
    int64_t * v3 = _calloc((v2 + 31) / 32, 4); // 0x10000344c
    int64_t result = 0; // 0x100003460
    if (v3 != NULL) {
        // 0x10000347c
        *(int32_t *)v1 = v2;
        *(int64_t *)(v1 + 8) = (int64_t)v3;
        result = 1;
    }
    // 0x1000034a8
    return result;
}

// Address range: 0x1000034bc - 0x1000034ec
int64_t function_1000034bc(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1000034d0
    _free((int64_t *)*v1);
    *v1 = 0;
    return &g2;
}

// Address range: 0x1000034ec - 0x1000035cc
int64_t function_1000034ec(void) {
    // 0x1000034ec
    int64_t v1; // 0x1000034ec
    uint32_t v2 = (int32_t)v1; // 0x1000034fc
    int64_t result; // 0x1000034ec
    if ((int32_t)v1 <= v2) {
        // 0x100003534
        result = ___assert_rtn("bit_array_set", "unprimeable-numbers.c", 28, "index < b->size");
    }
    int32_t * v3 = (int32_t *)(*(int64_t *)(v1 + 8) + (v1 / 8 & 0x1ffffffc)); // 0x10000356c
    int32_t v4 = 1 << v2 % 32; // 0x10000357c
    int32_t v5 = *v3;
    *v3 = (uint64_t)v1 % 2 == 0 ? v5 & -1 - v4 : v5 | v4;
    return result;
}

// Address range: 0x1000035cc - 0x10000367c
int64_t function_1000035cc(void) {
    // 0x1000035cc
    int64_t v1; // 0x1000035cc
    uint64_t v2 = v1;
    uint32_t v3 = (int32_t)v2; // 0x1000035dc
    if ((int32_t)v1 <= v3) {
        // 0x100003608
        ___assert_rtn("bit_array_get", "unprimeable-numbers.c", 38, "index < b->size");
    }
    int32_t v4 = *(int32_t *)(*(int64_t *)(v1 + 8) + (v2 / 8 & 0x1ffffffc)); // 0x10000365c
    return (v4 & 1 << v3 % 32) != 0;
}

// Address range: 0x10000367c - 0x1000037e0
int64_t function_10000367c(void) {
    // 0x10000367c
    if (function_10000341c() % 2 == 0) {
        // 0x1000037cc
        return 0;
    }
    // 0x1000036d0
    int64_t v1; // 0x10000367c
    uint32_t v2 = (int32_t)v1; // 0x10000368c
    if (v2 <= 9 == (v2 != 9)) {
        // 0x1000037ac
        *(int32_t *)v1 = v2;
        // 0x1000037cc
        return 1;
    }
    int32_t v3 = 3;
    int32_t v4; // 0x10000367c
    int32_t v5; // 0x10000367c
    int32_t v6; // 0x100003788
    int32_t v7; // 0x100003724
    if (function_1000035cc() % 2 == 0) {
        // 0x10000371c
        v4 = 9;
        v7 = 2 * v3;
        v5 = v4;
        if (v4 >= v2 != v4 != v2) {
            function_1000034ec();
            v6 = v5 + v7;
            v5 = v6;
            while (v6 >= v2 != v6 != v2) {
                // 0x100003758
                function_1000034ec();
                v6 = v5 + v7;
                v5 = v6;
            }
        }
    }
    int32_t v8 = v3 + 2; // 0x1000037a0
    int32_t v9 = v8 * v8; // 0x1000036d8
    int32_t v10 = v9; // 0x1000036e8
    while (v9 >= v2 != v9 != v2) {
        // 0x1000036f0
        v3 = v8;
        if (function_1000035cc() % 2 == 0) {
            // 0x10000371c
            v4 = v10;
            v7 = 2 * v3;
            v5 = v4;
            if (v4 >= v2 != v4 != v2) {
                function_1000034ec();
                v6 = v5 + v7;
                v5 = v6;
                while (v6 >= v2 != v6 != v2) {
                    // 0x100003758
                    function_1000034ec();
                    v6 = v5 + v7;
                    v5 = v6;
                }
            }
        }
        // 0x10000379c
        v8 = v3 + 2;
        v9 = v8 * v8;
        v10 = v9;
    }
    // 0x1000037ac
    *(int32_t *)v1 = v2;
    // 0x1000037cc
    return 1;
}

// Address range: 0x1000037e0 - 0x100003808
int64_t function_1000037e0(int64_t * a1) {
    // 0x1000037e0
    return function_1000034bc((int64_t)a1 + 8);
}

// Address range: 0x100003808 - 0x100003930
int64_t function_100003808(void) {
    // 0x100003808
    int64_t v1; // 0x100003808
    uint32_t v2 = (int32_t)v1; // 0x100003818
    uint32_t v3 = (int32_t)v1;
    if (v3 <= v2 == (v3 != v2)) {
        // 0x100003844
        ___assert_rtn("is_prime", "unprimeable-numbers.c", 68, "n <= s->limit");
    }
    // 0x100003868
    if (v2 == 2) {
        // 0x10000391c
        return 1;
    }
    // 0x100003890
    if (v2 < 2) {
        // 0x10000391c
        return 0;
    }
    int64_t result = 0; // 0x1000038c0
    if (2 * v2 / 2 != v2) {
        // 0x1000038dc
        result = function_1000035cc() % 2 == 0;
    }
    // 0x10000391c
    return result;
}

// Address range: 0x100003930 - 0x100003984
int64_t function_100003930(void) {
    // 0x100003930
    int64_t v1; // 0x100003930
    int32_t v2 = v1; // 0x100003934
    int32_t result = 0; // 0x10000394c
    if (v2 == 0) {
        // 0x100003978
        return 0;
    }
    uint32_t v3 = v2; // 0x10000394c
    result++;
    while (v3 >= 10) {
        // 0x100003954
        v3 /= 10;
        result++;
    }
    // 0x100003978
    return result;
}

// Address range: 0x100003984 - 0x100003a48
int64_t function_100003984(void) {
    // 0x100003984
    int64_t v1; // 0x100003984
    int32_t v2 = v1; // 0x100003988
    int32_t v3 = v1; // 0x10000398c
    int32_t v4 = v2 % 10;
    int32_t v5 = v2; // 0x1000039b0
    int32_t v6 = v3; // 0x1000039b0
    int32_t v7 = 0; // 0x1000039b0
    if (v3 == 0) {
        // 0x100003a10
        return v2 + (int32_t)v1 - v4;
    }
    int32_t v8 = 1; // 0x1000039b0
    v7 += v8 * v4;
    v8 *= 10;
    v5 /= 10;
    v6--;
    int32_t v9 = v5 % 10;
    while (v6 != 0) {
        // 0x1000039b8
        v7 += v8 * v9;
        v8 *= 10;
        v5 /= 10;
        v6--;
        v9 = v5 % 10;
    }
    // 0x100003a10
    return (v5 + (int32_t)v1 - v9) * v8 + v7;
}

// Address range: 0x100003a48 - 0x100003b70
int64_t function_100003a48(void) {
    // 0x100003a48
    if (function_100003808() % 2 != 0) {
        // 0x100003b5c
        return 0;
    }
    uint32_t v1 = (int32_t)function_100003930(); // 0x100003a8c
    int32_t v2 = 0; // 0x100003aa8
    int64_t result = 1; // 0x100003aa8
    if (v1 == 0) {
      lab_0x100003b5c:
        // 0x100003b5c
        return result;
    }
    int32_t v3 = 0; // 0x100003b28
    int64_t v4; // 0x100003a48
    if ((int32_t)v4 != (int32_t)function_100003984()) {
        // 0x100003af8
        result = 0;
        if (function_100003808() % 2 != 0) {
            return result;
        }
    }
    while (v3 >= 8 != v3 != 8) {
        // 0x100003b24
        v3++;
        if ((int32_t)v4 != (int32_t)function_100003984()) {
            // 0x100003af8
            result = 0;
            if (function_100003808() % 2 != 0) {
                return result;
            }
        }
    }
    // 0x100003b38
    v2++;
    while (v2 < v1) {
        // 0x100003ab8
        v3 = 0;
        if ((int32_t)v4 != (int32_t)function_100003984()) {
            // 0x100003af8
            result = 0;
            if (function_100003808() % 2 != 0) {
                return result;
            }
        }
        while (v3 >= 8 != v3 != 8) {
            // 0x100003b24
            v3++;
            if ((int32_t)v4 != (int32_t)function_100003984()) {
                // 0x100003af8
                result = 0;
                if (function_100003808() % 2 != 0) {
                    return result;
                }
            }
        }
        // 0x100003b38
        v2++;
    }
    // 0x100003b5c
    return 1;
}

// Address range: 0x100003b70 - 0x100003e5c
int64_t entry_point(void) {
    // 0x100003b70
    _setlocale(0, (char *)&g1);
    int64_t v1 = 0; // bp-96, 0x100003bb8
    int64_t result; // 0x100003b70
    int32_t v2; // 0x100003b70
    if (function_10000367c() % 2 == 0) {
        int64_t v3 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003bd8
        v2 = _fprintf((struct _IO_FILE *)v3, "Out of memory\n");
        result = 1;
    } else {
        // 0x100003bf4
        _printf("First 35 unprimeable numbers:\n");
        int64_t v4; // bp-64, 0x100003b70
        _memset(&v4, 0, 40);
        int64_t v5 = &v4;
        int32_t v6 = 100;
        uint32_t v7 = 0;
        int32_t v8 = 0;
        if (v8 >= 10) {
            // 0x100003c80
            if (v7 >= 600) {
                // break -> 0x100003dac
                break;
            }
        }
        int32_t v9 = v7; // 0x100003c98
        int32_t v10 = v8; // 0x100003c98
        int32_t v11; // 0x100003b70
        int32_t v12; // 0x100003b70
        int32_t * v13; // 0x100003d5c
        if (function_100003a48() % 2 != 0) {
            if (v7 < 35) {
                if (v7 != 0) {
                    // 0x100003cc8
                    _printf(", ");
                }
                // 0x100003cf8
                _printf("%'u", v6);
                v11 = v7 + 1;
            } else {
                // 0x100003cf8
                v11 = v7 + 1;
                if (v7 == 599) {
                    // 0x100003d18
                    _printf("\n600th unprimeable number: %'u\n", v6);
                    v11 = 600;
                }
            }
            // 0x100003d38
            v12 = v11;
            v13 = (int32_t *)((int64_t)(4 * (v6 % 10)) + v5);
            v9 = v12;
            v10 = v8;
            if (*v13 == 0) {
                // 0x100003d70
                *v13 = v6;
                v9 = v12;
                v10 = v8 + 1;
            }
        }
        int32_t v14 = v6 + 1; // 0x100003da0
        int32_t v15 = v6; // 0x100003c3c
        int32_t v16 = 0x98967f; // 0x100003c3c
        while (v14 < 0x989680) {
            // 0x100003c44
            v6 = v14;
            v7 = v9;
            v8 = v10;
            if (v8 >= 10) {
                // 0x100003c80
                v16 = v15;
                if (v7 >= 600) {
                    // break -> 0x100003dac
                    break;
                }
            }
            // 0x100003c8c
            v9 = v7;
            v10 = v8;
            if (function_100003a48() % 2 != 0) {
                if (v7 < 35) {
                    if (v7 != 0) {
                        // 0x100003cc8
                        _printf(", ");
                    }
                    // 0x100003cf8
                    _printf("%'u", v6);
                    v11 = v7 + 1;
                } else {
                    // 0x100003cf8
                    v11 = v7 + 1;
                    if (v7 == 599) {
                        // 0x100003d18
                        _printf("\n600th unprimeable number: %'u\n", v6);
                        v11 = 600;
                    }
                }
                // 0x100003d38
                v12 = v11;
                v13 = (int32_t *)((int64_t)(4 * (v6 % 10)) + v5);
                v9 = v12;
                v10 = v8;
                if (*v13 == 0) {
                    // 0x100003d70
                    *v13 = v6;
                    v9 = v12;
                    v10 = v8 + 1;
                }
            }
            // 0x100003d9c
            v14 = v6 + 1;
            v15 = v6;
            v16 = 0x98967f;
        }
        // 0x100003dac
        function_1000037e0(&v1);
        int32_t v17 = 0; // 0x100003e0c
        v17++;
        v2 = _printf("Least unprimeable number ending in %u: %'u\n", v16, 40);
        result = 0;
        while (v17 != 10) {
            // 0x100003dd0
            v17++;
            v2 = _printf("Least unprimeable number ending in %u: %'u\n", v16, 40);
            result = 0;
        }
    }
    int64_t v18 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e34
    if (v18 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003e48
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003e4c
    return result;
}

// Address range: 0x100003e5c - 0x100003e68
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e5c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(int64_t a1) {
    // 0x100003e68
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e74 - 0x100003e80
int64_t * function_100003e74(int32_t nmemb, int32_t size) {
    // 0x100003e74
    return _calloc(nmemb, size);
}

// Address range: 0x100003e80 - 0x100003e8c
int32_t function_100003e80(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e80
    return _fprintf(stream, format);
}

// Address range: 0x100003e8c - 0x100003e98
void function_100003e8c(int64_t * ptr) {
    // 0x100003e8c
    _free(ptr);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int64_t * s, int32_t c, int32_t n) {
    // 0x100003e98
    return _memset(s, c, n);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// Address range: 0x100003eb0 - 0x100003ebc
char * function_100003eb0(int32_t category, char * locale) {
    // 0x100003eb0
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 19

