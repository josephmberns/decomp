//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039bc(void);
int64_t function_100003d2c(void);
void function_100003e78(int32_t status, int32_t errnum, char * format, ...);
int64_t function_100003e84(void);
int64_t function_100003e90(int64_t * a1, int64_t a2, int64_t a3);
int64_t function_100003e9c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003ea8(struct __dirstream * dirp);
void function_100003eb4(int32_t status, char * format, ...);
int32_t function_100003ec0(char * file, struct stat * buf);
struct __dirstream * function_100003ecc(char * name);
int32_t function_100003ed8(char * s);
struct dirent * function_100003ee4(struct __dirstream * dirp);
int32_t function_100003ef0(struct re_pattern_buffer * preg, char * pattern, int32_t cflags);
int32_t function_100003efc(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags);
void function_100003f08(struct re_pattern_buffer * preg);
int32_t function_100003f14(char * s1, char * s2);
int32_t function_100003f20(char * s);
void function_100003f2c(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void ___error(int32_t a1, int32_t a2, char * a3, ...);
int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t * a1, int64_t a2, int64_t a3);
int64_t ___strncpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _closedir(struct __dirstream * a1);
void _err(int32_t a1, char * a2, ...);
int32_t _lstat(char * a1, struct stat * a2);
struct __dirstream * _opendir(char * a1);
int32_t _puts(char * a1);
struct dirent * _readdir(struct __dirstream * a1);
int32_t _regcomp(struct re_pattern_buffer * a1, char * a2, int32_t a3);
int32_t _regexec(struct re_pattern_buffer * a1, char * a2, int32_t a3, struct _TYPEDEF_regmatch_t a4[1], int32_t a5);
void _regfree(struct re_pattern_buffer * a1);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
void _warn(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039bc - 0x100003d2c
int64_t function_1000039bc(void) {
    // 0x1000039bc
    int64_t v1; // 0x1000039bc
    uint64_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000039d4
    char * v4 = (char *)v1; // 0x1000039dc
    int32_t v5 = _strlen(v4); // 0x1000039f0
    int32_t result = 2; // 0x100003a08
    int64_t v6; // bp-1056, 0x1000039bc
    int64_t v7; // 0x100003a24
    int64_t v8; // 0x1000039bc
    int64_t v9; // 0x1000039bc
    int64_t v10; // 0x1000039bc
    int64_t v11; // 0x1000039bc
    if (v5 < 1023 != (1022 - v5 & v5) < 0) {
        // 0x100003a1c
        v7 = &v6;
        ___strcpy_chk(&v6, v1, 1024);
        *(char *)((int64_t)v5 + v7) = 47;
        struct __dirstream * v12 = _opendir(v4); // 0x100003a54
        if (v12 == NULL) {
            // 0x100003a70
            _warn("can't open %s", v4);
            result = 3;
        } else {
            // 0x100003a94
            ___error((int32_t)(int64_t)v12, (int32_t)v1, (char *)1024);
            g1 = 0;
            int64_t v13 = 1023 - v5;
            int64_t v14; // bp-1248, 0x1000039bc
            int64_t v15 = &v14;
            int32_t v16; // 0x1000039bc
            int32_t v17 = v16 & 0xf000;
            int32_t v18 = 0; // 0x100003a9c
            int64_t v19 = 1024; // 0x100003a9c
            int32_t v20; // 0x1000039bc
            int64_t v21; // 0x1000039bc
            int64_t v22; // 0x1000039bc
            while (true) {
                // 0x100003aa0
                v20 = v18;
                int64_t v23; // 0x1000039bc
                v9 = v23;
                v11 = v19;
                while (true) {
                  lab_0x100003aa0_2:
                    // 0x100003aa0
                    v22 = v11;
                    int64_t v24 = v9;
                    int64_t v25; // 0x1000039bc
                    while (true) {
                        // 0x100003aa0
                        v21 = v24;
                        struct dirent * v26 = _readdir(v12); // 0x100003aa4
                        if (v26 == NULL) {
                            // break (via goto) -> 0x100003c88
                            goto lab_0x100003c88;
                        }
                        // 0x100003ac0
                        v25 = (int64_t)v26 + 21;
                        char * v27 = (char *)v25;
                        while ((v2 & 4) == 0) {
                            // 0x100003ad4
                            if (*v27 != 46) {
                                // break -> 0x100003af0
                                break;
                            }
                            v26 = _readdir(v12);
                            if (v26 == NULL) {
                                // break (via goto) -> 0x100003c88
                                goto lab_0x100003c88;
                            }
                            // 0x100003ac0
                            v25 = (int64_t)v26 + 21;
                            v27 = (char *)v25;
                        }
                        int64_t v28 = (int64_t)"."; // 0x100003b0c
                        if (_strcmp(v27, ".") != 0) {
                            // 0x100003b14
                            v28 = (int64_t)"..";
                            if (_strcmp(v27, "..") != 0) {
                                // break -> 0x100003b3c
                                break;
                            }
                        }
                        // 0x100003b38
                        v24 = v28;
                    }
                    // 0x100003b3c
                    ___strncpy_chk((int64_t)(v5 + 1) + v7, v25, v13, -1);
                    if (_lstat((char *)&v6, (struct stat *)&v14) == -1) {
                        // break -> 0x100003b8c
                        break;
                    }
                    // 0x100003bb0
                    v8 = v15;
                    v10 = v13;
                    if ((v2 & 2) == 0 == v17 == 0xa000) {
                        goto lab_0x100003aa0;
                    } else {
                        if (v17 == 0x4000) {
                            int64_t v29 = v13; // 0x100003c04
                            if (v2 % 2 != 0) {
                                // 0x100003c0c
                                function_1000039bc();
                                v29 = v2 & 0xffffffff;
                            }
                            // 0x100003c20
                            v8 = v15;
                            v10 = v29;
                            if ((v2 & 8) == 0) {
                                goto lab_0x100003aa0;
                            } else {
                                goto lab_0x100003c3c;
                            }
                        } else {
                            goto lab_0x100003c3c;
                        }
                    }
                }
                // 0x100003b8c
                _warn("Can't stat %s", &v14);
                v18 = 3;
                v23 = v15;
                v19 = v13;
            }
          lab_0x100003c88:;
            int32_t v30 = _closedir(v12); // 0x100003c8c
            result = v20;
            if (v20 == 0) {
                // 0x100003cb4
                ___error(v30, (int32_t)v21, (char *)v22);
                result = g1 == 0 ? 0 : 3;
            }
        }
    }
    // 0x100003cec
    if (*(int64_t *)*(int64_t *)0x100004010 != v3) {
        // 0x100003d14
        ___stack_chk_fail();
    }
    // 0x100003d18
    return result;
  lab_0x100003aa0:
    // 0x100003aa0
    v9 = v8;
    v11 = v10;
    goto lab_0x100003aa0_2;
  lab_0x100003c3c:;
    int32_t v31 = _regexec((struct re_pattern_buffer *)v1, (char *)&v6, 0, {
        (struct {int32_t e0; int32_t e1;}){
            .e0 = 0,
            .e1 = 0
        }    
}, 0); // 0x100003c50
    v8 = v7;
    v10 = 0;
    if (v31 == 0) {
        // 0x100003c64
        _puts((char *)&v6);
        v8 = v7;
        v10 = 0;
    }
    goto lab_0x100003aa0;
}

// Address range: 0x100003d2c - 0x100003db0
int64_t function_100003d2c(void) {
    // 0x100003d2c
    int64_t v1; // bp-80, 0x100003d2c
    int64_t v2; // 0x100003d2c
    int32_t v3 = _regcomp((struct re_pattern_buffer *)&v1, (char *)v2, 5); // 0x100003d50
    int64_t result = 1; // 0x100003d5c
    if (v3 == 0) {
        int64_t v4 = function_1000039bc(); // 0x100003d80
        _regfree((struct re_pattern_buffer *)&v1);
        result = v4 & 0xffffffff;
    }
    // 0x100003da0
    return result;
}

// Address range: 0x100003db0 - 0x100003e68
int64_t entry_point(void) {
    int64_t result = function_100003d2c(); // 0x100003dd4
    uint64_t v1 = result & 0xffffffff; // 0x100003de4
    if (v1 >= 3 != v1 != 3) {
        // 0x100003df8
        return result;
    }
    // 0x100003e48
    _err(1, "Unknown error?");
    return 0;
}

// Address range: 0x100003e78 - 0x100003e84
void function_100003e78(int32_t status, int32_t errnum, char * format, ...) {
    // 0x100003e78
    ___error(status, errnum, format);
}

// Address range: 0x100003e84 - 0x100003e90
int64_t function_100003e84(void) {
    // 0x100003e84
    return ___stack_chk_fail();
}

// Address range: 0x100003e90 - 0x100003e9c
int64_t function_100003e90(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003e90
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e9c - 0x100003ea8
int64_t function_100003e9c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e9c
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(struct __dirstream * dirp) {
    // 0x100003ea8
    return _closedir(dirp);
}

// Address range: 0x100003eb4 - 0x100003ec0
void function_100003eb4(int32_t status, char * format, ...) {
    // 0x100003eb4
    _err(status, format);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(char * file, struct stat * buf) {
    // 0x100003ec0
    return _lstat(file, buf);
}

// Address range: 0x100003ecc - 0x100003ed8
struct __dirstream * function_100003ecc(char * name) {
    // 0x100003ecc
    return _opendir(name);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(char * s) {
    // 0x100003ed8
    return _puts(s);
}

// Address range: 0x100003ee4 - 0x100003ef0
struct dirent * function_100003ee4(struct __dirstream * dirp) {
    // 0x100003ee4
    return _readdir(dirp);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(struct re_pattern_buffer * preg, char * pattern, int32_t cflags) {
    // 0x100003ef0
    return _regcomp(preg, pattern, cflags);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags) {
    // 0x100003efc
    return _regexec(preg, string, nmatch, pmatch, eflags);
}

// Address range: 0x100003f08 - 0x100003f14
void function_100003f08(struct re_pattern_buffer * preg) {
    // 0x100003f08
    _regfree(preg);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * s1, char * s2) {
    // 0x100003f14
    return _strcmp(s1, s2);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * s) {
    // 0x100003f20
    return _strlen(s);
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(char * format, ...) {
    // 0x100003f2c
    _warn(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 19

