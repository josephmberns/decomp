//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003eac(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
void function_100003eb8(int32_t status);
int32_t function_100003ec4(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ed0(char * filename, char * modes);
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003ee8(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003ef4(char * format, ...);
int32_t function_100003f00(char * s1, char * s2);

// --------------------- Global Variables ---------------------

char * g1 = "\xcf\xfa\xed\xfe\f"; // 0x100008000
char * g2; // 0x100008008
int64_t g3 = 0; // 0x10000ce28
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strncpy_chk(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003be8 - 0x100003eac
int64_t entry_point(void) {
    // 0x100003be8
    int64_t v1; // 0x100003be8
    int32_t v2 = v1; // 0x100003bf8
    int32_t v3 = v2 - 1; // 0x100003c18
    struct _IO_FILE * v4; // 0x100003be8
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0) {
        // 0x100003c88
        v4 = (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008;
    } else {
        struct _IO_FILE * v5 = _fopen((char *)*(int64_t *)(v1 + 8), "r"); // 0x100003c38
        v4 = v5;
        if (v5 == NULL) {
            int64_t v6 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003c5c
            _fprintf((struct _IO_FILE *)v6, "cannot read %s\n", (char *)v1);
            _exit(1);
            // UNREACHABLE
        }
    }
    int32_t * v7 = (int32_t *)v1; // 0x100003cd4
    int32_t v8 = 0; // 0x100003ce0
    int32_t v9 = -1; // 0x100003ce0
    int32_t v10 = 0; // 0x100003ce0
    int32_t v11 = 0; // 0x100003ce0
    if (_fscanf(v4, "License %s @ %s for job %u\n", (char **)v1, (char **)v1, v7) == -1) {
      lab_0x100003dfc:
        // 0x100003dfc
        _printf("Maximum simultaneous license use is %d at the following times:\n", (int64_t)"License %s @ %s for job %u\n");
        int32_t v12 = -v11; // 0x100003e28
        if (v12 < 0 != (v11 & v12) < 0) {
            _printf("%s\n", "License %s @ %s for job %u\n");
            int32_t v13 = 1; // 0x100003e6c
            int32_t v14 = v13 - v11; // 0x100003e28
            int32_t v15 = v13; // 0x100003e30
            while (v14 < 0 != ((v14 ^ v13) & (v13 ^ v11)) < 0) {
                // 0x100003e38
                _printf("%s\n", "License %s @ %s for job %u\n");
                v13 = v15 + 1;
                v14 = v13 - v11;
                v15 = v13;
            }
        }
        int64_t v16 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e84
        if (v16 != (int64_t)v4) {
            // 0x100003e98
            _fclose(v4);
        }
        // 0x100003ea4
        _exit(0);
        return &g4;
    }
    int32_t v17; // 0x100003be8
    int32_t v18; // 0x100003be8
    int32_t v19; // 0x100003be8
    int64_t v20; // 0x100003be8
    int64_t v21; // 0x100003be8
    int64_t v22; // 0x100003be8
    int64_t v23; // 0x100003be8
    int64_t v24; // 0x100003be8
    while (true) {
      lab_0x100003ce8:;
        int32_t v25 = v9;
        v21 = v20;
        v10 += (_strcmp((char *)&g1, "OUT") == 0 ? 1 : -1);
        int32_t v26 = v10 - v25; // 0x100003d34
        if (v26 == 0 || v26 < 0 != ((v26 ^ v10) & (v10 ^ v25)) < 0) {
            // 0x100003d60
            v18 = v8;
            v17 = v25;
            v9 = v25;
            v19 = v8;
            v22 = v21;
            v24 = v23;
            if (v10 == v25) {
                goto lab_0x100003d78;
            } else {
                goto lab_0x100003df8;
            }
        } else {
            // 0x100003d60
            *(char *)&g2 = 0;
            v18 = 0;
            v17 = v10;
            goto lab_0x100003d78;
        }
    }
  lab_0x100003dc8:;
    int64_t v27 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003dd0
    _fprintf((struct _IO_FILE *)v27, "increase MAX_MAXOUT (now it is %u)\n", (int32_t)v21);
    _exit(1);
    // UNREACHABLE
  lab_0x100003d78:;
    int32_t v28 = v18;
    if (v28 < 1000 == (999 - v28 & v28) < 0) {
        // break -> 0x100003dc8
        goto lab_0x100003dc8;
    }
    // 0x100003d8c
    ___strncpy_chk(20 * (int64_t)v28 + (int64_t)&g2, &g3, 20, -1);
    v9 = v17;
    v19 = v28 + 1;
    v22 = 20;
    v24 = -1;
    goto lab_0x100003df8;
  lab_0x100003df8:;
    int32_t v29 = _fscanf(v4, "License %s @ %s for job %u\n", (char **)v22, (char **)v24, v7); // 0x100003cd4
    v23 = v24;
    v20 = v22;
    v8 = v19;
    v11 = v19;
    if (v29 == -1) {
        goto lab_0x100003dfc;
    }
    goto lab_0x100003ce8;
}

// Address range: 0x100003eac - 0x100003eb8
int64_t function_100003eac(int64_t a1, int64_t * a2, int64_t a3, int64_t a4) {
    // 0x100003eac
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003eb8 - 0x100003ec4
void function_100003eb8(int32_t status) {
    // 0x100003eb8
    _exit(status);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(struct _IO_FILE * stream) {
    // 0x100003ec4
    return _fclose(stream);
}

// Address range: 0x100003ed0 - 0x100003edc
struct _IO_FILE * function_100003ed0(char * filename, char * modes) {
    // 0x100003ed0
    return _fopen(filename, modes);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003edc
    return _fprintf(stream, format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ee8
    return _fscanf(stream, format);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * s1, char * s2) {
    // 0x100003f00
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

