//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000029e8(void);
int64_t function_100002a74(void);
int64_t function_100002bd8(void);
int64_t function_100002c80(void);
int64_t function_100002d40(void);
int64_t function_100002e6c(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100002ec8(void);
int64_t function_100002f18(void);
int64_t function_100002fd0(int64_t a1);
int64_t function_100003388(void);
int64_t function_1000033d4(int64_t a1);
int64_t function_100003898(void);
int64_t function_100003940(void);
int64_t function_100003a40(void);
int64_t function_100003bd0(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t function_100003bdc(char * nptr);
int64_t * function_100003be8(int32_t nmemb, int32_t size);
void function_100003bf4(int32_t status);
int32_t function_100003c00(struct _IO_FILE * stream);
struct _IO_FILE * function_100003c0c(char * filename, char * modes);
int32_t function_100003c18(int32_t c);
int32_t function_100003c24(char * format, ...);
int64_t * function_100003c30(int64_t * ptr, int32_t size);
int32_t function_100003c3c(char * s1, char * s2);
char * function_100003c48(char * s);
int32_t function_100003c54(char * s);
char * function_100003c60(char * s, char * delim);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x1000084a8
int32_t g2 = 0; // 0x1000084b0
struct _IO_FILE * g3 = NULL; // 0x1000084b8
float128_t * g4 = NULL; // 0x1000084c0
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x1000029e8 - 0x100002a74
int64_t function_1000029e8(void) {
    // 0x1000029e8
    int64_t v1; // 0x1000029e8
    int64_t v2; // bp-1032, 0x1000029e8
    int64_t v3; // 0x1000029e8
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("(%d, %d) error: %s\n", 0, 1000, (char *)v3);
    _exit(1);
    return &g5;
}

// Address range: 0x100002a74 - 0x100002bd8
int64_t function_100002a74(void) {
    int32_t v1 = 0; // 0x100002a8c
    int64_t result; // 0x100002bbc
    int32_t v2; // 0x100002a74
    while (true) {
        // 0x100002a90
        int64_t v3; // 0x100002a74
        *(int32_t *)v3 = v1;
        int32_t v4 = _fgetc(g3); // 0x100002a98
        int64_t v5; // 0x100002a74
        v2 = *(int32_t *)&v5;
        switch (v4) {
            case -1: {
            }
            case 10: {
                // 0x100002ac8
                result = 0;
                if (v2 != 0) {
                    // 0x100002ba4
                    *(char *)(g1 + (int64_t)v2) = 0;
                    result = g1;
                }
                // 0x100002bc8
                return result;
            }
        }
        int32_t v6 = v2 + 1; // 0x100002af4
        int32_t v7 = g2; // 0x100002afc
        int32_t v8 = v6 - v7; // 0x100002b00
        int64_t v9; // 0x100002a74
        if (v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            int32_t v10 = v7 == 0 ? 128 : 2 * v7;
            g2 = v10;
            int64_t v11 = (int64_t)_realloc((int64_t *)g1, v10); // 0x100002b64
            g1 = v11;
            v9 = v11;
        } else {
            // 0x100002aec
            v9 = g1;
        }
        // 0x100002b74
        *(char *)(v9 + (int64_t)v2) = (char)v4;
        v1 = *(int32_t *)&v5 + 1;
    }
    // 0x100002ac8
    result = 0;
    if (v2 != 0) {
        // 0x100002ba4
        *(char *)(g1 + (int64_t)v2) = 0;
        result = g1;
    }
    // 0x100002bc8
    return result;
}

// Address range: 0x100002bd8 - 0x100002c80
int64_t function_100002bd8(void) {
    // 0x100002bd8
    int64_t result; // 0x100002bd8
    int32_t v1 = result;
    if (v1 < 1) {
        // 0x100002c5c
        *(char *)(result + (int64_t)v1) = 0;
        return result;
    }
    uint32_t v2 = v1 - 1; // 0x100002c1c
    char v3 = *(char *)(result + (int64_t)v2); // 0x100002c20
    int32_t v4 = v1; // 0x100002c3c
    while (_isspace((int32_t)v3) != 0) {
        // 0x100002c48
        *(int32_t *)result = v2;
        int64_t v5; // 0x100002bd8
        int32_t v6 = *(int32_t *)&v5; // 0x100002bf4
        v4 = v6;
        if (v6 < 1) {
            // break -> 0x100002c5c
            break;
        }
        v2 = v6 - 1;
        v3 = *(char *)(result + (int64_t)v2);
        v4 = v6;
    }
    // 0x100002c5c
    *(char *)(result + (int64_t)v4) = 0;
    return result;
}

// Address range: 0x100002c80 - 0x100002d40
int64_t function_100002c80(void) {
    int64_t v1 = 0; // 0x100002cfc
    int64_t v2 = 32 * v1; // 0x100002cb8
    int64_t v3; // 0x100002c80
    while (_strcmp((char *)*(int64_t *)(v2 + (int64_t)"l<" + 8), (char *)v3) != 0) {
        // 0x100002c98
        v1++;
        if (v1 >= 31) {
            // 0x100002d08
            function_1000029e8();
            // UNREACHABLE
        }
        v2 = 32 * v1;
    }
    // 0x100002cd8
    return (int64_t)*(int32_t *)(v2 + (int64_t)"l<" + 16);
}

// Address range: 0x100002d40 - 0x100002e6c
int64_t function_100002d40(void) {
    // 0x100002d40
    function_100002a74();
    int64_t v1 = function_100002bd8(); // 0x100002d68
    int64_t v2; // 0x100002d40
    *(int32_t *)(v2 + 4) = _atoi(_strtok((char *)v1, " "));
    *(int32_t *)(v2 + 8) = _atoi(_strtok(NULL, " "));
    char * v3 = _strtok(NULL, " "); // 0x100002db8
    *(int32_t *)v2 = (int32_t)function_100002c80();
    int64_t result = _strlen(v3); // 0x100002ddc
    int64_t v4 = result + (int64_t)v3; // 0x100002de4
    int32_t v5; // 0x100002d40
    if (v4 == v1 + (int64_t)v5) {
        // 0x100002e60
        return result;
    }
    char * v6 = (char *)v4; // 0x100002e18
    v6 = (char *)((int64_t)v6 + 1);
    while (_isspace((int32_t)*v6) != 0) {
        // 0x100002e1c
        v6 = (char *)((int64_t)v6 + 1);
    }
    int64_t result2 = (int64_t)_strdup(v6); // 0x100002e50
    *(int64_t *)(v2 + 16) = result2;
    // 0x100002e60
    return result2;
}

// Address range: 0x100002e6c - 0x100002ec8
int64_t function_100002e6c(int64_t a1, int64_t a2, int64_t a3) {
    int64_t * v1 = _calloc(32, 1); // 0x100002e8c
    *(int32_t *)v1 = (int32_t)a1;
    int64_t result = (int64_t)v1; // 0x100002ea4
    *(int64_t *)(result + 8) = a2;
    *(int64_t *)(result + 16) = a3;
    return result;
}

// Address range: 0x100002ec8 - 0x100002f18
int64_t function_100002ec8(void) {
    int64_t * v1 = _calloc(32, 1); // 0x100002ee4
    int64_t result = (int64_t)v1; // 0x100002ee4
    int64_t v2; // 0x100002ec8
    *(int32_t *)v1 = (int32_t)v2;
    *(int64_t *)(result + 24) = (int64_t)_strdup((char *)v2);
    return result;
}

// Address range: 0x100002f18 - 0x100002fd0
int64_t function_100002f18(void) {
    // 0x100002f18
    int64_t v1; // 0x100002f18
    if (*(int32_t *)&g4 == (int32_t)v1) {
        // 0x100002f48
        return function_100002d40();
    }
    // 0x100002f6c
    function_1000029e8();
    // UNREACHABLE
}

// Address range: 0x100002fd0 - 0x100003320
int64_t function_100002fd0(int64_t a1) {
    uint32_t v1 = *(int32_t *)&g4 - 4; // 0x100002ff8
    if (v1 >= 25 != v1 != 25) {
        // 0x100003010
        int64_t result; // 0x100002fd0
        return result;
    }
    // 0x1000031a4
    function_1000029e8();
    // UNREACHABLE
}

// Address range: 0x100003388 - 0x1000033d4
int64_t function_100003388(void) {
    // 0x100003388
    function_100002f18();
    int64_t result = function_100002fd0((int64_t)&g5); // 0x1000033ac
    function_100002f18();
    return result;
}

// Address range: 0x1000033d4 - 0x100003824
int64_t function_1000033d4(int64_t a1) {
    uint32_t v1 = *(int32_t *)&g4; // 0x1000033ec
    if (v1 >= 28 != v1 != 28) {
        // 0x100003408
        int64_t result; // 0x1000033d4
        return result;
    }
    // 0x1000037d0
    function_1000029e8();
    // UNREACHABLE
}

// Address range: 0x100003898 - 0x100003940
int64_t function_100003898(void) {
    // 0x100003898
    function_100002d40();
    int64_t v1 = 0;
    int64_t result = function_100002e6c(3, v1, function_1000033d4(v1)); // 0x1000038e4
    while (result != 0) {
        // 0x100003924
        if (*(int32_t *)&g4 == 0) {
            // break -> 0x100003930
            break;
        }
        v1 = result;
        result = function_100002e6c(3, v1, function_1000033d4(v1));
    }
    // 0x100003930
    return result;
}

// Address range: 0x100003940 - 0x100003a40
int64_t function_100003940(void) {
    // 0x100003940
    int64_t v1; // 0x100003940
    if (v1 == 0) {
        // 0x100003a34
        return _printf(";\n");
    }
    char * v2 = (char *)v1; // 0x10000399c
    _printf("%-14s ", v2);
    int64_t result; // 0x100003940
    if ((int32_t)v1 < 3) {
        // 0x1000039e8
        result = _printf("%s\n", v2);
    } else {
        // 0x100003a08
        _printf("\n");
        function_100003940();
        result = function_100003940();
    }
    // 0x100003a34
    return result;
}

// Address range: 0x100003a40 - 0x100003ae0
int64_t function_100003a40(void) {
    // 0x100003a40
    int64_t v1; // 0x100003a40
    if ((char)v1 == 0) {
        // 0x100003ad4
        int64_t result; // 0x100003a40
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, (char *)v1); // 0x100003a8c
    int64_t result2 = (int64_t)v2; // 0x100003a8c
    *(int64_t *)v1 = result2;
    if (v2 != NULL) {
        // 0x100003ad4
        return result2;
    }
    // 0x100003aac
    function_1000029e8();
    // UNREACHABLE
}

// Address range: 0x100003ae0 - 0x100003bd0
int64_t entry_point(void) {
    // 0x100003ae0
    function_100003a40();
    function_100003a40();
    function_100003898();
    function_100003940();
    return 0;
}

// Address range: 0x100003bd0 - 0x100003bdc
int64_t function_100003bd0(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003bd0
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003bdc - 0x100003be8
int32_t function_100003bdc(char * nptr) {
    // 0x100003bdc
    return _atoi(nptr);
}

// Address range: 0x100003be8 - 0x100003bf4
int64_t * function_100003be8(int32_t nmemb, int32_t size) {
    // 0x100003be8
    return _calloc(nmemb, size);
}

// Address range: 0x100003bf4 - 0x100003c00
void function_100003bf4(int32_t status) {
    // 0x100003bf4
    _exit(status);
}

// Address range: 0x100003c00 - 0x100003c0c
int32_t function_100003c00(struct _IO_FILE * stream) {
    // 0x100003c00
    return _fgetc(stream);
}

// Address range: 0x100003c0c - 0x100003c18
struct _IO_FILE * function_100003c0c(char * filename, char * modes) {
    // 0x100003c0c
    return _fopen(filename, modes);
}

// Address range: 0x100003c18 - 0x100003c24
int32_t function_100003c18(int32_t c) {
    // 0x100003c18
    return _isspace(c);
}

// Address range: 0x100003c24 - 0x100003c30
int32_t function_100003c24(char * format, ...) {
    // 0x100003c24
    return _printf(format);
}

// Address range: 0x100003c30 - 0x100003c3c
int64_t * function_100003c30(int64_t * ptr, int32_t size) {
    // 0x100003c30
    return _realloc(ptr, size);
}

// Address range: 0x100003c3c - 0x100003c48
int32_t function_100003c3c(char * s1, char * s2) {
    // 0x100003c3c
    return _strcmp(s1, s2);
}

// Address range: 0x100003c48 - 0x100003c54
char * function_100003c48(char * s) {
    // 0x100003c48
    return _strdup(s);
}

// Address range: 0x100003c54 - 0x100003c60
int32_t function_100003c54(char * s) {
    // 0x100003c54
    return _strlen(s);
}

// Address range: 0x100003c60 - 0x100003c6c
char * function_100003c60(char * s, char * delim) {
    // 0x100003c60
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 28

