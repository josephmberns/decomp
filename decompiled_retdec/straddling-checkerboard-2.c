//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000380c(void);
int64_t function_1000039b0(void);
int64_t function_100003c08(void);
int64_t function_100003ec4(int64_t a1);
void function_100003ed0(int32_t status);
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003ee8(int64_t * s, int32_t c, int32_t n);
int32_t function_100003ef4(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1 = "\xcf\xfa\xed\xfe\f"; // 0x100008008
char * g2; // 0x100008088

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000380c - 0x1000039b0
int64_t function_10000380c(void) {
    int32_t v1 = 0;
    int64_t result; // 0x10000380c
    char * v2 = (char *)(result + (int64_t)v1); // 0x100003840
    char v3 = *v2; // 0x100003840
    char * v4; // 0x10000380c
    int32_t v5; // 0x100003944
    switch (v3) {
        case 0: {
            // 0x100003854
            _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "Table too short\n");
            _exit(1);
            // UNREACHABLE
        }
        case 32: {
            // 0x100003890
            *(int32_t *)((int64_t)"__stubs" + 4) = v1;
            // break -> 0x100003994
            break;
        }
        default: {
            // 0x1000038c4
            v4 = NULL;
            if (v1 < 10 == (9 - v1 & v1) < 0) {
                // 0x1000038e4
                v4 = v1 < 20 == (19 - v1 & v1) < 0 ? (char *)0x736275 : (char *)0x74735f5f;
            }
            // 0x100003928
            v5 = 10 * (int32_t)(int64_t)v4 + v1 % 10;
            *(char *)(((int64_t)v3 & 0xffffffff) + (int64_t)&g1) = (char)v5;
            *(char *)((int64_t)v5 + (int64_t)&g2) = *v2;
            // break -> 0x100003994
            break;
        }
    }
    int32_t v6 = v1 + 1; // 0x100003998
    while (v1 < 29 != (28 - v1 & v6) < 0) {
        // 0x100003838
        v1 = v6;
        v2 = (char *)(result + (int64_t)v1);
        v3 = *v2;
        switch (v3) {
            case 0: {
                // 0x100003854
                _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "Table too short\n");
                _exit(1);
                // UNREACHABLE
            }
            case 32: {
                // 0x100003890
                *(int32_t *)((int64_t)"__stubs" + 4) = v1;
                // break -> 0x100003994
                break;
            }
            default: {
                // 0x1000038c4
                v4 = NULL;
                if (v1 < 10 == (9 - v1 & v1) < 0) {
                    // 0x1000038e4
                    v4 = v1 < 20 == (19 - v1 & v1) < 0 ? (char *)0x736275 : (char *)0x74735f5f;
                }
                // 0x100003928
                v5 = 10 * (int32_t)(int64_t)v4 + v1 % 10;
                *(char *)(((int64_t)v3 & 0xffffffff) + (int64_t)&g1) = (char)v5;
                *(char *)((int64_t)v5 + (int64_t)&g2) = *v2;
                // break -> 0x100003994
                break;
            }
        }
        // 0x100003994
        v6 = v1 + 1;
    }
    // 0x1000039a4
    return result;
}

// Address range: 0x1000039b0 - 0x100003c08
int64_t function_1000039b0(void) {
    // 0x1000039b0
    char * v1; // 0x1000039b0
    char * v2; // 0x1000039b0
    int64_t v3; // 0x1000039b0
    int64_t v4; // 0x1000039b0
    char * v5; // 0x1000039b0
    int64_t v6; // 0x1000039b0
    int64_t result; // 0x1000039b0
    int64_t v7; // 0x1000039c8
    while (true) {
      lab_0x1000039c4_2:
        // 0x1000039c4
        v4 = v3;
        v1 = (char *)v4;
        int64_t v8 = v6; // 0x1000039b0
        int32_t v9; // 0x1000039d4
        int32_t v10; // 0x100003a00
        int32_t v11; // 0x1000039b0
        while (true) {
            char v12 = *(char *)v8; // 0x1000039d0
            if (v12 == 0) {
                // break (via goto) -> 0x100003bf0
                goto lab_0x100003bf0;
            }
            // 0x1000039e8
            v7 = v8 + 1;
            v9 = v12;
            if (v12 < 48 == (47 - v9 & v9) < 0) {
                // 0x1000039fc
                v10 = v9 - 57;
                v11 = 56 - v9;
                if (v10 == 0 || v10 < 0 != (v11 & v9) < 0) {
                    // break -> 0x100003a10
                    break;
                }
            }
            int32_t v13 = v9 & -33; // 0x100003afc
            if (v13 < 65 == (64 - v13 & v9) < 0) {
                int32_t v14 = v13 - 90; // 0x100003b1c
                if (v14 == 0 || v14 < 0 != (89 - v13 & v9) < 0) {
                    char v15 = *(char *)((int64_t)v13 + (int64_t)&g1); // 0x100003b38
                    v5 = (char *)((int64_t)v15 & 0xffffffff);
                    goto lab_0x100003b88;
                }
            }
            // 0x100003b44
            v8 = v7;
            v5 = (char *)69;
            if ((int32_t)result != 0 != (v13 == 0)) {
                goto lab_0x100003b88;
            }
        }
        int32_t v16 = v9 - 48; // 0x100003a24
        *v1 = 57;
        char * v17 = (char *)(v4 + 2); // 0x100003a88
        *(char *)(v4 + 1) = 48;
        int32_t v18 = v16; // 0x100003a9c
        char * v19 = v17; // 0x100003a9c
        if (v10 != 0 && v10 < 0 == (v16 & v11) < 0) {
            // 0x100003aa4
            *v17 = (char)(v16 / 10) + 48;
            v18 = v16 % 10;
            v19 = (char *)(v4 + 3);
        }
        // 0x100003adc
        *v19 = (char)v18 + 48;
        v2 = v19;
        goto lab_0x1000039c4;
    }
  lab_0x100003bf0:
    // 0x100003bf0
    *v1 = 0;
    return result;
  lab_0x100003b88:;
    int64_t v20 = (int64_t)v5;
    int32_t v21 = v20; // 0x100003b88
    int32_t v22 = v21 - 9; // 0x100003b8c
    int64_t v23 = v20; // 0x100003b94
    char * v24 = v1; // 0x100003b94
    if (v22 == 0 || v22 < 0 != (8 - v21 & v21) < 0) {
        goto lab_0x100003bd4;
    } else {
        // 0x100003b9c
        *v1 = (char)(v21 / 10) + 48;
        v23 = v21 % 10;
        v24 = (char *)(v4 + 1);
        goto lab_0x100003bd4;
    }
  lab_0x1000039c4:
    // 0x1000039c4
    v3 = (int64_t)v2 + 1;
    v6 = v7;
    goto lab_0x1000039c4_2;
  lab_0x100003bd4:
    // 0x100003bd4
    *v24 = (char)v23 + 48;
    v2 = v24;
    goto lab_0x1000039c4;
}

// Address range: 0x100003c08 - 0x100003d58
int64_t function_100003c08(void) {
    // 0x100003c08
    int64_t result; // 0x100003c08
    char * v1 = (char *)result;
    char v2 = *(char *)result; // 0x100003c28
    if (v2 == 0) {
        // 0x100003d40
        *v1 = 0;
        return result;
    }
    // 0x100003c40
    int64_t v3; // 0x100003c08
    char * v4 = (char *)(v3 + 1);
    int32_t v5 = (int32_t)v2 - 48; // 0x100003c44
    int32_t v6 = v5; // 0x100003c60
    char * v7 = v4; // 0x100003c60
    if (v5 == 0x736275) {
        // 0x100003c88
        v6 = (int32_t)*v4 + 0x481d862;
        v7 = (char *)(v3 + 2);
    }
    char * v8 = v7;
    char v9 = *(char *)((int64_t)v6 + (int64_t)&g2); // 0x100003cc0
    char v10 = v9; // 0x100003cd4
    char * v11 = v8; // 0x100003cd4
    if (v9 == 46) {
        // 0x100003cdc
        v10 = *v8;
        v11 = (char *)((int64_t)v8 + 1);
    }
    char v12 = v10;
    char v13 = (int32_t)result == 0 == v12 == 47 ? 32 : v12;
    int64_t v14; // 0x100003c08
    int64_t v15 = v14 + 1; // 0x100003d30
    *v1 = v13;
    char * v16 = (char *)v15;
    char v17 = *v11; // 0x100003c28
    while (v17 != 0) {
        int64_t v18 = (int64_t)v11;
        v4 = (char *)(v18 + 1);
        v5 = (int32_t)v17 - 48;
        v6 = v5;
        v7 = v4;
        if (v5 == 0x736275) {
            // 0x100003c88
            v6 = (int32_t)*v4 + 0x481d862;
            v7 = (char *)(v18 + 2);
        }
        // 0x100003cb4
        v8 = v7;
        v9 = *(char *)((int64_t)v6 + (int64_t)&g2);
        v10 = v9;
        v11 = v8;
        if (v9 == 46) {
            // 0x100003cdc
            v10 = *v8;
            v11 = (char *)((int64_t)v8 + 1);
        }
        // 0x100003cf4
        v12 = v10;
        v13 = (int32_t)result == 0 == v12 == 47 ? 32 : v12;
        v15++;
        *v16 = v13;
        v16 = (char *)v15;
        v17 = *v11;
    }
    // 0x100003d40
    *v16 = 0;
    return result;
}

// Address range: 0x100003d58 - 0x100003ec4
int64_t entry_point(void) {
    // 0x100003d58
    int64_t v1; // bp-140, 0x100003d58
    _memset(&v1, 0, 100);
    int64_t v2; // bp-240, 0x100003d58
    _memset(&v2, 0, 100);
    function_10000380c();
    _printf("message: %s\n", NULL);
    function_1000039b0();
    _printf("encoded: %s\n", &v1);
    function_100003c08();
    _printf("decoded: %s\n", &v2);
    _printf("\nNo spaces:\n");
    function_1000039b0();
    _printf("encoded: %s\n", &v1);
    function_100003c08();
    int32_t v3 = _printf("decoded: %s\n", &v2); // 0x100003e88
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e98
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003eac
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003eb0
    return 0;
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t function_100003ec4(int64_t a1) {
    // 0x100003ec4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ed0 - 0x100003edc
void function_100003ed0(int32_t status) {
    // 0x100003ed0
    _exit(status);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003edc
    return _fprintf(stream, format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t * function_100003ee8(int64_t * s, int32_t c, int32_t n) {
    // 0x100003ee8
    return _memset(s, c, n);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

