//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000032e8(void);
int64_t function_10000335c(void);
int64_t function_1000033e0(void);
int64_t function_1000034e4(void);
int64_t function_100003554(void);
int64_t function_1000035a0(void);
int64_t function_1000037f8(void);
int64_t function_100003ca8(void);
int64_t function_100003e0c(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t function_100003e18(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003e24(int32_t fd);
void function_100003e30(int64_t * ptr);
int32_t function_100003e3c(int32_t fd, struct stat * buf);
int32_t function_100003e48(int32_t c);
int64_t * function_100003e54(int32_t size);
int32_t function_100003e60(char * file, int32_t oflag, ...);
int32_t function_100003e6c(char * format, ...);
int32_t function_100003e78(int32_t fd, int64_t * buf, int32_t nbytes);
int64_t * function_100003e84(int64_t * ptr, int32_t size);
int32_t function_100003e90(char * s);
int32_t function_100003e9c(char * s1, char * s2, int32_t n);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _close(int32_t a1);
void _free(int64_t * a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000032e8 - 0x10000335c
int64_t function_1000032e8(void) {
    // 0x1000032e8
    int64_t v1; // 0x1000032e8
    int64_t v2 = *(int64_t *)(v1 + 8); // 0x1000032fc
    if (v2 != 0) {
        // 0x100003310
        _free((int64_t *)v2);
    }
    int64_t v3 = *(int64_t *)(v1 + 16); // 0x100003324
    if (v3 != 0) {
        // 0x100003338
        _free((int64_t *)v3);
    }
    // 0x100003348
    _free((int64_t *)v1);
    return &g1;
}

// Address range: 0x10000335c - 0x1000033e0
int64_t function_10000335c(void) {
    // 0x10000335c
    int64_t v1; // 0x10000335c
    int32_t v2 = _strlen((char *)v1); // 0x100003370
    int64_t * v3 = _malloc(16); // 0x100003380
    int64_t result = (int64_t)v3; // 0x100003380
    int32_t v4 = v2 + 1; // 0x10000338c
    int64_t v5 = (int64_t)_malloc(v4); // 0x100003398
    *v3 = v5;
    ___strcpy_chk(v5, v1, -1);
    *(int64_t *)(result + 8) = (int64_t)v4;
    return result;
}

// Address range: 0x1000033e0 - 0x1000034e4
int64_t function_1000033e0(void) {
    // 0x1000033e0
    int64_t v1; // 0x1000033e0
    int32_t v2 = _strlen((char *)v1); // 0x100003400
    int32_t v3 = v2; // 0x100003418
    if ((int32_t)v1 == -1) {
        // 0x100003420
        v3 = _strlen((char *)v1);
    }
    int64_t v4 = v3;
    int64_t * v5 = (int64_t *)(v1 + 8); // 0x100003438
    int32_t v6 = v3 + v2; // 0x100003444
    int32_t v7 = v6 + 1; // 0x100003448
    uint64_t v8 = (int64_t)v7; // 0x10000344c
    int64_t v9 = v4; // 0x100003454
    if (*v5 < v8) {
        // 0x10000345c
        *v5 = v8;
        v9 = (int64_t)_realloc((int64_t *)v4, v7);
        *(int64_t *)v1 = v9;
    }
    int64_t result = ___memcpy_chk(v9 + (int64_t)v2, v1, v3, -1); // 0x1000034b8
    *(char *)(result + (int64_t)v6) = 0;
    return result;
}

// Address range: 0x1000034e4 - 0x100003554
int64_t function_1000034e4(void) {
    // 0x1000034e4
    int64_t result; // 0x1000034e4
    int64_t * v1 = (int64_t *)(result + 8); // 0x1000034f4
    int64_t * v2 = (int64_t *)(result + 8); // 0x100003500
    *v1 = *v2;
    *v2 = *v1;
    *(char *)result = 0;
    return result;
}

// Address range: 0x100003554 - 0x1000035a0
int64_t function_100003554(void) {
    // 0x100003554
    int64_t v1; // 0x100003554
    int64_t * v2 = (int64_t *)v1;
    if (v1 != 0) {
        // 0x10000357c
        _free(v2);
    }
    // 0x10000358c
    _free(v2);
    return &g1;
}

// Address range: 0x1000035a0 - 0x1000037f8
int64_t function_1000035a0(void) {
    // 0x1000035a0
    function_10000335c();
    int64_t v1; // 0x1000035a0
    int64_t * v2 = (int64_t *)(v1 + 8);
    int32_t v3 = v1;
    int32_t v4 = -v3;
    int32_t v5 = 0; // 0x1000035cc
    int32_t v6 = 0; // 0x1000035dc
    int32_t v7 = 0; // 0x1000035dc
    int32_t v8 = 0; // 0x1000035dc
    while (v5 == 0 && v4 < 0 != (v4 & v3) < 0) {
        // 0x1000035d0
        int32_t v9; // 0x1000035a0
        while (true) {
            int32_t v10 = v8;
            int32_t v11 = v7;
            int32_t v12 = v6;
            int64_t v13 = 24 * (int64_t)v10; // 0x100003660
            int32_t v14 = _strlen((char *)*(int64_t *)(*v2 + v13)); // 0x100003668
            int32_t v15 = _strlen((char *)(int64_t)v14); // 0x10000367c
            int32_t v16 = -v15; // 0x100003698
            int32_t v17 = 0; // 0x1000036a0
            int32_t v18 = v15; // 0x1000036a0
            int32_t v19 = v12; // 0x1000036a0
            int32_t v20 = v11; // 0x1000036a0
            if (v16 < 0 != (v15 & v16) < 0) {
                int32_t v21 = v17;
                int64_t v22 = *(int64_t *)(*v2 + v13); // 0x1000036cc
                int32_t v23 = _strncmp((char *)((int64_t)v18 + (int64_t)v21), (char *)v22, v14); // 0x1000036d4
                while (v23 != 0) {
                    int32_t v24 = v21 + 1; // 0x1000037a8
                    int32_t v25 = v24 - v15; // 0x100003698
                    v17 = v24;
                    v18 = v23;
                    v19 = v12;
                    v20 = v11;
                    if (v25 < 0 == ((v25 ^ v24) & (v24 ^ v15)) < 0) {
                        goto lab_0x1000037b8;
                    }
                    v21 = v17;
                    v22 = *(int64_t *)(*v2 + v13);
                    v23 = _strncmp((char *)((int64_t)v18 + (int64_t)v21), (char *)v22, v14);
                }
                // 0x1000036ec
                function_1000033e0();
                function_1000033e0();
                function_1000033e0();
                function_1000034e4();
                int32_t v26 = *(int32_t *)(v13 + 16 + *v2); // 0x100003780
                v19 = 1;
                v20 = v26 == 0 ? v11 : 1;
            }
            // 0x1000037b8
            v5 = v20;
            v9 = v19;
            if ((v5 || v9) != 0) {
                // break -> 0x1000037c8
                break;
            }
            // 0x100003644
            v8 = v10 + 1;
            int32_t v27 = v8 - v3; // 0x100003634
            v6 = v9;
            v7 = v5;
            if (v27 < 0 == ((v27 ^ v8) & (v8 ^ v3)) < 0) {
                // break -> 0x1000037c8
                break;
            }
        }
        // 0x1000037c8
        if (v9 == 0) {
            // break -> 0x1000037e4
            break;
        }
        v6 = 0;
        v7 = 0;
        v8 = 0;
    }
    // 0x1000037e4
    return function_100003554();
}

// Address range: 0x1000037f8 - 0x100003ca8
int64_t function_1000037f8(void) {
    // 0x1000037f8
    int64_t v1; // 0x1000037f8
    int32_t v2 = _open((char *)v1, 0); // 0x10000381c
    if (v2 == -1) {
        // 0x100003c94
        return 0;
    }
    // 0x100003840
    int64_t v3; // bp-192, 0x1000037f8
    _fstat(v2, (struct stat *)&v3);
    char * v4; // 0x1000037f8
    int64_t v5 = (int64_t)v4; // 0x10000384c
    int32_t v6 = v5;
    int64_t * v7 = _malloc(v6 + 2); // 0x100003854
    int64_t v8 = (int64_t)v7; // 0x100003854
    _read(v2, v7, v6);
    int64_t v9 = v8 + v5;
    *(char *)v9 = 10;
    *(char *)(v9 + 1) = 0;
    _close(v2);
    int32_t v10 = 0; // 0x1000038a4
    int64_t v11 = 0; // 0x1000038a4
    int64_t v12 = 0; // 0x1000038a4
    int64_t v13 = v8; // 0x1000038a4
    int64_t v14 = v5; // 0x1000038a4
    int64_t v15 = 0; // 0x1000038a4
    int64_t v16; // 0x1000037f8
    int64_t v17; // 0x1000037f8
    int64_t v18; // 0x1000037f8
    int32_t v19; // 0x1000037f8
    int64_t v20; // 0x1000037f8
    uint64_t v21; // 0x1000037f8
    char * v22; // 0x1000038b0
    int64_t v23; // 0x1000038ec
    int64_t v24; // 0x1000037f8
    int64_t v25; // 0x1000037f8
    while (true) {
      lab_0x1000038a8_2:
        // 0x1000038a8
        v21 = v15;
        int64_t v26 = v14;
        int64_t v27 = v13;
        v18 = v12;
        v16 = v11;
        v19 = v10;
        v22 = (char *)(v21 + v8);
        switch (*v22) {
            case 0: {
                goto lab_0x100003c58;
            }
            case 10: {
                // 0x1000038e4
                v23 = v16 + v8;
                if (v21 == v16 | *(char *)v23 == 35) {
                    int64_t v28 = v21 + 1;
                    v15 = v28;
                    v10 = v19;
                    v11 = v28;
                    v12 = v18;
                    v13 = v27;
                    v14 = v26;
                    goto lab_0x1000038a8_2;
                } else {
                    int64_t v29 = v16 + 1;
                    uint64_t v30 = v21 - 3; // 0x100003940
                    int64_t v31 = v29; // 0x10000394c
                    int64_t v32 = v16; // 0x10000394c
                    int64_t v33 = v26; // 0x10000394c
                    int64_t v34 = v27; // 0x10000394c
                    v24 = v27;
                    v25 = v26;
                    if (v29 >= v30) {
                        goto lab_0x1000039d8_2;
                    }
                    while (true) {
                        int64_t v35 = v31;
                        int64_t v36 = v35 + v8; // 0x10000395c
                        int64_t v37 = v34; // 0x10000396c
                        int64_t v38 = v33; // 0x10000396c
                        if (_isspace((int32_t)*(char *)v36) != 0) {
                            // 0x100003974
                            v20 = v32;
                            v37 = (int64_t)"->";
                            v38 = 2;
                            v17 = v35;
                            if (_strncmp((char *)(v36 + 1), "->", 2) == 0) {
                                goto lab_0x100003a18;
                            }
                        }
                        // 0x1000039ac
                        v33 = v38;
                        v34 = v37;
                        v31 = v35 + 1;
                        v32 = v35;
                        v24 = v34;
                        v25 = v33;
                        if (v31 >= v30) {
                            goto lab_0x1000039d8_2;
                        }
                    }
                    goto lab_0x100003a70;
                }
            }
            default: {
                // 0x1000038a8
                v15 = v21 + 1;
                v10 = v19;
                v11 = v16;
                v12 = v18;
                v13 = v27;
                v14 = v26;
                goto lab_0x1000038a8_2;
            }
        }
    }
  lab_0x1000039d8_2:
    // 0x1000039d8
    _printf("parse error: no -> in %.*s\n", v24, (char *)v25);
    goto lab_0x100003c58;
  lab_0x100003a18:;
    int64_t v56 = v17;
    int64_t v40 = v56; // 0x100003a30
    if (v56 == v16 || v56 < v16) {
        goto lab_0x100003a70;
    } else {
        int64_t v57 = v56 - 1; // 0x100003a40
        v17 = v57;
        v40 = v57;
        if (_isspace((int32_t)*(char *)(v57 + v8)) == 0) {
            goto lab_0x100003a70;
        } else {
            goto lab_0x100003a18;
        }
    }
  lab_0x100003c58:;
    int64_t * v39 = _malloc(24); // 0x100003c5c
    int64_t result = (int64_t)v39; // 0x100003c5c
    *(int64_t *)(result + 16) = v8;
    *(int64_t *)(result + 8) = v18;
    *(int32_t *)v39 = v19;
    // 0x100003c94
    return result;
  lab_0x100003c48:
    // 0x100003c48
    goto lab_0x1000038a8_2;
  lab_0x100003a70:
    // 0x100003a70
    if (v40 < v16) {
        // 0x100003a88
        _printf("left side blank? %.*s\n", (int64_t)"->", (char *)2);
        goto lab_0x100003c58;
    }
    // 0x100003abc
    *(char *)(v8 + 1 + v40) = 0;
    uint64_t v41 = v20 + 4;
    int64_t v42; // 0x1000037f8
    char * v43; // 0x1000037f8
    while (v41 < v21) {
        int64_t v44 = v41 + 1; // 0x100003b0c
        int64_t v45 = v44 + v8;
        char * v46 = (char *)v45;
        int64_t v47 = v44; // 0x100003b30
        v43 = v46;
        v42 = v45;
        if (_isspace((int32_t)*v46) == 0) {
            goto lab_0x100003b3c;
        }
        v41 = v47;
    }
    int64_t v48 = v41 + v8; // 0x100003b98
    v43 = (char *)v48;
    v42 = v48;
  lab_0x100003b3c:;
    int64_t v49 = v42;
    *v22 = 0;
    int32_t v50 = v19 + 1; // 0x100003b54
    int64_t v51 = 24 * (int64_t)v50; // 0x100003b64
    int64_t v52 = (int64_t)_realloc((int64_t *)v18, (int32_t)v51); // 0x100003b68
    int64_t v53 = 24 * (int64_t)v19 + v52; // 0x100003b8c
    *(int64_t *)v53 = v23;
    int32_t * v54 = (int32_t *)(v53 + 16);
    if (*v43 == 46) {
        // 0x100003bac
        *v54 = 1;
        *(int64_t *)(v53 + 8) = v49 + 1;
    } else {
        // 0x100003bf0
        *v54 = 0;
        *(int64_t *)(v53 + 8) = v49;
    }
    int64_t v55 = v21 + 1;
    v15 = v55;
    v10 = v50;
    v11 = v55;
    v12 = v52;
    v13 = v51;
    v14 = 2;
    goto lab_0x100003c48;
}

// Address range: 0x100003ca8 - 0x100003d80
int64_t function_100003ca8(void) {
    int64_t v1 = function_1000037f8(); // 0x100003cc0
    int64_t result = 0; // 0x100003cd4
    if (v1 != 0) {
        // 0x100003ce4
        int64_t v2; // 0x100003ca8
        char * v3 = (char *)v2; // 0x100003cf8
        _printf("Rules from '%s' ok\n", v3);
        function_10000335c();
        _printf("text:     %s\n", v3);
        function_1000035a0();
        _printf("markoved: %s\n", (char *)v1);
        function_100003554();
        function_1000032e8();
        result = _printf("\n");
    }
    // 0x100003d70
    return result;
}

// Address range: 0x100003d80 - 0x100003e0c
int64_t entry_point(void) {
    // 0x100003d80
    function_100003ca8();
    function_100003ca8();
    function_100003ca8();
    function_100003ca8();
    function_100003ca8();
    return 0;
}

// Address range: 0x100003e0c - 0x100003e18
int64_t function_100003e0c(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003e0c
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e18 - 0x100003e24
int64_t function_100003e18(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003e18
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e24 - 0x100003e30
int32_t function_100003e24(int32_t fd) {
    // 0x100003e24
    return _close(fd);
}

// Address range: 0x100003e30 - 0x100003e3c
void function_100003e30(int64_t * ptr) {
    // 0x100003e30
    _free(ptr);
}

// Address range: 0x100003e3c - 0x100003e48
int32_t function_100003e3c(int32_t fd, struct stat * buf) {
    // 0x100003e3c
    return _fstat(fd, buf);
}

// Address range: 0x100003e48 - 0x100003e54
int32_t function_100003e48(int32_t c) {
    // 0x100003e48
    return _isspace(c);
}

// Address range: 0x100003e54 - 0x100003e60
int64_t * function_100003e54(int32_t size) {
    // 0x100003e54
    return _malloc(size);
}

// Address range: 0x100003e60 - 0x100003e6c
int32_t function_100003e60(char * file, int32_t oflag, ...) {
    // 0x100003e60
    return _open(file, oflag);
}

// Address range: 0x100003e6c - 0x100003e78
int32_t function_100003e6c(char * format, ...) {
    // 0x100003e6c
    return _printf(format);
}

// Address range: 0x100003e78 - 0x100003e84
int32_t function_100003e78(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003e78
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003e84 - 0x100003e90
int64_t * function_100003e84(int64_t * ptr, int32_t size) {
    // 0x100003e84
    return _realloc(ptr, size);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(char * s) {
    // 0x100003e90
    return _strlen(s);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(char * s1, char * s2, int32_t n) {
    // 0x100003e9c
    return _strncmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 22

