//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct timespec {
    int64_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003be4(void);
int32_t function_100003f60(struct timespec * requested_time, struct timespec * remaining);
int32_t function_100003f6c(char * format, ...);
int32_t function_100003f78(char * s);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[%dA"; // 0x100003f84
struct timespec * g2 = NULL; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int32_t _nanosleep(struct timespec * a1, struct timespec * a2);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003be4 - 0x100003ea4
int64_t function_100003be4(void) {
    // 0x100003be4
    int64_t result; // 0x100003be4
    int32_t v1 = result; // 0x100003bf0
    int32_t v2 = v1 * (int32_t)result; // 0x100003c0c
    int32_t v3 = -v2; // 0x100003c10
    char v4 = *(char *)result;
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003e7c
        *(char *)result = v4;
        return result;
    }
    int32_t v5 = 0;
    int64_t v6 = 0;
    char v7; // 0x100003cd8
    uint32_t v8; // 0x100003cf4
    char v9; // 0x100003cf8
    char v10; // 0x100003d20
    char v11; // 0x100003d40
    char v12; // 0x100003d60
    uint32_t v13; // 0x100003d80
    char v14; // 0x100003d88
    char v15; // 0x100003dac
    char v16; // 0x100003dd4
    char v17; // 0x100003e30
    switch (v4) {
        case 32: {
            // 0x100003c7c
            *(char *)(v6 + result) = 32;
            // break -> 0x100003e6c
            break;
        }
        case 46: {
            // 0x100003cc4
            v7 = *(char *)(result + (int64_t)(v5 + -1 - v1));
            v8 = v5 - v1;
            v9 = *(char *)(result + (int64_t)v8);
            v10 = *(char *)(result + (int64_t)(v8 + 1));
            v11 = *(char *)(result + (int64_t)(v5 - 1));
            v12 = *(char *)(result + (int64_t)(v5 + 1));
            v13 = v5 + v1;
            v14 = *(char *)(result + (int64_t)(v13 - 1));
            v15 = *(char *)(result + (int64_t)v13);
            v16 = *(char *)(result + (int64_t)(v13 + 1));
            v17 = (int32_t)(v9 == 72) + (int32_t)(v7 != 72) + (int32_t)(v10 == 72) + (int32_t)(v11 == 72) + (int32_t)(v12 == 72) + (int32_t)(v14 == 72) + (int32_t)(v15 == 72) + (int32_t)(v16 == 72) >= 2 ? 46 : 72;
            *(char *)(v6 + result) = v17;
            // break -> 0x100003e6c
            break;
        }
        case 72: {
            // 0x100003cac
            *(char *)(v6 + result) = 116;
            // break -> 0x100003e6c
            break;
        }
        case 116: {
            // 0x100003c94
            *(char *)(v6 + result) = 46;
            // break -> 0x100003e6c
            break;
        }
        default: {
            // 0x100003e44
            *(char *)(v6 + result) = v4;
            // break -> 0x100003e6c
            break;
        }
    }
    int32_t v18 = v5 + 1; // 0x100003e70
    int32_t v19 = v18 - v2; // 0x100003c10
    int64_t v20 = v18;
    char v21 = *(char *)(result + v20);
    while (v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
        // 0x100003c20
        v5 = v18;
        v6 = v20;
        char v22 = v21;
        switch (v22) {
            case 32: {
                // 0x100003c7c
                *(char *)(v6 + result) = 32;
                // break -> 0x100003e6c
                break;
            }
            case 46: {
                // 0x100003cc4
                v7 = *(char *)(result + (int64_t)(v5 + -1 - v1));
                v8 = v5 - v1;
                v9 = *(char *)(result + (int64_t)v8);
                v10 = *(char *)(result + (int64_t)(v8 + 1));
                v11 = *(char *)(result + (int64_t)(v5 - 1));
                v12 = *(char *)(result + (int64_t)(v5 + 1));
                v13 = v5 + v1;
                v14 = *(char *)(result + (int64_t)(v13 - 1));
                v15 = *(char *)(result + (int64_t)v13);
                v16 = *(char *)(result + (int64_t)(v13 + 1));
                v17 = (int32_t)(v9 == 72) + (int32_t)(v7 != 72) + (int32_t)(v10 == 72) + (int32_t)(v11 == 72) + (int32_t)(v12 == 72) + (int32_t)(v14 == 72) + (int32_t)(v15 == 72) + (int32_t)(v16 == 72) >= 2 ? 46 : 72;
                *(char *)(v6 + result) = v17;
                // break -> 0x100003e6c
                break;
            }
            case 72: {
                // 0x100003cac
                *(char *)(v6 + result) = 116;
                // break -> 0x100003e6c
                break;
            }
            case 116: {
                // 0x100003c94
                *(char *)(v6 + result) = 46;
                // break -> 0x100003e6c
                break;
            }
            default: {
                // 0x100003e44
                *(char *)(v6 + result) = v22;
                // break -> 0x100003e6c
                break;
            }
        }
        // 0x100003e6c
        v18 = v5 + 1;
        v19 = v18 - v2;
        v20 = v18;
        v21 = *(char *)(result + v20);
    }
    // 0x100003e7c
    *(char *)(v20 + result) = v21;
    return result;
}

// Address range: 0x100003ea4 - 0x100003f60
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003eb8
    while (true) {
        // 0x100003ebc
        _puts((char *)(512 * (int64_t)v1 + (int64_t)"+-----------+\n|tH.........|\n|.   .      |\n|   ...     |\n|.   .      |\n|Ht.. ......|\n+-----------+\n"));
        function_100003be4();
        _printf((char *)&g1);
        _printf((char *)0x100003f8a);
        _nanosleep((struct timespec *)&g2, NULL);
        v1 = 1 - v1;
    }
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(struct timespec * requested_time, struct timespec * remaining) {
    // 0x100003f60
    return _nanosleep(requested_time, remaining);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * s) {
    // 0x100003f78
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

