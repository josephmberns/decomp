//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b5c(void);
int64_t function_100003cc8(void);
int64_t function_100003de4(void);
int64_t function_100003e7c(void);
int32_t function_100003f14(int32_t c);
int32_t function_100003f20(char * format, ...);
int32_t function_100003f2c(int32_t c);
int32_t function_100003f38(char * s);
int32_t function_100003f44(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003b5c - 0x100003cc8
int64_t function_100003b5c(void) {
    // 0x100003b5c
    int64_t v1; // 0x100003b5c
    char * v2 = (char *)v1; // 0x100003b6c
    int64_t v3; // 0x100003b5c
    while (true) {
      lab_0x100003b74:;
        // 0x100003b74
        int64_t v4; // 0x100003b5c
        int64_t v5 = v4;
        char * v6 = (char *)v5;
        int64_t v7 = v5 + 1; // 0x100003b8c
        while (_isspace((int32_t)*v6) != 0) {
            // 0x100003b78
            v5 = v7;
            v6 = (char *)v5;
            v7 = v5 + 1;
        }
        // 0x100003ba4
        if ((int32_t)function_100003cc8() == 0) {
            // 0x100003bc0
            _strtol(v6, (char **)v1, 10);
            v3 = v5;
            if (v2 == v6) {
                // break -> 0x100003c8c
                break;
            }
        }
        int64_t v8; // 0x100003b5c
        int64_t v9 = v8;
        char * v10 = (char *)v9;
        int64_t v11 = v9 + 1;
        v8 = v11;
        while (_isspace((int32_t)*v10) != 0) {
            // 0x100003c08
            v9 = v8;
            v10 = (char *)v9;
            v11 = v9 + 1;
            v8 = v11;
        }
        // 0x100003c34
        v4 = v11;
        v3 = v9;
        switch (*v10) {
            case 0: {
                // 0x100003c4c
                _putchar(10);
                // 0x100003cb8
                return 1;
            }
            case 44: {
                goto lab_0x100003b74;
            }
            default: {
                goto lab_0x100003c8c;
            }
        }
    }
  lab_0x100003c8c:
    // 0x100003c8c
    *(int64_t *)v1 = v3;
    _printf("\nSyntax error at %s\n", v2);
    // 0x100003cb8
    return 0;
}

// Address range: 0x100003cc8 - 0x100003de4
int64_t function_100003cc8(void) {
    // 0x100003cc8
    char * v1; // bp-56, 0x100003cc8
    int64_t v2; // 0x100003cc8
    _strtol((char *)v2, &v1, 10);
    int64_t v3 = (int64_t)v1;
    if (v2 == v3) {
        // 0x100003dd4
        return 0;
    }
    int64_t v4 = v3; // 0x100003d34
    char * v5 = v1; // 0x100003d34
    if (_isspace((int32_t)*v1) != 0) {
        int64_t v6 = (int64_t)v1 + 1; // 0x100003d40
        char * v7 = (char *)v6;
        v4 = v6;
        v5 = v7;
        while (_isspace((int32_t)*v7) != 0) {
            // 0x100003d3c
            v6 = (int64_t)v7 + 1;
            v7 = (char *)v6;
            v4 = v6;
            v5 = v7;
        }
    }
    // 0x100003d4c
    if (*v5 != 45) {
        // 0x100003d64
        *(int64_t *)v2 = v4;
        // 0x100003dd4
        return 0;
    }
    int64_t v8 = v4 + 1; // 0x100003d7c
    _strtol((char *)v8, (char **)v2, 10);
    int64_t result = 0; // 0x100003db0
    if (v8 != v2) {
        // 0x100003dc0
        result = function_100003de4() & 0xffffffff;
    }
    // 0x100003dd4
    return result;
}

// Address range: 0x100003de4 - 0x100003e7c
int64_t function_100003de4(void) {
    // 0x100003de4
    int64_t v1; // 0x100003de4
    int32_t v2 = v1; // 0x100003df0
    int32_t v3 = v1; // 0x100003df4
    int32_t v4 = v3 - v2; // 0x100003e00
    int32_t v5 = v1 ^ v1;
    if (v4 == 0 || v4 < 0 != ((v4 ^ v3) & v5) < 0) {
        // 0x100003e6c
        return 0;
    }
    int32_t v6 = v2 - v3; // 0x100003e24
    if (v6 != 0 && v6 < 0 == ((v6 ^ v2) & v5) < 0) {
        // 0x100003e6c
        return 1;
    }
    int32_t v7 = v2; // 0x100003e2c
    v7++;
    _printf("%d ", v1);
    while (v7 - v3 == 0 || v7 - v3 < 0 != ((v7 - v3 ^ v7) & (v7 ^ v3)) < 0) {
        // 0x100003e34
        v7++;
        _printf("%d ", v1);
    }
    // 0x100003e6c
    return 1;
}

// Address range: 0x100003e7c - 0x100003eb4
int64_t function_100003e7c(void) {
    // 0x100003e7c
    int64_t v1; // 0x100003e7c
    return _printf("%d ", v1);
}

// Address range: 0x100003eb4 - 0x100003f14
int64_t entry_point(void) {
    // 0x100003eb4
    if ((int32_t)function_100003b5c() != 0) {
        // 0x100003ee4
        _puts("Ok");
    }
    // 0x100003ef4
    function_100003b5c();
    return 0;
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(int32_t c) {
    // 0x100003f14
    return _isspace(c);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * format, ...) {
    // 0x100003f20
    return _printf(format);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t c) {
    // 0x100003f2c
    return _putchar(c);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * s) {
    // 0x100003f38
    return _puts(s);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f44
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

