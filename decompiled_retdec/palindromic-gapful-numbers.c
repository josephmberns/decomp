//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003900(void);
int64_t function_100003964(void);
int64_t function_1000039b4(void);
int64_t function_100003b18(void);
int64_t function_100003b98(void);
int64_t function_100003efc(int64_t a1);
int32_t function_100003f08(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003900 - 0x100003964
int64_t function_100003900(void) {
    // 0x100003900
    int64_t v1; // 0x100003900
    if (v1 == 0) {
        // 0x100003958
        return 0;
    }
    int64_t result = 0; // 0x10000391c
    int64_t v2; // 0x100003900
    uint64_t v3 = v2;
    result = v3 % 10 + 10 * result;
    v2 = v3 / 10;
    while (v3 >= 10) {
        // 0x100003924
        v3 = v2;
        result = v3 % 10 + 10 * result;
        v2 = v3 / 10;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003964 - 0x1000039b4
int64_t function_100003964(void) {
    // 0x100003964
    int64_t v1; // 0x100003964
    int64_t result = v1;
    *(int64_t *)result = 10;
    *(int64_t *)(result + 8) = (0x100000000 * v1 >> 32) * result - 1;
    *(int32_t *)(result + 16) = (int32_t)v1;
    *(char *)(result + 20) = 0;
    return result;
}

// Address range: 0x1000039b4 - 0x100003b18
int64_t function_1000039b4(void) {
    // 0x1000039b4
    int64_t v1; // 0x1000039b4
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 + 8); // 0x1000039c8
    int64_t v4 = *v3 + 1; // 0x1000039cc
    *v3 = v4;
    int32_t * v5 = (int32_t *)(v2 + 16); // 0x1000039e8
    int32_t v6 = *v5; // 0x1000039e8
    char * v7 = (char *)(v2 + 20);
    unsigned char v8 = *v7;
    if (v4 != v2 * (int64_t)(v6 + 1)) {
        // 0x100003a70
        return (v8 % 2 == 0 ? v2 : 10 * v2) * v4 + function_100003900();
    }
    int32_t v9 = v6; // 0x100003a14
    if (v8 % 2 != 0) {
        // 0x100003a1c
        *(int64_t *)v2 = 10 * v2;
        v9 = *v5;
    }
    // 0x100003a34
    *v3 = v2 * (int64_t)v9;
    char v10 = *v7 % 2 ^ 1;
    *v7 = v10;
    // 0x100003a70
    return (v10 % 2 == 0 ? v2 : 10 * v2) * *v3 + function_100003900();
}

// Address range: 0x100003b18 - 0x100003b98
int64_t function_100003b18(void) {
    // 0x100003b18
    int64_t v1; // 0x100003b18
    uint64_t v2 = v1;
    if (v2 < 10) {
        // 0x100003b54
        int64_t v3; // 0x100003b18
        return v2 % (10 * v3 + v2 % 10) == 0;
    }
    int64_t v4; // 0x100003b18
    uint64_t v5 = v4;
    int64_t v6 = v5 / 10; // 0x100003b48
    while (v5 >= 100) {
        // 0x100003b40
        v5 = v6;
        v6 = v5 / 10;
    }
    // 0x100003b54
    return v2 % (10 * v6 + v2 % 10) == 0;
}

// Address range: 0x100003b98 - 0x100003c8c
int64_t function_100003b98(void) {
    // 0x100003b98
    int64_t v1; // 0x100003b98
    int32_t v2 = v1; // 0x100003ba4
    int32_t v3 = -v2;
    int32_t result; // 0x100003c68
    for (int32_t i = 1; i < 10; i++) {
        // 0x100003bd4
        _printf("%d: ", v1);
        if (v3 < 0 != (v3 & v2) < 0) {
            _printf(" %llu", v1);
            int32_t v4 = 1; // 0x100003c54
            int32_t v5 = v4 - v2; // 0x100003c00
            int32_t v6 = v4; // 0x100003c08
            while (v5 < 0 != ((v5 ^ v4) & (v4 ^ v2)) < 0) {
                // 0x100003c10
                _printf(" %llu", v1);
                v4 = v6 + 1;
                v5 = v4 - v2;
                v6 = v4;
            }
        }
        // 0x100003c60
        result = _printf("\n");
    }
    // 0x100003c80
    return result;
}

// Address range: 0x100003c8c - 0x100003efc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ca4
    int64_t v2; // bp-1472, 0x100003c8c
    int64_t v3 = &v2;
    int64_t v4; // bp-2552, 0x100003c8c
    int64_t v5 = &v4;
    int64_t v6 = 1;
    int32_t v7; // 0x100003c8c
    int32_t v8; // 0x100003c8c
    int64_t v9; // 0x100003c8c
    int64_t v10; // 0x100003d24
    while (true) {
        // 0x100003cf8
        function_100003964();
        int64_t v11 = v6 - 1;
        int64_t v12 = 160 * v11 + v3;
        int64_t v13 = 120 * v11 + v5;
        int64_t v14; // bp-3272, 0x100003c8c
        v9 = 80 * v11 + (int64_t)&v14;
        v7 = 0;
        while (true) {
          lab_0x100003d0c:
            // 0x100003d0c
            v8 = v7;
            if (v8 < 1000 == (999 - v8 & v8) < 0) {
                // break (via goto) -> 0x100003e20
                goto lab_0x100003e20;
            }
            // 0x100003d20
            v10 = function_1000039b4();
            while (function_100003b18() % 2 == 0) {
                if (v8 < 1000 == (999 - v8 & v8) < 0) {
                    // break (via goto) -> 0x100003e20
                    goto lab_0x100003e20;
                }
                // 0x100003d20
                v10 = function_1000039b4();
            }
            if (v8 < 20 == (19 - v8 & v8) < 0) {
                if (v8 < 100 == (99 - v8 & v8) < 0) {
                    goto lab_0x100003dc8;
                } else {
                    if (v8 < 85 == (84 - v8 & v8) < 0) {
                        // 0x100003da0
                        *(int64_t *)(v13 + (int64_t)(8 * v8 - 680)) = v10;
                        // 0x100003e0c
                        v7 = v8 + 1;
                        goto lab_0x100003d0c;
                    } else {
                        goto lab_0x100003dc8;
                    }
                }
            } else {
                // 0x100003d54
                *(int64_t *)(v12 + 8 * (int64_t)v8) = v10;
                // 0x100003e0c
                v7 = v8 + 1;
                goto lab_0x100003d0c;
            }
        }
      lab_0x100003e20:
        // 0x100003e20
        v6++;
        if (v6 == 10) {
            // break -> 0x100003e30
            break;
        }
    }
    // 0x100003e30
    _printf("First %d palindromic gapful numbers ending in:\n", 9);
    function_100003b98();
    int64_t v15; // 0x100003c8c
    _printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", v3, v15);
    function_100003b98();
    _printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", v5, v15);
    int64_t v16 = function_100003b98(); // 0x100003ec0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ee4
        ___stack_chk_fail(v16);
    }
    // 0x100003ee8
    return 0;
  lab_0x100003dc8:
    if (v8 < 990 == (989 - v8 & v8) < 0) {
        // 0x100003ddc
        *(int64_t *)(v9 + (int64_t)(8 * v8 - 0x1ef0)) = v10;
    }
    // 0x100003e0c
    v7 = v8 + 1;
    goto lab_0x100003d0c;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(int64_t a1) {
    // 0x100003efc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

