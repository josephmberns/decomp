//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003894(void);
int64_t function_100003974(void);
int64_t function_1000039f4(void);
int64_t function_100003b7c(void);
int64_t function_100003dcc(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003dd8(int64_t a1);
void function_100003de4(int32_t status);
int64_t * function_100003df0(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003dfc(int64_t * s, int32_t c, int32_t n);
int32_t function_100003e08(char * format, ...);
void function_100003e14(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

float64_t g1 = 41.0; // 0x100003e20
float64_t g2 = 39.0; // 0x100003e28
float64_t g3 = 40.0; // 0x100003e30
float64_t g4 = 36.0; // 0x100003e38
int64_t g5 = 0x402e000000000000; // 0x100003e40
int64_t g6 = 0x3fc206a9bd53322c; // 0x100003e98

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x100003894 - 0x100003974
int64_t function_100003894(void) {
    // 0x100003894
    int64_t result; // 0x100003894
    if ((int32_t)result + 1 - (int32_t)result >= 1) {
        // 0x1000038e8
        return result;
    }
    // 0x1000038d4
    _printf("Array slice cannot be empty\n");
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003974 - 0x1000039f4
int64_t function_100003974(void) {
    // 0x100003974
    int64_t v1; // 0x100003974
    int64_t v2 = v1;
    int64_t v3 = v1;
    if ((float64_t)v3 == (float64_t)v2) {
        // 0x1000039bc
        return (float64_t)v3 > (float64_t)v2 ? 0xffffffff : 0;
    }
    if ((float64_t)v3 > (float64_t)v2 == (float64_t)v3 >= (float64_t)v2 == (float64_t)v3 <= (float64_t)v2) {
        // 0x1000039e8
        return 1;
    }
    // 0x1000039bc
    return (float64_t)v3 > (float64_t)v2 ? 0xffffffff : 0;
}

// Address range: 0x1000039f4 - 0x100003b7c
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    int32_t v2 = v1; // 0x100003a08
    int32_t v3 = -v2; // 0x100003a1c
    int32_t v4 = 0; // 0x100003a24
    if (v3 < 0 != (v3 & v2) < 0) {
        float64_t v5 = *(float64_t *)(8 * (int64_t)v4 + v1); // 0x100003a34
        while (v5 == v5 && 0.0 == 0.0) {
            // 0x100003a14
            v4++;
            int32_t v6 = v4 - v2; // 0x100003a1c
            if (v6 < 0 == ((v6 ^ v4) & (v4 ^ v2)) < 0) {
                goto lab_0x100003a80;
            }
            v5 = *(float64_t *)(8 * (int64_t)v4 + v1);
        }
        // 0x100003a50
        _printf("Unable to deal with arrays containing NaN\n\n");
        // 0x100003b6c
        return 1;
    }
  lab_0x100003a80:
    // 0x100003a80
    _qsort((int64_t *)v1, v2, 8, (int32_t (*)(int64_t *, int64_t *))0x100003974);
    *(float64_t *)v1 = (float64_t)v1;
    function_100003894();
    *(float64_t *)(v1 + 16) = (float64_t)v1;
    int64_t v7 = *(int64_t *)((8 * v1 + 0xfffffff8 & 0xfffffff8) + v1);
    float64_t v8 = v7;
    *(int64_t *)(v1 + 32) = v7;
    function_100003894();
    *(int64_t *)(v1 + 8) = (int64_t)v8;
    function_100003894();
    *(int64_t *)(v1 + 24) = (int64_t)v8;
    // 0x100003b6c
    return 0;
}

// Address range: 0x100003b7c - 0x100003c50
int64_t function_100003b7c(void) {
    // 0x100003b7c
    int64_t v1; // bp-47, 0x100003b7c
    ___sprintf_chk(&v1, 0, 7, "%%.%dlf");
    _printf("[");
    for (int32_t i = 0; i < 5; i++) {
        // 0x100003be0
        _printf((char *)&v1);
        if (i < 4) {
            // 0x100003c10
            _printf(", ");
        }
    }
    // 0x100003c34
    _printf("]\n\n");
    int32_t v2; // 0x100003b7c
    return (uint32_t)v2;
}

// Address range: 0x100003c50 - 0x100003dcc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c70
    int64_t v2; // bp-168, 0x100003c50
    _memcpy(&v2, &g5, 88);
    if ((int32_t)function_1000039f4() == 0) {
        // 0x100003cb4
        function_100003b7c();
    }
    // 0x100003cc4
    int64_t v3; // bp-216, 0x100003c50
    _memset(&v3, 0, 48);
    int64_t v4 = &v3; // 0x100003cdc
    v3 = g4;
    *(int64_t *)(v4 + 8) = (int64_t)g3;
    *(float64_t *)(v4 + 16) = 7.0;
    *(int64_t *)(v4 + 24) = (int64_t)g2;
    *(int64_t *)(v4 + 32) = (int64_t)g1;
    *(float64_t *)(v4 + 40) = 15.0;
    if ((int32_t)function_1000039f4() == 0) {
        // 0x100003d3c
        function_100003b7c();
    }
    // 0x100003d4c
    int64_t v5; // bp-376, 0x100003c50
    _memcpy(&v5, &g6, 160);
    int64_t v6 = function_1000039f4(); // 0x100003d70
    int64_t v7 = v6; // 0x100003d7c
    if ((int32_t)v6 == 0) {
        // 0x100003d84
        v7 = function_100003b7c();
    }
    // 0x100003d94
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003db4
        ___stack_chk_fail(v7);
    }
    // 0x100003db8
    return 0;
}

// Address range: 0x100003dcc - 0x100003dd8
int64_t function_100003dcc(int64_t * a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003dcc
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003dd8 - 0x100003de4
int64_t function_100003dd8(int64_t a1) {
    // 0x100003dd8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003de4 - 0x100003df0
void function_100003de4(int32_t status) {
    // 0x100003de4
    _exit(status);
}

// Address range: 0x100003df0 - 0x100003dfc
int64_t * function_100003df0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003df0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dfc - 0x100003e08
int64_t * function_100003dfc(int64_t * s, int32_t c, int32_t n) {
    // 0x100003dfc
    return _memset(s, c, n);
}

// Address range: 0x100003e08 - 0x100003e14
int32_t function_100003e08(char * format, ...) {
    // 0x100003e08
    return _printf(format);
}

// Address range: 0x100003e14 - 0x100003e20
void function_100003e14(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e14
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

