//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000032d4(void);
int64_t function_1000033b0(void);
int64_t function_100003428(void);
int64_t function_1000034d4(void);
int64_t function_100003500(void);
int64_t function_10000352c(void);
int64_t function_1000037c8(void);
int64_t function_1000038ac(int64_t a1, int64_t a2, int64_t * a3);
int64_t function_1000038c8(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ec8(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003ed4(int64_t a1);
int64_t * function_100003ee0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003eec(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000032d4 - 0x1000033b0
int64_t function_1000032d4(void) {
    // 0x1000032d4
    float64_t v1; // 0x1000032d4
    float64_t v2 = 1.0 - v1; // 0x1000032f8
    float64_t v3; // bp-80, 0x1000032d4
    int64_t result; // 0x1000032d4
    *(int64_t *)(result + 16) = (int64_t)v3;
    float64_t * v4 = (float64_t *)(result + 8); // 0x10000334c
    *v4 = v1 * v1 + v2 * v1;
    float64_t v5 = v2 * v1 + v1 * v3; // 0x100003364
    *(float64_t *)(result + 8) = v5;
    int64_t v6 = result + 16; // 0x100003394
    *(float64_t *)v6 = v1 * v5 + v2 * *v4;
    *(int64_t *)result = *(int64_t *)v6;
    return result;
}

// Address range: 0x1000033b0 - 0x100003428
int64_t function_1000033b0(void) {
    // 0x1000033b0
    function_1000032d4();
    return function_1000032d4();
}

// Address range: 0x100003428 - 0x1000034d4
int64_t function_100003428(void) {
    // 0x100003428
    float64_t v1; // 0x100003428
    float64_t v2 = v1;
    float64_t v3 = v1;
    float64_t v4 = v1;
    float64_t v5 = v1;
    float64_t v6 = v1;
    float64_t v7 = v1;
    float64_t v8 = v1;
    float64_t v9 = v1;
    if (v5 <= v7 == (v5 != v7) || v9 <= v3 == (v9 != v3)) {
        // 0x1000034c4
        return 0;
    }
    int64_t result = 0; // 0x1000034a4
    if (v4 <= v6 != v4 != v6) {
        // 0x1000034ac
        result = v8 == v2 | v8 > v2;
    }
    // 0x1000034c4
    return result;
}

// Address range: 0x1000034d4 - 0x100003500
int64_t function_1000034d4(void) {
    // 0x1000034d4
    int64_t result; // 0x1000034d4
    return result;
}

// Address range: 0x100003500 - 0x10000352c
int64_t function_100003500(void) {
    // 0x100003500
    int64_t result; // 0x100003500
    return result;
}

// Address range: 0x10000352c - 0x1000037c8
int64_t function_10000352c(void) {
    // 0x10000352c
    int64_t v1; // 0x10000352c
    char * v2 = (char *)v1; // 0x100003550
    char * v3 = (char *)v1; // 0x100003554
    function_100003500();
    int64_t * v4 = (int64_t *)(v1 + 24);
    function_100003500();
    function_1000034d4();
    function_1000034d4();
    function_100003500();
    int64_t * v5 = (int64_t *)(v1 + 24);
    function_100003500();
    function_1000034d4();
    function_1000034d4();
    *v2 = 1;
    *v3 = 0;
    int64_t result = function_100003428(); // 0x10000364c
    if (result % 2 == 0) {
        // 0x1000037bc
        return result;
    }
    // 0x100003658
    *v2 = 0;
    float64_t v6 = llvm_maxnum_f64((float64_t)v1, (float64_t)v1); // 0x100003668
    float64_t v7 = llvm_minnum_f64((float64_t)v1, (float64_t)v1); // 0x100003678
    int64_t result2 = result; // 0x100003688
    if (v7 != v6) {
        result2 = result;
        if (v7 > v6 != (v7 >= v6 == v7 <= v6)) {
            // 0x1000036a4
            result2 = ___assert_rtn("testIntersect", "b-zier-curves-intersections-1.c", 84, "xmax >= xmin");
        }
    }
    float64_t v8 = v7 - v6; // 0x1000036d0
    float64_t v9; // bp-40, 0x10000352c
    float64_t v10 = v9; // 0x1000036d4
    if (v8 <= v10 == (v8 != v10)) {
        // 0x1000037bc
        return result2;
    }
    float64_t v11 = llvm_maxnum_f64((float64_t)*v4, (float64_t)*v5); // 0x1000036f0
    float64_t v12 = llvm_minnum_f64((float64_t)*v4, (float64_t)*v5); // 0x100003700
    int64_t result3 = result2; // 0x100003710
    if (v12 != v11) {
        result3 = result2;
        if (v12 > v11 != (v12 >= v11 == v12 <= v11)) {
            // 0x10000372c
            result3 = ___assert_rtn("testIntersect", "b-zier-curves-intersections-1.c", 88, "ymax >= ymin");
        }
    }
    float64_t v13 = v12 - v11; // 0x100003758
    if (v13 <= v10 != v13 != v10) {
        // 0x100003770
        *v3 = 1;
        *(float64_t *)v1 = 0.5 * v7 + 0.5 * v6;
        *(float64_t *)(v1 + 8) = 0.5 * v11 + 0.5 * v12;
    }
    // 0x1000037bc
    return result3;
}

// Address range: 0x1000037c8 - 0x1000038ac
int64_t function_1000037c8(void) {
    // 0x1000037c8
    int64_t v1; // 0x1000037c8
    int32_t v2 = v1; // 0x1000037d8
    if (v2 == 0) {
        // 0x10000389c
        return 0;
    }
    int32_t v3 = 0; // 0x10000381c
    float128_t v4 = *(float128_t *)(16 * (int64_t)v3 + v1); // 0x10000382c
    int32_t result = 0; // 0x100003844
    float64_t v5; // 0x1000037c8
    if (__asm_fabd((float64_t)v4, v5) > v5) {
        // 0x10000385c
        result = __asm_fabd(v5, v5) > v5;
    }
    // 0x10000387c
    v3++;
    while (v3 != v2 == result == 0) {
        // 0x100003824
        v4 = *(float128_t *)(16 * (int64_t)v3 + v1);
        result = 0;
        if (__asm_fabd((float64_t)v4, v5) > v5) {
            // 0x10000385c
            result = __asm_fabd(v5, v5) > v5;
        }
        // 0x10000387c
        v3++;
    }
    // 0x10000389c
    return result;
}

// Address range: 0x1000038ac - 0x1000038c8
int64_t function_1000038ac(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x1000038ac
    return ___chkstk_darwin();
}

// Address range: 0x1000038c8 - 0x100003d00
int64_t function_1000038c8(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1000038c8
    int64_t v1; // 0x1000038c8
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x1000038ec
    *v2 = *(int64_t *)*(int64_t *)0x100004018;
    int64_t v3; // bp-6296, 0x1000038c8
    _memcpy(&v3, (int64_t *)v1, 48);
    _memcpy((int64_t *)((int64_t)&v3 + 48), (int64_t *)v1, 48);
    int64_t v4; // bp-6152, 0x1000038c8
    _memcpy(&v4, &v3, 96);
    int64_t v5 = &v4; // 0x10000396c
    int64_t v6; // bp-6392, 0x1000038c8
    int64_t * v7 = (int64_t *)((int64_t)&v6 + 48);
    int32_t v8 = 1;
    int32_t v9 = 0;
    int32_t v10 = v8 - 1; // 0x100003968
    int64_t * v11 = (int64_t *)(96 * (int64_t)v10 + v5); // 0x100003984
    _memcpy(&v6, v11, 96);
    int64_t v12; // bp-6464, 0x1000038c8
    _memcpy(&v12, &v6, 48);
    int64_t v13; // bp-6512, 0x1000038c8
    _memcpy(&v13, v7, 48);
    int64_t v14 = function_10000352c(); // 0x1000039e8
    int32_t v15; // 0x1000038c8
    int32_t v16; // 0x1000038c8
    int64_t v17; // bp-6560, 0x1000038c8
    int64_t v18; // bp-6608, 0x1000038c8
    int64_t v19; // bp-6656, 0x1000038c8
    int64_t v20; // bp-6704, 0x1000038c8
    int64_t v21; // bp-6752, 0x1000038c8
    int64_t v22; // bp-6800, 0x1000038c8
    int64_t v23; // bp-6896, 0x1000038c8
    int64_t v24; // bp-6992, 0x1000038c8
    int64_t v25; // bp-7088, 0x1000038c8
    int64_t v26; // bp-7184, 0x1000038c8
    int64_t v27; // 0x100003a0c
    int32_t v28; // 0x100003c34
    int64_t * v29; // 0x100003c74
    int32_t v30; // 0x100003c7c
    int32_t v31; // 0x100003a24
    int32_t v32; // 0x100003a38
    int32_t v33; // 0x1000038c8
    int64_t v34; // 0x1000038c8
    if (v33 % 2 == 0) {
        // 0x100003a80
        v34 = v14;
        v16 = v10;
        v15 = v9;
        if (v33 % 2 == 0) {
            // 0x100003a8c
            _memcpy(&v21, &v6, 48);
            function_1000033b0();
            _memcpy(&v22, v7, 48);
            function_1000033b0();
            _memcpy(&v23, &v17, 48);
            _memcpy((int64_t *)((int64_t)&v23 + 48), &v19, 48);
            _memcpy(v11, &v23, 96);
            _memcpy(&v24, &v17, 48);
            _memcpy((int64_t *)((int64_t)&v24 + 48), &v20, 48);
            _memcpy((int64_t *)(96 * (int64_t)v8 + v5), &v24, 96);
            _memcpy(&v25, &v18, 48);
            _memcpy((int64_t *)((int64_t)&v25 + 48), &v19, 48);
            _memcpy((int64_t *)(96 * (int64_t)(v8 + 1) + v5), &v25, 96);
            v28 = v8 + 3;
            _memcpy(&v26, &v18, 48);
            _memcpy((int64_t *)((int64_t)&v26 + 48), &v20, 48);
            v29 = _memcpy((int64_t *)(96 * (int64_t)(v8 + 2) + v5), &v26, 96);
            v30 = v8 - 61;
            v34 = (int64_t)v29;
            v16 = v28;
            v15 = v9;
            if (v30 != 0 && v30 < 0 == (v28 & 60 - v8) < 0) {
                // 0x100003c98
                v34 = ___assert_rtn("findIntersects", "b-zier-curves-intersections-1.c", 140, "numWorksets <= 64");
                v16 = v28;
                v15 = v9;
            }
        }
    } else {
        // 0x1000039f8
        v27 = function_1000037c8();
        v34 = v27;
        v16 = v10;
        v15 = v9;
        if (v27 % 2 == 0) {
            // 0x100003a18
            v31 = v9 + 1;
            v32 = v9 - 3;
            v34 = v27;
            v16 = v10;
            v15 = v31;
            if (v32 != 0 && v32 < 0 == (v31 & 2 - v9) < 0) {
                // 0x100003a54
                v34 = ___assert_rtn("findIntersects", "b-zier-curves-intersections-1.c", 130, "numIntersects <= 4");
                v16 = v10;
                v15 = v31;
            }
        }
    }
    // 0x100003cc4
    while (v16 != 0) {
        // 0x100003964
        v8 = v16;
        v9 = v15;
        v10 = v8 - 1;
        v11 = (int64_t *)(96 * (int64_t)v10 + v5);
        _memcpy(&v6, v11, 96);
        _memcpy(&v12, &v6, 48);
        _memcpy(&v13, v7, 48);
        v14 = function_10000352c();
        if (v33 % 2 == 0) {
            // 0x100003a80
            v34 = v14;
            v16 = v10;
            v15 = v9;
            if (v33 % 2 == 0) {
                // 0x100003a8c
                _memcpy(&v21, &v6, 48);
                function_1000033b0();
                _memcpy(&v22, v7, 48);
                function_1000033b0();
                _memcpy(&v23, &v17, 48);
                _memcpy((int64_t *)((int64_t)&v23 + 48), &v19, 48);
                _memcpy(v11, &v23, 96);
                _memcpy(&v24, &v17, 48);
                _memcpy((int64_t *)((int64_t)&v24 + 48), &v20, 48);
                _memcpy((int64_t *)(96 * (int64_t)v8 + v5), &v24, 96);
                _memcpy(&v25, &v18, 48);
                _memcpy((int64_t *)((int64_t)&v25 + 48), &v19, 48);
                _memcpy((int64_t *)(96 * (int64_t)(v8 + 1) + v5), &v25, 96);
                v28 = v8 + 3;
                _memcpy(&v26, &v18, 48);
                _memcpy((int64_t *)((int64_t)&v26 + 48), &v20, 48);
                v29 = _memcpy((int64_t *)(96 * (int64_t)(v8 + 2) + v5), &v26, 96);
                v30 = v8 - 61;
                v34 = (int64_t)v29;
                v16 = v28;
                v15 = v9;
                if (v30 != 0 && v30 < 0 == (v28 & 60 - v8) < 0) {
                    // 0x100003c98
                    v34 = ___assert_rtn("findIntersects", "b-zier-curves-intersections-1.c", 140, "numWorksets <= 64");
                    v16 = v28;
                    v15 = v9;
                }
            }
        } else {
            // 0x1000039f8
            v27 = function_1000037c8();
            v34 = v27;
            v16 = v10;
            v15 = v9;
            if (v27 % 2 == 0) {
                // 0x100003a18
                v31 = v9 + 1;
                v32 = v9 - 3;
                v34 = v27;
                v16 = v10;
                v15 = v31;
                if (v32 != 0 && v32 < 0 == (v31 & 2 - v9) < 0) {
                    // 0x100003a54
                    v34 = ___assert_rtn("findIntersects", "b-zier-curves-intersections-1.c", 130, "numIntersects <= 4");
                    v16 = v10;
                    v15 = v31;
                }
            }
        }
    }
    int64_t result = v34; // 0x100003ce0
    if (*(int64_t *)*(int64_t *)0x100004018 != *v2) {
        // 0x100003ce8
        result = ___stack_chk_fail(v34);
    }
    // 0x100003cec
    return result;
}

// Address range: 0x100003d00 - 0x100003ec8
int64_t entry_point(void) {
    int64_t v1 = -0x4010000000000000; // bp-160, 0x100003d4c
    int64_t v2 = 0x4000000000000000; // bp-208, 0x100003d98
    int64_t v3; // bp-368, 0x100003d00
    _memcpy(&v3, &v1, 48);
    int64_t v4; // bp-416, 0x100003d00
    _memcpy(&v4, &v2, 48);
    int64_t v5; // bp-104, 0x100003d00
    function_1000038ac((int64_t)&v3, (int64_t)&v4, &v5);
    int32_t v6; // 0x100003e78
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003e48
        int128_t v7; // 0x100003d00
        v6 = _printf("(% f, %f)\n", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
    }
    int64_t v8 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003e9c
    if (v8 != *(int64_t *)*(int64_t *)0x100004018) {
        // 0x100003eb0
        ___stack_chk_fail((int64_t)v6);
    }
    // 0x100003eb4
    return 0;
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003ec8
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t function_100003ed4(int64_t a1) {
    // 0x100003ed4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t * function_100003ee0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ee0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(char * format, ...) {
    // 0x100003eec
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

