//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003990(void);
int32_t function_100003ec8(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x300000002; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003990 - 0x100003b58
int64_t function_100003990(void) {
    // 0x100003990
    int64_t v1; // 0x100003990
    int32_t v2 = v1; // 0x100003994
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003b48
        return 0;
    }
    int32_t v3 = 0; // 0x1000039a4
    int32_t v4 = *(int32_t *)(4 * (int64_t)v3 + (int64_t)&g1); // 0x1000039ec
    int64_t result = 1; // 0x1000039f8
    int32_t v5; // 0x100003990
    while (v4 != v2) {
        // 0x100003a14
        result = 0;
        if (v2 % v4 == 0) {
            // break -> 0x100003b48
            break;
        }
        int32_t v6 = v4 * v4; // 0x100003a74
        int32_t v7 = v2 - v6; // 0x100003a78
        result = 1;
        if (v7 < 0 != ((v7 ^ v2) & (v6 ^ v2)) < 0) {
            // break -> 0x100003b48
            break;
        }
        // 0x1000039c8
        v3++;
        if (v3 >= 67) {
            // 0x100003ab0
            v5 = *(int32_t *)((int64_t)&g1 + 264);
            goto lab_0x100003ac8;
        }
        v4 = *(int32_t *)(4 * (int64_t)v3 + (int64_t)&g1);
        result = 1;
    }
    // 0x100003b48
    return result;
  lab_0x100003ac8:;
    int32_t v8 = v5 + 2;
    int32_t v9 = v8 * v8; // 0x100003ad0
    int32_t v10 = v9 - v2; // 0x100003ad8
    result = 1;
    if (v10 == 0 || v10 < 0 != ((v10 ^ v9) & (v9 ^ v2)) < 0) {
        // 0x100003ae8
        v5 = v8;
        result = 0;
        if (v2 % v8 == 0) {
            return result;
        } else {
            goto lab_0x100003ac8;
        }
    } else {
        return result;
    }
}

// Address range: 0x100003b58 - 0x100003ec8
int64_t entry_point(void) {
    // 0x100003b58
    _printf("First 35 safe primes:\n");
    int32_t v1 = 0;
    int32_t v2 = 2;
    int32_t v3 = v1; // 0x100003bb8
    int64_t v4; // 0x100003b58
    if (function_100003990() % 2 != 0) {
        // 0x100003bc0
        v3 = v1;
        if (function_100003990() % 2 != 0) {
            if (v1 < 35 != (34 - v1 & v1) < 0) {
                // 0x100003bf0
                _printf("%d ", v4);
            }
            // 0x100003c10
            v3 = v1 + 1;
        }
    }
    int32_t v5 = v2 + 1; // 0x100003c28
    while (v2 < 0xf423f != (0xf423e - v2 & v5) < 0) {
        // 0x100003bb0
        v1 = v3;
        v2 = v5;
        v3 = v1;
        if (function_100003990() % 2 != 0) {
            // 0x100003bc0
            v3 = v1;
            if (function_100003990() % 2 != 0) {
                if (v1 < 35 != (34 - v1 & v1) < 0) {
                    // 0x100003bf0
                    _printf("%d ", v4);
                }
                // 0x100003c10
                v3 = v1 + 1;
            }
        }
        // 0x100003c24
        v5 = v2 + 1;
    }
    // 0x100003c34
    _printf("\nThere are  %d safe primes below  %d\n", v4, v4);
    int32_t v6 = 0xf4240;
    if (function_100003990() % 2 != 0) {
        // 0x100003ca8
        function_100003990();
    }
    int32_t v7 = v6 + 1; // 0x100003cdc
    while (v6 < 0x98967f != (0x98967e - v6 & v7) < 0) {
        // 0x100003c98
        v6 = v7;
        if (function_100003990() % 2 != 0) {
            // 0x100003ca8
            function_100003990();
        }
        // 0x100003cd8
        v7 = v6 + 1;
    }
    // 0x100003ce8
    _printf("There are %d safe primes below %d\n", v4, v4);
    _printf("\nFirst 40 unsafe primes:\n");
    int32_t v8 = 0;
    int32_t v9 = 2;
    int32_t v10 = v8; // 0x100003d60
    if (function_100003990() % 2 != 0) {
        // 0x100003d68
        v10 = v8;
        if (function_100003990() % 2 == 0) {
            if (v8 < 40 != (39 - v8 & v8) < 0) {
                // 0x100003d98
                _printf("%d ", v4);
            }
            // 0x100003db8
            v10 = v8 + 1;
        }
    }
    int32_t v11 = v9 + 1; // 0x100003dd0
    while (v9 < 0xf423f != (0xf423e - v9 & v11) < 0) {
        // 0x100003d58
        v8 = v10;
        v9 = v11;
        v10 = v8;
        if (function_100003990() % 2 != 0) {
            // 0x100003d68
            v10 = v8;
            if (function_100003990() % 2 == 0) {
                if (v8 < 40 != (39 - v8 & v8) < 0) {
                    // 0x100003d98
                    _printf("%d ", v4);
                }
                // 0x100003db8
                v10 = v8 + 1;
            }
        }
        // 0x100003dcc
        v11 = v9 + 1;
    }
    // 0x100003ddc
    _printf("\nThere are  %d unsafe primes below  %d\n", v4, v4);
    int32_t v12 = 0xf4240;
    if (function_100003990() % 2 != 0) {
        // 0x100003e50
        function_100003990();
    }
    int32_t v13 = v12 + 1; // 0x100003e84
    while (v12 < 0x98967f != (0x98967e - v12 & v13) < 0) {
        // 0x100003e40
        v12 = v13;
        if (function_100003990() % 2 != 0) {
            // 0x100003e50
            function_100003990();
        }
        // 0x100003e80
        v13 = v12 + 1;
    }
    // 0x100003e90
    _printf("There are %d unsafe primes below %d\n", v4, v4);
    return 0;
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(char * format, ...) {
    // 0x100003ec8
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

