//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ac4(void);
int64_t * function_100003f40(int32_t nmemb, int32_t size);
void function_100003f4c(int64_t * ptr);
int32_t function_100003f58(char * format, ...);
int32_t function_100003f64(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ac4 - 0x100003eb0
int64_t function_100003ac4(void) {
    // 0x100003ac4
    int64_t v1; // 0x100003ac4
    int32_t v2 = _strlen((char *)v1); // 0x100003adc
    int32_t result = _strlen((char *)v1); // 0x100003aec
    if (v2 == 0) {
        // 0x100003ea0
        return result;
    }
    int64_t * v3 = _calloc(v2, 4); // 0x100003b84
    int64_t * v4 = _calloc(result, 4); // 0x100003b94
    int32_t v5 = -v2;
    if (v5 < 0 == (v2 & v5) < 0) {
        // 0x100003d38
        _free(v3);
        _free(v4);
        // 0x100003ea0
        return &g1;
    }
    int32_t v6 = v2 - result; // 0x100003b3c
    int32_t v7 = (v6 == 0 | v6 < 0 != ((v6 ^ v2) & (result ^ v2)) < 0 ? result : v2) / 2; // 0x100003b6c
    int64_t v8 = (int64_t)v3; // 0x100003b84
    int64_t v9 = (int64_t)v4; // 0x100003b94
    int32_t v10 = 0; // 0x100003d18
    float64_t v11 = 0.0;
    while (true) {
        float64_t v12 = v11;
        int32_t v13 = v10;
        int32_t v14 = v13 + 1 - v7; // 0x100003bd0
        int32_t v15 = -v14; // 0x100003bd8
        int32_t v16 = v14 == 0 | v15 < 0 != (v14 & v15) < 0 ? v14 : 0;
        int32_t v17 = v13 + v7; // 0x100003c1c
        int32_t v18 = v17 - result; // 0x100003c24
        int32_t v19 = v18 < 0 == ((v18 ^ v17) & (v17 ^ result)) < 0 ? result : v17;
        int32_t v20 = v16 - v19; // 0x100003c74
        float64_t v21 = v12; // 0x100003c7c
        if (v20 < 0 != ((v20 ^ v16) & (v19 ^ v16)) < 0) {
            int64_t v22 = v13;
            char * v23 = (char *)(v1 + v22);
            int32_t v24 = v16; // 0x100003d04
            int32_t * v25; // 0x100003ac4
            while (true) {
                int32_t v26 = v24;
                int64_t v27 = v26; // 0x100003c88
                v25 = (int32_t *)(4 * v27 + v9);
                if (*v25 == 0) {
                    // 0x100003ca4
                    if (*v23 == *(char *)(v1 + v27)) {
                        // break -> 0x100003cd0
                        break;
                    }
                }
                // 0x100003d00
                v24 = v26 + 1;
                int32_t v28 = v24 - v19; // 0x100003c74
                v21 = v12;
                if (v28 < 0 == ((v28 ^ v24) & (v24 ^ v19)) < 0) {
                    goto lab_0x100003d14;
                }
            }
            // 0x100003cd0
            *(int32_t *)(4 * v22 + v8) = 1;
            *v25 = 1;
            v21 = v12 + 1.0;
        }
      lab_0x100003d14:
        // 0x100003d14
        v11 = v21;
        v10 = v13 + 1;
        int32_t v29 = v10 - v2; // 0x100003bb8
        if (v29 < 0 == ((v29 ^ v10) & (v10 ^ v2)) < 0) {
            // break -> 0x100003d24
            break;
        }
    }
    int32_t v30 = 0; // 0x100003d28
    int32_t v31 = 0; // 0x100003d28
    if (v11 == 0.0) {
        // 0x100003d38
        _free(v3);
        _free(v4);
        // 0x100003ea0
        return &g1;
    }
    int32_t v32 = v31; // 0x100003d8c
    int32_t v33; // 0x100003ac4
    int32_t v34; // 0x100003ac4
    if (*(int32_t *)(4 * (int64_t)v30 + v8) != 0) {
        v33 = v32;
        v34 = v33 + 1;
        v31 = v34;
        while (*(int32_t *)(4 * (int64_t)v33 + v9) == 0) {
            // 0x100003d9c
            v33 = v34;
            v34 = v33 + 1;
            v31 = v34;
        }
    }
    // 0x100003e14
    v30++;
    while (v30 - v2 < 0 != ((v30 - v2 ^ v30) & (v30 ^ v2)) < 0) {
        // 0x100003d78
        v32 = v31;
        if (*(int32_t *)(4 * (int64_t)v30 + v8) != 0) {
            v33 = v32;
            v34 = v33 + 1;
            v31 = v34;
            while (*(int32_t *)(4 * (int64_t)v33 + v9) == 0) {
                // 0x100003d9c
                v33 = v34;
                v34 = v33 + 1;
                v31 = v34;
            }
        }
        // 0x100003e14
        v30++;
    }
    // 0x100003e24
    _free(v3);
    _free(v4);
    __asm_sshll(0.0f, 0);
    __asm_sshll(0.0f, 0);
    // 0x100003ea0
    return &g1;
}

// Address range: 0x100003eb0 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003eb0
    function_100003ac4();
    int128_t v1; // 0x100003eb0
    _printf("%f\n", (float64_t)(int64_t)v1);
    function_100003ac4();
    _printf("%f\n", (float64_t)(int64_t)v1);
    function_100003ac4();
    _printf("%f\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t nmemb, int32_t size) {
    // 0x100003f40
    return _calloc(nmemb, size);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * ptr) {
    // 0x100003f4c
    _free(ptr);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * format, ...) {
    // 0x100003f58
    return _printf(format);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

