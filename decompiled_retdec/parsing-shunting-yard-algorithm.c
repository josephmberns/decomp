//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000032bc(void);
int64_t function_100003420(void);
int64_t function_1000035f0(void);
int64_t function_100003750(void);
int64_t function_100003da0(int64_t a1);
int32_t function_100003dac(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003db8(void);
int64_t * function_100003dc4(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003dd0(char * format, ...);
int32_t function_100003ddc(char * s);
int32_t function_100003de8(struct re_pattern_buffer * preg, char * pattern, int32_t cflags);
int32_t function_100003df4(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[1;1H\x1b[JText | %s"; // 0x100003e61
char * g2 = "\xea>"; // 0x100004050
int64_t g3 = 0x60000000003e00; // 0x100008000
int64_t g4 = 0x60000000003e01; // 0x100008030
int64_t g5 = 0x60000000003e1d; // 0x1000081b0
int32_t * g6 = (int32_t *)0x100000cfeedfacf; // 0x100008270
int32_t * g7 = (int32_t *)0x100000c; // 0x100008274
int32_t * g8 = (int32_t *)0x200000000; // 0x100008278
float128_t * g9 = (float128_t *)0x55800000012; // 0x100008280
float128_t * g10 = NULL; // 0x100009a80

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _getchar(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
int32_t _regcomp(struct re_pattern_buffer * a1, char * a2, int32_t a3);
int32_t _regexec(struct re_pattern_buffer * a1, char * a2, int32_t a3, struct _TYPEDEF_regmatch_t a4[1], int32_t a5);

// ------------------------ Functions -------------------------

// Address range: 0x1000032bc - 0x100003420
int64_t function_1000032bc(void) {
    // 0x1000032bc
    _printf((char *)&g1);
    _printf("\nStack| ");
    int32_t v1 = *(int32_t *)&g7; // 0x100003304
    int32_t v2 = -v1; // 0x100003308
    int64_t v3; // 0x1000032bc
    if (v2 < 0 != (v1 & v2) < 0) {
        int32_t v4 = 0; // 0x100003368
        _printf("%.*s ", v3, (char *)v3);
        v4++;
        int32_t v5 = *(int32_t *)&g7; // 0x100003304
        while (v4 - v5 < 0 != ((v4 - v5 ^ v4) & (v5 ^ v4)) < 0) {
            // 0x100003318
            _printf("%.*s ", v3, (char *)v3);
            v4++;
            v5 = *(int32_t *)&g7;
        }
    }
    // 0x100003374
    _printf("\nQueue| ");
    int32_t v6 = *(int32_t *)&g6; // 0x100003394
    int32_t v7 = -v6; // 0x100003398
    if (v7 < 0 == (v6 & v7) < 0) {
        // 0x100003404
        _puts("\n\n<press enter>");
        return _getchar();
    }
    int32_t v8 = 0; // 0x1000033f8
    _printf("%.*s ", v3, (char *)v3);
    v8++;
    int32_t v9 = *(int32_t *)&g6; // 0x100003394
    while (v8 - v9 < 0 != ((v8 - v9 ^ v8) & (v9 ^ v8)) < 0) {
        // 0x1000033a8
        _printf("%.*s ", v3, (char *)v3);
        v8++;
        v9 = *(int32_t *)&g6;
    }
    // 0x100003404
    _puts("\n\n<press enter>");
    return _getchar();
}

// Address range: 0x100003420 - 0x1000035f0
int64_t function_100003420(void) {
    int64_t v1 = g4; // 0x10000345c
    int64_t v2 = 0; // 0x10000345c
    int32_t v3 = 0; // 0x10000345c
    int64_t v4; // 0x100003420
    if (g4 != 0) {
        while (_regcomp((struct re_pattern_buffer *)(v2 + (int64_t)&g4 + 16), (char *)v1, 9) == 0) {
            // 0x100003440
            v3++;
            v2 = 48 * (int64_t)v3;
            v1 = *(int64_t *)(v2 + (int64_t)&g4);
            if (v1 == 0) {
                goto lab_0x100003514;
            }
        }
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000034ac
        _fprintf((struct _IO_FILE *)v5, "[Error %s] %s\n", (char *)9, (char *)v4);
        // 0x1000035e0
        return 0;
    }
  lab_0x100003514:;
    int64_t v6 = g5; // 0x100003530
    int64_t v7 = 0; // 0x100003530
    if (g5 == 0) {
        // 0x1000035e0
        return 1;
    }
    int32_t v8 = 0; // 0x100003530
    while (_regcomp((struct re_pattern_buffer *)(v7 + (int64_t)&g5 + 16), (char *)v6, 9) == 0) {
        int32_t v9 = v8 + 1; // 0x1000035c8
        int64_t v10 = 48 * (int64_t)v9; // 0x100003520
        int64_t v11 = *(int64_t *)(v10 + (int64_t)&g5); // 0x100003524
        v6 = v11;
        v7 = v10;
        v8 = v9;
        if (v11 == 0) {
            // 0x1000035e0
            return 1;
        }
    }
    int64_t v12 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003580
    _fprintf((struct _IO_FILE *)v12, "[Error %s] %s\n", (char *)9, (char *)v4);
    // 0x1000035e0
    return 0;
}

// Address range: 0x1000035f0 - 0x100003750
int64_t function_1000035f0(void) {
    struct _TYPEDEF_regmatch_t v1; // 0x1000036c0
    struct _TYPEDEF_regmatch_t v2[1]; // 0x1000036c0
    int64_t v3; // 0x1000035f0
    int64_t v4 = v3;
    char * v5 = (char *)v4;
    v3 = v4 + 1;
    // 0x1000035f0
    while (*v5 == 32) {
        // 0x100003610
        v4 = v3;
        v5 = (char *)v4;
        v3 = v4 + 1;
    }
    // 0x100003638
    int64_t v6; // 0x1000035f0
    int64_t * v7 = (int64_t *)v6; // 0x100003640
    *v7 = v4;
    if (*v5 == 0) {
        // 0x100003740
        return &g3;
    }
    // 0x100003674
    if (*(int64_t *)v6 == 0) {
        // 0x100003740
        return 0;
    }
    // 0x100003698
    v1 = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    int64_t v8; // bp-80, 0x1000035f0
    v1.e0 = &v8;
    v2[0] = v1;
    int32_t v9 = 0; // 0x10000372c
    int64_t v10; // 0x1000035f0
    int64_t result = v10;
    while (_regexec((struct re_pattern_buffer *)(result + 16), v5, 1, v2, 2) != 0) {
        // 0x100003674
        v9++;
        int64_t v11 = 48 * (int64_t)v9 + v6; // 0x100003684
        if (*(int64_t *)v11 == 0) {
            // 0x100003740
            return 0;
        }
        result = v11;
    }
    // 0x1000036d8
    *(int64_t *)v6 = v4;
    int64_t v12 = v6 - v8; // 0x1000036f0
    *(int32_t *)(v6 + 8) = (int32_t)v12;
    *v7 = (0x100000000 * v12 >> 32) + v4;
    // 0x100003740
    return result;
}

// Address range: 0x100003750 - 0x100003c4c
int64_t function_100003750(void) {
    // 0x100003750
    *(int32_t *)&g7 = 0;
    *(int32_t *)&g6 = 0;
    *(int32_t *)&g8 = 0;
    function_1000032bc();
    int32_t * v1; // 0x100003750
    int32_t v2; // 0x100003750
    int64_t result; // 0x100003750
    int64_t v3; // bp-32, 0x100003750
    int32_t v4; // 0x100003750
    float128_t v5; // bp-72, 0x100003750
    int64_t v6; // 0x100003750
    int32_t v7; // 0x100003a2c
    int64_t v8; // 0x100003750
    int64_t v9; // 0x100003750
    if ((char)v6 == 0) {
        // 0x100003750
        v1 = (int32_t *)(v6 + 12);
        goto lab_0x100003be0;
      lab_0x1000038d4_2:;
        int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000038dc
        _fprintf((struct _IO_FILE *)v11, "[Error %s] %s\n", &v5, &v3);
        result = 0;
        goto lab_0x100003c3c;
      lab_0x100003a5c:;
        int32_t v12 = v7 - v4; // 0x100003a68
        if (v12 == 0 || v12 < 0 != ((v12 ^ v7) & (v7 ^ v4)) < 0) {
            // break -> 0x100003ae8
            goto lab_0x100003ae8_2;
        }
        goto lab_0x100003a7c;
      lab_0x100003a7c:;
        int32_t v13 = *(int32_t *)&g6; // 0x100003a84
        *(int32_t *)&g6 = v13 + 1;
        int64_t v14 = 24 * (int64_t)v13; // 0x100003a98
        int32_t v15 = v2 - 1; // 0x100003ab4
        *(int32_t *)&g7 = v15;
        int64_t v16 = 24 * (int64_t)v15; // 0x100003ac8
        float128_t v17 = *(float128_t *)(v16 + (int64_t)&g10); // 0x100003acc
        *(float128_t *)(v14 + (int64_t)&g9) = v17;
        int64_t v18 = *(int64_t *)(v16 + (int64_t)&g10 + 16); // 0x100003ad4
        *(int64_t *)(v14 + (int64_t)&g9 + 16) = v18;
        function_1000032bc();
        int32_t v19 = *(int32_t *)&g7; // 0x1000039ec
        v2 = v19;
        if (v19 == 0) {
            // break -> 0x100003ae8
            goto lab_0x100003ae8_2;
        }
        goto lab_0x100003a00;
      lab_0x100003be0:
        // 0x100003be0
        result = 1;
        if (*v1 >= 1) {
            int64_t v10 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c00
            _fprintf((struct _IO_FILE *)v10, "[Error %s] %s\n", (char *)v8, (char *)v9);
            result = 0;
        }
      lab_0x100003c3c:
        // 0x100003c3c
        return result;
    }
    while (true) {
        int64_t v21 = function_1000035f0(); // 0x1000037bc
        int64_t v22 = v21; // 0x1000037d0
        if (v21 == 0 || v21 == (int64_t)&g3) {
            // break -> 0x1000037f4
            break;
        }
        while (*(int32_t *)(v22 + 12) == -1) {
            // 0x100003844
            *(int32_t *)&g8 = *(int32_t *)&g8 + 100;
            v22 = function_1000035f0();
            if (v22 == 0 || v22 == (int64_t)&g3) {
                // break (via goto) -> 0x1000037f4
                goto lab_0x1000037f4;
            }
        }
        int32_t v23 = *(int32_t *)&g6; // 0x100003864
        *(int32_t *)&g6 = v23 + 1;
        int64_t v24 = 24 * (int64_t)v23; // 0x100003878
        *(float128_t *)(v24 + (int64_t)&g9) = v5;
        int64_t v25; // 0x100003750
        *(int64_t *)(v24 + (int64_t)&g9 + 16) = v25;
        function_1000032bc();
        int64_t v26 = function_1000035f0(); // 0x1000038b8
        int64_t v27 = v26; // 0x1000038cc
        if (v26 == 0) {
            goto lab_0x1000038d4_2;
        }
        int32_t v28; // 0x100003750
        int32_t v29; // 0x100003910
        int32_t * v30; // 0x100003750
        while (true) {
          lab_0x10000390c:
            // 0x10000390c
            v29 = *(int32_t *)(v27 + 8);
            v30 = (int32_t *)(v27 + 12);
            int32_t v31 = *v30; // 0x100003928
            int32_t v32; // 0x100003750
            if (v31 < 1) {
                // 0x10000395c
                v32 = v31;
                if (v31 == -1) {
                    int32_t v33 = *(int32_t *)&g8; // 0x10000397c
                    v32 = v33;
                    if (v33 < 100 != (99 - v33 & v33) < 0) {
                        int64_t v34 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003998
                        _fprintf((struct _IO_FILE *)v34, "[Error %s] %s\n", &v5, &v3);
                        result = 0;
                        return result;
                    }
                }
            } else {
                // 0x10000393c
                v32 = *(int32_t *)&g8 + v31;
            }
            // 0x1000039e0
            v4 = v32;
            int32_t v35 = *(int32_t *)&g7; // 0x1000039ec
            v2 = v35;
            int32_t v36 = v31; // 0x1000039f8
            v28 = 0;
            if (v35 != 0) {
                while (true) {
                  lab_0x100003a00:;
                    int64_t v20 = 24 * (int64_t)v2; // 0x100003a10
                    v7 = *(int32_t *)(v20 + (int64_t)&g10 - 12);
                    if (v7 == v4) {
                        // 0x100003a44
                        if (*(int32_t *)(v20 + (int64_t)&g10 - 8) == 1) {
                            goto lab_0x100003a7c;
                        } else {
                            goto lab_0x100003a5c;
                        }
                    } else {
                        goto lab_0x100003a5c;
                    }
                }
              lab_0x100003ae8_2:
                // 0x100003ae8
                v36 = *v30;
                v28 = 0;
            }
            // 0x100003ae8
            switch (v36) {
                case -1: {
                    // 0x100003b00
                    *(int32_t *)&g8 = *(int32_t *)&g8 - 100;
                    int64_t v37 = function_1000035f0(); // 0x1000038b8
                    v27 = v37;
                    if (v37 == 0) {
                        goto lab_0x1000038d4_2;
                    }
                    goto lab_0x10000390c;
                }
                case 0: {
                    // 0x100003b30
                    function_1000032bc();
                    result = 1;
                    if (*(int32_t *)&g8 != 0) {
                        int64_t v38 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b5c
                        _fprintf((struct _IO_FILE *)v38, "[Error %s] %s\n", &v5, &v3);
                        result = 0;
                    }
                    // 0x100003c3c
                    return result;
                }
                default: {
                    goto lab_0x100003b98;
                }
            }
        }
      lab_0x100003b98:;
        int64_t v39 = v29; // 0x100003914
        *(int32_t *)&g7 = v28 + 1;
        int64_t v40 = 24 * (int64_t)v28; // 0x100003bb4
        *(float128_t *)(v40 + (int64_t)&g10) = v5;
        *(int64_t *)(v40 + (int64_t)&g10 + 16) = v39;
        function_1000032bc();
        v25 = v39;
        int64_t v41; // 0x100003750
        if (*(char *)&v41 == 0) {
            // 0x100003790
            v1 = v30;
            v8 = &v5;
            v9 = &v3;
            goto lab_0x100003be0;
        }
    }
  lab_0x1000037f4:;
    int64_t v42 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000037fc
    _fprintf((struct _IO_FILE *)v42, "[Error %s] %s\n", &v5, &v3);
    // 0x100003c3c
    return 0;
}

// Address range: 0x100003c4c - 0x100003da0
int64_t entry_point(void) {
    // 0x100003c4c
    int64_t v1; // bp-88, 0x100003c4c
    _memcpy(&v1, (int64_t *)&g2, 64);
    int64_t v2 = function_100003420(); // 0x100003c80
    int64_t v3 = v2; // 0x100003c8c
    int64_t result = 1; // 0x100003c8c
    if ((int32_t)v2 != 0) {
        // 0x100003ca8
        v3 = v2;
        result = 0;
        if (v1 != 0) {
            _printf("Testing string `%s'   <enter>\n", (char *)&g2);
            _getchar();
            function_100003750();
            int32_t v4 = _printf("string `%s': %s\n\n", (char *)&g2, (char *)64); // 0x100003d44
            int32_t v5 = 1; // 0x100003d50
            int32_t v6 = v5; // 0x100003cbc
            while (*(int64_t *)(8 * (int64_t)v5 + (int64_t)&v1) != 0) {
                // 0x100003cc4
                _printf("Testing string `%s'   <enter>\n", (char *)&g2);
                _getchar();
                function_100003750();
                v4 = _printf("string `%s': %s\n\n", (char *)&g2, (char *)64);
                v5 = v6 + 1;
                v6 = v5;
            }
            // 0x100003ca8
            v3 = v4;
            result = 0;
        }
    }
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d78
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d8c
        ___stack_chk_fail(v3);
    }
    // 0x100003d90
    return result;
}

// Address range: 0x100003da0 - 0x100003dac
int64_t function_100003da0(int64_t a1) {
    // 0x100003da0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003dac - 0x100003db8
int32_t function_100003dac(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003dac
    return _fprintf(stream, format);
}

// Address range: 0x100003db8 - 0x100003dc4
int32_t function_100003db8(void) {
    // 0x100003db8
    return _getchar();
}

// Address range: 0x100003dc4 - 0x100003dd0
int64_t * function_100003dc4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003dc4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dd0 - 0x100003ddc
int32_t function_100003dd0(char * format, ...) {
    // 0x100003dd0
    return _printf(format);
}

// Address range: 0x100003ddc - 0x100003de8
int32_t function_100003ddc(char * s) {
    // 0x100003ddc
    return _puts(s);
}

// Address range: 0x100003de8 - 0x100003df4
int32_t function_100003de8(struct re_pattern_buffer * preg, char * pattern, int32_t cflags) {
    // 0x100003de8
    return _regcomp(preg, pattern, cflags);
}

// Address range: 0x100003df4 - 0x100003e00
int32_t function_100003df4(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags) {
    // 0x100003df4
    return _regexec(preg, string, nmatch, pmatch, eflags);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

