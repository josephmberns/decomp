//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036c8(void);
int64_t function_1000036f0(void);
int64_t function_100003718(void);
int64_t function_10000383c(void);
int64_t function_100003998(char * a1);
int64_t function_1000039cc(void);
int64_t * function_100003e74(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003e80(char * format, ...);
void function_100003e8c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

int64_t g1 = 100; // 0x100003f90
int32_t g2 = -0x1120531; // 0x100008000
int32_t g3 = 0x100000c; // 0x100008004
int64_t g4 = 0x200000000; // 0x100008008
int64_t g5 = 0x1200000002; // 0x10000800c
int64_t g6 = 0; // 0x100021a18
char * g7; // 0x10003b428
int32_t g8;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _bsearch(int64_t * a1, int64_t * a2, int32_t a3, int32_t a4, int32_t (*a5)(int64_t *, int64_t *));
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x1000036c8 - 0x1000036f0
int64_t function_1000036c8(void) {
    // 0x1000036c8
    return 0;
}

// Address range: 0x1000036f0 - 0x100003718
int64_t function_1000036f0(void) {
    // 0x1000036f0
    return 0;
}

// Address range: 0x100003718 - 0x10000383c
int64_t function_100003718(void) {
    // 0x100003718
    int64_t v1; // 0x100003718
    int32_t v2 = v1; // 0x100003718
    int32_t v3 = 0;
    int32_t v4 = 1;
    int32_t v5 = 8;
    int32_t v6 = 9 * v4; // 0x100003760
    int32_t v7 = v3; // 0x100003718
    int32_t v8 = v6; // 0x100003718
    int32_t v9 = v4; // 0x100003718
    int32_t v10; // 0x100003718
    switch (v10 % 3) {
        case 0: {
            // 0x1000037b8
            v7 = v6 + v3;
            v8 = 0;
            v9 = 1;
            // break -> 0x10000380c
            break;
        }
        case 1: {
            // 0x1000037d8
            v7 = v3 - v6;
            v8 = 0;
            v9 = 1;
            // break -> 0x10000380c
            break;
        }
        case 2: {
            // 0x1000037f8
            v7 = v3;
            v8 = v6;
            v9 = 10 * v4;
            // break -> 0x10000380c
            break;
        }
    }
    int32_t result = v7;
    int32_t v11 = v5 - 1; // 0x100003748
    v2 /= 3;
    while (v5 == 0 == (v5 & -v5) < 0) {
        // 0x100003750
        v3 = result;
        v4 = v9;
        int32_t v12 = v5;
        v5 = v11;
        v6 = v4 * v12 + v8;
        v7 = v3;
        v8 = v6;
        v9 = v4;
        switch (v10 % 3) {
            case 0: {
                // 0x1000037b8
                v7 = v6 + v3;
                v8 = 0;
                v9 = 1;
                // break -> 0x10000380c
                break;
            }
            case 1: {
                // 0x1000037d8
                v7 = v3 - v6;
                v8 = 0;
                v9 = 1;
                // break -> 0x10000380c
                break;
            }
            case 2: {
                // 0x1000037f8
                v7 = v3;
                v8 = v6;
                v9 = 10 * v4;
                // break -> 0x10000380c
                break;
            }
        }
        // 0x10000380c
        result = v7;
        v11 = v5 - 1;
        v2 /= 3;
    }
    // 0x100003830
    return result;
}

// Address range: 0x10000383c - 0x100003998
int64_t function_10000383c(void) {
    int32_t v1 = 0x19a1; // 0x10000383c
    char * v2 = (char *)&g7;
    int32_t v3 = 1;
    char * v4 = v2; // 0x10000383c
    int32_t v5; // 0x10000383c
    int32_t v6; // 0x10000383c
    int32_t v7; // 0x100003848
    int32_t v8; // 0x1000038d0
    switch (v7 % v5 / v6) {
        case 0: {
            // 0x1000038cc
            v8 = v3 - 1;
            v4 = v2;
            if (v8 != 0 && v8 < 0 == (v3 & -v3) < 0) {
                // 0x1000038e0
                *v2 = 43;
                v4 = (char *)((int64_t)v2 + 1);
            }
            // break -> 0x100003914
            break;
        }
        case 1: {
            // 0x1000038fc
            *v2 = 45;
            v4 = (char *)((int64_t)v2 + 1);
            // break -> 0x100003914
            break;
        }
    }
    char * v9 = (char *)((int64_t)v4 + 1);
    *v4 = (char)v3 + 48;
    int32_t v10 = v3 + 1; // 0x10000394c
    int32_t v11 = v3 - 8; // 0x100003878
    while (v11 == 0 || v11 < 0 != (7 - v3 & v10) < 0) {
        // 0x100003888
        v1 /= 3;
        v2 = v9;
        v3 = v10;
        v4 = v2;
        switch (v7 % v5 / v6) {
            case 0: {
                // 0x1000038cc
                v8 = v3 - 1;
                v4 = v2;
                if (v8 != 0 && v8 < 0 == (v3 & -v3) < 0) {
                    // 0x1000038e0
                    *v2 = 43;
                    v4 = (char *)((int64_t)v2 + 1);
                }
                // break -> 0x100003914
                break;
            }
            case 1: {
                // 0x1000038fc
                *v2 = 45;
                v4 = (char *)((int64_t)v2 + 1);
                // break -> 0x100003914
                break;
            }
        }
        // 0x100003914
        v9 = (char *)((int64_t)v4 + 1);
        *v4 = (char)v3 + 48;
        v10 = v3 + 1;
        v11 = v3 - 8;
    }
    // 0x100003958
    *v9 = 0;
    function_100003718();
    int64_t v12; // 0x10000383c
    return _printf("%9d = %s\n", v12, (char *)v12);
}

// Address range: 0x100003998 - 0x1000039cc
int64_t function_100003998(char * a1) {
    // 0x100003998
    int64_t v1; // 0x100003998
    return _printf("\n\n%s\n\n", (char *)v1);
}

// Address range: 0x1000039cc - 0x100003b94
int64_t function_1000039cc(void) {
    int32_t v1 = 0;
    int64_t v2 = function_100003718(); // 0x1000039fc
    int64_t v3 = 8 * (int64_t)v1; // 0x100003a04
    *(int32_t *)(v3 + (int64_t)&g6) = (int32_t)v2;
    *(int32_t *)(v3 + (int64_t)&g6 + 4) = v1;
    int32_t v4 = v1 + 1; // 0x100003a2c
    while (v1 < 0x3341 != (0x3340 - v1 & v4) < 0) {
        // 0x1000039f8
        v1 = v4;
        v2 = function_100003718();
        v3 = 8 * (int64_t)v1;
        *(int32_t *)(v3 + (int64_t)&g6) = (int32_t)v2;
        *(int32_t *)(v3 + (int64_t)&g6 + 4) = v1;
        v4 = v1 + 1;
    }
    // 0x100003a38
    g2 = 0x3342;
    _qsort(&g6, 0x3342, 8, (int32_t (*)(int64_t *, int64_t *))0x1000036c8);
    *(int32_t *)&g4 = 1;
    *(int32_t *)&g5 = *(int32_t *)&g6;
    int32_t v5 = -g2; // 0x100003a98
    int32_t v6 = 0; // 0x100003aa0
    int32_t v7; // 0x100003b60
    if (v5 < 0 == (g2 & v5) < 0) {
        // 0x100003b5c
        v7 = 1;
        g3 = v7;
        _qsort(&g4, v7, 8, (int32_t (*)(int64_t *, int64_t *))0x1000036f0);
        return &g8;
    }
    int32_t v8 = 0;
    int64_t v9 = 8 * (int64_t)v8; // 0x100003ab4
    int32_t * v10 = (int32_t *)(8 * (int64_t)v6 + (int64_t)&g6); // 0x100003acc
    int32_t v11; // 0x1000039cc
    int32_t * v12; // 0x100003b38
    int32_t v13; // 0x100003ae8
    int64_t v14; // 0x100003af4
    if (*(int32_t *)(v9 + (int64_t)&g4 + 4) == *v10) {
        // 0x100003b28
        v12 = (int32_t *)(v9 + (int64_t)&g4);
        *v12 = *v12 + 1;
        v11 = v8;
    } else {
        // 0x100003ae0
        v13 = v8 + 1;
        v14 = 8 * (int64_t)v13;
        *(int32_t *)(v14 + (int64_t)&g4) = 1;
        *(int32_t *)(v14 + (int64_t)&g4 + 4) = *v10;
        v11 = v13;
    }
    int32_t v15 = v11;
    v6++;
    int32_t v16 = v6 - g2; // 0x100003a98
    while (v16 < 0 != ((v16 ^ v6) & (g2 ^ v6)) < 0) {
        // 0x100003aa8
        v8 = v15;
        v9 = 8 * (int64_t)v8;
        v10 = (int32_t *)(8 * (int64_t)v6 + (int64_t)&g6);
        if (*(int32_t *)(v9 + (int64_t)&g4 + 4) == *v10) {
            // 0x100003b28
            v12 = (int32_t *)(v9 + (int64_t)&g4);
            *v12 = *v12 + 1;
            v11 = v8;
        } else {
            // 0x100003ae0
            v13 = v8 + 1;
            v14 = 8 * (int64_t)v13;
            *(int32_t *)(v14 + (int64_t)&g4) = 1;
            *(int32_t *)(v14 + (int64_t)&g4 + 4) = *v10;
            v11 = v13;
        }
        // 0x100003b4c
        v15 = v11;
        v6++;
        v16 = v6 - g2;
    }
    // 0x100003b5c
    v7 = v15 + 1;
    g3 = v7;
    _qsort(&g4, v7, 8, (int32_t (*)(int64_t *, int64_t *))0x1000036f0);
    return &g8;
}

// Address range: 0x100003b94 - 0x100003e74
int64_t entry_point(void) {
    // 0x100003b94
    function_1000039cc();
    function_100003998("Show all solutions that sum to 100");
    int64_t v1 = g1; // bp-32, 0x100003bcc
    int64_t * v2 = _bsearch(&v1, &g6, g2, 8, (int32_t (*)(int64_t *, int64_t *))0x1000036c8); // 0x100003bec
    if (v2 != NULL) {
        int32_t * v3 = (int32_t *)v2;
        while (v3 != (int32_t *)&g6) {
            int32_t * v4 = (int32_t *)((int64_t)v3 - 8); // 0x100003c34
            if (*v4 != 100) {
                // break -> 0x100003c68
                break;
            }
            v3 = v4;
        }
        int64_t v5 = (int64_t)v3; // 0x100003c68
        int64_t v6 = v5; // 0x100003c90
        int32_t * v7 = v3; // 0x100003c90
        if (8 * (int64_t)g2 + (int64_t)&g6 != v5) {
            while (*v7 == 100) {
                int64_t v8 = v6 + 8; // 0x100003cc0
                function_10000383c();
                v6 = v8;
                v7 = (int32_t *)v8;
                if (8 * (int64_t)g2 + (int64_t)&g6 == v8) {
                    // break -> 0x100003cd8
                    break;
                }
            }
        }
    }
    // 0x100003cd8
    function_100003998("Show the positve sum that has the maximum number of solutions");
    int32_t v9 = g3; // 0x100003cf4
    v9--;
    uint32_t v10 = *(int32_t *)(8 * (int64_t)v9 + (int64_t)&g4 + 4); // 0x100003d08
    while (v10 < 0) {
        // 0x100003cf8
        v9--;
        v10 = *(int32_t *)(8 * (int64_t)v9 + (int64_t)&g4 + 4);
    }
    // 0x100003d2c
    _printf("%d has %d solutions\n", (int64_t)&g6, (int64_t)g2);
    function_100003998("Show the lowest positive number that can't be expressed");
    int32_t v11 = 0; // 0x100003d80
    int64_t v12 = v11; // bp-56, 0x100003d8c
    int64_t * v13 = _bsearch(&v12, &g6, g2, 8, (int32_t (*)(int64_t *, int64_t *))0x1000036c8); // 0x100003db0
    v11++;
    while (v13 != NULL) {
        // 0x100003d84
        v12 = v11;
        v13 = _bsearch(&v12, &g6, g2, 8, (int32_t (*)(int64_t *, int64_t *))0x1000036c8);
        v11++;
    }
    // 0x100003dc4
    _printf("%d\n", (int64_t)&g6);
    function_100003998("Show the ten highest numbers that can be expressed");
    int32_t v14 = g2 - 1;
    if ((v14 & 9 - g2) < 0) {
        // 0x100003e64
        return 0;
    }
    int32_t v15 = v14; // 0x100003e30
    function_10000383c();
    v15--;
    int32_t v16 = g2 - 10; // 0x100003e24
    while (v15 - v16 < 0 == ((v15 - v16 ^ v15) & (v16 ^ v15)) < 0) {
        // 0x100003e38
        function_10000383c();
        v15--;
        v16 = g2 - 10;
    }
    // 0x100003e64
    return 0;
}

// Address range: 0x100003e74 - 0x100003e80
int64_t * function_100003e74(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e74
    return _bsearch(key, base, nmemb, size, compar);
}

// Address range: 0x100003e80 - 0x100003e8c
int32_t function_100003e80(char * format, ...) {
    // 0x100003e80
    return _printf(format);
}

// Address range: 0x100003e8c - 0x100003e98
void function_100003e8c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e8c
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

