//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a04(void);
int64_t function_100003ae0(void);
int64_t function_100003eb8(int64_t a1);
int32_t function_100003ec4(struct _IO_FILE * stream);
char * function_100003ed0(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003ee8(char * s, char * format, ...);
int32_t function_100003ef4(char * s1, char * s2);
int32_t function_100003f00(char * s, char * reject);
int32_t function_100003f0c(char * s);
int32_t function_100003f18(char * s, char * accept);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _feof(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _sscanf(char * a1, char * a2, ...);
int32_t _strcasecmp(char * a1, char * a2);
int32_t _strcspn(char * a1, char * a2);
int32_t _strlen(char * a1);
int32_t _strspn(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a04 - 0x100003ae0
int64_t function_100003a04(void) {
    // 0x100003a04
    int64_t v1; // 0x100003a04
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003a10
    int64_t v3 = *(int64_t *)(v1 + 8); // 0x100003a1c
    if (v3 == 0) {
        // 0x100003ad0
        return _fprintf(v2, "; %s\n", (char *)v1);
    }
    char * v4 = (char *)v1;
    int32_t result; // 0x100003a04
    if (*(char *)v3 == 0) {
        // 0x100003a74
        result = _fprintf(v2, "%s\n", v4);
    } else {
        // 0x100003a9c
        result = _fprintf(v2, "%s %s\n", v4, (char *)v1);
    }
    // 0x100003ad0
    return result;
}

// Address range: 0x100003ae0 - 0x100003e38
int64_t function_100003ae0(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003af8
    int64_t v2; // 0x100003ae0
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2; // 0x100003b00
    int64_t * v4; // 0x100003ae0
    int64_t v5; // bp-288, 0x100003ae0
    int64_t result; // 0x100003ae0
    int64_t * v6; // 0x100003ae0
    int32_t v7; // 0x100003d08
    int64_t v8; // 0x100003ae0
    if (_fgets((char *)&v5, 256, v3) == NULL) {
        // 0x100003ae0
        v4 = (int64_t *)v2;
      lab_0x100003d38:;
        int32_t v9 = 0; // 0x100003d54
        if (*v4 == 0) {
          lab_0x100003dd4:;
            int32_t v10 = _feof(v3); // 0x100003dd8
            result = v10 == 0 ? 0xffffffff : 0;
            v8 = v10;
        } else {
            while (true) {
                // 0x100003d5c
                int64_t v11; // 0x100003ae0
                if (*(int32_t *)(v11 + 16) == 0) {
                    int64_t v12 = function_100003a04(); // 0x100003d9c
                    result = 0xffffffff;
                    v8 = v12;
                    if ((int32_t)v12 < 0) {
                        // break -> 0x100003df8
                        break;
                    }
                }
                int32_t v13 = v9 + 1; // 0x100003dc8
                int64_t v14 = 24 * (int64_t)v13 + v2; // 0x100003d48
                v11 = v14;
                v9 = v13;
                if (*(int64_t *)v14 == 0) {
                    goto lab_0x100003dd4;
                }
            }
        }
    } else {
        char ** v15 = (char **)v2;
        v6 = (int64_t *)v2;
        while (true) {
          lab_0x100003b34:;
            int32_t v16 = _strlen((char *)&v5); // 0x100003b3c
            int32_t v17 = _strspn((char *)&v5, "\t "); // 0x100003b54
            if (v17 == v16 | v17 == _strcspn((char *)&v5, "#")) {
                goto lab_0x100003cf0;
            } else {
                // 0x100003bac
                if (_sscanf((char *)&v5, "; %127s", v15) == 1) {
                    goto lab_0x100003c04;
                } else {
                    // 0x100003bd8
                    if (_sscanf((char *)&v5, "%127s", v15) == 1) {
                        goto lab_0x100003c04;
                    } else {
                        goto lab_0x100003cf0;
                    }
                }
            }
        }
      lab_0x100003d1c:
        // 0x100003d1c
        result = 0xffffffff;
        v8 = v7;
    }
  lab_0x100003df8:
    // 0x100003df8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e20
        ___stack_chk_fail(v8);
    }
    // 0x100003e24
    return result;
  lab_0x100003cf0:
    // 0x100003cf0
    v7 = _fprintf((struct _IO_FILE *)v2, "%s", (char *)v2);
    if (v7 < 0) {
        // break -> 0x100003d1c
        goto lab_0x100003d1c;
    }
    goto lab_0x100003d2c;
  lab_0x100003d2c:;
    char * v18 = _fgets((char *)&v5, 256, v3); // 0x100003b1c
    v4 = v6;
    if (v18 == NULL) {
        goto lab_0x100003d38;
    }
    goto lab_0x100003b34;
  lab_0x100003c04:;
    int64_t v19 = *v6; // 0x100003c20
    int64_t v20 = v19; // 0x100003c2c
    if (v19 == 0) {
        goto lab_0x100003cf0;
    } else {
        int64_t v21; // bp-416, 0x100003ae0
        int32_t v22 = _strcasecmp((char *)v20, (char *)&v21); // 0x100003c4c
        int32_t v23 = 0; // 0x100003c58
        int64_t v24; // 0x100003ae0
        int64_t v25; // 0x100003c78
        if (v22 == 0) {
            // 0x100003c60
            v25 = function_100003a04();
            result = 0xffffffff;
            v8 = v25;
            if ((int32_t)v25 < 0) {
                goto lab_0x100003df8;
            }
            // 0x100003c98
            *(int32_t *)(v24 + 16) = 1;
            v23 = 1;
        }
        int32_t v26 = v23;
        int32_t v27 = 1; // 0x100003cc4
        int64_t v28 = 24 * (int64_t)v27 + v2; // 0x100003c20
        int64_t v29 = *(int64_t *)v28; // 0x100003c20
        v20 = v29;
        v24 = v28;
        int32_t v30 = v27; // 0x100003c2c
        int32_t v31 = v26; // 0x100003c2c
        while (v29 != 0) {
            // 0x100003c34
            v22 = _strcasecmp((char *)v20, (char *)&v21);
            v23 = v31;
            if (v22 == 0) {
                // 0x100003c60
                v25 = function_100003a04();
                result = 0xffffffff;
                v8 = v25;
                if ((int32_t)v25 < 0) {
                    goto lab_0x100003df8;
                }
                // 0x100003c98
                *(int32_t *)(v24 + 16) = 1;
                v23 = 1;
            }
            // 0x100003cc0
            v26 = v23;
            v27 = v30 + 1;
            v28 = 24 * (int64_t)v27 + v2;
            v29 = *(int64_t *)v28;
            v20 = v29;
            v24 = v28;
            v30 = v27;
            v31 = v26;
        }
        if (v26 == 0) {
            goto lab_0x100003cf0;
        } else {
            goto lab_0x100003d2c;
        }
    }
}

// Address range: 0x100003e38 - 0x100003eb8
int64_t entry_point(void) {
    int64_t result = 0; // 0x100003e74
    if ((int32_t)function_100003ae0() < 0) {
        // 0x100003e7c
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "failed\n");
        result = 1;
    }
    // 0x100003ea8
    return result;
}

// Address range: 0x100003eb8 - 0x100003ec4
int64_t function_100003eb8(int64_t a1) {
    // 0x100003eb8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(struct _IO_FILE * stream) {
    // 0x100003ec4
    return _feof(stream);
}

// Address range: 0x100003ed0 - 0x100003edc
char * function_100003ed0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ed0
    return _fgets(s, n, stream);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003edc
    return _fprintf(stream, format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * s, char * format, ...) {
    // 0x100003ee8
    return _sscanf(s, format);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * s1, char * s2) {
    // 0x100003ef4
    return _strcasecmp(s1, s2);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * s, char * reject) {
    // 0x100003f00
    return _strcspn(s, reject);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * s) {
    // 0x100003f0c
    return _strlen(s);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * s, char * accept) {
    // 0x100003f18
    return _strspn(s, accept);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

