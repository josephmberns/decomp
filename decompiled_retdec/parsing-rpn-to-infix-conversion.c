//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003604(void);
int64_t function_1000037c4(void);
int64_t function_100003860(void);
int64_t function_100003a5c(int64_t a1);
int64_t function_100003abc(void);
int64_t function_100003bb8(void);
int64_t function_100003cb8(void);
int64_t function_100003eb8(int64_t a1, int64_t a2, int64_t a3);
void function_100003ec4(int32_t status);
int64_t * function_100003ed0(int32_t size);
int32_t function_100003edc(char * format, ...);
int32_t function_100003ee8(char * s);
char * function_100003ef4(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003604 - 0x1000037c4
int64_t function_100003604(void) {
    // 0x100003604
    int64_t v1; // 0x100003604
    if ((char)v1 == (char)v1) {
        // 0x1000037b8
        return 0;
    }
    uint32_t v2 = (int32_t)v1 % 256;
    if (v2 == 94) {
        // 0x1000037b8
        return 1;
    }
    uint32_t v3 = (int32_t)v1 % 256;
    if (v3 == 94) {
        // 0x1000037b8
        return 2;
    }
    // 0x100003674
    if (v2 == 47) {
        // 0x1000037b8
        return 1;
    }
    // 0x100003694
    if (v3 == 47) {
        // 0x1000037b8
        return 2;
    }
    // 0x1000036b4
    if (v2 == 42) {
        // 0x1000037b8
        return 1;
    }
    // 0x1000036d4
    if (v3 == 42) {
        // 0x1000037b8
        return 2;
    }
    // 0x1000036f4
    if (v2 == 43) {
        // 0x1000037b8
        return 1;
    }
    int64_t result = 2; // 0x100003720
    if (v3 != 43) {
        // 0x100003734
        result = v2 != 45 ? 2 : 1;
    }
    // 0x1000037b8
    return result;
}

// Address range: 0x1000037c4 - 0x100003860
int64_t function_1000037c4(void) {
    // 0x1000037c4
    int64_t v1; // 0x1000037c4
    uint32_t v2 = (int32_t)v1 % 256;
    return v2 == 94 | v2 == 47 | v2 == 42 | (char)v1 == 43 | v2 == 45;
}

// Address range: 0x100003860 - 0x100003a5c
int64_t function_100003860(void) {
    // 0x100003860
    int64_t v1; // 0x100003860
    if (v1 == 0) {
        // 0x100003a50
        return 0;
    }
    char v2 = v1;
    int64_t * v3 = (int64_t *)(v1 + 16); // 0x100003888
    int64_t v4; // 0x1000038f4
    int64_t v5; // 0x100003860
    if (*v3 == 0) {
        goto lab_0x10000394c;
    } else {
        // 0x10000389c
        if ((int32_t)function_1000037c4() == 1) {
            // 0x1000038bc
            v4 = (int64_t)*(char *)*v3 & 0xffffffff;
            if ((int32_t)function_100003604() == 1) {
                goto lab_0x100003924;
            } else {
                // 0x1000038e4
                v4 = (int64_t)*(char *)*v3 & 0xffffffff;
                v5 = v4;
                if (v2 == 94 == (int32_t)function_100003604() == 0) {
                    goto lab_0x100003924;
                } else {
                    goto lab_0x10000394c;
                }
            }
        } else {
            goto lab_0x10000394c;
        }
    }
  lab_0x10000394c:
    // 0x10000394c
    function_100003860();
    int64_t v6 = v5; // 0x100003958
    goto lab_0x10000395c;
  lab_0x10000395c:
    // 0x10000395c
    _printf(" %s ", (char *)v6);
    if (*(int64_t *)(v1 + 24) == 0 || (int32_t)function_1000037c4() != 1) {
        // 0x100003a50
        return function_100003860();
    }
    // 0x1000039ac
    if ((int32_t)function_100003604() != 1) {
        // 0x1000039d4
        if (v2 == 94 | (int32_t)function_100003604() != 0) {
            // 0x100003a50
            return function_100003860();
        }
    }
    // 0x100003a14
    _printf("(");
    function_100003860();
    // 0x100003a50
    return _printf(")");
  lab_0x100003924:
    // 0x100003924
    _printf("(");
    function_100003860();
    _printf(")");
    v6 = v4;
    goto lab_0x10000395c;
}

// Address range: 0x100003a5c - 0x100003abc
int64_t function_100003a5c(int64_t a1) {
    int32_t v1 = *(int32_t *)&g1; // 0x100003a68
    if (v1 >= 0) {
        // 0x100003a90
        *(int32_t *)&g1 = v1 - 1;
        return *(int64_t *)(g2 + 8 * (int64_t)v1);
    }
    // 0x100003a7c
    _printf("\nInvalid RPN !");
    _exit(0);
    // UNREACHABLE
}

// Address range: 0x100003abc - 0x100003bb8
int64_t function_100003abc(void) {
    int64_t result = (int64_t)_malloc(32); // 0x100003ad4
    int64_t v1; // 0x100003abc
    ___strcpy_chk(result, v1, 10);
    int64_t v2 = 0; // 0x100003b00
    if ((int32_t)function_1000037c4() == 1) {
        // 0x100003b08
        function_100003a5c((int64_t)&g3);
        v2 = function_100003abc();
    }
    // 0x100003b28
    *(int64_t *)(result + 24) = v2;
    int64_t v3 = 0; // 0x100003b48
    if ((int32_t)function_1000037c4() == 1) {
        // 0x100003b50
        function_100003a5c((int64_t)&g3);
        v3 = function_100003abc();
    }
    // 0x100003b70
    *(int64_t *)(result + 16) = v3;
    if (v1 != 0) {
        // 0x100003b90
        _printf("\n");
        function_100003860();
    }
    // 0x100003ba8
    return result;
}

// Address range: 0x100003bb8 - 0x100003cb8
int64_t function_100003bb8(void) {
    // 0x100003bb8
    if ((int32_t)function_1000037c4() == 0) {
        // 0x100003ca8
        return 0;
    }
    int32_t v1 = *(int32_t *)&g1; // 0x100003c14
    int32_t v2 = -v1; // 0x100003c18
    int32_t v3 = 0; // 0x100003c20
    int32_t v4 = 0; // 0x100003c20
    int32_t v5 = 0; // 0x100003c20
    if (v1 == 0 || v2 < 0 != (v1 & v2) < 0) {
        int64_t v6 = function_1000037c4(); // 0x100003c40
        v5 += (int32_t)((int32_t)v6 != 1);
        v4 += (int32_t)((int32_t)v6 == 1);
        v3++;
        int32_t v7 = *(int32_t *)&g1; // 0x100003c14
        while (v3 - v7 == 0 || v3 - v7 < 0 != ((v3 - v7 ^ v3) & (v7 ^ v3)) < 0) {
            // 0x100003c28
            v6 = function_1000037c4();
            v5 += (int32_t)((int32_t)v6 != 1);
            v4 += (int32_t)((int32_t)v6 == 1);
            v3++;
            v7 = *(int32_t *)&g1;
        }
        // 0x100003ca8
        return v5 == v4 + 1;
    }
    // 0x100003ca8
    return false;
}

// Address range: 0x100003cb8 - 0x100003df4
int64_t function_100003cb8(void) {
    int32_t v1 = 0; // 0x100003ccc
    int32_t v2; // 0x100003cb8
    int64_t v3; // 0x100003da8
    char * v4; // 0x100003dd0
    int64_t v5; // 0x100003cb8
    char * v6; // 0x100003d64
    int64_t * v7; // 0x100003d94
    while (true) {
        // 0x100003cd0
        int32_t v8; // 0x100003cb8
        int64_t v9; // 0x100003cb8
        switch (*(char *)(v9 + (int64_t)v8)) {
            case 0: {
                // 0x100003d30
                g2 = (int64_t)_malloc(8 * *(int32_t *)&g1 + 8);
                v6 = _strtok((char *)v5, " ");
                v2 = 0;
                if (v6 == NULL) {
                    // 0x100003de8
                    return 0;
                }
                v7 = _malloc(_strlen(v6));
                v3 = 8 * (int64_t)v2;
                *(int64_t *)(g2 + v3) = (int64_t)v7;
                ___strcpy_chk(*(int64_t *)(g2 + v3), (int64_t)v6, -1);
                v4 = _strtok(NULL, " ");
                v2++;
                while (v4 != NULL) {
                    // 0x100003d88
                    v7 = _malloc(_strlen(v4));
                    v3 = 8 * (int64_t)v2;
                    *(int64_t *)(g2 + v3) = (int64_t)v7;
                    ___strcpy_chk(*(int64_t *)(g2 + v3), (int64_t)v4, -1);
                    v4 = _strtok(NULL, " ");
                    v2++;
                }
                // 0x100003de8
                return 0;
            }
            case 32: {
                // 0x100003d08
                *(int32_t *)&g1 = *(int32_t *)&g1 + 1;
                // break -> 0x100003d20
                break;
            }
        }
        // 0x100003d20
        v1++;
    }
    // 0x100003d30
    g2 = (int64_t)_malloc(8 * *(int32_t *)&g1 + 8);
    v6 = _strtok((char *)v5, " ");
    v2 = 0;
    if (v6 == NULL) {
        // 0x100003de8
        return 0;
    }
    v7 = _malloc(_strlen(v6));
    v3 = 8 * (int64_t)v2;
    *(int64_t *)(g2 + v3) = (int64_t)v7;
    ___strcpy_chk(*(int64_t *)(g2 + v3), (int64_t)v6, -1);
    v4 = _strtok(NULL, " ");
    v2++;
    while (v4 != NULL) {
        // 0x100003d88
        v7 = _malloc(_strlen(v4));
        v3 = 8 * (int64_t)v2;
        *(int64_t *)(g2 + v3) = (int64_t)v7;
        ___strcpy_chk(*(int64_t *)(g2 + v3), (int64_t)v4, -1);
        v4 = _strtok(NULL, " ");
        v2++;
    }
    // 0x100003de8
    return 0;
}

// Address range: 0x100003df4 - 0x100003eb8
int64_t entry_point(void) {
    // 0x100003df4
    int64_t v1; // 0x100003df4
    if ((int32_t)v1 == 1) {
        // 0x100003e20
        _printf("Usage : %s <RPN expression enclosed by quotes> <optional parameter to trace the build process>", (char *)v1);
        // 0x100003ea8
        return 0;
    }
    // 0x100003e40
    function_100003cb8();
    if ((int32_t)function_100003bb8() == 0) {
        // 0x100003e60
        _printf("\nInvalid RPN !");
    } else {
        // 0x100003e74
        function_100003a5c((int64_t)&g3);
        function_100003abc();
        _printf("\nFinal infix expression : ");
        function_100003860();
    }
    // 0x100003ea8
    return 0;
}

// Address range: 0x100003eb8 - 0x100003ec4
int64_t function_100003eb8(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003eb8
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ec4 - 0x100003ed0
void function_100003ec4(int32_t status) {
    // 0x100003ec4
    _exit(status);
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t * function_100003ed0(int32_t size) {
    // 0x100003ed0
    return _malloc(size);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * format, ...) {
    // 0x100003edc
    return _printf(format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * s) {
    // 0x100003ee8
    return _strlen(s);
}

// Address range: 0x100003ef4 - 0x100003f00
char * function_100003ef4(char * s, char * delim) {
    // 0x100003ef4
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

