//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038c0(void);
int64_t function_100003e4c(int64_t a1);
int64_t function_100003e58(int64_t * a1, int64_t a2, int64_t a3);
void function_100003e64(int64_t * ptr);
int64_t * function_100003e70(int32_t size);
int32_t function_100003e7c(char * format, ...);
char * function_100003e88(char * s, int32_t c);
int32_t function_100003e94(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003ea0; // 0x100008000
char * g2 = "\xbb>"; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t * a1, int64_t a2, int64_t a3);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038c0 - 0x100003d60
int64_t function_1000038c0(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000038d4
    int64_t v2; // 0x1000038c0
    int32_t v3 = _strlen((char *)v2); // 0x1000038f0
    int64_t v4; // bp-51, 0x1000038c0
    ___strcpy_chk(&v4, g1, 27);
    int64_t v5 = (int64_t)g2; // 0x100003918
    int64_t v6; // bp-78, 0x1000038c0
    int64_t v7 = ___strcpy_chk(&v6, v5, 27); // 0x100003940
    int64_t v8; // 0x1000038c0
    int32_t v9; // 0x1000038c0
    int64_t v10; // 0x1000038c0
    int64_t v11; // 0x1000038c0
    int64_t v12; // 0x1000038c0
    if (v3 != 0) {
        int64_t v13 = &v4;
        int64_t v14 = &v6;
        int32_t v15; // bp-105, 0x1000038c0
        v10 = &v15;
        v11 = v10 - 1;
        v9 = 0;
        v12 = v5;
        while (true) {
          lab_0x100003948:
            // 0x100003948
            if ((int32_t)v2 != 0) {
                // 0x10000395c
                _printf("%s  %s\n", (char *)v12, (char *)27);
            }
            int64_t v16 = v9;
            int32_t v17 = (int32_t)*(char *)(v2 + v16);
            int64_t v18; // 0x1000038c0
            int64_t v19; // 0x1000038c0
            if ((int32_t)v2 == 0) {
                int64_t v20 = (int64_t)_strchr((char *)&v6, v17); // 0x1000039a8
                int64_t v21 = v20 - v14; // 0x1000039b0
                *(char *)(v2 + v16) = *(char *)((0x100000000 * v21 >> 32) + v13);
                v18 = v21;
                v19 = v20;
            } else {
                int64_t v22 = (int64_t)_strchr((char *)&v4, v17); // 0x1000039f0
                int64_t v23 = v22 - v13; // 0x1000039f8
                *(char *)(v2 + v16) = *(char *)((0x100000000 * v23 >> 32) + v14);
                v18 = v23;
                v19 = v22;
            }
            // 0x100003a24
            v7 = v19;
            if ((int64_t)v3 - 1 == v16) {
                // break -> 0x100003d30
                break;
            }
            int32_t v24 = v18;
            int32_t v25 = v24; // 0x100003a5c
            if (v24 < 26 != (25 - v24 & v24) < 0) {
                int32_t v26 = v25;
                char v27 = *(char *)((int64_t)v26 + v13); // 0x100003a70
                *(char *)((int64_t)(v26 - v24) + v10) = v27;
                int32_t v28 = v26 + 1; // 0x100003a94
                while (v26 < 25 != (24 - v26 & v28) < 0) {
                    // 0x100003a64
                    v26 = v28;
                    v27 = *(char *)((int64_t)v26 + v13);
                    *(char *)((int64_t)(v26 - v24) + v10) = v27;
                    v28 = v26 + 1;
                }
            }
            int32_t v29 = -v24;
            if (v29 < 0 != (v29 & v24) < 0) {
                int32_t v30 = 0; // 0x100003af8
                char v31 = *(char *)((int64_t)v30 + v13); // 0x100003acc
                *(char *)((int64_t)(26 - v24 + v30) + v10) = v31;
                v30++;
                while (v30 - v24 < 0 != ((v30 - v24 ^ v30) & (v30 ^ v24)) < 0) {
                    // 0x100003ac0
                    v31 = *(char *)((int64_t)v30 + v13);
                    *(char *)((int64_t)(26 - v24 + v30) + v10) = v31;
                    v30++;
                }
            }
            int64_t v32 = 2;
            *(char *)(v11 + v32) = *(char *)(v32 + v10);
            int64_t v33 = v32 + 1;
            while (v33 != 14) {
                // 0x100003b2c
                v32 = v33;
                *(char *)(v11 + v32) = *(char *)(v32 + v10);
                v33 = v32 + 1;
            }
            // 0x100003b64
            ___strcpy_chk(&v4, v10, 27);
            int32_t v34 = v24; // 0x100003b94
            if (v24 < 26 != (25 - v24 & v24) < 0) {
                int32_t v35 = v34;
                char v36 = *(char *)((int64_t)v35 + v14); // 0x100003ba8
                *(char *)((int64_t)(v35 - v24) + v10) = v36;
                int32_t v37 = v35 + 1; // 0x100003bcc
                while (v35 < 25 != (24 - v35 & v37) < 0) {
                    // 0x100003b9c
                    v35 = v37;
                    v36 = *(char *)((int64_t)v35 + v14);
                    *(char *)((int64_t)(v35 - v24) + v10) = v36;
                    v37 = v35 + 1;
                }
            }
            if (v29 < 0 != (v29 & v24) < 0) {
                int32_t v38 = 0; // 0x100003c30
                char v39 = *(char *)((int64_t)v38 + v14); // 0x100003c04
                *(char *)((int64_t)(26 - v24 + v38) + v10) = v39;
                v38++;
                while (v38 - v24 < 0 != ((v38 - v24 ^ v38) & (v38 ^ v24)) < 0) {
                    // 0x100003bf8
                    v39 = *(char *)((int64_t)v38 + v14);
                    *(char *)((int64_t)(26 - v24 + v38) + v10) = v39;
                    v38++;
                }
            }
            int64_t v40 = 1;
            while (true) {
                int64_t v41 = v40;
                *(char *)(v11 + v41) = *(char *)(v41 + v10);
                v40 = v41 + 1;
                v8 = 3;
                if (v40 == 26) {
                    goto lab_0x100003ccc;
                }
            }
            goto lab_0x100003d04;
        }
    }
  lab_0x100003d30:;
    int64_t result = v7; // 0x100003d48
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d50
        result = ___stack_chk_fail(v7);
    }
    // 0x100003d54
    return result;
  lab_0x100003ccc:;
    int64_t v42 = v8;
    *(char *)(v11 + v42) = *(char *)(v42 + v10);
    int64_t v43 = v42 + 1;
    v8 = v43;
    if (v43 == 14) {
        goto lab_0x100003d04;
    } else {
        goto lab_0x100003ccc;
    }
  lab_0x100003d04:;
    int64_t v44 = ___strcpy_chk(&v6, v10, 27); // 0x100003d18
    int32_t v45 = v9 + 1; // 0x100003d24
    v9 = v45;
    v12 = v10;
    v7 = v44;
    if (v3 <= v45) {
        // break -> 0x100003d30
        goto lab_0x100003d30;
    }
    goto lab_0x100003948;
}

// Address range: 0x100003d60 - 0x100003e4c
int64_t entry_point(void) {
    int64_t * v1 = _malloc(_strlen("WELLDONEISBETTERTHANWELLSAID") + 1); // 0x100003d90
    int64_t * v2 = _malloc(_strlen("WELLDONEISBETTERTHANWELLSAID") + 1); // 0x100003da4
    int64_t v3; // 0x100003d60
    _printf("The original plaintext is : %s\n", (char *)v3);
    _printf("\nThe left and right alphabets after each permutation during encryption are :\n\n");
    function_1000038c0();
    _printf("\nThe ciphertext is : %s\n", v1);
    function_1000038c0();
    _printf("\nThe recovered plaintext is : %s\n", v2);
    _free(v1);
    _free(v2);
    return 0;
}

// Address range: 0x100003e4c - 0x100003e58
int64_t function_100003e4c(int64_t a1) {
    // 0x100003e4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e58 - 0x100003e64
int64_t function_100003e58(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003e58
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e64 - 0x100003e70
void function_100003e64(int64_t * ptr) {
    // 0x100003e64
    _free(ptr);
}

// Address range: 0x100003e70 - 0x100003e7c
int64_t * function_100003e70(int32_t size) {
    // 0x100003e70
    return _malloc(size);
}

// Address range: 0x100003e7c - 0x100003e88
int32_t function_100003e7c(char * format, ...) {
    // 0x100003e7c
    return _printf(format);
}

// Address range: 0x100003e88 - 0x100003e94
char * function_100003e88(char * s, int32_t c) {
    // 0x100003e88
    return _strchr(s, c);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(char * s) {
    // 0x100003e94
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

