//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003454(void);
int64_t function_1000035f4(void);
int64_t function_100003810(void);
int64_t function_100003a4c(void);
int64_t function_100003bdc(void);
int64_t function_100003ec4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ed0(int64_t a1);
void function_100003edc(int32_t status);
int32_t function_100003ee8(struct _IO_FILE * stream);
int32_t function_100003ef4(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f00(char * filename, char * modes);
int32_t function_100003f0c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f18(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_100003f24(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f30(int32_t size);
void function_100003f3c(char * s);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(int32_t c);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000
char * g2 = "\x01\a\v\r\x11\x13\x17\x1d"; // 0x10000801e
int64_t g3 = 0x100000cfeedfacf; // 0x100008028

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fflush(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003454 - 0x1000035f4
int64_t function_100003454(void) {
    int64_t * v1 = _malloc(0x8888889); // 0x100003474
    g3 = (int64_t)v1;
    if (v1 == NULL) {
        // 0x100003498
        _perror("malloc");
        _exit(1);
        // UNREACHABLE
    }
    struct _IO_FILE * v2 = _fopen("primebits", "r"); // 0x1000034bc
    if (v2 != NULL) {
        // 0x1000034d8
        _fread((int64_t *)g3, 1, 0x8888889, v2);
        // 0x1000035e8
        return _fclose(v2);
    }
    // 0x100003500
    ___memset_chk(g3, 255, 0x8888889, -1);
    int32_t v3 = 4;
    uint32_t v4 = 7;
    int32_t v5 = v3; // 0x10000354c
    if (v4 != v3 && v4 >= v3) {
        // 0x100003554
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004018, "sieve %u\n", 0x8888889);
        v5 = 2 * v3;
    }
    // 0x10000358c
    function_1000035f4();
    int32_t v6 = function_100003810(); // 0x1000035a0
    while (v6 < 0x10000) {
        // 0x10000353c
        v3 = v5;
        v4 = v6;
        v5 = v3;
        if (v4 != v3 && v4 >= v3) {
            // 0x100003554
            _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004018, "sieve %u\n", 0x8888889);
            v5 = 2 * v3;
        }
        // 0x10000358c
        function_1000035f4();
        v6 = function_100003810();
    }
    struct _IO_FILE * v7 = _fopen("primebits", "w"); // 0x1000035b8
    _fwrite((int64_t *)g3, 1, 0x8888889, v7);
    // 0x1000035e8
    return _fclose(v7);
}

// Address range: 0x1000035f4 - 0x100003810
int64_t function_1000035f4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003608
    int64_t v2; // bp-32, 0x1000035f4
    int64_t v3 = &v2;
    int64_t v4; // bp-96, 0x1000035f4
    int64_t v5 = &v4;
    int64_t v6 = 0;
    unsigned char v7 = *(char *)(v6 + (int64_t)&g2); // 0x10000363c
    int64_t v8; // 0x1000035f4
    int32_t v9 = (int32_t)v7 * (int32_t)v8; // 0x100003644
    char v10 = *(char *)((int64_t)(v9 % 30) + (int64_t)&g1); // 0x100003668
    *(char *)(v6 + v3) = -1 - v10;
    *(int64_t *)(8 * v6 + v5) = (int64_t)(v9 / 30);
    v6++;
    int64_t v11 = 7; // 0x100003628
    while (v6 != 8) {
        // 0x100003630
        v7 = *(char *)(v6 + (int64_t)&g2);
        v9 = (int32_t)v7 * (int32_t)v8;
        v10 = *(char *)((int64_t)(v9 % 30) + (int64_t)&g1);
        *(char *)(v6 + v3) = -1 - v10;
        *(int64_t *)(8 * v6 + v5) = (int64_t)(v9 / 30);
        v6++;
        v11 = 7;
    }
    int64_t v12 = 8 * v11 + v5;
    int64_t * v13 = (int64_t *)v12; // 0x1000036ec
    *v13 = *v13 - *(int64_t *)(v12 - 8);
    int64_t v14 = v11 - 1;
    v11 = v14;
    while (v14 != 0) {
        // 0x1000036d4
        v12 = 8 * v11 + v5;
        v13 = (int64_t *)v12;
        *v13 = *v13 - *(int64_t *)(v12 - 8);
        v14 = v11 - 1;
        v11 = v14;
    }
    int64_t v15 = v8 & 0xffffffff; // 0x10000370c
    v4 = v15;
    int64_t v16 = v15; // 0x100003744
    for (int64_t i = 1; i < 8; i++) {
        // 0x100003734
        v16 -= *(int64_t *)(8 * i + v5);
        v4 = v16;
    }
    int32_t v17 = 1; // 0x100003780
    int32_t v18; // 0x1000035f4
    if (v18 < 0x8888889) {
        int32_t v19; // 0x1000035f4
        char * v20 = (char *)(g3 + (int64_t)v19); // 0x1000037a8
        *v20 = *v20 & *(char *)((int64_t)v17 | v3);
        v17 = (v17 + 1) % 8;
        int64_t v21 = *(int64_t *)((int64_t)(8 * v17) + v5); // 0x1000037cc
        int32_t v22 = v19 + (int32_t)v21; // 0x1000037d8
        v19 = v22;
        while (v22 < 0x8888889) {
            // 0x100003788
            v20 = (char *)(g3 + (int64_t)v19);
            *v20 = *v20 & *(char *)((int64_t)v17 | v3);
            v17 = (v17 + 1) % 8;
            v21 = *(int64_t *)((int64_t)(8 * v17) + v5);
            v22 = v19 + (int32_t)v21;
            v19 = v22;
        }
    }
    // 0x1000037e0
    int64_t result; // 0x1000035f4
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003800
        result = ___stack_chk_fail(v8);
    }
    // 0x100003804
    return result;
}

// Address range: 0x100003810 - 0x100003a4c
int64_t function_100003810(void) {
    // 0x100003810
    int64_t v1; // 0x100003810
    uint32_t v2 = (int32_t)v1; // 0x100003814
    if (v2 == 5 || v2 < 5) {
        // 0x1000039d0
        switch (v2) {
            case 2: {
                // 0x100003a40
                return 3;
            }
            case 3: {
                // 0x100003a40
                return 5;
            }
        }
        // 0x100003a40
        return v2 == 5 ? 7 : 2;
    }
    char v3 = *(char *)((int64_t)(v2 % 30) + (int64_t)&g1); // 0x100003858
    int32_t v4 = 2 * v3; // 0x100003860
    int32_t v5 = v4 & 254;
    int32_t v6 = 0; // 0x100003884
    int32_t v7 = 0; // 0x100003884
    if (v5 != 0) {
        v7 = 0x1000000 * v7 + 0x1000000 >> 24;
        int32_t v8 = 1 << v7 % 256; // 0x100003874
        int32_t v9 = v8 - v5; // 0x10000387c
        v6 = v7;
        while (v9 < 0 != (v8 & -v9) < 0) {
            // 0x100003890
            v7 = 0x1000000 * v7 + 0x1000000 >> 24;
            v8 = 1 << v7 % 256;
            v9 = v8 - v5;
            v6 = v7;
        }
    }
    int64_t v10 = v2 / 30; // 0x100003838
    int64_t v11 = v10; // 0x1000038ec
    int32_t v12 = v4; // 0x1000038ec
    int32_t v13 = v6; // 0x1000038ec
    int64_t v14 = v10; // 0x1000038ec
    if (v5 - 1 >= (int32_t)*(char *)(g3 + v10)) {
        while (v11 < 0x8888888 != (v11 & 0x8888887 - v11) < 0) {
            // 0x1000038f4
            v11++;
            // 0x1000038a4
            v12 = 1;
            v13 = 0;
            v14 = v11;
            if (*(char *)(v11 + g3) != 0) {
                goto lab_0x100003930;
            }
        }
        // 0x100003a40
        return 0;
    }
  lab_0x100003930:;
    int64_t v15 = v14;
    if (v15 < 0x8888889 == (0x8888888 - v15 & v15) < 0) {
        // 0x100003a40
        return 0;
    }
    int32_t v16 = (int32_t)*(char *)(v15 + g3);
    unsigned char v17; // 0x1000039b8
    if ((v12 & v16) != 0) {
        // 0x10000399c
        v17 = *(char *)((int64_t)(v13 % 256) + (int64_t)&g2);
        // 0x100003a40
        return 30 * v15 + (int64_t)v17 & 0xffffffff;
    }
    int32_t v18 = 0x1000000 * v13 + 0x1000000 >> 24; // 0x100003988
    int32_t v19 = 0x2000000 * v12 >> 24; // 0x100003994
    int32_t v20 = v18; // 0x100003978
    int32_t v21 = v19; // 0x100003978
    while ((v19 & v16) == 0) {
        // 0x100003980
        v18 = 0x1000000 * v20 + 0x1000000 >> 24;
        v19 = 0x2000000 * v21 >> 24;
        v20 = v18;
        v21 = v19;
    }
    // 0x10000399c
    v17 = *(char *)((int64_t)(v18 % 256) + (int64_t)&g2);
    // 0x100003a40
    return 30 * v15 + (int64_t)v17 & 0xffffffff;
}

// Address range: 0x100003a4c - 0x100003bdc
int64_t function_100003a4c(void) {
    // 0x100003a4c
    int64_t v1; // 0x100003a4c
    uint64_t v2 = v1;
    if (v2 == 5 || v2 < 5) {
        // 0x100003b70
        return v2 == 5 | (v2 & -2) == 2;
    }
    // 0x100003a70
    if (v2 < 0xffffffff) {
        uint32_t v3 = (int32_t)v2;
        char v4 = *(char *)(g3 + (int64_t)(v3 / 30)); // 0x100003aa0
        char v5 = *(char *)((int64_t)(v3 % 30) + (int64_t)&g1); // 0x100003abc
        // 0x100003bcc
        return v5 & v4;
    }
    uint64_t v6 = 2;
    uint64_t v7 = v6 * v6; // 0x100003afc
    int64_t result = 1; // 0x100003b18
    while (v7 == v2 || v7 < v2) {
        // 0x100003b20
        result = 0;
        if (v2 % v6 == 0) {
            // break -> 0x100003bcc
            break;
        }
        int64_t v8 = function_100003810(); // 0x100003b58
        result = 1;
        if ((int32_t)v8 == 0) {
            // break -> 0x100003bcc
            break;
        }
        v6 = v8 & 0xffffffff;
        v7 = v6 * v6;
        result = 1;
    }
    // 0x100003bcc
    return result;
}

// Address range: 0x100003bdc - 0x100003d38
int64_t function_100003bdc(void) {
    // 0x100003bdc
    int64_t v1; // 0x100003bdc
    uint64_t v2 = v1;
    if (v2 >= 0xffffffff != v2 != 0xffffffff) {
        // 0x100003c10
        if ((int32_t)function_100003a4c() != 0) {
            // 0x100003d28
            return 1;
        }
    }
    int32_t v3 = 0;
    int64_t v4 = function_100003810(); // 0x100003c68
    int64_t v5; // 0x100003bdc
    int64_t v6 = v5; // 0x100003c78
    int32_t v7 = v3; // 0x100003c78
    while ((int32_t)v4 != 0) {
        uint64_t v8 = v4 & 0xffffffff;
        int64_t v9 = v5; // 0x100003ca8
        int32_t v10 = v3; // 0x100003ca8
        int32_t v11 = v3; // 0x100003ca8
        int64_t v12 = v5; // 0x100003ca8
        if (v5 % v8 == 0) {
            int64_t v13 = v12 / v8; // 0x100003cbc
            int32_t v14 = v11 + 1; // 0x100003cd4
            *(int64_t *)(8 * (int64_t)v11 + v1) = v8;
            v9 = v13;
            v10 = v14;
            v11 = v14;
            v12 = v13;
            while (v13 % v8 == 0) {
                // 0x100003cb0
                v13 = v12 / v8;
                v14 = v11 + 1;
                *(int64_t *)(8 * (int64_t)v11 + v1) = v8;
                v9 = v13;
                v10 = v14;
                v11 = v14;
                v12 = v13;
            }
        }
        // 0x100003c44
        v3 = v10;
        v5 = v9;
        v6 = v9;
        v7 = v3;
        if (v9 < v8 * v8) {
            // break -> 0x100003ce8
            break;
        }
        v4 = function_100003810();
        v6 = v5;
        v7 = v3;
    }
    int64_t v15 = v6;
    int32_t result = v7; // 0x100003cf4
    if (v15 != 1 && v15 != 0) {
        // 0x100003cfc
        *(int64_t *)(8 * (int64_t)v7 + v1) = v15;
        result = v7 + 1;
    }
    // 0x100003d28
    return result;
}

// Address range: 0x100003d38 - 0x100003ec4
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d50
    function_100003454();
    int64_t v2; // bp-536, 0x100003d38
    int64_t v3 = &v2;
    int32_t v4 = 1; // 0x100003e80
    int64_t v5; // 0x100003d38
    int64_t v6; // 0x100003d38
    _printf("2^%u - 1 = %llu", (int32_t)v6, v5);
    _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004020);
    int32_t v7 = function_100003bdc(); // 0x100003ddc
    int32_t v8 = v7 - 1; // 0x100003de0
    int32_t v9 = -v7;
    int32_t v10; // 0x100003d38
    int32_t v11; // 0x100003e60
    int32_t v12; // 0x100003e00
    if (v9 < 0 != (v7 & v9) < 0 && v8 != 0 && v8 < 0 == (v7 & v9) < 0) {
        _printf(" %c %llu", (char)v3, v5);
        v11 = 1;
        v12 = v11 - v7;
        v10 = v11;
        while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v7)) < 0) {
            // 0x100003e10
            _printf(" %c %llu", (char)v3, v5);
            v11 = v10 + 1;
            v12 = v11 - v7;
            v10 = v11;
        }
    }
    int32_t v13 = _putchar(10); // 0x100003e74
    v4++;
    while (v4 != 64) {
        // 0x100003d84
        _printf("2^%u - 1 = %llu", (int32_t)v3, v5);
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004020);
        v7 = function_100003bdc();
        v8 = v7 - 1;
        v9 = -v7;
        if (v9 < 0 != (v7 & v9) < 0 && v8 != 0 && v8 < 0 == (v7 & v9) < 0) {
            _printf(" %c %llu", (char)v3, v5);
            v11 = 1;
            v12 = v11 - v7;
            v10 = v11;
            while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v7)) < 0) {
                // 0x100003e10
                _printf(" %c %llu", (char)v3, v5);
                v11 = v10 + 1;
                v12 = v11 - v7;
                v10 = v11;
            }
        }
        // 0x100003e70
        v13 = _putchar(10);
        v4++;
    }
    // 0x100003e8c
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003eac
        ___stack_chk_fail((int64_t)v13);
    }
    // 0x100003eb0
    return 0;
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t function_100003ec4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ec4
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t function_100003ed0(int64_t a1) {
    // 0x100003ed0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(int32_t status) {
    // 0x100003edc
    _exit(status);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(struct _IO_FILE * stream) {
    // 0x100003ee8
    return _fclose(stream);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(struct _IO_FILE * stream) {
    // 0x100003ef4
    return _fflush(stream);
}

// Address range: 0x100003f00 - 0x100003f0c
struct _IO_FILE * function_100003f00(char * filename, char * modes) {
    // 0x100003f00
    return _fopen(filename, modes);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f0c
    return _fprintf(stream, format);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f18
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f24
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t * function_100003f30(int32_t size) {
    // 0x100003f30
    return _malloc(size);
}

// Address range: 0x100003f3c - 0x100003f48
void function_100003f3c(char * s) {
    // 0x100003f3c
    _perror(s);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t c) {
    // 0x100003f54
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 19

