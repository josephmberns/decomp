//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000319c(void);
int64_t function_1000032ec(void);
int64_t function_100003388(void);
int64_t function_10000346c(void);
int64_t function_1000034b0(void);
int64_t function_100003500(void);
int64_t function_100003650(void);
int64_t function_100003958(void);
int64_t function_100003b40(void);
void function_100003da0(int32_t status, int32_t errnum, char * format, ...);
int64_t function_100003dac(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003db8(int64_t a1);
int32_t function_100003dc4(struct _IO_FILE * stream);
char * function_100003dd0(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003ddc(char * filename, char * modes);
int32_t function_100003de8(struct _IO_FILE * stream, char * format, ...);
void function_100003df4(int64_t * ptr);
int32_t function_100003e00(int32_t c);
int64_t * function_100003e0c(int32_t size);
int32_t function_100003e18(char * format, ...);
char * function_100003e24(char * s);
char * function_100003e30(int32_t errnum);
int32_t function_100003e3c(char * s);
char * function_100003e48(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void ___error(int32_t a1, int32_t a2, char * a3, ...);
int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x10000319c - 0x1000032ec
int64_t function_10000319c(void) {
    // 0x10000319c
    int64_t v1; // 0x10000319c
    int32_t v2 = _strlen((char *)v1); // 0x1000031b4
    int64_t v3 = v2; // 0x1000031b4
    int64_t v4 = v3; // 0x1000031b4
    int32_t v5 = v2 - 1;
    int32_t result; // 0x10000319c
    if (v5 >= 0) {
        int64_t v6 = v5; // 0x10000319c
        int32_t v7 = v5;
        int32_t v8 = _isspace((int32_t)*(char *)(v3 + v6)); // 0x1000031fc
        int64_t v9 = v8; // 0x1000031fc
        v4 = v9;
        int32_t v10; // 0x10000319c
        result = v10;
        while (v8 != 0) {
            // 0x10000321c
            *(char *)(v6 + v9) = 0;
            int32_t v11 = v10 + 1; // 0x100003234
            v7--;
            result = v11;
            if (v7 < 0) {
                // break -> 0x100003254
                break;
            }
            // 0x10000321c
            v6--;
            v10 = v11;
            v8 = _isspace((int32_t)*(char *)(v4 + v6));
            v9 = v8;
            v4 = v9;
            result = v10;
        }
    }
    int32_t v12 = -v2; // 0x10000325c
    if (v12 < 0 == (v2 & v12) < 0) {
        // 0x1000032dc
        return result;
    }
    int32_t v13 = 0; // 0x1000032d0
    int32_t result2 = result; // 0x1000032c4
    int32_t v14 = _isspace((int32_t)*(char *)&v4); // 0x100003280
    int64_t v15 = v14; // 0x100003280
    v4 = v15;
    while (v14 != 0) {
        // 0x1000032a0
        *(char *)v15 = 0;
        *(int64_t *)v1 = v4 + 1;
        result2++;
        v13++;
        int32_t v16 = v13 - v2; // 0x10000325c
        if (v16 < 0 == ((v16 ^ v13) & (v13 ^ v2)) < 0) {
            // break -> 0x1000032dc
            break;
        }
        v14 = _isspace((int32_t)*(char *)&v4);
        v15 = v14;
        v4 = v15;
    }
    // 0x1000032dc
    return result2;
}

// Address range: 0x1000032ec - 0x100003388
int64_t function_1000032ec(void) {
    // 0x1000032ec
    int64_t v1; // 0x1000032ec
    if (v1 == 0) {
        // 0x100003378
        return 0;
    }
    int64_t v2 = *(int64_t *)(v1 + 16); // 0x10000331c
    int64_t v3; // 0x1000032ec
    if (v2 != 0) {
        // 0x100003330
        _free((int64_t *)v2);
        v3 = &g1;
    }
    // 0x100003368
    _free((int64_t *)v3);
    _free((int64_t *)v1);
    // 0x100003378
    return 0;
}

// Address range: 0x100003388 - 0x10000346c
int64_t function_100003388(void) {
    int64_t * v1 = _malloc(24); // 0x1000033a0
    int64_t v2 = (int64_t)v1; // 0x1000033a0
    int64_t v3; // 0x100003388
    *(int32_t *)(v2 + 8) = (int32_t)v3;
    *(int32_t *)(v2 + 12) = (int32_t)v3;
    *v1 = (int64_t)_strdup(",");
    int64_t v4 = (8 * v3 & 0x7fffffff8) * (v3 & 0xffffffff); // 0x1000033e8
    int64_t * v5 = _malloc((int32_t)v4); // 0x1000033ec
    int64_t v6 = (int64_t)v5; // 0x1000033ec
    *(int64_t *)(v2 + 16) = v6;
    int64_t result; // 0x100003388
    if (v5 == NULL) {
        // 0x10000344c
        function_1000032ec();
        result = 0;
    } else {
        // 0x100003414
        ___memset_chk(v6, 0, v4, -1);
        result = v2;
    }
    // 0x10000345c
    return result;
}

// Address range: 0x10000346c - 0x1000034b0
int64_t function_10000346c(void) {
    // 0x10000346c
    int64_t v1; // 0x10000346c
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x100003488
    int64_t v3 = *(int64_t *)(v1 + 16); // 0x10000349c
    int64_t result = *(int64_t *)(8 * (int64_t)(v2 * (int32_t)v1 + (int32_t)v1) + v3); // 0x1000034a4
    return result;
}

// Address range: 0x1000034b0 - 0x100003500
int64_t function_1000034b0(void) {
    // 0x1000034b0
    return 0;
}

// Address range: 0x100003500 - 0x100003650
int64_t function_100003500(void) {
    // 0x100003500
    int64_t v1; // 0x100003500
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100003514
    if (*v2 == 0) {
        // 0x100003644
        return _printf("[Empty table]\n");
    }
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x10000352c
    if (*v3 == 0) {
        // 0x100003644
        return _printf("[Empty table]\n");
    }
    // 0x100003550
    _printf("\n[Table cols=%d rows=%d]\n", v1, v1);
    for (int32_t i = 0; i < *v2; i++) {
        // 0x1000035a4
        _printf("[|");
        if (*v3 != 0) {
            function_10000346c();
            _printf("%s\t|", NULL);
            int64_t v4 = 1; // 0x100003608
            int64_t v5 = v4 & 0xffffffff;
            int64_t v6 = v5; // 0x1000035cc
            char * v7 = (char *)v5; // 0x1000035cc
            while (*v3 > (int32_t)v4) {
                // 0x1000035d4
                function_10000346c();
                _printf("%s\t|", v7);
                v4 = v6 + 1;
                v5 = v4 & 0xffffffff;
                v6 = v5;
                v7 = (char *)v5;
            }
        }
        // 0x100003614
        _printf("]\n");
    }
    // 0x100003644
    return _printf("\n");
}

// Address range: 0x100003650 - 0x100003958
int64_t function_100003650(void) {
    // 0x100003650
    int64_t v1; // 0x100003650
    uint32_t v2 = (int32_t)v1; // 0x100003664
    int64_t v3 = function_100003388(); // 0x100003670
    if (v3 == 0) {
        char * v4 = (char *)v1; // 0x100003904
        ___error(0, v2, v4);
        ___error((int32_t)&g1, v2, v4);
        _strerror(g1);
        _printf("Unable to resize CSV table: error %d - %s\n", v1 & 0xffffffff, v4);
        // 0x100003948
        return 0xffffffff;
    }
    uint32_t v5 = (int32_t)v1; // 0x100003660
    int32_t * v6 = (int32_t *)(v3 + 8); // 0x100003698
    *v6 = v2;
    int32_t * v7 = (int32_t *)(v3 + 12); // 0x1000036a4
    *v7 = v5;
    int32_t * v8 = (int32_t *)(v1 + 12); // 0x1000036b0
    uint32_t v9 = *v8; // 0x1000036b0
    int32_t v10 = v9 == v5 | v9 > v5 ? v9 : v5;
    int32_t * v11 = (int32_t *)(v1 + 8); // 0x1000036f0
    int32_t v12; // 0x100003650
    int32_t v13; // 0x100003650
    uint32_t v14; // 0x100003650
    if (v10 != 0) {
        uint32_t v15 = *v11; // 0x1000036f0
        v12 = v15 == v2 | v15 > v2 ? v15 : v2;
        int32_t v16 = 0; // 0x1000038ac
        while (true) {
            uint32_t v17 = v16;
            v13 = 0;
            if (v12 != 0) {
                while (true) {
                  lab_0x100003768:
                    // 0x100003768
                    v14 = v13;
                    int32_t v18 = 0; // 0x100003784
                    if (v17 < *v8) {
                        // 0x10000378c
                        v18 = v14 < *v11;
                    }
                    int32_t v19 = v18;
                    if (v17 < *v7) {
                        // 0x1000037f4
                        if (v19 == 0 | v14 >= *v6) {
                            if (v19 == 0) {
                                goto lab_0x100003894;
                            } else {
                                // 0x100003868
                                _free((int64_t *)function_10000346c());
                                goto lab_0x100003894;
                            }
                        } else {
                            // 0x100003828
                            function_10000346c();
                            function_1000034b0();
                            goto lab_0x100003894;
                        }
                    } else {
                        if (v19 == 0) {
                            goto lab_0x100003894;
                        } else {
                            // 0x100003868
                            _free((int64_t *)function_10000346c());
                            goto lab_0x100003894;
                        }
                    }
                }
            }
          lab_0x1000038a8:
            // 0x1000038a8
            v16 = v17 + 1;
            if (v16 == v10) {
                // break -> 0x1000038b8
                break;
            }
        }
    }
    int64_t * v20 = (int64_t *)(v1 + 16); // 0x1000038bc
    _free((int64_t *)*v20);
    *v11 = v2;
    *v8 = v5;
    int64_t * v21 = (int64_t *)(v3 + 16); // 0x1000038e0
    *v20 = *v21;
    *v21 = 0;
    function_1000032ec();
    // 0x100003948
    return 0;
  lab_0x100003894:;
    int32_t v22 = v14 + 1; // 0x100003898
    v13 = v22;
    if (v22 == v12) {
        // break -> 0x1000038a8
        goto lab_0x1000038a8;
    }
    goto lab_0x100003768;
}

// Address range: 0x100003958 - 0x100003b40
int64_t function_100003958(void) {
    // 0x100003958
    int64_t v1; // 0x100003958
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x10000398c
    int64_t result; // 0x100003958
    int32_t v3; // 0x100003958
    if (v2 == NULL) {
        // 0x100003ad4
        _fclose(NULL);
        v3 = _printf("Unable to open %s for reading.", "r");
        result = 0xffffffff;
    } else {
        // 0x1000039b8
        int64_t v4; // bp-2080, 0x100003958
        char * v5 = _fgets((char *)&v4, 2048, v2); // 0x1000039c4
        int32_t v6 = 0; // 0x1000039d0
        int32_t v7 = 0; // 0x1000039d0
        int32_t v8 = 0; // 0x1000039d0
        if (v5 != NULL) {
            char * v9 = _strtok((char *)&v4, (char *)&v4); // 0x100003a00
            int32_t v10 = v6; // 0x100003a14
            char * v11 = v9; // 0x100003a14
            int32_t v12 = v6; // 0x100003a14
            int32_t v13; // 0x100003958
            uint32_t v14; // 0x100003958
            int32_t v15; // 0x100003958
            int32_t v16; // 0x100003a2c
            char * v17; // 0x100003a00
            if (v9 != NULL) {
                v14 = v12;
                function_10000319c();
                v16 = 1;
                v13 = v16 == v14 | v16 < v14 ? v14 : v16;
                function_100003650();
                _strdup(v11);
                function_1000034b0();
                v17 = _strtok(NULL, NULL);
                v10 = v13;
                v11 = v17;
                v15 = v16;
                while (v17 != NULL) {
                    // 0x100003a1c
                    v14 = v13;
                    function_10000319c();
                    v16 = v15 + 1;
                    v13 = v16 == v14 | v16 < v14 ? v14 : v16;
                    function_100003650();
                    _strdup(v11);
                    function_1000034b0();
                    v17 = _strtok(NULL, NULL);
                    v10 = v13;
                    v11 = v17;
                    v15 = v16;
                }
            }
            int32_t v18 = 1; // 0x1000039dc
            char * v19 = _fgets((char *)&v4, 2048, v2); // 0x1000039c4
            v6 = v10;
            int32_t v20 = v18; // 0x1000039d0
            v7 = v18;
            v8 = v10;
            while (v19 != NULL) {
                // 0x1000039d8
                v9 = _strtok((char *)&v4, (char *)&v4);
                v10 = v6;
                v11 = v9;
                v12 = v6;
                if (v9 != NULL) {
                    v14 = v12;
                    function_10000319c();
                    v16 = 1;
                    v13 = v16 == v14 | v16 < v14 ? v14 : v16;
                    function_100003650();
                    _strdup(v11);
                    function_1000034b0();
                    v17 = _strtok(NULL, NULL);
                    v10 = v13;
                    v11 = v17;
                    v15 = v16;
                    while (v17 != NULL) {
                        // 0x100003a1c
                        v14 = v13;
                        function_10000319c();
                        v16 = v15 + 1;
                        v13 = v16 == v14 | v16 < v14 ? v14 : v16;
                        function_100003650();
                        _strdup(v11);
                        function_1000034b0();
                        v17 = _strtok(NULL, NULL);
                        v10 = v13;
                        v11 = v17;
                        v15 = v16;
                    }
                }
                // 0x1000039b8
                v18 = v20 + 1;
                v19 = _fgets((char *)&v4, 2048, v2);
                v6 = v10;
                v20 = v18;
                v7 = v18;
                v8 = v10;
            }
        }
        int32_t v21 = _fclose(v2); // 0x100003ab0
        *(int32_t *)(v1 + 8) = v7;
        *(int32_t *)(v1 + 12) = v8;
        v3 = v21;
        result = 0;
    }
    int64_t v22 = *(int64_t *)0x100004018; // 0x100003b10
    if (*(int64_t *)v22 != *(int64_t *)*(int64_t *)0x100004018) {
        // 0x100003b28
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003b2c
    return result;
}

// Address range: 0x100003b40 - 0x100003c88
int64_t function_100003b40(void) {
    // 0x100003b40
    int64_t v1; // 0x100003b40
    struct _IO_FILE * v2 = _fopen((char *)v1, "w"); // 0x100003b60
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100003b78
    if (*v3 == 0) {
        // 0x100003c70
        _fclose(v2);
        return 0;
    }
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x100003b9c
    int64_t v5 = 0;
    if (*v4 != 0) {
        for (int32_t i = 0; i < *v4; i++) {
            // 0x100003bb0
            function_10000346c();
            _fprintf(v2, "%s%s", (char *)v5, (char *)v1);
        }
    }
    // 0x100003c4c
    _fprintf(v2, "\n");
    int64_t v6 = v5 + 1; // 0x100003c64
    while (*v3 > (int32_t)v6) {
        // 0x100003b94
        v5 = v6 & 0xffffffff;
        if (*v4 != 0) {
            for (int32_t i = 0; i < *v4; i++) {
                // 0x100003bb0
                function_10000346c();
                _fprintf(v2, "%s%s", (char *)v5, (char *)v1);
            }
        }
        // 0x100003c4c
        _fprintf(v2, "\n");
        v6 = v5 + 1;
    }
    // 0x100003c70
    _fclose(v2);
    return 0;
}

// Address range: 0x100003c88 - 0x100003da0
int64_t entry_point(void) {
    // 0x100003c88
    int64_t v1; // 0x100003c88
    _printf("%s\n%s\n\n", (char *)v1, (char *)v1);
    function_100003388();
    function_100003958();
    function_100003500();
    function_1000034b0();
    function_1000034b0();
    function_1000034b0();
    function_1000034b0();
    function_1000034b0();
    function_100003500();
    function_100003b40();
    function_1000032ec();
    return 0;
}

// Address range: 0x100003da0 - 0x100003dac
void function_100003da0(int32_t status, int32_t errnum, char * format, ...) {
    // 0x100003da0
    ___error(status, errnum, format);
}

// Address range: 0x100003dac - 0x100003db8
int64_t function_100003dac(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003dac
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003db8 - 0x100003dc4
int64_t function_100003db8(int64_t a1) {
    // 0x100003db8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003dc4 - 0x100003dd0
int32_t function_100003dc4(struct _IO_FILE * stream) {
    // 0x100003dc4
    return _fclose(stream);
}

// Address range: 0x100003dd0 - 0x100003ddc
char * function_100003dd0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003dd0
    return _fgets(s, n, stream);
}

// Address range: 0x100003ddc - 0x100003de8
struct _IO_FILE * function_100003ddc(char * filename, char * modes) {
    // 0x100003ddc
    return _fopen(filename, modes);
}

// Address range: 0x100003de8 - 0x100003df4
int32_t function_100003de8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003de8
    return _fprintf(stream, format);
}

// Address range: 0x100003df4 - 0x100003e00
void function_100003df4(int64_t * ptr) {
    // 0x100003df4
    _free(ptr);
}

// Address range: 0x100003e00 - 0x100003e0c
int32_t function_100003e00(int32_t c) {
    // 0x100003e00
    return _isspace(c);
}

// Address range: 0x100003e0c - 0x100003e18
int64_t * function_100003e0c(int32_t size) {
    // 0x100003e0c
    return _malloc(size);
}

// Address range: 0x100003e18 - 0x100003e24
int32_t function_100003e18(char * format, ...) {
    // 0x100003e18
    return _printf(format);
}

// Address range: 0x100003e24 - 0x100003e30
char * function_100003e24(char * s) {
    // 0x100003e24
    return _strdup(s);
}

// Address range: 0x100003e30 - 0x100003e3c
char * function_100003e30(int32_t errnum) {
    // 0x100003e30
    return _strerror(errnum);
}

// Address range: 0x100003e3c - 0x100003e48
int32_t function_100003e3c(char * s) {
    // 0x100003e3c
    return _strlen(s);
}

// Address range: 0x100003e48 - 0x100003e54
char * function_100003e48(char * s, char * delim) {
    // 0x100003e48
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 25

