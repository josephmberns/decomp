//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct termios {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char e4;
    char e5[1];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_1000027fc(void);
int64_t function_100002a40(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);
int64_t function_1000030dc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_1000036a8(void);
int64_t function_10000384c(void);
int64_t function_100003898(void);
int32_t function_100003e30(void);
int64_t * function_100003e3c(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003e48(int64_t * s, int32_t c, int32_t n);
int32_t function_100003e54(char * format, ...);
int32_t function_100003e60(void);
void function_100003e6c(int32_t seed);
int32_t function_100003e78(int32_t fd, struct termios * termios_p);
int32_t function_100003e84(int32_t fd, int32_t optional_actions, struct termios * termios_p);
int32_t function_100003e90(int32_t * timer);
int32_t function_100003e9c(int32_t useconds);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100003ea8
char * g2 = "\x1b[2J\x1b[HScore: %ld"; // 0x100003f2c
char * g3 = "\x1b[7m\x1b[%sm%*zd \x1b[0m|"; // 0x100003f4c
int64_t g4 = 0x100000cfeedfacf; // 0x100008060
int32_t g5 = 0; // 0x1000080a0
int64_t g6 = 0; // 0x1000080b0
int32_t g7 = 0; // 0x1000080b8
struct termios * g8 = NULL; // 0x1000080c0
int64_t g9 = 0; // 0x1000080d8
struct termios * g10 = (struct termios *)5; // 0x100008108
int32_t g11;

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _tcgetattr(int32_t a1, struct termios * a2);
int32_t _tcsetattr(int32_t a1, int32_t a2, struct termios * a3);
int32_t _time(int32_t * a1);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000027fc - 0x100002a40
int64_t function_1000027fc(void) {
    // 0x1000027fc
    _printf((char *)&g2);
    int64_t v1; // 0x1000027fc
    if (g6 != 0) {
        // 0x100002844
        _printf(" (+%ld)", (int32_t)v1);
    }
    // 0x100002868
    _printf("\n");
    for (int32_t i = 0; i < 25; i++) {
        // 0x100002890
        _printf("-");
    }
    // 0x1000028b0
    _printf("\n");
    int64_t v2 = 0;
    _printf("|");
    int64_t v3 = 4 * v2 + (int64_t)&g4; // 0x10000290c
    for (int64_t i = 0; i < 4; i++) {
        // 0x100002900
        if (*(int32_t *)(v3 + 16 * i) == 0) {
            // 0x100002990
            _printf("%*s |", v1, (char *)v1);
        } else {
            // 0x100002928
            _printf((char *)&g3);
        }
    }
    // 0x1000029cc
    _printf("\n");
    v2++;
    int32_t v4 = 0; // 0x1000028d0
    while (v2 != 4) {
        // 0x1000028d8
        _printf("|");
        v3 = 4 * v2 + (int64_t)&g4;
        for (int64_t i = 0; i < 4; i++) {
            // 0x100002900
            if (*(int32_t *)(v3 + 16 * i) == 0) {
                // 0x100002990
                _printf("%*s |", v1, (char *)v1);
            } else {
                // 0x100002928
                _printf((char *)&g3);
            }
        }
        // 0x1000029cc
        _printf("\n");
        v2++;
        v4 = 0;
    }
    _printf("-");
    int32_t v5 = v4 + 1; // 0x100002a1c
    v4 = v5;
    while (v5 != 25) {
        // 0x100002a08
        _printf("-");
        v5 = v4 + 1;
        v4 = v5;
    }
    // 0x100002a28
    return _printf("\n");
}

// Address range: 0x100002a40 - 0x1000030cc
int64_t function_100002a40(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8) {
    // 0x100002a40
    g6 = 0;
    int64_t result; // 0x100002a40
    return result;
}

// Address range: 0x1000030dc - 0x100003698
int64_t function_1000030dc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1000030dc
    int64_t result; // 0x1000030dc
    return result;
}

// Address range: 0x1000036a8 - 0x10000384c
int64_t function_1000036a8(void) {
    int32_t v1 = 0;
    int32_t v2 = -1;
    int32_t v3; // 0x1000036a8
    int64_t result; // 0x1000036a8
    int32_t v4; // 0x1000036a8
    int32_t v5; // 0x1000036a8
    int64_t v6; // 0x1000036f8
    int32_t v7; // 0x100003700
    while (true) {
        int32_t v8 = v1;
        v6 = 16 * (int64_t)v8 + (int64_t)&g4;
        v1 = v8 + 1;
        int64_t v9 = 16 * (int64_t)v1 + (int64_t)&g4;
        v4 = 0;
        while (true) {
          lab_0x1000036ec:
            // 0x1000036ec
            v5 = v4;
            int64_t v10 = 4 * (int64_t)v5; // 0x100003700
            v7 = *(int32_t *)(v10 + v6);
            int64_t v11 = *(int64_t *)(8 * (int64_t)v7 + (int64_t)&g1); // 0x10000370c
            result = 1;
            if (v11 == 2048) {
                return result;
            }
            if (v7 == 0) {
                goto lab_0x100003804;
            } else {
                // 0x100003754
                v3 = v2;
                if (v8 < 3 == (v1 & 2 - v8) < 0) {
                    goto lab_0x1000037ac;
                } else {
                    // 0x10000376c
                    if (v7 == *(int32_t *)(v9 + v10)) {
                        goto lab_0x100003804;
                    } else {
                        goto lab_0x1000037ac;
                    }
                }
            }
        }
      lab_0x100003824:
        // 0x100003824
        if (v8 < 3 == (v1 & 2 - v8) < 0) {
            // 0x100003834
            result = v2;
            return result;
        }
    }
  lab_0x100003840:
    // 0x100003840
    return result;
  lab_0x100003804:;
    int32_t v12 = v5 + 1; // 0x100003814
    int32_t v13 = 2 - v5 & v12; // 0x100003808
    int32_t v14 = v5 - 3; // 0x100003808
    int32_t v15 = v12; // 0x100003808
    int32_t v16 = 0; // 0x100003808
    goto lab_0x100003810;
  lab_0x100003810:
    // 0x100003810
    v2 = v16;
    v4 = v15;
    if (v14 < 0 == v13 < 0) {
        // break -> 0x100003824
        goto lab_0x100003824;
    }
    goto lab_0x1000036ec;
  lab_0x1000037ac:;
    int32_t v17 = v5 + 1;
    int32_t v18 = v5 - 3;
    int32_t v19 = v17 & 2 - v5;
    v13 = v19;
    v14 = v18;
    v15 = v17;
    v16 = v3;
    if (v18 < 0 == v19 < 0) {
        goto lab_0x100003810;
    } else {
        // 0x1000037c4
        v13 = v19;
        v14 = v18;
        v15 = v17;
        v16 = v3;
        if (v7 == *(int32_t *)(v6 + (int64_t)(4 * v5 + 4))) {
            goto lab_0x100003804;
        } else {
            goto lab_0x100003810;
        }
    }
}

// Address range: 0x10000384c - 0x100003898
int64_t function_10000384c(void) {
    // 0x10000384c
    g5 = 0;
    function_1000030dc((int64_t)&g4, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11);
    function_100002a40((int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11);
    function_1000030dc((int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11);
    return g5;
}

// Address range: 0x100003898 - 0x100003a08
int64_t function_100003898(void) {
    int32_t v1 = g7; // 0x1000038ac
    if (v1 < 16 == (15 - v1 & v1) < 0) {
        // 0x1000039fc
        int64_t result; // 0x100003898
        return result;
    }
    int32_t result2 = _rand(); // 0x1000038c4
    int32_t v2 = 0;
    uint64_t v3 = 0;
    int64_t v4 = 16 * v3 + (int64_t)&g4; // 0x100003934
    int32_t v5 = 0;
    int32_t v6 = 0;
    uint64_t v7 = 0;
    int32_t * v8 = (int32_t *)(v4 + 4 * v7);
    int32_t v9 = v5; // 0x100003948
    if (*v8 == 0) {
        if (v5 == result2 % (16 - g7)) {
            // break (via goto) -> 0x10000396c
            goto lab_0x10000396c;
        }
        // 0x1000039c4
        v9 = v5 + 1;
    }
    int64_t v10 = v7 + 1;
    int32_t v11 = v6 + 1; // 0x100003920
    while (v7 < 3 != (2 - v6 & (int32_t)v10) < 0) {
        // 0x100003928
        v5 = v9;
        v6 = v11;
        v7 = v10;
        v8 = (int32_t *)(v4 + 4 * v7);
        v9 = v5;
        if (*v8 == 0) {
            if (v5 == result2 % (16 - g7)) {
                // break (via goto) -> 0x10000396c
                goto lab_0x10000396c;
            }
            // 0x1000039c4
            v9 = v5 + 1;
        }
        // 0x1000039d8
        v10 = v7 + 1;
        v11 = v6 + 1;
    }
    int64_t v12 = v3 + 1;
    int32_t v13 = v2 + 1; // 0x100003904
    while (v3 < 3 != (2 - v2 & (int32_t)v12) < 0) {
        // 0x100003914
        v2 = v13;
        v3 = v12;
        v4 = 16 * v3 + (int64_t)&g4;
        v5 = v9;
        v6 = 0;
        v7 = 0;
        v8 = (int32_t *)(v4 + 4 * v7);
        v9 = v5;
        if (*v8 == 0) {
            if (v5 == result2 % (16 - g7)) {
                // break (via goto) -> 0x10000396c
                goto lab_0x10000396c;
            }
            // 0x1000039c4
            v9 = v5 + 1;
        }
        // 0x1000039d8
        v10 = v7 + 1;
        v11 = v6 + 1;
        while (v7 < 3 != (2 - v6 & (int32_t)v10) < 0) {
            // 0x100003928
            v5 = v9;
            v6 = v11;
            v7 = v10;
            v8 = (int32_t *)(v4 + 4 * v7);
            v9 = v5;
            if (*v8 == 0) {
                if (v5 == result2 % (16 - g7)) {
                    // break (via goto) -> 0x10000396c
                    goto lab_0x10000396c;
                }
                // 0x1000039c4
                v9 = v5 + 1;
            }
            // 0x1000039d8
            v10 = v7 + 1;
            v11 = v6 + 1;
        }
        // 0x1000039ec
        v12 = v3 + 1;
        v13 = v2 + 1;
    }
    // 0x1000039fc
    return result2;
  lab_0x10000396c:;
    int32_t result3 = _rand(); // 0x10000396c
    *v8 = result3 % 10 == 0 ? 2 : 1;
    g7++;
    // 0x1000039fc
    return result3;
}

// Address range: 0x100003a08 - 0x100003cac
int64_t entry_point(int64_t a1) {
    // 0x100003a08
    _tcgetattr(0, (struct termios *)&g10);
    _memcpy((int64_t *)&g8, (int64_t *)&g10, 72);
    g9 &= -265;
    _tcsetattr(0, 0, (struct termios *)&g8);
    _srand(_time(NULL));
    _memset(&g4, 0, 96);
    function_100003898();
    function_100003898();
    function_1000027fc();
    int32_t result = _getchar(); // 0x100003ab4
    while (result >= 119 == (result != 119)) {
        // 0x100003aa4
        result = _getchar();
    }
    // 0x100003ad8
    return result;
}

// Address range: 0x100003e30 - 0x100003e3c
int32_t function_100003e30(void) {
    // 0x100003e30
    return _getchar();
}

// Address range: 0x100003e3c - 0x100003e48
int64_t * function_100003e3c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e3c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003e48 - 0x100003e54
int64_t * function_100003e48(int64_t * s, int32_t c, int32_t n) {
    // 0x100003e48
    return _memset(s, c, n);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(char * format, ...) {
    // 0x100003e54
    return _printf(format);
}

// Address range: 0x100003e60 - 0x100003e6c
int32_t function_100003e60(void) {
    // 0x100003e60
    return _rand();
}

// Address range: 0x100003e6c - 0x100003e78
void function_100003e6c(int32_t seed) {
    // 0x100003e6c
    _srand(seed);
}

// Address range: 0x100003e78 - 0x100003e84
int32_t function_100003e78(int32_t fd, struct termios * termios_p) {
    // 0x100003e78
    return _tcgetattr(fd, termios_p);
}

// Address range: 0x100003e84 - 0x100003e90
int32_t function_100003e84(int32_t fd, int32_t optional_actions, struct termios * termios_p) {
    // 0x100003e84
    return _tcsetattr(fd, optional_actions, termios_p);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(int32_t * timer) {
    // 0x100003e90
    return _time(timer);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(int32_t useconds) {
    // 0x100003e9c
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

