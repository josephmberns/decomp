//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a28(void);
int64_t function_100003b54(void);
int64_t * function_100003ed8(int32_t nmemb, int32_t size);
int32_t function_100003ee4(void);
void function_100003ef0(int64_t * ptr);
int32_t function_100003efc(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _clock(void);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a28 - 0x100003b54
int64_t function_100003a28(void) {
    int32_t v1 = 0x270f; // 0x100003af4
    for (int32_t i = 9; i > -1; i--) {
        int32_t v2 = 9;
        int32_t v3 = 9;
        int32_t v4 = v2 + i + v3; // 0x100003aac
        int32_t v5 = 9;
        *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
        v1--;
        int32_t v6 = v5 - 1; // 0x100003acc
        int32_t v7 = v1; // 0x100003acc
        while (v5 != 0) {
            // 0x100003ad4
            v5 = v6;
            *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
            v1 = v7 - 1;
            v6 = v5 - 1;
            v7 = v1;
        }
        int32_t v8 = v3 - 1; // 0x100003a9c
        while (v3 != 0) {
            // 0x100003aa4
            v3 = v8;
            v4 = v2 + i + v3;
            v5 = 9;
            *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
            v1--;
            v6 = v5 - 1;
            v7 = v1;
            while (v5 != 0) {
                // 0x100003ad4
                v5 = v6;
                *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
                v1 = v7 - 1;
                v6 = v5 - 1;
                v7 = v1;
            }
            // 0x100003b14
            v8 = v3 - 1;
        }
        int32_t v9 = v2 - 1; // 0x100003a6c
        while (v2 != 0) {
            // 0x100003a74
            v2 = v9;
            v3 = 9;
            v4 = v2 + i + v3;
            v5 = 9;
            *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
            v1--;
            v6 = v5 - 1;
            v7 = v1;
            while (v5 != 0) {
                // 0x100003ad4
                v5 = v6;
                *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
                v1 = v7 - 1;
                v6 = v5 - 1;
                v7 = v1;
            }
            // 0x100003b14
            v8 = v3 - 1;
            while (v3 != 0) {
                // 0x100003aa4
                v3 = v8;
                v4 = v2 + i + v3;
                v5 = 9;
                *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
                v1--;
                v6 = v5 - 1;
                v7 = v1;
                while (v5 != 0) {
                    // 0x100003ad4
                    v5 = v6;
                    *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
                    v1 = v7 - 1;
                    v6 = v5 - 1;
                    v7 = v1;
                }
                // 0x100003b14
                v8 = v3 - 1;
            }
            // 0x100003b28
            v9 = v2 - 1;
        }
    }
    // 0x100003b4c
    int64_t result; // 0x100003a28
    return result;
}

// Address range: 0x100003b54 - 0x100003c6c
int64_t function_100003b54(void) {
    int64_t v1 = 0; // 0x100003c34
    int32_t v2 = 0;
    int32_t * v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1); // 0x100003ba8
    int32_t v4 = 0;
    int32_t v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1); // 0x100003bb0
    int64_t v6 = v1 + (int64_t)(v5 + *v3); // 0x100003b54
    int32_t v7 = 0;
    int32_t v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1); // 0x100003bf4
    int64_t result; // 0x100003b54
    *(char *)(v6 + result + (int64_t)v8) = 1;
    int32_t v9 = v7 + 1; // 0x100003c20
    v6++;
    while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
        // 0x100003be4
        v7 = v9;
        v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *(char *)(v6 + result + (int64_t)v8) = 1;
        v9 = v7 + 1;
        v6++;
    }
    // 0x100003c2c
    v1 += 0x2710;
    int32_t v10 = v4 + 1; // 0x100003c44
    while (v4 < 0x270f != (0x270e - v4 & v10) < 0) {
        // 0x100003b9c
        v4 = v10;
        v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1);
        v6 = v1 + (int64_t)(v5 + *v3);
        v7 = 0;
        v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *(char *)(v6 + result + (int64_t)v8) = 1;
        v9 = v7 + 1;
        v6++;
        while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
            // 0x100003be4
            v7 = v9;
            v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
            *(char *)(v6 + result + (int64_t)v8) = 1;
            v9 = v7 + 1;
            v6++;
        }
        // 0x100003c2c
        v1 += 0x2710;
        v10 = v4 + 1;
    }
    int32_t v11 = v2 + 1; // 0x100003c58
    while (v2 < 102 != (101 - v2 & v11) < 0) {
        // 0x100003b84
        v2 = v11;
        v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1);
        v4 = 0;
        v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1);
        v6 = v1 + (int64_t)(v5 + *v3);
        v7 = 0;
        v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *(char *)(v6 + result + (int64_t)v8) = 1;
        v9 = v7 + 1;
        v6++;
        while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
            // 0x100003be4
            v7 = v9;
            v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
            *(char *)(v6 + result + (int64_t)v8) = 1;
            v9 = v7 + 1;
            v6++;
        }
        // 0x100003c2c
        v1 += 0x2710;
        v10 = v4 + 1;
        while (v4 < 0x270f != (0x270e - v4 & v10) < 0) {
            // 0x100003b9c
            v4 = v10;
            v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1);
            v6 = v1 + (int64_t)(v5 + *v3);
            v7 = 0;
            v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
            *(char *)(v6 + result + (int64_t)v8) = 1;
            v9 = v7 + 1;
            v6++;
            while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
                // 0x100003be4
                v7 = v9;
                v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
                *(char *)(v6 + result + (int64_t)v8) = 1;
                v9 = v7 + 1;
                v6++;
            }
            // 0x100003c2c
            v1 += 0x2710;
            v10 = v4 + 1;
        }
        // 0x100003c54
        v11 = v2 + 1;
    }
    // 0x100003c64
    return result;
}

// Address range: 0x100003c6c - 0x100003ed8
int64_t entry_point(void) {
    // 0x100003c6c
    _clock();
    int64_t * v1 = _calloc(0x65ed8764, 1); // 0x100003ca4
    function_100003a28();
    function_100003b54();
    _clock();
    int128_t v2; // 0x100003c6c
    _printf("Sieving took %lf seconds.\n", (float64_t)(int64_t)v2);
    _printf("\nThe first 50 self numbers are:\n");
    if (v1 >= (int64_t *)-0x265ed8764) {
        // 0x100003e90
        _free(v1);
        _clock();
        _printf("\nOverall took %lf seconds.\n", (float64_t)(int64_t)v2);
        return 0;
    }
    int64_t v3 = (int64_t)v1;
    uint64_t v4 = v3 + 0x265ed8764; // 0x100003d14
    int64_t v5 = v3; // 0x100003d9c
    char * v6 = (char *)v1; // 0x100003c6c
    int64_t v7 = 0; // 0x100003d44
    while (true) {
        int64_t v8 = v7;
        v7 = v8;
        if (*v6 == 0) {
            // 0x100003d40
            v7 = v8 + 1;
            int64_t v9 = v8 - 49; // 0x100003d4c
            if (v9 != 0 && v9 < 0 == (v7 & 48 - v8) < 0) {
                // break -> 0x100003d80
                break;
            }
            // 0x100003d5c
            _printf("%ld ", 1);
        }
        // 0x100003d98
        v5++;
        v6 = (char *)v5;
        if (v4 <= v5) {
            goto lab_0x100003de0;
        }
    }
    // 0x100003d80
    _printf("\n\n     Index  Self number\n");
  lab_0x100003de0:;
    int64_t v10 = 1;
    int64_t v11 = 0;
    int64_t v12 = v10; // 0x100003df0
    int64_t v13 = v11; // 0x100003df0
    int64_t v14; // 0x100003dfc
    int64_t v15; // 0x100003e48
    int64_t v16; // 0x100003c6c
    if (*(char *)v3 == 0) {
        // 0x100003df8
        v14 = v11 + 1;
        v12 = v10;
        v13 = v14;
        if (v14 == v10) {
            // 0x100003e18
            _printf("%10lld  %11ld\n", 1, (int32_t)v16);
            v15 = 10 * v10;
            v12 = v15;
            v13 = v10;
            if (v15 == 0x2540be400) {
                // break -> 0x100003e90
                break;
            }
        }
    }
    int64_t v17 = v3 + 1; // 0x100003e84
    int64_t v18 = v17; // 0x100003dd8
    while (v4 > v17) {
        // 0x100003de0
        v10 = v12;
        v11 = v13;
        v12 = v10;
        v13 = v11;
        if (*(char *)v18 == 0) {
            // 0x100003df8
            v14 = v11 + 1;
            v12 = v10;
            v13 = v14;
            if (v14 == v10) {
                // 0x100003e18
                _printf("%10lld  %11ld\n", 1, (int32_t)v16);
                v15 = 10 * v10;
                v12 = v15;
                v13 = v10;
                if (v15 == 0x2540be400) {
                    // break -> 0x100003e90
                    break;
                }
            }
        }
        // 0x100003e80
        v17 = v18 + 1;
        v18 = v17;
    }
    // 0x100003e90
    _free(v1);
    _clock();
    _printf("\nOverall took %lf seconds.\n", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003ed8 - 0x100003ee4
int64_t * function_100003ed8(int32_t nmemb, int32_t size) {
    // 0x100003ed8
    return _calloc(nmemb, size);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(void) {
    // 0x100003ee4
    return _clock();
}

// Address range: 0x100003ef0 - 0x100003efc
void function_100003ef0(int64_t * ptr) {
    // 0x100003ef0
    _free(ptr);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(char * format, ...) {
    // 0x100003efc
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

