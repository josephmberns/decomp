//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002eb0(void);
int64_t function_100002f4c(void);
int64_t function_100002ff0(int64_t a1, int64_t a2);
int64_t function_1000031b4(void);
int64_t function_10000327c(void);
int64_t function_10000332c(void);
int64_t function_1000033e0(void);
int64_t function_100003424(void);
int64_t function_10000353c(void);
int64_t function_1000036e0(void);
int64_t function_100003794(void);
int64_t function_100003828(void);
int64_t function_100003920(void);
int64_t function_100003a08(void);
int64_t function_100003c88(void);
int64_t function_100003ccc(int64_t a1);
int64_t function_100003d84(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003d90(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003d9c(struct _IO_FILE * stream, char * format, ...);
void function_100003da8(int64_t * ptr);
int64_t * function_100003db4(int32_t size);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002eb0 - 0x100002f4c
int64_t function_100002eb0(void) {
    // 0x100002eb0
    int64_t v1; // 0x100002eb0
    int64_t v2 = v1;
    if (v2 == 0) {
        // 0x100002f40
        return 0;
    }
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x100002ee8
    int64_t result = ___memcpy_chk(*(int64_t *)(v2 + 24), *(int64_t *)(v2 + 16), 8 * v3, -1); // 0x100002ef4
    int64_t v4 = *(int64_t *)(v2 + 32);
    if (v4 == 0) {
        // 0x100002f40
        return result;
    }
    int64_t v5 = v4; // 0x100002f14
    int64_t result2 = function_100002eb0(); // 0x100002f24
    v5 += 8;
    while (v5 != 0) {
        // 0x100002f1c
        result2 = function_100002eb0();
        v5 += 8;
    }
    // 0x100002f40
    return result2;
}

// Address range: 0x100002f4c - 0x100002ff0
int64_t function_100002f4c(void) {
    // 0x100002f4c
    int64_t v1; // 0x100002f4c
    if (v1 == 0) {
        // 0x100002fe4
        return 0;
    }
    // 0x100002f70
    _free((int64_t *)*(int64_t *)(v1 + 16));
    _free((int64_t *)*(int64_t *)(v1 + 24));
    int64_t v2 = *(int64_t *)(v1 + 32); // 0x100002f8c
    if (v2 == 0) {
        // 0x100002fd8
        _free((int64_t *)v1);
        // 0x100002fe4
        return &g1;
    }
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x100002fb0
    function_100002f4c();
    _free((int64_t *)v2);
    while (v3 != 0) {
        int64_t v4 = v3;
        v3 = *(int64_t *)(v4 + 8);
        function_100002f4c();
        _free((int64_t *)v4);
    }
    // 0x100002fd8
    _free((int64_t *)v1);
    // 0x100002fe4
    return &g1;
}

// Address range: 0x100002ff0 - 0x1000031b4
int64_t function_100002ff0(int64_t a1, int64_t a2) {
    // 0x100002ff0
    int64_t v1; // 0x100002ff0
    int32_t v2 = v1; // 0x100003004
    int32_t v3 = 1 - v2; // 0x100003010
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x10000302c
        ___assert_rtn("ftroff_generator_output", "continued-fraction-arithmetic-g-matrix-ng-continued-fraction-n--2.c", 121, "1 <= max_terms");
    }
    // 0x100003050
    function_100002eb0();
    if (v2 != 0) {
        // 0x1000030a8
        return *(int64_t *)(v1 + 24);
    }
    // 0x10000308c
    _fprintf((struct _IO_FILE *)v1, ", ~ ... ~ ]");
    return function_100002eb0();
}

// Address range: 0x1000031b4 - 0x10000327c
int64_t function_1000031b4(void) {
    int64_t * v1 = _malloc(40); // 0x1000031cc
    int64_t result = (int64_t)v1; // 0x1000031cc
    *v1 = 0x10000327c;
    int64_t * v2 = (int64_t *)(result + 8); // 0x1000031ec
    *v2 = 2;
    int64_t * v3 = _malloc(16); // 0x1000031fc
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003204
    *v4 = (int64_t)v3;
    int64_t * v5 = _malloc(8 * (int32_t)*v2); // 0x100003214
    int64_t * v6 = (int64_t *)(result + 24); // 0x10000321c
    *v6 = (int64_t)v5;
    ___memcpy_chk(*v6, *v4, 8 * *v2, -1);
    *(int64_t *)(result + 32) = 0;
    return result;
}

// Address range: 0x10000327c - 0x10000332c
int64_t function_10000327c(void) {
    // 0x10000327c
    int64_t result; // 0x10000327c
    int64_t * v1 = (int64_t *)(result + 8); // 0x100003294
    int64_t v2 = *v1; // 0x100003294
    *(char *)result = (char)(v2 != 0);
    int64_t v3; // 0x10000327c
    if (*(char *)&v3 % 2 != 0) {
        // 0x1000032c8
        *(int64_t *)result = v2;
        *v1 = result % v2;
        *(int64_t *)result = result / v2;
    }
    // 0x100003324
    return result;
}

// Address range: 0x10000332c - 0x1000033e0
int64_t function_10000332c(void) {
    int64_t * v1 = _malloc(40); // 0x10000333c
    int64_t result = (int64_t)v1; // 0x10000333c
    *v1 = 0x1000033e0;
    int64_t * v2 = (int64_t *)(result + 8); // 0x100003360
    *v2 = 1;
    int64_t * v3 = _malloc(8); // 0x100003370
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003378
    *v4 = (int64_t)v3;
    int64_t * v5 = _malloc(8 * (int32_t)*v2); // 0x100003388
    int64_t * v6 = (int64_t *)(result + 24); // 0x100003394
    *v6 = (int64_t)v5;
    *(int64_t *)*v4 = 1;
    ___memcpy_chk(*v6, *v4, 8 * *v2, -1);
    *(int64_t *)(result + 32) = 0;
    return result;
}

// Address range: 0x1000033e0 - 0x100003424
int64_t function_1000033e0(void) {
    // 0x1000033e0
    int64_t result; // 0x1000033e0
    *(char *)result = 1;
    *(int64_t *)result = 2;
    return result;
}

// Address range: 0x100003424 - 0x10000353c
int64_t function_100003424(void) {
    int64_t * v1 = _malloc(40); // 0x100003448
    int64_t result = (int64_t)v1; // 0x100003448
    *v1 = 0x10000353c;
    int64_t * v2 = (int64_t *)(result + 8); // 0x100003468
    *v2 = 4;
    int64_t * v3 = _malloc(32); // 0x100003478
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003480
    *v4 = (int64_t)v3;
    int64_t * v5 = _malloc(8 * (int32_t)*v2); // 0x100003490
    int64_t * v6 = (int64_t *)(result + 24); // 0x100003498
    *v6 = (int64_t)v5;
    ___memcpy_chk(*v6, *v4, 8 * *v2, -1);
    int64_t * v7 = _malloc(16); // 0x100003504
    int64_t * v8 = (int64_t *)(result + 32); // 0x10000350c
    *v8 = (int64_t)v7;
    *(int64_t *)(*v8 + 8) = 0;
    return result;
}

// Address range: 0x10000353c - 0x1000036e0
int64_t function_10000353c(void) {
    // 0x10000353c
    int64_t v1; // 0x10000353c
    char * v2 = (char *)v1; // 0x100003550
    int64_t * v3 = (int64_t *)(v1 + 16); // 0x100003570
    int64_t * v4 = (int64_t *)(v1 + 24); // 0x10000357c
    int64_t * v5 = (int64_t *)(v1 + 8);
    int64_t v6 = *v3; // 0x100003570
    int64_t v7 = *v4; // 0x10000357c
    int64_t v8 = v7; // 0x100003590
    int64_t v9 = v6; // 0x100003590
    int64_t result; // 0x10000353c
    if ((v7 || v6) == 0) {
        // 0x1000035ac
        *v2 = 0;
        // 0x1000036d4
        return result;
    }
    int64_t v10; // 0x10000353c
    int64_t v11; // 0x10000353c
    int64_t v12; // 0x1000035d0
    int64_t v13; // 0x100003608
    int64_t result2; // 0x10000353c
    while (true) {
        // 0x1000035c0
        v11 = v9;
        v10 = v8;
        int64_t v14; // 0x10000353c
        int64_t v15; // 0x10000353c
        if (v11 == 0 || v10 == 0) {
            // 0x1000036bc
            v15 = function_100003c88();
        } else {
            // 0x100003600
            result2 = v14;
            v12 = *v5;
            v13 = result2 / v11;
            if (v13 == v12 / v10) {
                // break -> 0x100003638
                break;
            }
            // 0x1000036a8
            v15 = function_100003c88();
        }
        // 0x1000036d0
        v9 = *v3;
        v8 = *v4;
        result = v15;
        v14 = v15;
        if ((v8 || v9) == 0) {
            // 0x1000035ac
            *v2 = 0;
            // 0x1000036d4
            return result;
        }
    }
    // 0x100003638
    *(int64_t *)v1 = v11;
    *v5 = v10;
    *v3 = result2 - v13 * v11;
    *v4 = v12 - v13 * v10;
    *v2 = 1;
    *(int64_t *)v1 = v13;
    // 0x1000036d4
    return result2;
}

// Address range: 0x1000036e0 - 0x100003794
int64_t function_1000036e0(void) {
    // 0x1000036e0
    function_1000031b4();
    int64_t v1; // 0x1000036e0
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003740
    _fprintf(v2, "%s %jd over %jd %s", (char *)v1, v1, v1, (char *)v1);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v2, "%s%s", (char *)20, (char *)v1);
    return function_100002f4c();
}

// Address range: 0x100003794 - 0x100003828
int64_t function_100003794(void) {
    // 0x100003794
    function_10000332c();
    int64_t v1; // 0x100003794
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x1000037d4
    char * v3 = (char *)v1; // 0x1000037d4
    _fprintf(v2, "%s sqrt 2 %s", (char *)v1, v3);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v2, "%s%s", (char *)20, v3);
    return function_100002f4c();
}

// Address range: 0x100003828 - 0x100003920
int64_t function_100003828(void) {
    int64_t v1 = function_1000031b4(); // 0x10000387c
    function_100003424();
    int64_t v2; // 0x100003828
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2; // 0x1000038cc
    char * v4 = (char *)v2; // 0x1000038cc
    _fprintf(v3, "%s %s %s", (char *)v2, v4, (char *)v1);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v3, "%s%s", (char *)20, v4);
    return function_100002f4c();
}

// Address range: 0x100003920 - 0x100003a08
int64_t function_100003920(void) {
    int64_t v1 = function_10000332c(); // 0x100003964
    function_100003424();
    int64_t v2; // 0x100003920
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2; // 0x1000039b4
    char * v4 = (char *)v2; // 0x1000039b4
    _fprintf(v3, "%s %s %s", (char *)v2, v4, (char *)v1);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v3, "%s%s", (char *)20, v4);
    return function_100002f4c();
}

// Address range: 0x100003a08 - 0x100003af8
int64_t function_100003a08(void) {
    // 0x100003a08
    function_10000332c();
    function_100003424();
    function_100003424();
    function_100003424();
    int64_t v1; // 0x100003a08
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003aa4
    _fprintf(v2, "%s {1 ~ + ~ { 1 over { sqrt 2 } }} over 2 %s", NULL, (char *)2);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v2, "%s%s", (char *)20, (char *)2);
    return function_100002f4c();
}

// Address range: 0x100003af8 - 0x100003c88
int64_t entry_point(void) {
    struct _IO_FILE * v1 = (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010; // 0x100003b2c
    _fprintf(v1, ".nr PO 0.25i\n");
    _fprintf(v1, ".nr HM 0.25i\n");
    _fprintf(v1, ".ps 14\n");
    function_1000036e0();
    function_1000036e0();
    function_100003794();
    function_100003828();
    function_100003828();
    function_100003828();
    function_100003920();
    function_100003920();
    function_100003920();
    function_100003a08();
    return 0;
}

// Address range: 0x100003c88 - 0x100003ccc
int64_t function_100003c88(void) {
    // 0x100003c88
    int64_t v1; // 0x100003c88
    return *(int64_t *)(v1 + 24);
}

// Address range: 0x100003ccc - 0x100003d84
int64_t function_100003ccc(int64_t a1) {
    // 0x100003ccc
    int64_t result; // 0x100003ccc
    int64_t * v1 = (int64_t *)(result - 8); // 0x100003ccc
    int64_t v2 = *v1; // 0x100003ccc
    int64_t * v3 = (int64_t *)v2; // 0x100003cd0
    int64_t v4 = *v3; // 0x100003cd0
    int64_t v5 = *(int64_t *)(v2 + 16); // 0x100003cdc
    int64_t * v6 = (int64_t *)(v2 + 8);
    if (*(char *)(result - 25) % 2 == 0) {
        // 0x100003d5c
        *v6 = v4;
        *(int64_t *)(*v1 + 24) = v5;
    } else {
        // 0x100003cf0
        *v3 = *v6 + v4 * a1;
        *(int64_t *)(*v1 + 8) = v4;
        *(int64_t *)(*v1 + 16) = *(int64_t *)(v2 + 24) + v5 * a1;
        *(int64_t *)(*v1 + 24) = v5;
    }
    // 0x100003d78
    return result;
}

// Address range: 0x100003d84 - 0x100003d90
int64_t function_100003d84(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003d84
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003d90 - 0x100003d9c
int64_t function_100003d90(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d90
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003d9c - 0x100003da8
int32_t function_100003d9c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003d9c
    return _fprintf(stream, format);
}

// Address range: 0x100003da8 - 0x100003db4
void function_100003da8(int64_t * ptr) {
    // 0x100003da8
    _free(ptr);
}

// Address range: 0x100003db4 - 0x100003dc0
int64_t * function_100003db4(int32_t size) {
    // 0x100003db4
    return _malloc(size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 22

