//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f3c(void);
int64_t function_100003f48(int64_t * a1, int64_t a2, int64_t a3);
float64_t function_100003f54(char * nptr);
char * function_100003f60(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003f6c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t * a1, int64_t a2, int64_t a3);
float64_t _atof(char * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003948 - 0x100003f3c
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003960
    int64_t v2; // bp-332, 0x100003948
    int64_t v3 = &v2;
    int64_t v4 = 0;
    int32_t v5 = 0;
    char v6; // 0x100003948
    int32_t v7; // 0x100003948
    int32_t v8; // 0x100003948
    int32_t v9; // 0x100003948
    int32_t v10; // 0x100003948
    int32_t v11; // 0x100003948
    int32_t v12; // 0x100003948
    int64_t v13; // 0x100003a2c
    int64_t v14; // 0x100003a20
    while (true) {
        // 0x10000398c
        int64_t v15; // 0x100003948
        int64_t v16; // 0x100003948
        _printf("Enter %d%s value : ", v15, (char *)v16);
        v14 = 100 * v4 + v3;
        v13 = *(int64_t *)*(int64_t *)0x100004010;
        char * v17 = (char *)v14;
        _fgets(v17, 100, (struct _IO_FILE *)v13);
        char v18 = *v17; // 0x100003a58
        v6 = v18;
        v11 = 0;
        v7 = v5;
        v9 = v5;
        if (v18 != 0) {
            while (true) {
              lab_0x100003a6c:
                // 0x100003a6c
                v12 = v11;
                char v19 = v6;
                int32_t v20 = v19; // 0x100003a84
                if (v19 < 48 == (47 - v20 & v20) < 0) {
                    int32_t v21 = v20 - 57; // 0x100003ab4
                    if (v21 == 0 || v21 < 0 != (56 - v20 & v20) < 0) {
                        // 0x100003b48
                        v8 = v7;
                        v10 = v8;
                        switch (v19) {
                            case 46: {
                                goto lab_0x100003bcc;
                            }
                            case 45: {
                                goto lab_0x100003bcc;
                            }
                            case 43: {
                                goto lab_0x100003bcc;
                            }
                            default: {
                                goto lab_0x100003c3c;
                            }
                        }
                    } else {
                        // 0x100003c2c
                        v10 = 1;
                        goto lab_0x100003c3c;
                    }
                } else {
                    // 0x100003c2c
                    v10 = 1;
                    goto lab_0x100003c3c;
                }
            }
        }
      lab_0x100003c50:
        // 0x100003c50
        v5 = v9;
        v4++;
        v16 = v13;
        v15 = 100;
        if (v4 == 3) {
            // break -> 0x100003c60
            break;
        }
    }
    int64_t v22; // 0x100003948
    int64_t v23; // bp-456, 0x100003948
    int64_t v24; // 0x100003948
    if (v5 == 0) {
        int64_t v25 = &v23;
        _atof((char *)&v2);
        float64_t v26; // 0x100003948
        v23 = v26;
        int64_t v27 = 1;
        float64_t v28 = _atof((char *)(100 * v27 + v3)); // 0x100003ca4
        *(int64_t *)(8 * v27 + v25) = (int64_t)v26;
        v27++;
        while (v27 != 3) {
            // 0x100003c90
            v28 = _atof((char *)(100 * v27 + v3));
            float64_t v29; // 0x100003948
            *(int64_t *)(8 * v27 + v25) = (int64_t)v29;
            v27++;
        }
        // 0x100003ccc
        v22 = v25;
        v24 = (float32_t)v28;
    } else {
        // 0x100003c60
        v22 = &v23;
        int128_t v30; // 0x100003948
        v24 = v30;
    }
    // 0x100003ccc
    int64_t v31; // bp-432, 0x100003948
    int64_t v32 = &v31;
    int64_t v33 = 0;
    int64_t v34 = v13;
    int64_t v35 = 100;
    int64_t v36; // 0x100003948
    int32_t v37; // 0x100003948
    int32_t v38; // 0x100003948
    int64_t v39; // 0x100003948
    char * v40; // 0x100003948
    int64_t * v41; // 0x100003948
    int64_t v42; // 0x100003948
    int64_t v43; // 0x100003948
    int64_t v44; // 0x100003948
    int64_t v45; // 0x100003948
    while (true) {
        int64_t v46 = v33;
        v33 = v46 + 1;
        int64_t v47 = 8 * v46 + v22;
        float64_t * v48 = (float64_t *)v47;
        int64_t * v49 = (int64_t *)v47;
        v39 = 100 * v46 + v3;
        v40 = (char *)v39;
        v41 = (int64_t *)v39;
        v37 = v33;
        while (true) {
          lab_0x100003d0c_2:
            // 0x100003d0c
            v42 = v35;
            v44 = v34;
            v38 = v37;
            if (v5 == 0) {
                float64_t v50 = *v48; // 0x100003d28
                int64_t v51 = v38;
                int64_t v52 = 8 * v51 + v22; // 0x100003d30
                float64_t v53 = *(float64_t *)v52; // 0x100003d30
                v36 = v51;
                if (v50 == v53) {
                    goto lab_0x100003d74;
                } else {
                    v36 = v51;
                    if (v50 > v53 == v50 >= v53 == v50 <= v53) {
                        int64_t * v54 = (int64_t *)v52;
                        *v54 = *v49;
                        *v49 = *v54;
                        v43 = v42;
                        v45 = v44;
                        goto lab_0x100003e2c;
                    } else {
                        goto lab_0x100003d74;
                    }
                }
            } else {
                // 0x100003d0c
                v36 = v38;
                goto lab_0x100003d74;
            }
        }
      lab_0x100003e40:
        // 0x100003e40
        if (v33 == 2) {
            // break -> 0x100003e58
            break;
        }
    }
    char v55 = v35;
    for (int32_t i = 0; i < 3; i++) {
        // 0x100003e6c
        if (v5 == 1) {
            // 0x100003e80
            _printf("%c = %s", v55, (char *)v34);
        } else {
            // 0x100003ebc
            _printf("%c = %lf", v55, (float64_t)v24);
        }
    }
    // 0x100003f04
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f24
        ___stack_chk_fail();
    }
    // 0x100003f28
    return 0;
  lab_0x100003c3c:;
    int32_t v56 = v12 + 1; // 0x100003c40
    char v57 = *(char *)(v14 + (int64_t)v56); // 0x100003a58
    v6 = v57;
    v11 = v56;
    v7 = v10;
    v9 = v10;
    if (v57 == 0) {
        // break -> 0x100003c50
        goto lab_0x100003c50;
    }
    goto lab_0x100003a6c;
  lab_0x100003bcc:;
    char v58 = *(char *)(v14 + (int64_t)(v12 + 1)); // 0x100003be8
    int32_t v59 = v58; // 0x100003be8
    if (v58 < 48 == (47 - v59 & v59) < 0) {
        int32_t v60 = v59 - 57; // 0x100003c1c
        v10 = v8;
        if (v60 == 0 || v60 < 0 != (56 - v59 & v59) < 0) {
            goto lab_0x100003c3c;
        } else {
            // 0x100003c2c
            v10 = 1;
            goto lab_0x100003c3c;
        }
    } else {
        // 0x100003c2c
        v10 = 1;
        goto lab_0x100003c3c;
    }
  lab_0x100003d74:;
    char v61 = *v40; // 0x100003d84
    int32_t v62 = v61; // 0x100003d84
    int64_t v63 = 100 * v36 + v3; // 0x100003d90
    char v64 = *(char *)v63; // 0x100003d90
    int32_t v65 = v62 - (int32_t)v64; // 0x100003d94
    v43 = v42;
    v45 = v44;
    if (v65 != 0 && v65 < 0 == ((v65 ^ v62) & (int32_t)(v64 ^ v61)) < 0) {
        // 0x100003da4
        ___strcpy_chk(&v31, v63, 100);
        ___strcpy_chk((int64_t *)v63, v39, -1);
        ___strcpy_chk(v41, v32, -1);
        v43 = v32;
        v45 = -1;
    }
    goto lab_0x100003e2c;
  lab_0x100003e2c:
    // 0x100003e2c
    v34 = v45;
    v35 = v43;
    int32_t v66 = v38 + 1;
    v37 = v66;
    if (v38 < 2 == (v66 & 1 - v38) < 0) {
        // break -> 0x100003e40
        goto lab_0x100003e40;
    }
    goto lab_0x100003d0c_2;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(void) {
    // 0x100003f3c
    return ___stack_chk_fail();
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003f48
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f54 - 0x100003f60
float64_t function_100003f54(char * nptr) {
    // 0x100003f54
    return _atof(nptr);
}

// Address range: 0x100003f60 - 0x100003f6c
char * function_100003f60(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f60
    return _fgets(s, n, stream);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

