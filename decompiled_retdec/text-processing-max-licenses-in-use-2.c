//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f00(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003f0c(int64_t a1, int64_t a2, int64_t a3, char * a4);
int32_t function_100003f18(int32_t fd);
void function_100003f24(int32_t status, char * format, ...);
int32_t function_100003f30(int32_t fd, struct stat * buf);
int64_t * function_100003f3c(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003f48(int64_t * addr, int32_t len);
int32_t function_100003f54(char * file, int32_t oflag, ...);
int32_t function_100003f60(char * format, ...);
int32_t function_100003f6c(char * s1, char * s2, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t a2, int64_t a3);
int64_t ___sprintf_chk(int64_t a1, int64_t a2, int64_t a3, char * a4);
int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003cac - 0x100003f00
int64_t entry_point(void) {
    int32_t v1 = _open("mlijobs.txt", 0); // 0x100003cc8
    if (v1 == -1) {
        // 0x100003ce4
        _err(1, "open");
    }
    // 0x100003cf4
    int64_t v2; // bp-168, 0x100003cac
    _fstat(v1, (struct stat *)&v2);
    int32_t v3; // 0x100003cac
    int64_t * v4 = _mmap(NULL, v3, 3, 2, v1, 0); // 0x100003d18
    int64_t v5 = v3; // 0x100003d40
    int64_t v6 = v5 - 33; // 0x100003d44
    int64_t v7 = 33 - v5; // 0x100003d48
    if (v7 < 0 == (v7 & v6) < 0) {
        // 0x100003ed8
        _printf((char *)v4);
        _munmap(v4, v3);
        return _close(v1);
    }
    int64_t v8 = (int64_t)v4;
    int64_t v9 = v8; // 0x100003cac
    int32_t v10 = 0; // 0x100003cac
    int32_t v11 = 0; // 0x100003cac
    char * v12 = (char *)v4; // 0x100003cac
    int32_t v13; // 0x100003cac
    int32_t v14; // 0x100003cac
    int32_t v15; // 0x100003cac
    int32_t v16; // 0x100003cac
    int32_t v17; // 0x100003cac
    char * v18; // 0x100003cac
    while (true) {
      lab_0x100003d58:
        // 0x100003d58
        v18 = v12;
        v14 = v11;
        int32_t v19 = v10;
        v16 = v15;
        v13 = v19;
        if (_strncmp(v18, "License OUT", 11) == 0) {
            int32_t v20 = v19 + 1; // 0x100003d80
            int32_t v21 = v20 - v14; // 0x100003d8c
            v13 = v20;
            if (v21 < 0 == ((v21 ^ v20) & (v20 ^ v14)) < 0) {
                int32_t v22 = v21 == 0 ? v16 : 0;
                int64_t v23 = (int64_t)(26 * v22) + v8; // 0x100003dd8
                ___memmove_chk(v23, v9 + 14, 19);
                ___sprintf_chk(v23 + 19, 0, -1, "%6d\n");
                v11 = v21 == 0 ? v14 : v20;
                v10 = v20;
                v17 = v22 + 1;
                goto lab_0x100003e78;
            } else {
                goto lab_0x100003e40;
            }
        } else {
            goto lab_0x100003e40;
        }
    }
  lab_0x100003ed8:
    // 0x100003ed8
    _printf((char *)v4);
    _munmap(v4, v3);
    return _close(v1);
  lab_0x100003e40:
    // 0x100003e40
    v11 = v14;
    v10 = v13 + (int32_t)(_strncmp(v18, "License IN ", 11) == 0);
    v17 = v16;
    goto lab_0x100003e78;
  lab_0x100003e78:;
    char * v24 = v18;
    int64_t v25 = (int64_t)v24;
    int64_t v26 = v25; // 0x100003e9c
    v12 = v24;
    while (v8 + v5 > v25) {
        int64_t v27 = v25 + 1; // 0x100003ea8
        char * v28 = (char *)v27;
        v26 = v27;
        v12 = v28;
        char * v29 = v28; // 0x100003ec8
        if (*v24 == 10) {
            // break -> 0x100003d34
            break;
        }
        v24 = v29;
        v25 = (int64_t)v24;
        v26 = v25;
        v12 = v24;
    }
    int64_t v30 = v26 - v8; // 0x100003d3c
    int64_t v31 = v30 - v6; // 0x100003d48
    v9 = v26;
    v15 = v17;
    if (v31 < 0 == ((v31 ^ v30) & (v30 ^ v6)) < 0) {
        // break -> 0x100003ed8
        goto lab_0x100003ed8;
    }
    goto lab_0x100003d58;
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t function_100003f00(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003f00
    return ___memmove_chk(a1, a2, a3);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t function_100003f0c(int64_t a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003f0c
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(int32_t fd) {
    // 0x100003f18
    return _close(fd);
}

// Address range: 0x100003f24 - 0x100003f30
void function_100003f24(int32_t status, char * format, ...) {
    // 0x100003f24
    _err(status, format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int32_t fd, struct stat * buf) {
    // 0x100003f30
    return _fstat(fd, buf);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003f3c
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int64_t * addr, int32_t len) {
    // 0x100003f48
    return _munmap(addr, len);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * file, int32_t oflag, ...) {
    // 0x100003f54
    return _open(file, oflag);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * s1, char * s2, int32_t n) {
    // 0x100003f6c
    return _strncmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

