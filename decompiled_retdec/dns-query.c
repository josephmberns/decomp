//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct addrinfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct sockaddr * e5;
    char * e6;
    struct addrinfo * e7;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f28(int64_t a1);
void function_100003f34(int32_t status);
int32_t function_100003f40(struct _IO_FILE * stream, char * format, ...);
void function_100003f4c(struct addrinfo * ai);
char * function_100003f58(int32_t ecode);
int32_t function_100003f64(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai);
int32_t function_100003f70(struct sockaddr * sa, int32_t salen, char * host, int32_t hostlen, char * serv, int32_t servlen, int32_t flags);
int64_t * function_100003f7c(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f88(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _freeaddrinfo(struct addrinfo * a1);
char * _gai_strerror(int32_t a1);
int32_t _getaddrinfo(char * a1, char * a2, struct addrinfo * a3, struct addrinfo ** a4);
int32_t _getnameinfo(struct sockaddr * a1, int32_t a2, char * a3, int32_t a4, char * a5, int32_t a6, int32_t a7);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d70 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003d70
    int64_t v1; // bp-1112, 0x100003d70
    _memset(&v1, 0, 48);
    struct addrinfo * v2; // bp-1128, 0x100003d70
    int32_t v3 = _getaddrinfo("www.kame.net", NULL, (struct addrinfo *)&v1, &v2); // 0x100003dc8
    if (v3 != 0) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003dec
        _gai_strerror(v3);
        _fprintf((struct _IO_FILE *)v4, "%s\n", &v1);
        _exit(1);
        // UNREACHABLE
    }
    struct addrinfo * v5 = v2; // 0x100003e20
    v2 = NULL;
    if (v5 != NULL) {
        int64_t v6 = (int64_t)v5; // 0x100003edc
        int64_t v7 = *(int64_t *)(v6 + 32); // 0x100003e44
        uint32_t v8 = *(int32_t *)(v6 + 16); // 0x100003e4c
        int64_t v9; // bp-1057, 0x100003d70
        int32_t v10 = _getnameinfo((struct sockaddr *)v7, v8, (char *)&v9, 1025, NULL, 0, 2); // 0x100003e64
        int64_t v11; // 0x100003e88
        if (v10 == 0) {
            // 0x100003eb8
            _printf("%s\n", (char *)(int64_t)v8);
        } else {
            // 0x100003e80
            v11 = *(int64_t *)*(int64_t *)0x100004010;
            _gai_strerror(v10);
            _fprintf((struct _IO_FILE *)v11, "%s\n", &v9);
        }
        // 0x100003ed8
        v6 += 40;
        while (v6 != 0) {
            // 0x100003e40
            v7 = *(int64_t *)(v6 + 32);
            v8 = *(int32_t *)(v6 + 16);
            v10 = _getnameinfo((struct sockaddr *)v7, v8, (char *)&v9, 1025, NULL, 0, 2);
            if (v10 == 0) {
                // 0x100003eb8
                _printf("%s\n", (char *)(int64_t)v8);
            } else {
                // 0x100003e80
                v11 = *(int64_t *)*(int64_t *)0x100004010;
                _gai_strerror(v10);
                _fprintf((struct _IO_FILE *)v11, "%s\n", &v9);
            }
            // 0x100003ed8
            v6 += 40;
        }
    }
    // 0x100003ee8
    _freeaddrinfo(v2);
    int64_t v12 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003efc
    if (v12 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f10
        ___stack_chk_fail((int64_t)&g1);
    }
    // 0x100003f14
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1) {
    // 0x100003f28
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int32_t status) {
    // 0x100003f34
    _exit(status);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f40
    return _fprintf(stream, format);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(struct addrinfo * ai) {
    // 0x100003f4c
    _freeaddrinfo(ai);
}

// Address range: 0x100003f58 - 0x100003f64
char * function_100003f58(int32_t ecode) {
    // 0x100003f58
    return _gai_strerror(ecode);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai) {
    // 0x100003f64
    return _getaddrinfo(name, service, req, pai);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(struct sockaddr * sa, int32_t salen, char * host, int32_t hostlen, char * serv, int32_t servlen, int32_t flags) {
    // 0x100003f70
    return _getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);
}

// Address range: 0x100003f7c - 0x100003f88
int64_t * function_100003f7c(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f7c
    return _memset(s, c, n);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

