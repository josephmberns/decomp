//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000370c(void);
int64_t function_1000038a4(void);
int64_t function_100003908(void);
int64_t function_100003a8c(void);
int32_t function_100003e8c(char * nptr);
int64_t * function_100003e98(int32_t size);
int32_t function_100003ea4(char * format, ...);
int32_t function_100003eb0(void);
void function_100003ebc(int32_t seed);
int64_t function_100003ec8(char * nptr, char ** endptr, int32_t base);
int32_t function_100003ed4(int32_t * timer);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int64_t _strtoull(char * a1, char ** a2, int32_t a3);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000370c - 0x1000038a4
int64_t function_10000370c(void) {
    // 0x10000370c
    int64_t v1; // 0x10000370c
    int32_t v2 = v1; // 0x100003718
    g1 = (int64_t)_malloc(8 * v2) - 8;
    int32_t v3 = _rand(); // 0x10000373c
    int64_t result = v3; // 0x10000373c
    int32_t v4 = v3 % v2 + 1; // 0x100003754
    *(int64_t *)(g1 + 8) = (int64_t)v4;
    int32_t v5 = v2 + 1; // 0x100003788
    int32_t v6 = 1 - v2; // 0x10000378c
    int32_t v7 = 2; // 0x100003794
    int64_t result2 = result; // 0x100003794
    if (v6 < 0 == (v6 & v5) < 0) {
        // 0x100003898
        return result;
    }
    int32_t v8 = v4; // 0x100003794
    int32_t v9 = v7;
    int32_t v10 = -v9; // 0x1000037c8
    int32_t v11 = 0;
    int32_t v12; // 0x10000370c
    int32_t v13; // 0x10000370c
    int32_t v14; // 0x10000370c
    int32_t v15; // 0x10000370c
    int32_t v16; // 0x1000037ec
    int32_t v17; // 0x100003804
    int32_t v18; // 0x10000382c
    int32_t v19; // 0x1000037c8
    int64_t v20; // 0x10000370c
    int64_t v21; // 0x10000370c
    while (true) {
        // 0x1000037c0
        v12 = v8;
        v20 = result2;
        v14 = 0;
        v13 = v12;
        v21 = v20;
        if (v10 < 0 != (v9 & v10) < 0) {
            // 0x1000037d8
            v18 = 0;
            v15 = v18;
            v16 = *(int32_t *)(8 * (int64_t)v15 + g1);
            while (v16 != v12) {
                // 0x100003828
                v18 = v15 + 1;
                v19 = v18 - v9;
                v14 = v18;
                v13 = v12;
                v21 = v20;
                if (v19 < 0 == ((v19 ^ v18) & (v18 ^ v9)) < 0) {
                    goto lab_0x100003838;
                }
                v15 = v18;
                v16 = *(int32_t *)(8 * (int64_t)v15 + g1);
            }
            // 0x100003804
            v17 = _rand();
            v14 = v15;
            v13 = v17 % v2 + 1;
            v21 = v17;
        }
        // 0x100003838
        result2 = v21;
        v8 = v13;
        v11 = v14 == v9 ? 1 : v11;
        if (v11 % 2 != 0) {
            // break -> 0x100003860
            break;
        }
    }
    // 0x100003860
    *(int64_t *)(g1 + 8 * (int64_t)v9) = (int64_t)v8;
    v7 = v9 + 1;
    int32_t v22 = v7 - v5; // 0x10000378c
    while (v22 < 0 != ((v22 ^ v7) & (v7 ^ v5)) < 0) {
        // 0x1000037a4
        v9 = v7;
        v10 = -v9;
        v11 = 0;
        while (true) {
            // 0x1000037c0
            v12 = v8;
            v20 = result2;
            v14 = 0;
            v13 = v12;
            v21 = v20;
            if (v10 < 0 != (v9 & v10) < 0) {
                // 0x1000037d8
                v18 = 0;
                v15 = v18;
                v16 = *(int32_t *)(8 * (int64_t)v15 + g1);
                while (v16 != v12) {
                    // 0x100003828
                    v18 = v15 + 1;
                    v19 = v18 - v9;
                    v14 = v18;
                    v13 = v12;
                    v21 = v20;
                    if (v19 < 0 == ((v19 ^ v18) & (v18 ^ v9)) < 0) {
                        goto lab_0x100003838;
                    }
                    v15 = v18;
                    v16 = *(int32_t *)(8 * (int64_t)v15 + g1);
                }
                // 0x100003804
                v17 = _rand();
                v14 = v15;
                v13 = v17 % v2 + 1;
                v21 = v17;
            }
            // 0x100003838
            result2 = v21;
            v8 = v13;
            v11 = v14 == v9 ? 1 : v11;
            if (v11 % 2 != 0) {
                // break -> 0x100003860
                break;
            }
        }
        // 0x100003860
        *(int64_t *)(g1 + 8 * (int64_t)v9) = (int64_t)v8;
        v7 = v9 + 1;
        v22 = v7 - v5;
    }
    // 0x100003898
    return result2;
}

// Address range: 0x1000038a4 - 0x100003908
int64_t function_1000038a4(void) {
    // 0x1000038a4
    int64_t result; // 0x1000038a4
    int32_t v1 = result; // 0x1000038a8
    int32_t v2 = v1 + 1; // 0x1000038c0
    int32_t v3 = -v1; // 0x1000038c4
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003900
        return result;
    }
    int32_t v4 = 1; // 0x1000038cc
    *(char *)((8 * (int64_t)v4 | 4) + g1) = 0;
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x1000038d4
        *(char *)((8 * (int64_t)v4 | 4) + g1) = 0;
        v4++;
    }
    // 0x100003900
    return result;
}

// Address range: 0x100003908 - 0x100003a8c
int64_t function_100003908(void) {
    // 0x100003908
    int64_t v1; // 0x100003908
    int32_t v2 = v1; // 0x100003914
    int32_t v3 = v2 + 1; // 0x100003930
    int32_t v4 = -v2; // 0x100003934
    if (v4 < 0 == (v3 & v4) < 0) {
        // 0x100003a78
        return 0;
    }
    int32_t v5 = v1; // 0x100003918
    int32_t v6 = -v5; // 0x100003958
    int32_t v7 = 1; // 0x100003a58
    while (v6 < 0 != (v6 & v5) < 0) {
        int32_t v8 = 0; // 0x100003a14
        int64_t v9 = 8 * (int64_t)(_rand() % v2 + 1) + g1; // 0x10000399c
        char * v10 = (char *)(v9 + 4);
        while (*v10 % 2 != 0) {
            // 0x10000396c
            v9 = 8 * (int64_t)(_rand() % v2 + 1) + g1;
            v10 = (char *)(v9 + 4);
        }
        while (*(int32_t *)v9 != v7) {
            // 0x1000039f0
            *v10 = 1;
            v8++;
            int32_t v11 = v8 - v5; // 0x100003958
            if (v11 < 0 == ((v11 ^ v8) & (v8 ^ v5)) < 0) {
                // break (via goto) -> 0x100003a78
                goto lab_0x100003a78;
            }
            v9 = 8 * (int64_t)(_rand() % v2 + 1) + g1;
            v10 = (char *)(v9 + 4);
            while (*v10 % 2 != 0) {
                // 0x10000396c
                v9 = 8 * (int64_t)(_rand() % v2 + 1) + g1;
                v10 = (char *)(v9 + 4);
            }
        }
        // 0x100003a20
        function_1000038a4();
        v7++;
        int32_t v12 = v7 - v3; // 0x100003934
        if (v12 < 0 == ((v12 ^ v7) & (v7 ^ v3)) < 0) {
            // 0x100003a78
            return 0;
        }
    }
  lab_0x100003a78:
    // 0x100003a78
    function_1000038a4();
    // 0x100003a78
    return 1;
}

// Address range: 0x100003a8c - 0x100003c60
int64_t function_100003a8c(void) {
    // 0x100003a8c
    int64_t v1; // 0x100003a8c
    int32_t v2 = v1; // 0x100003a98
    int32_t v3 = v2 + 1; // 0x100003ab4
    int32_t v4 = -v2; // 0x100003ab8
    if (v4 < 0 == (v3 & v4) < 0) {
        // 0x100003c4c
        return 0;
    }
    int32_t v5 = v1; // 0x100003a9c
    int32_t v6 = -v5; // 0x100003ae4
    int32_t v7 = 1; // 0x100003c2c
    while (v6 < 0 != (v6 & v5) < 0) {
        int32_t v8 = v7;
        int32_t v9 = 0; // 0x100003be8
        int64_t v10 = 8 * (int64_t)v8; // 0x100003b04
        *(char *)((v10 | 4) + g1) = 1;
        int32_t v11 = *(int32_t *)(g1 + v10); // 0x100003b1c
        while (v11 != v7) {
            int32_t v12 = v11; // 0x100003b64
            if (v8 == v11) {
                int32_t v13 = _rand() % v2 + 1; // 0x100003b84
                v12 = v13;
                while (*(char *)(g1 + 4 + 8 * (int64_t)v13) % 2 != 0) {
                    // 0x100003b70
                    v13 = _rand() % v2 + 1;
                    v12 = v13;
                }
            }
            // 0x100003be4
            v9++;
            int32_t v14 = v9 - v5; // 0x100003ae4
            if (v14 < 0 == ((v14 ^ v9) & (v9 ^ v5)) < 0) {
                // break (via goto) -> 0x100003c4c
                goto lab_0x100003c4c;
            }
            v8 = v12;
            v10 = 8 * (int64_t)v8;
            *(char *)((v10 | 4) + g1) = 1;
            v11 = *(int32_t *)(g1 + v10);
        }
        // 0x100003bf4
        function_1000038a4();
        v7++;
        int32_t v15 = v7 - v3; // 0x100003ab8
        if (v15 < 0 == ((v15 ^ v7) & (v7 ^ v3)) < 0) {
            // 0x100003c4c
            return 0;
        }
    }
  lab_0x100003c4c:
    // 0x100003c4c
    function_1000038a4();
    // 0x100003c4c
    return 1;
}

// Address range: 0x100003c60 - 0x100003e8c
int64_t entry_point(void) {
    // 0x100003c60
    int64_t v1; // 0x100003c60
    if ((int32_t)v1 != 4) {
        int64_t result = _printf("Usage : %s <Number of prisoners> <Number of chances> <Number of trials>", (char *)v1); // 0x100003cb0
        // 0x100003e7c
        return result;
    }
    // 0x100003cb4
    _atoi((char *)*(int64_t *)(v1 + 8));
    uint32_t v2 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003ccc
    int64_t v3 = *(int64_t *)(v1 + 24); // 0x100003cd8
    int64_t v4; // bp-72, 0x100003c60
    int64_t v5 = _strtoull((char *)v3, (char **)&v4, 10); // 0x100003ce4
    _srand(_time(NULL));
    _printf("Running random trials...");
    int64_t v6 = 0; // 0x100003d1c
    int64_t v7 = &v4; // 0x100003d1c
    if (v5 != 0) {
        function_10000370c();
        function_100003908();
        v6++;
        while (v6 != v5) {
            // 0x100003d24
            function_10000370c();
            function_100003908();
            v6++;
        }
        // 0x100003d0c
        v7 = v2;
    }
    // 0x100003d70
    int128_t v8; // 0x100003c60
    _printf("\n\nGames Played : %llu\nGames Won : %llu\nChances : %lf %% \n\n", v7, 10, (float64_t)(int64_t)v8);
    _printf("Running strategic trials...");
    int64_t v9 = 0; // 0x100003ddc
    if (v5 == 0) {
        // 0x100003e30
        _printf("\n\nGames Played : %llu\nGames Won : %llu\nChances : %lf %% \n\n", v7, 10, (float64_t)(int64_t)v8);
        // 0x100003e7c
        return 0;
    }
    function_10000370c();
    function_100003a8c();
    v9++;
    while (v9 != v5) {
        // 0x100003de4
        function_10000370c();
        function_100003a8c();
        v9++;
    }
    // 0x100003e30
    _printf("\n\nGames Played : %llu\nGames Won : %llu\nChances : %lf %% \n\n", (int64_t)v2, 10, (float64_t)(int64_t)v8);
    // 0x100003e7c
    return 0;
}

// Address range: 0x100003e8c - 0x100003e98
int32_t function_100003e8c(char * nptr) {
    // 0x100003e8c
    return _atoi(nptr);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int32_t size) {
    // 0x100003e98
    return _malloc(size);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(void) {
    // 0x100003eb0
    return _rand();
}

// Address range: 0x100003ebc - 0x100003ec8
void function_100003ebc(int32_t seed) {
    // 0x100003ebc
    _srand(seed);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(char * nptr, char ** endptr, int32_t base) {
    // 0x100003ec8
    return _strtoull(nptr, endptr, base);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(int32_t * timer) {
    // 0x100003ed4
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

