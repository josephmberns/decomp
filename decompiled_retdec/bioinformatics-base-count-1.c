//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038a8(void);
int64_t function_1000038fc(void);
int64_t function_100003b60(void);
int64_t function_100003ebc(int64_t a1);
int64_t function_100003ec8(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003ed4(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ee0(char * filename, char * modes);
void function_100003eec(int64_t * ptr);
int32_t function_100003ef8(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f04(int32_t size);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(char * s);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200085; // 0x100008018
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038a8 - 0x1000038fc
int64_t function_1000038a8(void) {
    // 0x1000038a8
    int64_t v1; // 0x1000038a8
    int32_t v2 = v1; // 0x1000038ac
    int32_t v3 = v2 - 10; // 0x1000038c0
    int32_t result = 1; // 0x1000038c8
    if (v3 == 0 || v3 < 0 != (9 - v2 & v2) < 0) {
        // 0x1000038f0
        return 1;
    }
    int32_t v4 = v2; // 0x1000038c8
    v4 /= 10;
    result++;
    while (v4 != 10 && v4 < 10 == (9 - v4 & v4) < 0) {
        // 0x1000038d0
        v4 /= 10;
        result++;
    }
    // 0x1000038f0
    return result;
}

// Address range: 0x1000038fc - 0x100003b10
int64_t function_1000038fc(void) {
    // 0x1000038fc
    int64_t v1; // 0x1000038fc
    int32_t result = _strlen((char *)v1); // 0x100003910
    *(int32_t *)&g1 = *(int32_t *)&g1 + result;
    int32_t v2 = -result; // 0x100003940
    int32_t v3 = 0; // 0x100003948
    if (v2 < 0 != (result & v2) < 0) {
        uint64_t v4 = (int64_t)*(char *)(v1 + (int64_t)v3) + 0xffffffbf & 0xffffffff; // 0x100003960
        while (v4 >= 19 == (v4 != 19)) {
            // 0x100003938
            v3++;
            int32_t v5 = v3 - result; // 0x100003940
            if (v5 < 0 == ((v5 ^ v3) & (v3 ^ result)) < 0) {
                goto lab_0x1000039f4;
            }
            v4 = (int64_t)*(char *)(v1 + (int64_t)v3) + 0xffffffbf & 0xffffffff;
        }
        // 0x100003974
        return result;
    }
  lab_0x1000039f4:;
    int64_t v6 = g2; // 0x100003a08
    if (g2 == 0) {
        // 0x100003a10
        g2 = (int64_t)_malloc(24);
        *(int64_t *)g2 = (int64_t)_malloc(result);
        int64_t result2 = ___strcpy_chk(*(int64_t *)g2, v1, -1); // 0x100003a50
        *(int32_t *)(g2 + 8) = result;
        *(int64_t *)(g2 + 16) = 0;
        // 0x100003974
        return result2;
    }
    int64_t * v7 = (int64_t *)(v6 + 16);
    int64_t v8 = *v7; // 0x100003a88
    while (v8 != 0) {
        // 0x100003a84
        v7 = (int64_t *)(v8 + 16);
        v8 = *v7;
    }
    int64_t * v9 = _malloc(24); // 0x100003ab0
    int64_t v10 = (int64_t)v9; // 0x100003ab0
    int64_t v11 = (int64_t)_malloc(result); // 0x100003ac0
    *v9 = v11;
    int64_t result3 = ___strcpy_chk(v11, v1, -1); // 0x100003adc
    *(int32_t *)(v10 + 8) = result;
    *(int64_t *)(v10 + 16) = 0;
    *v7 = v10;
    // 0x100003974
    return result3;
}

// Address range: 0x100003b60 - 0x100003db4
int64_t function_100003b60(void) {
    // 0x100003b60
    function_1000038a8();
    _printf("Sequence:\n");
    int64_t v1; // 0x100003b60
    if (g2 != 0) {
        int64_t v2 = g2; // 0x100003c10
        _printf("\n%*d%3s%3s", v1, v1, (char *)v1, (char *)v1);
        v2 += 16;
        while (v2 != 0) {
            // 0x100003bb4
            _printf("\n%*d%3s%3s", v1, v1, (char *)v1, (char *)v1);
            v2 += 16;
        }
    }
    // 0x100003c1c
    _printf("\n\nBase Count\n----------\n\n");
    char v3 = v1; // 0x100003c74
    char * v4 = (char *)v1; // 0x100003c74
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("%3c%3s%*d\n", v3, v4, v1, v1);
    _printf("\n%3s%*d\n", (char *)v1, v1, v1);
    _free((int64_t *)g2);
    return &g3;
}

// Address range: 0x100003db4 - 0x100003ebc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc8
    int64_t v2; // 0x100003db4
    int64_t v3; // 0x100003db4
    if ((int32_t)v3 == 2) {
        struct _IO_FILE * v4 = _fopen((char *)*(int64_t *)(v3 + 8), (char *)0x100003f92); // 0x100003e28
        char ** v5 = (char **)v3; // 0x100003e4c
        if (_fscanf(v4, "%s", v5) != -1) {
            function_1000038fc();
            while (_fscanf(v4, "%s", v5) != -1) {
                // 0x100003e60
                function_1000038fc();
            }
        }
        // 0x100003e6c
        _fclose(v4);
        v2 = function_100003b60();
    } else {
        // 0x100003df4
        v2 = _printf("Usage : %s <Gene file name>\n", (char *)v3);
    }
    // 0x100003e80
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ea8
        ___stack_chk_fail(v2);
    }
    // 0x100003eac
    return 0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(int64_t a1) {
    // 0x100003ebc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ec8
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(struct _IO_FILE * stream) {
    // 0x100003ed4
    return _fclose(stream);
}

// Address range: 0x100003ee0 - 0x100003eec
struct _IO_FILE * function_100003ee0(char * filename, char * modes) {
    // 0x100003ee0
    return _fopen(filename, modes);
}

// Address range: 0x100003eec - 0x100003ef8
void function_100003eec(int64_t * ptr) {
    // 0x100003eec
    _free(ptr);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ef8
    return _fscanf(stream, format);
}

// Address range: 0x100003f04 - 0x100003f10
int64_t * function_100003f04(int32_t size) {
    // 0x100003f04
    return _malloc(size);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * s) {
    // 0x100003f1c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

