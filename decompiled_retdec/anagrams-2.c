//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003978(void);
int64_t function_1000039ac(void);
int64_t function_100003f0c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t * function_100003f18(int32_t nmemb, int32_t size);
int32_t function_100003f24(int32_t fd);
int32_t function_100003f30(int32_t fd, struct stat * buf);
int64_t * function_100003f3c(int32_t size);
int32_t function_100003f48(char * file, int32_t oflag, ...);
int32_t function_100003f54(char * format, ...);
void function_100003f60(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003f6c(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_100003f78(char * s1, char * s2);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _close(int32_t a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003978 - 0x1000039ac
int64_t function_100003978(void) {
    // 0x100003978
    int64_t v1; // 0x100003978
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x1000039ac - 0x100003aa8
int64_t function_1000039ac(void) {
    // 0x1000039ac
    int64_t result; // 0x1000039ac
    char * v1 = (char *)result; // 0x1000039c4
    char v2 = *v1; // 0x1000039c4
    if (v2 == 0) {
        // 0x100003aa0
        return result;
    }
    int32_t v3 = 0; // 0x1000039d0
    char * v4 = v1;
    v3++;
    char * v5 = (char *)(result + (int64_t)v3);
    char v6 = *v5; // 0x1000039f0
    char v7 = v2; // 0x1000039fc
    while (v6 != 0) {
        char v8 = v6;
        char v9 = v7; // 0x100003a18
        int32_t v10 = v8; // 0x100003a0c
        int32_t v11 = v10 - (int32_t)v9; // 0x100003a1c
        char v12 = v9; // 0x100003a24
        if (v11 < 0 != ((v11 ^ v10) & (int32_t)(v8 ^ v9)) < 0) {
            // 0x100003a2c
            *v5 = v9;
            *v4 = v8;
            v12 = v8;
        }
        int32_t v13 = v3 + 1;
        char * v14 = (char *)(result + (int64_t)v13); // 0x1000039f0
        char v15 = *v14; // 0x1000039f0
        while (v15 != 0) {
            // 0x100003a04
            v8 = v15;
            v9 = v12;
            v10 = v8;
            v11 = v10 - (int32_t)v9;
            v12 = v9;
            if (v11 < 0 != ((v11 ^ v10) & (int32_t)(v8 ^ v9)) < 0) {
                // 0x100003a2c
                *v14 = v9;
                *v4 = v8;
                v12 = v8;
            }
            // 0x100003a7c
            v13++;
            v14 = (char *)(result + (int64_t)v13);
            v15 = *v14;
        }
        // 0x100003a90
        v7 = *v5;
        if (v7 == 0) {
            // break -> 0x100003aa0
            break;
        }
        v4 = v5;
        v3++;
        v5 = (char *)(result + (int64_t)v3);
        v6 = *v5;
    }
    // 0x100003aa0
    return result;
}

// Address range: 0x100003aa8 - 0x100003f0c
int64_t entry_point(void) {
    int32_t v1 = _open("unixdict.txt", 0); // 0x100003ad4
    if (v1 == -1) {
        // 0x100003ef8
        return 1;
    }
    // 0x100003afc
    int64_t v2; // bp-184, 0x100003aa8
    _fstat(v1, (struct stat *)&v2);
    int64_t * v3 = (int64_t *)((int64_t)&v2 + 96); // 0x100003b0c
    int64_t * v4 = _malloc(2 * (int32_t)*v3); // 0x100003b14
    int64_t v5 = (int64_t)v4; // 0x100003b14
    int64_t v6 = *v3;
    int64_t v7 = v6 + v5; // 0x100003b28
    _read(v1, v4, (int32_t)v6);
    ___memcpy_chk(v7, v5, *v3, -1);
    int64_t v8 = *v3; // 0x100003b6c
    char * v9 = NULL; // 0x100003b78
    if (v8 != 0) {
        char * v10 = NULL;
        int64_t v11 = 0;
        char * v12 = (char *)(v11 + v5); // 0x100003b88
        int64_t v13 = v8; // 0x100003b94
        char * v14 = v10; // 0x100003b94
        if (*v12 == 10) {
            // 0x100003b9c
            *(char *)(v11 + v7) = 0;
            *v12 = 0;
            function_1000039ac();
            v13 = *v3;
            v14 = (char *)((int64_t)v10 + 1 & 0xffffffff);
        }
        char * v15 = v14;
        int64_t v16 = v13; // 0x100003b6c
        int64_t v17 = v11 + 1; // 0x100003bf0
        v9 = v15;
        while (v17 < v16) {
            // 0x100003b80
            v10 = v15;
            v11 = v17;
            v12 = (char *)(v11 + v5);
            v13 = v16;
            v14 = v10;
            if (*v12 == 10) {
                // 0x100003b9c
                *(char *)(v11 + v7) = 0;
                *v12 = 0;
                function_1000039ac();
                v13 = *v3;
                v14 = (char *)((int64_t)v10 + 1 & 0xffffffff);
            }
            // 0x100003bec
            v15 = v14;
            v16 = v13;
            v17 = v11 + 1;
            v9 = v15;
        }
    }
    int64_t v18 = (int64_t)v9;
    int64_t * v19 = _calloc((int32_t)v18, 24); // 0x100003c04
    int64_t v20 = (int64_t)v19; // 0x100003c04
    int64_t v21 = *v3; // 0x100003c24
    int64_t v22 = v21; // 0x100003c30
    if (v21 != 0) {
        int64_t v23 = 0;
        int64_t v24 = 0;
        int64_t v25 = 0;
        int64_t v26; // 0x100003aa8
        int64_t v27; // 0x100003aa8
        int64_t v28; // 0x100003aa8
        int64_t v29; // 0x100003c70
        int64_t v30; // 0x100003aa8
        if (*(char *)(v25 + v5) == 0) {
            // 0x100003c54
            v29 = 24 * v23 + v20;
            *(int64_t *)v29 = v24 + v7;
            *(int64_t *)(v29 + 8) = v24 + v5;
            v30 = v25 + 1;
            v26 = v30;
            v22 = *v3;
            v27 = v23 + 1;
            v28 = v30;
        } else {
            // 0x100003c38
            v26 = v25 + 1;
            v27 = v23;
            v28 = v24;
        }
        int64_t v31 = v26;
        while (v31 < v22) {
            // 0x100003c38
            v23 = v27;
            v24 = v28;
            v25 = v31;
            if (*(char *)(v25 + v5) == 0) {
                // 0x100003c54
                v29 = 24 * v23 + v20;
                *(int64_t *)v29 = v24 + v7;
                *(int64_t *)(v29 + 8) = v24 + v5;
                v30 = v25 + 1;
                v26 = v30;
                v22 = *v3;
                v27 = v23 + 1;
                v28 = v30;
            } else {
                // 0x100003c38
                v26 = v25 + 1;
                v27 = v23;
                v28 = v24;
            }
            // 0x100003cb4
            v31 = v26;
        }
    }
    int64_t v32 = 0x100000000 * v18;
    uint64_t v33 = v32 >> 32; // 0x100003cc8
    _qsort(v19, (int32_t)v33, 24, (int32_t (*)(int64_t *, int64_t *))0x100003978);
    if (v32 == 0) {
        // 0x100003ee8
        _close(v1);
        // 0x100003ef8
        return 0;
    }
    int64_t v34 = 0;
    int64_t v35 = 0;
    int64_t v36 = 0;
    int64_t v37 = 0;
    int64_t v38 = 0;
    int64_t v39 = *(int64_t *)(24 * v38 + v20); // 0x100003d1c
    int64_t v40 = *(int64_t *)(24 * v34 + v20); // 0x100003d2c
    int64_t v41; // 0x100003aa8
    int64_t v42; // 0x100003aa8
    int64_t v43; // 0x100003aa8
    int64_t v44; // 0x100003aa8
    int64_t v45; // 0x100003aa8
    int64_t v46; // 0x100003aa8
    int64_t v47; // 0x100003aa8
    int64_t v48; // 0x100003dc0
    int64_t v49; // 0x100003dd0
    int64_t v50; // 0x100003ddc
    int64_t v51; // 0x100003de8
    if (_strcmp((char *)v39, (char *)v40) == 0) {
        // 0x100003d44
        v43 = v34;
        v44 = v35 + 1;
        v45 = v36;
        v47 = v37;
    } else {
        // 0x100003d54
        v43 = v38;
        v44 = 0;
        v45 = v36;
        v47 = v37;
        if (v35 >= v36) {
            // 0x100003d7c
            v41 = v35 == v36 ? v37 : 0;
            v46 = v41;
            v42 = v34;
            v43 = v34;
            v44 = 0;
            v45 = v35;
            v47 = v41;
            if (v34 < v38) {
                v48 = v46 + 1;
                v49 = 24 * v46 + v20;
                v50 = v42 + 1;
                v51 = 24 * v42 + v20;
                *(float128_t *)v49 = *(float128_t *)v51;
                *(int64_t *)(v49 + 16) = *(int64_t *)(v51 + 16);
                v46 = v48;
                v42 = v50;
                v43 = v38;
                v44 = 0;
                v45 = v35;
                v47 = v48;
                while (v50 != v38) {
                    // 0x100003db8
                    v48 = v46 + 1;
                    v49 = 24 * v46 + v20;
                    v50 = v42 + 1;
                    v51 = 24 * v42 + v20;
                    *(float128_t *)v49 = *(float128_t *)v51;
                    *(int64_t *)(v49 + 16) = *(int64_t *)(v51 + 16);
                    v46 = v48;
                    v42 = v50;
                    v43 = v38;
                    v44 = 0;
                    v45 = v35;
                    v47 = v48;
                }
            }
        }
    }
    int64_t v52 = v47;
    int64_t v53 = v38 + 1; // 0x100003e14
    while (v53 < v33) {
        // 0x100003d0c
        v34 = v43;
        v35 = v44;
        v36 = v45;
        v37 = v52;
        v38 = v53;
        v39 = *(int64_t *)(24 * v38 + v20);
        v40 = *(int64_t *)(24 * v34 + v20);
        if (_strcmp((char *)v39, (char *)v40) == 0) {
            // 0x100003d44
            v43 = v34;
            v44 = v35 + 1;
            v45 = v36;
            v47 = v37;
        } else {
            // 0x100003d54
            v43 = v38;
            v44 = 0;
            v45 = v36;
            v47 = v37;
            if (v35 >= v36) {
                // 0x100003d7c
                v41 = v35 == v36 ? v37 : 0;
                v46 = v41;
                v42 = v34;
                v43 = v34;
                v44 = 0;
                v45 = v35;
                v47 = v41;
                if (v34 < v38) {
                    v48 = v46 + 1;
                    v49 = 24 * v46 + v20;
                    v50 = v42 + 1;
                    v51 = 24 * v42 + v20;
                    *(float128_t *)v49 = *(float128_t *)v51;
                    *(int64_t *)(v49 + 16) = *(int64_t *)(v51 + 16);
                    v46 = v48;
                    v42 = v50;
                    v43 = v38;
                    v44 = 0;
                    v45 = v35;
                    v47 = v48;
                    while (v50 != v38) {
                        // 0x100003db8
                        v48 = v46 + 1;
                        v49 = 24 * v46 + v20;
                        v50 = v42 + 1;
                        v51 = 24 * v42 + v20;
                        *(float128_t *)v49 = *(float128_t *)v51;
                        *(int64_t *)(v49 + 16) = *(int64_t *)(v51 + 16);
                        v46 = v48;
                        v42 = v50;
                        v43 = v38;
                        v44 = 0;
                        v45 = v35;
                        v47 = v48;
                    }
                }
            }
        }
        // 0x100003e10
        v52 = v47;
        v53 = v38 + 1;
    }
    if (v52 == 0) {
        // 0x100003ee8
        _close(v1);
        // 0x100003ef8
        return 0;
    }
    int64_t v54 = v40; // 0x100003aa8
    uint64_t v55 = 0;
    _printf("%s ", (char *)v54);
    int64_t v56; // 0x100003aa8
    int64_t v57; // 0x100003eac
    int32_t v58; // 0x100003eb0
    if (v55 < v32 - 0x100000000 >> 32) {
        // 0x100003e88
        v56 = 24 * v55 + v20;
        v57 = *(int64_t *)(v56 + 24);
        v58 = _strcmp((char *)*(int64_t *)v56, (char *)v57);
        v54 = v57;
        if (v58 != 0) {
            // 0x100003ec4
            _printf((char *)0x100003f95);
            v54 = v57;
        }
    }
    int64_t v59 = v55 + 1; // 0x100003edc
    while (v59 != v52) {
        // 0x100003e40
        v55 = v59;
        _printf("%s ", (char *)v54);
        if (v55 < v32 - 0x100000000 >> 32) {
            // 0x100003e88
            v56 = 24 * v55 + v20;
            v57 = *(int64_t *)(v56 + 24);
            v58 = _strcmp((char *)*(int64_t *)v56, (char *)v57);
            v54 = v57;
            if (v58 != 0) {
                // 0x100003ec4
                _printf((char *)0x100003f95);
                v54 = v57;
            }
        }
        // 0x100003ed8
        v59 = v55 + 1;
    }
    // 0x100003ee8
    _close(v1);
    // 0x100003ef8
    return 0;
}

// Address range: 0x100003f0c - 0x100003f18
int64_t function_100003f0c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f0c
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t nmemb, int32_t size) {
    // 0x100003f18
    return _calloc(nmemb, size);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(int32_t fd) {
    // 0x100003f24
    return _close(fd);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int32_t fd, struct stat * buf) {
    // 0x100003f30
    return _fstat(fd, buf);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int32_t size) {
    // 0x100003f3c
    return _malloc(size);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * file, int32_t oflag, ...) {
    // 0x100003f48
    return _open(file, oflag);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// Address range: 0x100003f60 - 0x100003f6c
void function_100003f60(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f60
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003f6c
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * s1, char * s2) {
    // 0x100003f78
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

