//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003910(void);
int64_t function_1000039a0(void);
int64_t function_100003aa0(void);
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ee8(void);
int64_t * function_100003ef4(int32_t nmemb, int32_t size);
int32_t function_100003f00(int32_t fd);
int32_t function_100003f0c(int32_t fd, struct stat * buf);
int64_t * function_100003f18(int32_t size);
int64_t * function_100003f24(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f30(char * file, int32_t oflag, ...);
int32_t function_100003f3c(char * format, ...);
int32_t function_100003f48(int32_t fd, int64_t * buf, int32_t nbytes);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _close(int32_t a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003910 - 0x1000039a0
int64_t function_100003910(void) {
    // 0x100003910
    int64_t v1; // 0x100003910
    char v2 = *(char *)v1; // 0x100003930
    char v3 = v2; // 0x10000393c
    int64_t v4 = 0; // 0x10000393c
    if (v2 == 0) {
        // 0x100003994
        return 1;
    }
    int32_t v5 = 0; // 0x10000393c
    int64_t result = 0; // 0x100003964
    while (v3 != *(char *)(v4 + v1)) {
        // 0x100003924
        v5++;
        v4 = v5;
        v3 = *(char *)(v1 + v4);
        result = 1;
        if (v3 == 0) {
            // break -> 0x100003994
            break;
        }
        result = 0;
    }
    // 0x100003994
    return result;
}

// Address range: 0x1000039a0 - 0x100003aa0
int64_t function_1000039a0(void) {
    // 0x1000039a0
    int64_t v1; // 0x1000039a0
    ___memset_chk(v1, 0, 26, -1);
    char v2 = *(char *)v1; // 0x1000039e0
    char v3 = v2; // 0x1000039ec
    if (v2 == 0) {
        // 0x100003a90
        return 0;
    }
    int32_t v4 = 0; // 0x1000039ec
    int32_t v5 = v3; // 0x1000039fc
    int64_t result = 0; // 0x100003a08
    while (v3 < 97 == (96 - v5 & v5) < 0) {
        int32_t v6 = v5 - 122; // 0x100003a1c
        result = 0;
        if (v6 != 0 && v6 < 0 == (121 - v5 & v5) < 0) {
            // break -> 0x100003a90
            break;
        }
        // 0x100003a34
        v4++;
        int32_t v7 = *(int32_t *)(4 * (int64_t)v3 + (int64_t)&g1); // 0x100003a5c
        char * v8 = (char *)(v1 + (int64_t)v7); // 0x100003a64
        *v8 = *v8 + 1;
        v3 = *(char *)(v1 + (int64_t)v4);
        if (v3 == 0) {
            // 0x1000039d4
            result = v4;
            return result;
        }
        v5 = v3;
        result = 0;
    }
  lab_0x100003a90:
    // 0x100003a90
    return result;
}

// Address range: 0x100003aa0 - 0x100003c14
int64_t function_100003aa0(void) {
    int64_t v1 = 0;
    int64_t v2; // 0x100003aa0
    char * v3 = (char *)(v1 + v2); // 0x100003ae4
    int64_t v4; // 0x100003aa0
    int64_t v5 = *(int64_t *)(8 * (int64_t)*v3 + v4); // 0x100003ae8
    int64_t v6 = v5; // 0x100003afc
    if (v5 == 0) {
        // 0x100003b04
        v6 = (int64_t)_calloc(1, 80);
        *(int64_t *)(8 * (int64_t)*v3 + v4) = v6;
    }
    int64_t v7 = v6;
    v1++;
    while (v1 != 25) {
        int64_t v8 = v7;
        v3 = (char *)(v1 + v2);
        v5 = *(int64_t *)(8 * (int64_t)*v3 + v8);
        v6 = v5;
        if (v5 == 0) {
            // 0x100003b04
            v6 = (int64_t)_calloc(1, 80);
            *(int64_t *)(8 * (int64_t)*v3 + v8) = v6;
        }
        // 0x100003b34
        v7 = v6;
        v1++;
    }
    int64_t v9 = (int64_t)_malloc(16); // 0x100003b50
    char * v10 = (char *)(v2 + 25); // 0x100003b6c
    int64_t v11 = *(int64_t *)(8 * (int64_t)*v10 + v7); // 0x100003b70
    *(int64_t *)(v9 + 8) = v11;
    *(int64_t *)(8 * (int64_t)*v10 + v7) = v9;
    int64_t v12 = v9; // 0x100003b9c
    v12 += 8;
    int64_t result = 0; // 0x100003bac
    while (v12 != 0) {
        // 0x100003bb4
        if ((int32_t)function_100003910() != 0) {
            // 0x100003bd8
            result = *(int64_t *)v12;
            return result;
        }
        v12 += 8;
        result = 0;
    }
  lab_0x100003c04:
    // 0x100003c04
    return result;
}

// Address range: 0x100003c14 - 0x100003edc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c2c
    int64_t v2; // 0x100003c14
    int32_t v3 = v2; // 0x100003c38
    char * v4 = "unixdict.txt"; // 0x100003c50
    if (v3 < 2 == (1 - v3 & v3) < 0) {
        // 0x100003c68
        v4 = (char *)*(int64_t *)(v2 + 8);
    }
    int32_t v5 = _open(v4, 0); // 0x100003c80
    int64_t v6; // bp-248, 0x100003c14
    uint32_t v7 = _fstat(v5, (struct stat *)&v6); // 0x100003c90
    int64_t result = 1; // 0x100003c9c
    if (v7 >= 0) {
        // 0x100003cb0
        int32_t v8; // 0x100003c14
        int64_t * v9 = _malloc(v8); // 0x100003cb4
        _read(v5, v9, v8);
        _close(v5);
        int64_t v10; // bp-336, 0x100003c14
        _memset(&v10, 0, 80);
        char v11 = *(char *)0x3f54; // 0x100003d00
        int32_t v12 = 0; // 0x100003d0c
        if (v11 != 0) {
            *(int32_t *)(4 * (int64_t)v11 + (int64_t)&g1) = v12;
            int32_t v13 = v12 + 1; // 0x100003d40
            char v14 = *(char *)((int64_t)v13 + 0x3f54); // 0x100003d00
            v12 = v13;
            while (v14 != 0) {
                // 0x100003d14
                *(int32_t *)(4 * (int64_t)v14 + (int64_t)&g1) = v12;
                v13 = v12 + 1;
                v14 = *(char *)((int64_t)v13 + 0x3f54);
                v12 = v13;
            }
        }
        int64_t v15 = v8;
        result = 0;
        if (v8 > 0 != (-v15 & v15) < 0) {
            int64_t v16 = (int64_t)v9; // 0x100003cb4
            int32_t v17 = 0;
            int32_t v18 = 0;
            int64_t v19 = 0;
            int64_t v20 = 80;
            int32_t v21 = 0;
            char * v22 = (char *)v16; // 0x100003d78
            int32_t v23 = v18; // 0x100003d84
            int32_t v24 = v21; // 0x100003d84
            int64_t v25 = v19; // 0x100003d84
            int64_t v26 = v20; // 0x100003d84
            int32_t v27; // 0x100003c14
            int64_t v28; // bp-66, 0x100003c14
            int32_t v29; // 0x100003da8
            int32_t v30; // 0x100003db0
            int64_t v31; // 0x100003c14
            int64_t v32; // 0x100003c14
            if (*v22 == 10) {
                // 0x100003d90
                *v22 = 0;
                v29 = v21 - v17;
                v30 = v29 - v18;
                v27 = v18;
                v31 = v19;
                v32 = v20;
                if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v18)) < 0) {
                    // 0x100003dc0
                    function_1000039a0();
                    v27 = function_100003aa0() == 0 ? v18 : v29;
                    v31 = (int64_t)v17 + v16;
                    v32 = &v28;
                }
                // 0x100003e38
                v24 = v21 + 1;
                v23 = v27;
                v25 = v31;
                v26 = v32;
            }
            int64_t v33 = v26;
            int64_t v34 = v25;
            int32_t v35 = v23;
            int32_t v36 = v24 + 1; // 0x100003e50
            int64_t v37 = v36; // 0x100003d58
            int64_t v38 = v37 - v15; // 0x100003d60
            while (v38 < 0 != ((v38 ^ v37) & (int64_t)(v36 ^ v8)) < 0) {
                // 0x100003d70
                v17 = v24;
                v18 = v35;
                v19 = v34;
                v20 = v33;
                v21 = v36;
                v22 = (char *)(v37 + v16);
                v23 = v18;
                v24 = v21;
                v25 = v19;
                v26 = v20;
                if (*v22 == 10) {
                    // 0x100003d90
                    *v22 = 0;
                    v29 = v21 - v17;
                    v30 = v29 - v18;
                    v27 = v18;
                    v31 = v19;
                    v32 = v20;
                    if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v18)) < 0) {
                        // 0x100003dc0
                        function_1000039a0();
                        v27 = function_100003aa0() == 0 ? v18 : v29;
                        v31 = (int64_t)v17 + v16;
                        v32 = &v28;
                    }
                    // 0x100003e38
                    v24 = v21 + 1;
                    v23 = v27;
                    v25 = v31;
                    v26 = v32;
                }
                // 0x100003e4c
                v33 = v26;
                v34 = v25;
                v35 = v23;
                v36 = v24 + 1;
                v37 = v36;
                v38 = v37 - v15;
            }
            // 0x100003e5c
            result = 0;
            if (v35 != 0) {
                // 0x100003e70
                _printf("longest derangement: %s %s\n", (char *)v34, (char *)v33);
                result = 0;
            }
        }
    }
    // 0x100003e9c
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003ec4
        ___stack_chk_fail();
    }
    // 0x100003ec8
    return result;
}

// Address range: 0x100003edc - 0x100003ee8
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003edc
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(void) {
    // 0x100003ee8
    return ___stack_chk_fail();
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t * function_100003ef4(int32_t nmemb, int32_t size) {
    // 0x100003ef4
    return _calloc(nmemb, size);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(int32_t fd) {
    // 0x100003f00
    return _close(fd);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(int32_t fd, struct stat * buf) {
    // 0x100003f0c
    return _fstat(fd, buf);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int64_t * function_100003f24(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f24
    return _memset(s, c, n);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * file, int32_t oflag, ...) {
    // 0x100003f30
    return _open(file, oflag);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003f48
    return _read(fd, buf, nbytes);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

