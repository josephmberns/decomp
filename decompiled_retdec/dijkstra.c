//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t cf(int64_t a1, int64_t a2);
int64_t dequeue(void);
int64_t deregister_tm_clones(void);
int64_t dijkstra(int64_t a1);
int64_t enqueue(int64_t a1);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t queue_has_something(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x3e7
char g2 = 0; // 0x4020
int64_t g3 = 0; // 0x4040
int64_t g4 = 0; // 0x4680
int64_t g5 = 0; // 0x46a0
int64_t g6 = 0; // 0x4700
int32_t g7 = 0; // 0x4750
int32_t g8 = 0; // 0x4751
int64_t g9 = 0; // 0x4760
int32_t g10 = 0; // 0x47b0
int64_t g11; // 0x47b1
int32_t g12;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g12;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107a
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108a
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109a
void function_1090(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x1090
    qsort(base, nmemb, size, compar);
}

// Address range: 0x10a0 - 0x10aa
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10ba
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x1458, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return 0x4010;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (g2 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    g2 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x11dd
int64_t enqueue(int64_t a1) {
    int32_t v1 = g7; // 0x11b4
    g7 = &g8;
    *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g6) = (int32_t)a1;
    return a1 & 0xffffffff;
}

// Address range: 0x11dd - 0x120f
int64_t cf(int64_t a1, int64_t a2) {
    // 0x11dd
    return 0;
}

// Address range: 0x120f - 0x126b
int64_t dequeue(void) {
    // 0x120f
    qsort(&g6, g7, 4, (int32_t (*)(int64_t *, int64_t *))0x11dd);
    int32_t v1 = g7 - 1; // 0x1246
    g7 = v1;
    uint32_t result = *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g6); // 0x1266
    return result;
}

// Address range: 0x126b - 0x1283
int64_t queue_has_something(void) {
    int32_t v1 = g7; // 0x1273
    return v1 >= 0 == (v1 != 0);
}

// Address range: 0x1283 - 0x1458
int64_t dijkstra(int64_t a1) {
    // 0x1283
    *(int32_t *)((0x100000000 * a1 >> 30) + (int64_t)&g5) = 0;
    if (*(int32_t *)&g4 != 0) {
        int32_t v1 = 0; // 0x12e3
        if (v1 != (int32_t)a1) {
            // 0x12be
            *(int32_t *)(int64_t)&g5 = (int32_t)&g1;
        }
        // 0x12d9
        enqueue((int64_t)v1);
        v1++;
        int64_t v2 = v1; // 0x12f0
        while (v2 < (int64_t)*(int32_t *)&g4) {
            // 0x12b6
            if (v1 != (int32_t)a1) {
                // 0x12be
                *(int32_t *)(4 * v2 + (int64_t)&g5) = (int32_t)&g1;
            }
            // 0x12d9
            enqueue((int64_t)v1);
            v1++;
            v2 = v1;
        }
    }
    int64_t result = queue_has_something(); // 0x1447
    if ((int32_t)result == 0) {
        // 0x1454
        return result;
    }
    int64_t v3 = dequeue(); // 0x12fc
    int32_t v4 = g10; // 0x1304
    g10 = &g11;
    *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g9) = (int32_t)v3;
    int32_t v5 = *(int32_t *)&g4; // 0x1433
    int32_t v6; // 0x1283
    int32_t v7; // 0x1283
    int64_t v8; // 0x1283
    int32_t v9; // 0x1433
    int64_t v10; // 0x1283
    int32_t v11; // 0x1362
    int32_t v12; // 0x142f
    int64_t v13; // 0x143c
    int32_t * v14; // 0x1381
    uint32_t v15; // 0x13ca
    int64_t v16; // 0x134c
    int32_t * v17; // 0x1283
    if (v5 != 0) {
        // 0x1336
        v10 = 0x100000000 * v3;
        v16 = 20 * (v10 >> 32);
        v17 = (int32_t *)((v10 >> 30) + (int64_t)&g5);
        v12 = 0;
        v8 = 0;
        v7 = v5;
        v11 = *(int32_t *)(4 * (v8 + v16) + (int64_t)&g3);
        v6 = v7;
        if (v11 != 0) {
            // 0x136d
            v14 = (int32_t *)(4 * v8 + (int64_t)&g5);
            v15 = *v17 + v11;
            v6 = v7;
            if (*v14 > v15) {
                // 0x13d0
                *v14 = v15;
                v6 = *(int32_t *)&g4;
            }
        }
        // 0x142f
        v9 = v6;
        v12++;
        v13 = v12;
        while (v13 < (int64_t)v9) {
            // 0x1336
            v8 = v13;
            v7 = v9;
            v11 = *(int32_t *)(4 * (v8 + v16) + (int64_t)&g3);
            v6 = v7;
            if (v11 != 0) {
                // 0x136d
                v14 = (int32_t *)(4 * v8 + (int64_t)&g5);
                v15 = *v17 + v11;
                v6 = v7;
                if (*v14 > v15) {
                    // 0x13d0
                    *v14 = v15;
                    v6 = *(int32_t *)&g4;
                }
            }
            // 0x142f
            v9 = v6;
            v12++;
            v13 = v12;
        }
    }
    int64_t result2 = queue_has_something(); // 0x1447
    while ((int32_t)result2 != 0) {
        // 0x12f7
        v3 = dequeue();
        v4 = g10;
        g10 = &g11;
        *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g9) = (int32_t)v3;
        v5 = *(int32_t *)&g4;
        if (v5 != 0) {
            // 0x1336
            v10 = 0x100000000 * v3;
            v16 = 20 * (v10 >> 32);
            v17 = (int32_t *)((v10 >> 30) + (int64_t)&g5);
            v12 = 0;
            v8 = 0;
            v7 = v5;
            v11 = *(int32_t *)(4 * (v8 + v16) + (int64_t)&g3);
            v6 = v7;
            if (v11 != 0) {
                // 0x136d
                v14 = (int32_t *)(4 * v8 + (int64_t)&g5);
                v15 = *v17 + v11;
                v6 = v7;
                if (*v14 > v15) {
                    // 0x13d0
                    *v14 = v15;
                    v6 = *(int32_t *)&g4;
                }
            }
            // 0x142f
            v9 = v6;
            v12++;
            v13 = v12;
            while (v13 < (int64_t)v9) {
                // 0x1336
                v8 = v13;
                v7 = v9;
                v11 = *(int32_t *)(4 * (v8 + v16) + (int64_t)&g3);
                v6 = v7;
                if (v11 != 0) {
                    // 0x136d
                    v14 = (int32_t *)(4 * v8 + (int64_t)&g5);
                    v15 = *v17 + v11;
                    v6 = v7;
                    if (*v14 > v15) {
                        // 0x13d0
                        *v14 = v15;
                        v6 = *(int32_t *)&g4;
                    }
                }
                // 0x142f
                v9 = v6;
                v12++;
                v13 = v12;
            }
        }
        // 0x1442
        result2 = queue_has_something();
    }
    // 0x1454
    return result2;
}

// Address range: 0x1458 - 0x158f
int main(int argc, char ** argv) {
    // 0x1458
    printf("Enter the number of vertices: ");
    scanf(" %d", &g4);
    printf("Enter the adj matrix: ");
    int32_t v1 = *(int32_t *)&g4; // 0x151c
    int64_t v2 = 0; // 0x1525
    int32_t v3 = 0; // 0x1525
    if (v1 != 0) {
        int64_t v4 = 0; // 0x1516
        int32_t v5 = 0; // 0x1516
        int32_t v6; // 0x1509
        uint32_t v7; // 0x150d
        int64_t v8; // 0x1458
        int64_t v9; // 0x1516
        if (v1 != 0) {
            // 0x14c3
            v6 = 0;
            scanf(" %d", (int64_t *)(4 * 20 * v2 + (int64_t)&g3));
            v6++;
            v7 = *(int32_t *)&g4;
            v8 = v7;
            v9 = v6;
            v4 = v8;
            v5 = v7;
            while (v9 < v8) {
                // 0x14c3
                scanf(" %d", (int64_t *)(4 * (v9 + 20 * v2) + (int64_t)&g3));
                v6++;
                v7 = *(int32_t *)&g4;
                v8 = v7;
                v9 = v6;
                v4 = v8;
                v5 = v7;
            }
        }
        // 0x1518
        v3++;
        int64_t v10 = v3; // 0x1525
        v2 = v10;
        while (v4 > v10) {
            int32_t v11 = v5;
            v4 = 0;
            v5 = 0;
            if (v11 != 0) {
                // 0x14c3
                v6 = 0;
                scanf(" %d", (int64_t *)(4 * 20 * v2 + (int64_t)&g3));
                v6++;
                v7 = *(int32_t *)&g4;
                v8 = v7;
                v9 = v6;
                v4 = v8;
                v5 = v7;
                while (v9 < v8) {
                    // 0x14c3
                    scanf(" %d", (int64_t *)(4 * (v9 + 20 * v2) + (int64_t)&g3));
                    v6++;
                    v7 = *(int32_t *)&g4;
                    v8 = v7;
                    v9 = v6;
                    v4 = v8;
                    v5 = v7;
                }
            }
            // 0x1518
            v3++;
            v10 = v3;
            v2 = v10;
        }
    }
    // 0x1527
    dijkstra(0);
    puts("\nNode\tDist");
    if (*(int32_t *)&g4 == 0) {
        // 0x1588
        return 0;
    }
    int32_t v12 = 0; // 0x1586
    uint32_t v13 = *(int32_t *)(int64_t)&g5; // 0x155d
    printf("%d\t%d\n", (int64_t)v12, (int64_t)v13);
    v12++;
    int64_t v14 = v12; // 0x1586
    while (v14 < (int64_t)*(int32_t *)&g4) {
        // 0x1549
        v13 = *(int32_t *)(4 * v14 + (int64_t)&g5);
        printf("%d\t%d\n", (int64_t)v12, (int64_t)v13);
        v12++;
        v14 = v12;
    }
    // 0x1588
    return 0;
}

// Address range: 0x1590 - 0x159d
int64_t _fini(void) {
    // 0x1590
    int64_t result; // 0x1590
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (13.2.0)
// Detected functions: 18

