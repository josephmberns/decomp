//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e88(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003e94(int64_t a1);
void function_100003ea0(int64_t * ptr);
int64_t * function_100003eac(int32_t size);
int32_t function_100003eb8(char * format, ...);
int32_t function_100003ec4(struct re_pattern_buffer * preg, char * pattern, int32_t cflags);
int32_t function_100003ed0(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags);
void function_100003edc(struct re_pattern_buffer * preg);
int32_t function_100003ee8(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _regcomp(struct re_pattern_buffer * a1, char * a2, int32_t a3);
int32_t _regexec(struct re_pattern_buffer * a1, char * a2, int32_t a3, struct _TYPEDEF_regmatch_t a4[1], int32_t a5);
void _regfree(struct re_pattern_buffer * a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b38 - 0x100003e88
int64_t entry_point(void) {
    struct _TYPEDEF_regmatch_t v1; // 0x100003cb8
    struct _TYPEDEF_regmatch_t v2[1]; // 0x100003cb8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b50
    int64_t v4; // bp-96, 0x100003b38
    _regcomp((struct re_pattern_buffer *)&v4, "string$", 1);
    _regexec((struct re_pattern_buffer *)&v4, "this is a matching string", 0, {(struct {int32_t e0; int32_t e1;}){.e0 = 0, .e1 = 0}}, 0);
    _printf("'%s' %smatched with '%s'\n");
    _regexec((struct re_pattern_buffer *)&v4, "this is not a matching string!", 0, {(struct {int32_t e0; int32_t e1;}){.e0 = 0, .e1 = 0}}, 0);
    _printf("'%s' %smatched with '%s'\n", "this is not a matching string!", NULL, NULL);
    _regfree((struct re_pattern_buffer *)&v4);
    _regcomp((struct re_pattern_buffer *)&v4, "a[a-z]+", 1);
    v1 = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    int64_t v5; // bp-56, 0x100003b38
    v1.e0 = &v5;
    v2[0] = v1;
    if (_regexec((struct re_pattern_buffer *)&v4, "this is a matching string", 1, v2, 0) == 0) {
        int32_t v6 = _strlen("istyfied"); // 0x100003cdc
        int64_t v7; // 0x100003b38
        int64_t * v8 = _malloc(v6 + 2 + (int32_t)(1 - v7 + v5) + _strlen("this is a matching string")); // 0x100003d08
        int64_t v9 = (int64_t)v8; // 0x100003d08
        ___memcpy_chk(v9, (int64_t)"this is a matching string", v5 + 1, -1);
        ___memcpy_chk(v5 + v9, (int64_t)"istyfied", (int64_t)_strlen("istyfied"), -1);
        int32_t v10 = _strlen("istyfied"); // 0x100003d74
        int64_t v11 = v7 + (int64_t)"this is a matching string"; // 0x100003d94
        char * v12 = (char *)v11; // 0x100003da8
        ___memcpy_chk(v5 + v9 + (int64_t)v10, v11, (int64_t)_strlen(v12), -1);
        int32_t v13 = _strlen("istyfied"); // 0x100003dd4
        int32_t v14 = _strlen(v12); // 0x100003df0
        *(char *)(v5 + v9 + (int64_t)v13 + (int64_t)v14) = 0;
        _printf("mod string: '%s'\n", v12);
        _free(v8);
    } else {
        // 0x100003e2c
        _printf("the string '%s' is the same: no matching!\n", "this is a matching string");
    }
    // 0x100003e48
    _regfree((struct re_pattern_buffer *)&v4);
    if (*(int64_t *)*(int64_t *)0x100004010 != v3) {
        // 0x100003e70
        ___stack_chk_fail((int64_t)&g1);
    }
    // 0x100003e74
    return 0;
}

// Address range: 0x100003e88 - 0x100003e94
int64_t function_100003e88(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e88
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e94 - 0x100003ea0
int64_t function_100003e94(int64_t a1) {
    // 0x100003e94
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ea0 - 0x100003eac
void function_100003ea0(int64_t * ptr) {
    // 0x100003ea0
    _free(ptr);
}

// Address range: 0x100003eac - 0x100003eb8
int64_t * function_100003eac(int32_t size) {
    // 0x100003eac
    return _malloc(size);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(char * format, ...) {
    // 0x100003eb8
    return _printf(format);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(struct re_pattern_buffer * preg, char * pattern, int32_t cflags) {
    // 0x100003ec4
    return _regcomp(preg, pattern, cflags);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags) {
    // 0x100003ed0
    return _regexec(preg, string, nmatch, pmatch, eflags);
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(struct re_pattern_buffer * preg) {
    // 0x100003edc
    _regfree(preg);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * s) {
    // 0x100003ee8
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

