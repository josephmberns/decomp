//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a60(void);
int64_t function_100003e4c(int64_t a1);
int64_t * function_100003e58(int32_t nmemb, int32_t size);
int32_t function_100003e64(struct _IO_FILE * stream, char * format, ...);
void function_100003e70(int64_t * ptr);
int64_t * function_100003e7c(int32_t size);
int32_t function_100003e88(int32_t c);
int32_t function_100003e94(char * s);
char * function_100003ea0(char * s, int32_t c);
int32_t function_100003eac(char * s);

// --------------------- Global Variables ---------------------

char * g1 = "\xb8>"; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008008
char * g3; // 0x100008010
int64_t g4 = 0x50800000012; // 0x100008018
int64_t g5 = 0x200085; // 0x100008020
int64_t g6 = 0x4800000019; // 0x100008028
char g7[9] = "__PAGEZE"; // 0x100008030
int32_t g8;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003684 - 0x100003a60
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x10000369c
    int64_t result; // 0x100003684
    int64_t v2; // 0x100003684
    int64_t v3; // 0x100003684
    if ((int32_t)v2 == 2) {
        int64_t v4 = *(int64_t *)(v2 + 8); // 0x1000036fc
        *(int64_t *)&g3 = v4;
        uint32_t v5 = _strlen((char *)v4); // 0x100003710
        if (v5 < 2) {
            goto lab_0x100003740;
        } else {
            if (v5 == 94 || v5 < 94) {
                // 0x10000376c
                int64_t v6; // bp-416, 0x100003684
                int64_t v7 = &v6;
                for (int64_t i = 0; i < 94; i++) {
                    // 0x100003780
                    *(int32_t *)(4 * i + v7) = 0;
                }
                uint64_t v8 = (int64_t)v5; // 0x1000037b0
                int64_t v9 = 0; // 0x1000037c4
                if (v5 == 0) {
                  lab_0x1000038cc:;
                    int64_t * v10 = _calloc(v5, 8); // 0x1000038d4
                    *(int64_t *)&g7 = (int64_t)v10;
                    if (v10 == NULL) {
                        int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003900
                        v3 = _fprintf((struct _IO_FILE *)v11, "Could not allocate memory for nums\n");
                        result = 1;
                    } else {
                        int64_t * v12 = _malloc(8 * v5); // 0x100003928
                        int64_t v13 = (int64_t)v12; // 0x100003928
                        g4 = v13;
                        if (v12 == NULL) {
                            int64_t v14 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003954
                            _fprintf((struct _IO_FILE *)v14, "Could not allocate memory for inds\n");
                            _free((int64_t *)*(int64_t *)&g7);
                            v3 = &g8;
                            result = 1;
                        } else {
                            // 0x100003980
                            g5 = 0;
                            g6 = 0;
                            g2 = 2;
                            int64_t v15 = v13; // 0x1000039c4
                            if (v5 <= 2 != v5 != 2) {
                                function_100003a60();
                                int64_t v16 = g2 + 1; // 0x1000039ec
                                g2 = v16;
                                while (v16 >= v8 != v16 != v8) {
                                    // 0x1000039cc
                                    function_100003a60();
                                    v16 = g2 + 1;
                                    g2 = v16;
                                }
                                // 0x1000039ac
                                v15 = g4;
                            }
                            // 0x1000039f8
                            _free((int64_t *)v15);
                            _free((int64_t *)*(int64_t *)&g7);
                            v3 = &g8;
                            result = 0;
                        }
                    }
                } else {
                    char v17 = *(char *)(v9 + (int64_t)g3); // 0x1000037e4
                    while (_strchr(g1, (int32_t)v17) != NULL) {
                        char v18 = *(char *)(v9 + (int64_t)g3); // 0x100003814
                        char v19 = *g1; // 0x100003820
                        int32_t * v20 = (int32_t *)((4 * ((int64_t)v18 - (int64_t)v19) & 0xfffffffc) + v7);
                        if (*v20 != 0) {
                            // break -> 0x1000038a8
                            break;
                        }
                        // 0x10000384c
                        *v20 = 1;
                        int64_t v21 = v9 + 1; // 0x100003884
                        v9 = v21;
                        if (v21 >= v8) {
                            goto lab_0x1000038cc;
                        }
                        v17 = *(char *)(v9 + (int64_t)g3);
                    }
                    int64_t v22 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000038b0
                    v3 = _fprintf((struct _IO_FILE *)v22, "Invalid digits\n");
                    result = 1;
                }
                goto lab_0x100003a20;
            } else {
                goto lab_0x100003740;
            }
        }
    } else {
        int64_t v23 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000036cc
        v3 = _fprintf((struct _IO_FILE *)v23, "Usage is %s <digits>\n", (char *)v2);
        result = 1;
        goto lab_0x100003a20;
    }
  lab_0x100003740:;
    int64_t v24 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003748
    v3 = _fprintf((struct _IO_FILE *)v24, "Invalid number of digits\n");
    result = 1;
    goto lab_0x100003a20;
  lab_0x100003a20:
    // 0x100003a20
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003a48
        ___stack_chk_fail(v3);
    }
    // 0x100003a4c
    return result;
}

// Address range: 0x100003a60 - 0x100003e4c
int64_t function_100003a60(void) {
    // 0x100003a60
    int64_t v1; // 0x100003a60
    uint64_t v2 = v1;
    if (v2 == 0) {
        int64_t v3 = 0; // 0x100003dec
        if (g2 != 0) {
            int64_t v4 = *(int64_t *)(g4 + 8 * v3); // 0x100003e10
            _putchar((int32_t)*(char *)(v4 + (int64_t)g3));
            int64_t v5 = v3 + 1; // 0x100003e24
            v3 = v5;
            while (v5 < g2) {
                // 0x100003df4
                v4 = *(int64_t *)(g4 + 8 * v3);
                _putchar((int32_t)*(char *)(v4 + (int64_t)g3));
                v5 = v3 + 1;
                v3 = v5;
            }
        }
        // 0x100003e40
        return _puts((char *)0x100003f9f);
    }
    int64_t v6 = g2 - g5; // 0x100003a9c
    uint64_t v7 = v2 - 1; // 0x100003ae8
    int64_t v8 = v6; // 0x100003afc
    int64_t v9 = v6; // 0x100003afc
    if (v7 != 0) {
        // 0x100003b04
        v8 = 0;
        v9 = (g2 - g6) / v7;
    }
    uint64_t v10 = g5 == 0 ? g2 - 1 : v6;
    uint64_t v11 = v9;
    uint64_t v12 = v11 < v10 ? v11 : v10;
    int64_t v13 = 8 * v7; // 0x100003b80
    *(int64_t *)(g4 + v13) = v8;
    uint64_t v14 = *(int64_t *)(g4 + v13); // 0x100003b98
    int64_t result; // 0x100003a60
    if (v14 >= v12 == (v14 != v12)) {
        // 0x100003e40
        return result;
    }
    uint64_t v15 = v14; // 0x100003ba8
    while (true) {
        // 0x100003bb0
        int64_t v16; // 0x100003a60
        int64_t v17 = v16;
        int64_t * v18 = (int64_t *)(*(int64_t *)&g7 + 8 * v15); // 0x100003bd4
        *v18 = *v18 + 1;
        int64_t * v19 = (int64_t *)(g4 + v13);
        int64_t v20 = g5 + *v19; // 0x100003bf8
        g5 = v20;
        int64_t v21 = g6 + *v19 * v7; // 0x100003c20
        g6 = v21;
        int64_t v22 = g2 - 1;
        int64_t * v23; // 0x100003a60
        int64_t v24; // 0x100003a60
        int64_t v25; // 0x100003a60
        int64_t v26; // 0x100003a60
        while (v22 != v7 && v22 >= v7) {
            int64_t v27 = 8 * v22; // 0x100003c70
            uint64_t v28 = *(int64_t *)(*(int64_t *)&g7 + v27); // 0x100003c70
            uint64_t v29 = *(int64_t *)(v27 + g4); // 0x100003c84
            v23 = v19;
            v24 = v20;
            v25 = v21;
            v26 = v17;
            if (v29 <= v28 == (v29 != v28)) {
                goto lab_0x100003d28_2;
            }
            uint64_t v30 = v29 - v28; // 0x100003cc8
            int64_t v31 = v22; // 0x100003ce4
            v23 = v19;
            v24 = v20;
            v25 = v21;
            v26 = v17;
            if (v30 != v2 && v30 >= v2) {
                goto lab_0x100003d28_2;
            }
            v22 = v31 - 1;
        }
        // 0x100003d00
        v23 = v19;
        v24 = v20;
        v25 = v21;
        v26 = v17;
        if (v22 == v7) {
            int64_t v32 = function_100003a60(); // 0x100003d20
            v23 = (int64_t *)(g4 + v13);
            v24 = g5;
            v25 = g6;
            v26 = v32;
        }
      lab_0x100003d28_2:
        // 0x100003d28
        g6 = v25 - *v23 * v7;
        g5 = v24 - *v23;
        int64_t * v33 = (int64_t *)(8 * *v23 + *(int64_t *)&g7); // 0x100003d94
        *v33 = *v33 - 1;
        int64_t * v34 = (int64_t *)(g4 + v13); // 0x100003db8
        *v34 = *v34 + 1;
        v15 = *(int64_t *)(g4 + v13);
        v16 = v26;
        result = v26;
        if (v15 >= v12 == (v15 != v12)) {
            // break -> 0x100003e40
            break;
        }
    }
    // 0x100003e40
    return result;
}

// Address range: 0x100003e4c - 0x100003e58
int64_t function_100003e4c(int64_t a1) {
    // 0x100003e4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e58 - 0x100003e64
int64_t * function_100003e58(int32_t nmemb, int32_t size) {
    // 0x100003e58
    return _calloc(nmemb, size);
}

// Address range: 0x100003e64 - 0x100003e70
int32_t function_100003e64(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e64
    return _fprintf(stream, format);
}

// Address range: 0x100003e70 - 0x100003e7c
void function_100003e70(int64_t * ptr) {
    // 0x100003e70
    _free(ptr);
}

// Address range: 0x100003e7c - 0x100003e88
int64_t * function_100003e7c(int32_t size) {
    // 0x100003e7c
    return _malloc(size);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(int32_t c) {
    // 0x100003e88
    return _putchar(c);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(char * s) {
    // 0x100003e94
    return _puts(s);
}

// Address range: 0x100003ea0 - 0x100003eac
char * function_100003ea0(char * s, int32_t c) {
    // 0x100003ea0
    return _strchr(s, c);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(char * s) {
    // 0x100003eac
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

