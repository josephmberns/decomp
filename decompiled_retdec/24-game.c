//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <setjmp.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___sigset_t {
    int32_t e0[1];
};

struct __jmp_buf_tag {
    int32_t e0[8];
    int32_t e1;
    struct _TYPEDEF___sigset_t e2;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000030ac(void);
int64_t function_100003120(void);
int64_t function_1000031f8(void);
int64_t function_100003288(int64_t a1);
int64_t function_1000032f8(void);
int64_t function_100003354(void);
int64_t function_100003484(void);
int64_t function_10000356c(void);
int64_t function_10000369c(void);
int64_t function_100003740(void);
int64_t function_1000037ec(void);
int64_t function_100003848(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003a30(void);
void function_100003da4(int32_t status);
char * function_100003db0(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003dbc(int32_t c);
void function_100003dc8(struct __jmp_buf_tag env[1], int32_t val);
int32_t function_100003dd4(char * format, ...);
int32_t function_100003de0(void);
int32_t function_100003dec(struct __jmp_buf_tag env[1]);
void function_100003df8(int32_t seed);
int32_t function_100003e04(int32_t * timer);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1120531; // 0x100008000
int64_t g2 = 0x80000408; // 0x100008140
int32_t * g3 = (int32_t *)12; // 0x100008148
char g4[13] = "__DATA_CONST"; // 0x100008248
char g5[9] = "TA_CONST"; // 0x10000824c
int32_t g6;

// ------- Dynamically Linked Functions Without Header --------

char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000030ac - 0x100003120
int64_t function_1000030ac(void) {
    int32_t result; // 0x1000030d4
    for (int64_t i = 0; i < 4; i++) {
        // 0x1000030d4
        result = _rand();
        *(int32_t *)(32 * i + (int64_t)"__TEXT" + 4) = result % 9 + 1;
    }
    // 0x100003114
    return result;
}

// Address range: 0x100003120 - 0x1000031f8
int64_t function_100003120(void) {
    // 0x100003120
    g2 = 0;
    *(int32_t *)&g5 = 0;
    *(int32_t *)&g4 = 0;
    int64_t v1 = 0;
    int64_t v2 = 32 * v1; // 0x100003168
    *(int32_t *)(v2 + (int64_t)&g3) = 0;
    *(int64_t *)(v2 + (int64_t)&g3 + 24) = 0;
    *(int64_t *)(v2 + (int64_t)&g3 + 16) = 0;
    v1++;
    int64_t v3 = 0; // 0x10000315c
    while (v1 != 8) {
        // 0x100003164
        v2 = 32 * v1;
        *(int32_t *)(v2 + (int64_t)&g3) = 0;
        *(int64_t *)(v2 + (int64_t)&g3 + 24) = 0;
        *(int64_t *)(v2 + (int64_t)&g3 + 16) = 0;
        v1++;
        v3 = 0;
    }
    *(int32_t *)(32 * v3 + (int64_t)"__TEXT" + 8) = 0;
    int64_t v4 = v3 + 1;
    v3 = v4;
    while (v4 != 4) {
        // 0x1000031c8
        *(int32_t *)(32 * v3 + (int64_t)"__TEXT" + 8) = 0;
        v4 = v3 + 1;
        v3 = v4;
    }
    // 0x1000031f0
    int64_t result; // 0x100003120
    return result;
}

// Address range: 0x1000031f8 - 0x100003288
int64_t function_1000031f8(void) {
    // 0x1000031f8
    _longjmp({(struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){.e0 = {(int32_t)&g1, 0, 0, 0, 0, 0, 0, 0}, .e1 = 0, .e2 = (struct {int32_t e0[1];}){.e0 = {0}}}}, 1);
    int32_t v1 = *(int32_t *)&g4; // 0x100003234
    int64_t result = 0; // 0x100003240
    if (v1 < 8 != (7 - v1 & v1) < 0) {
        // 0x100003248
        *(int32_t *)&g4 = v1 + 1;
        result = 32 * (int64_t)v1 + (int64_t)&g3;
    }
    // 0x10000327c
    return result;
}

// Address range: 0x100003288 - 0x1000032f8
int64_t function_100003288(int64_t a1) {
    int32_t v1 = *(int32_t *)&g5; // 0x10000329c
    char v2 = *(char *)((int64_t)v1 + (int64_t)"ONST"); // 0x1000032a8
    int32_t v3 = _isspace((int32_t)v2); // 0x1000032ac
    int32_t v4 = *(int32_t *)&g5;
    unsigned char v5; // 0x1000032ec
    if (v3 == 0) {
        // 0x1000032d8
        v5 = *(char *)((int64_t)v4 + (int64_t)"ONST");
        return (int64_t)v5 & 0xffffffff;
    }
    int32_t v6 = v4 + 1; // 0x1000032cc
    *(int32_t *)&g5 = v6;
    char v7 = *(char *)((int64_t)v6 + (int64_t)"ONST"); // 0x1000032a8
    int32_t v8 = _isspace((int32_t)v7); // 0x1000032ac
    int32_t v9 = *(int32_t *)&g5;
    while (v8 != 0) {
        // 0x1000032c0
        v6 = v9 + 1;
        *(int32_t *)&g5 = v6;
        v7 = *(char *)((int64_t)v6 + (int64_t)"ONST");
        v8 = _isspace((int32_t)v7);
        v9 = *(int32_t *)&g5;
    }
    // 0x1000032d8
    v5 = *(char *)((int64_t)v9 + (int64_t)"ONST");
    return (int64_t)v5 & 0xffffffff;
}

// Address range: 0x1000032f8 - 0x100003354
int64_t function_1000032f8(void) {
    int32_t v1 = *(int32_t *)&g5; // 0x100003304
    int64_t result = 0; // 0x10000331c
    if (*(char *)((int64_t)v1 + (int64_t)"ONST") != 0) {
        uint32_t v2 = v1 + 1; // 0x100003330
        *(int32_t *)&g5 = v2;
        result = v2;
    }
    // 0x100003348
    return result;
}

// Address range: 0x100003354 - 0x100003484
int64_t function_100003354(void) {
    int64_t result = function_100003484(); // 0x100003360
    if (result == 0) {
        // 0x10000337c
        function_1000031f8();
    }
    int32_t v1 = function_100003288((int64_t)&g6); // 0x100003394
    if (v1 != 43 && v1 != 45) {
        // 0x100003474
        return result;
    }
    if ((int32_t)function_1000032f8() == 0) {
        // 0x1000033e4
        function_1000031f8();
    }
    int64_t v2 = function_100003484(); // 0x1000033f4
    int64_t v3 = v2; // 0x100003408
    if (v2 == 0) {
        // 0x100003410
        v3 = function_1000031f8();
    }
    int64_t result2 = v3;
    *(int32_t *)result2 = v1 != 43 ? 3 : 2;
    *(int64_t *)(result2 + 16) = result;
    *(int64_t *)(result2 + 24) = v2;
    int32_t v4 = function_100003288((int64_t)&g6); // 0x100003394
    bool v5 = v4 == 43; // 0x1000033c8
    while (v4 == 43 || v4 == 45) {
        int64_t v6 = result2;
        if ((int32_t)function_1000032f8() == 0) {
            // 0x1000033e4
            function_1000031f8();
        }
        // 0x1000033f4
        v2 = function_100003484();
        v3 = v2;
        if (v2 == 0) {
            // 0x100003410
            v3 = function_1000031f8();
        }
        // 0x100003420
        result2 = v3;
        *(int32_t *)result2 = !v5 ? 3 : 2;
        *(int64_t *)(result2 + 16) = v6;
        *(int64_t *)(result2 + 24) = v2;
        v4 = function_100003288((int64_t)&g6);
        v5 = v4 == 43;
    }
    // 0x100003474
    return result2;
}

// Address range: 0x100003484 - 0x10000356c
int64_t function_100003484(void) {
    int64_t result = function_10000369c(); // 0x100003490
    int32_t v1 = function_100003288((int64_t)&g6); // 0x1000034a0
    if (v1 != 42 && v1 != 47) {
        // 0x10000355c
        return result;
    }
    if ((int32_t)function_1000032f8() == 0) {
        // 0x1000034f0
        function_1000031f8();
    }
    int64_t result2 = function_10000369c(); // 0x100003500
    *(int32_t *)result2 = v1 != 42 ? 5 : 4;
    *(int64_t *)(result2 + 16) = result;
    *(int64_t *)(result2 + 24) = result2;
    int32_t v2 = function_100003288((int64_t)&g6); // 0x1000034a0
    bool v3 = v2 == 42; // 0x1000034d4
    while (v2 == 42 || v2 == 47) {
        int64_t v4 = result2;
        if ((int32_t)function_1000032f8() == 0) {
            // 0x1000034f0
            function_1000031f8();
        }
        // 0x100003500
        result2 = function_10000369c();
        *(int32_t *)result2 = !v3 ? 5 : 4;
        *(int64_t *)(result2 + 16) = v4;
        *(int64_t *)(result2 + 24) = result2;
        v2 = function_100003288((int64_t)&g6);
        v3 = v2 == 42;
    }
    // 0x10000355c
    return result2;
}

// Address range: 0x10000356c - 0x10000369c
int64_t function_10000356c(void) {
    // 0x10000356c
    int64_t v1; // 0x10000356c
    int32_t v2 = function_100003288(v1); // 0x10000357c
    int32_t v3 = v2 - 48; // 0x100003584
    if (v3 < 0 != (47 - v2 & v2) < 0) {
        // 0x10000368c
        return 0;
    }
    int32_t v4 = v2 - 57; // 0x100003598
    if (v4 != 0 && v4 < 0 == (56 - v2 & v2) < 0) {
        // 0x10000368c
        return 0;
    }
    int64_t v5 = function_1000032f8(); // 0x1000035a8
    *(int32_t *)v5 = 1;
    *(int32_t *)(v5 + 4) = v3;
    int64_t v6 = 0;
    int32_t v7 = 0; // 0x10000356c
    int64_t result; // 0x10000356c
    int32_t * v8; // 0x10000356c
    while (true) {
        int32_t v9 = v7;
        uint64_t v10 = v6;
        int64_t v11 = 32 * v10; // 0x1000035f8
        if (*(int32_t *)(v11 + (int64_t)"__TEXT" + 4) == v3) {
            // 0x100003618
            v8 = (int32_t *)(v11 + (int64_t)"__TEXT" + 8);
            if (*v8 == 0) {
                // break -> 0x10000363c
                break;
            }
        }
        // 0x100003664
        v6 = v10 + 1;
        v7 = v9 + 1;
        if (v10 < 3 == (2 - v9 & (int32_t)v6) < 0) {
            // 0x100003674
            function_1000031f8();
            result = 0;
            return result;
        }
    }
    // 0x10000363c
    *v8 = 1;
    result = v5;
  lab_0x10000368c:
    // 0x10000368c
    return result;
}

// Address range: 0x10000369c - 0x100003740
int64_t function_10000369c(void) {
    int64_t result = function_10000356c(); // 0x1000036a8
    if (result != 0) {
        // 0x100003730
        return result;
    }
    // 0x1000036d0
    if ((int32_t)function_100003288((int64_t)&g6) != 40) {
        // 0x100003730
        return 0;
    }
    // 0x1000036e8
    function_1000032f8();
    int64_t result2 = function_100003354(); // 0x1000036ec
    if ((int32_t)function_100003288(result2) != 41) {
        // 0x100003708
        function_1000031f8();
    }
    // 0x100003718
    function_1000032f8();
    // 0x100003730
    return result2;
}

// Address range: 0x100003740 - 0x1000037ec
int64_t function_100003740(void) {
    int64_t result = function_100003354(); // 0x10000374c
    if ((int32_t)function_100003288(result) != 0) {
        // 0x100003768
        function_1000031f8();
    }
    for (int64_t i = 0; i < 4; i++) {
        // 0x100003794
        if (*(int32_t *)(32 * i + (int64_t)"__TEXT" + 8) == 0) {
            // 0x1000037b8
            function_1000031f8();
        }
    }
    // 0x1000037dc
    return result;
}

// Address range: 0x1000037ec - 0x100003848
int64_t function_1000037ec(void) {
    // 0x1000037ec
    int64_t v1; // 0x1000037ec
    int32_t v2 = v1; // 0x1000037f0
    int32_t result = v1; // 0x1000037f4
    if (v2 == 0) {
        // 0x10000383c
        return result;
    }
    int32_t result2 = v2;
    int32_t v3 = result % result2;
    int32_t v4 = result2; // 0x100003808
    while (v3 != 0) {
        // 0x100003810
        result2 = v3;
        v3 = v4 % result2;
        v4 = result2;
    }
    // 0x10000383c
    return result2;
}

// Address range: 0x100003848 - 0x100003a20
int64_t function_100003848(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003848
    int64_t v1; // 0x100003848
    int32_t * v2 = (int32_t *)v1; // 0x100003858
    if ((int32_t)v1 == 1) {
        // 0x100003874
        *v2 = 1;
        // 0x1000038d4
        int64_t result; // 0x100003848
        return result;
    }
    // 0x100003894
    function_100003848(v1, (int64_t)&g6, (int64_t)&g6, (int64_t)&g6);
    int64_t result2 = function_100003848((int64_t)&g6, (int64_t)&g6, (int64_t)&g6, (int64_t)&g6); // 0x1000038b0
    uint32_t v3 = (int32_t)result2 - 2; // 0x1000038bc
    if (v3 >= 3 != v3 != 3) {
        // 0x1000038d4
        return result2;
    }
    int64_t result3 = function_1000037ec(); // 0x1000039d0
    int32_t v4 = result3; // 0x1000039d4
    if (v4 != 0) {
        // 0x1000039e8
        *v2 = (int32_t)v1 / v4;
        int32_t * v5 = (int32_t *)(v1 + 4); // 0x100003a04
        *v5 = *v5 / v4;
    }
    // 0x1000038d4
    return result3;
}

// Address range: 0x100003a30 - 0x100003c34
int64_t function_100003a30(void) {
    // 0x100003a30
    function_100003120();
    _printf("\nAvailable digits are:");
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003a6c
        int64_t v1; // 0x100003a30
        _printf(" %d", v1);
    }
    // 0x100003aac
    _printf(". Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr/n/q] ");
    for (int64_t i = 0; i < 64; i++) {
        // 0x100003ad8
        *(char *)(i + (int64_t)"ONST") = 10;
    }
    char * v2 = _fgets("ONST", 64, (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000); // 0x100003b20
    int64_t result = (int64_t)v2; // 0x100003b54
    if (*(char *)((int64_t)"ONST" + 63) != 10) {
        // 0x100003b5c
        result = function_1000031f8();
    }
    for (int64_t i = 0; i < 64; i++) {
        char * v3 = (char *)(i + (int64_t)"ONST"); // 0x100003b94
        if (*v3 == 10) {
            // 0x100003ba8
            *v3 = 0;
        }
    }
    // 0x100003c28
    return result;
}

// Address range: 0x100003c34 - 0x100003da4
int64_t entry_point(void) {
    // 0x100003c34
    _srand(_time(NULL));
    function_1000030ac();
    int32_t v1; // bp-28, 0x100003c34
    int64_t v2 = &v1;
    while (true) {
        // 0x100003c58
        function_100003a30();
        _setjmp({(struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){.e0 = {(int32_t)&g1, 0, 0, 0, 0, 0, 0, 0}, .e1 = 0, .e2 = (struct {int32_t e0[1];}){.e0 = {0}}}});
        int64_t v3; // 0x100003c34
        int64_t v4; // 0x100003c34
        if (g2 != 0) {
            _printf("%s at '%.*s'\n", (char *)v4, v3, (char *)v3);
            function_100003a30();
            _setjmp({(struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){.e0 = {(int32_t)&g1, 0, 0, 0, 0, 0, 0, 0}, .e1 = 0, .e2 = (struct {int32_t e0[1];}){.e0 = {0}}}});
            // 0x100003c84
            while (g2 != 0) {
                // 0x100003c84
                _printf("%s at '%.*s'\n", (char *)v4, v3, (char *)v3);
                function_100003a30();
                _setjmp({(struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){.e0 = {(int32_t)&g1, 0, 0, 0, 0, 0, 0, 0}, .e1 = 0, .e2 = (struct {int32_t e0[1];}){.e0 = {0}}}});
            }
        }
        // 0x100003cc8
        function_100003740();
        function_100003848((int64_t)&g6, (int64_t)&g6, (int64_t)&g6, (int64_t)&g6);
        if (v1 == 0) {
            // 0x100003ce8
            function_1000031f8();
        }
        // 0x100003cf8
        int32_t v5; // 0x100003c34
        if (v5 == 24 == v1 == 1) {
            // 0x100003d20
            _printf("You got 24.  Very good.\n");
        } else {
            if (v1 == 1) {
                // 0x100003d44
                _printf("Eval to: %d, ", v2);
            } else {
                // 0x100003d64
                _printf("Eval to: %d/%d, ", v2, v3);
            }
            // 0x100003d90
            _printf("no good.  Try again.\n");
        }
        // 0x100003da0
        v4 = v2;
    }
}

// Address range: 0x100003da4 - 0x100003db0
void function_100003da4(int32_t status) {
    // 0x100003da4
    _exit(status);
}

// Address range: 0x100003db0 - 0x100003dbc
char * function_100003db0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003db0
    return _fgets(s, n, stream);
}

// Address range: 0x100003dbc - 0x100003dc8
int32_t function_100003dbc(int32_t c) {
    // 0x100003dbc
    return _isspace(c);
}

// Address range: 0x100003dc8 - 0x100003dd4
void function_100003dc8(struct __jmp_buf_tag env[1], int32_t val) {
    // 0x100003dc8
    _longjmp(env, val);
}

// Address range: 0x100003dd4 - 0x100003de0
int32_t function_100003dd4(char * format, ...) {
    // 0x100003dd4
    return _printf(format);
}

// Address range: 0x100003de0 - 0x100003dec
int32_t function_100003de0(void) {
    // 0x100003de0
    return _rand();
}

// Address range: 0x100003dec - 0x100003df8
int32_t function_100003dec(struct __jmp_buf_tag env[1]) {
    // 0x100003dec
    return _setjmp(env);
}

// Address range: 0x100003df8 - 0x100003e04
void function_100003df8(int32_t seed) {
    // 0x100003df8
    _srand(seed);
}

// Address range: 0x100003e04 - 0x100003e10
int32_t function_100003e04(int32_t * timer) {
    // 0x100003e04
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 23

