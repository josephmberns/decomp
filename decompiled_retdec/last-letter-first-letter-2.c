//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000312c(void);
int64_t function_10000321c(void);
int64_t function_100003308(void);
int64_t function_10000367c(void);
int64_t function_100003738(void);
int64_t function_100003914(void);
int64_t function_10000397c(void);
int64_t function_1000039e8(void);
int64_t function_100003a5c(void);
void function_100003e84(void);
void function_100003e90(int64_t * s, int32_t n);
int64_t * function_100003e9c(int32_t nmemb, int32_t size);
int32_t function_100003ea8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003eb4(char * filename, char * modes);
int32_t function_100003ec0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003ecc(int64_t * ptr);
int32_t function_100003ed8(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003ee4(struct _IO_FILE * stream);
int32_t function_100003ef0(int32_t c);
int64_t * function_100003efc(int32_t size);
int32_t function_100003f08(char * format, ...);
int32_t function_100003f14(int32_t c);
int32_t function_100003f20(char * s);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1120531; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
int64_t g3 = 0x4b800000012; // 0x100008010
int64_t g4 = 0; // 0x10000ab20

// ------- Dynamically Linked Functions Without Header --------

void _abort(void);
void _bzero(int64_t * a1, int32_t a2);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _ftell(struct _IO_FILE * a1);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000312c - 0x10000321c
int64_t function_10000312c(void) {
    // 0x10000312c
    int64_t result; // 0x10000312c
    if (result != 0) {
        int64_t v1 = 0x100000000000000 * result;
        int64_t v2 = 424 * (v1 >> 56); // 0x10000316c
        int64_t v3 = (int64_t)*(char *)(result + 1); // 0x100003188
        int64_t v4 = *(int64_t *)(v2 + (int64_t)&g3 + 8 * v3); // 0x10000318c
        *(int64_t *)(result + 16) = v4;
        int32_t * v5 = (int32_t *)(v2 + (int64_t)&g3 + 320 + 4 * v3); // 0x1000031b8
        *v5 = *v5 + 1;
        int32_t * v6 = (int32_t *)(v2 + (int64_t)&g3 + 212); // 0x1000031c8
        *v6 = *v6 + 1;
        int64_t v7 = 424 * v3; // 0x1000031d8
        int32_t * v8 = (int32_t *)((v1 >> 54) + (int64_t)&g3 + 216 + v7); // 0x1000031f4
        *v8 = *v8 + 1;
        int32_t * v9 = (int32_t *)(v7 + (int64_t)&g3 + 208); // 0x100003204
        *v9 = *v9 + 1;
    }
    // 0x100003214
    return result;
}

// Address range: 0x10000321c - 0x100003308
int64_t function_10000321c(void) {
    // 0x10000321c
    int64_t v1; // 0x10000321c
    int64_t v2 = 0x100000000 * v1;
    int64_t v3 = 424 * (v2 >> 32); // 0x100003230
    int64_t v4 = 0x100000000 * v1;
    int64_t * v5 = (int64_t *)((v4 >> 29) + (int64_t)&g3 + v3); // 0x10000324c
    int64_t result = *v5; // 0x10000324c
    if (result != 0) {
        int64_t * v6 = (int64_t *)(result + 16); // 0x10000326c
        *v5 = *v6;
        *v6 = 0;
        int32_t * v7 = (int32_t *)((v4 >> 30) + (int64_t)&g3 + 320 + v3); // 0x100003294
        *v7 = *v7 - 1;
        int32_t * v8 = (int32_t *)(v3 + (int64_t)&g3 + 212); // 0x1000032a4
        *v8 = *v8 - 1;
        int64_t v9 = 424 * (v4 >> 32); // 0x1000032b8
        int32_t * v10 = (int32_t *)(v9 + (int64_t)&g3 + 216 + (v2 >> 30)); // 0x1000032dc
        *v10 = *v10 - 1;
        int32_t * v11 = (int32_t *)(v9 + (int64_t)&g3 + 208); // 0x1000032ec
        *v11 = *v11 - 1;
    }
    // 0x1000032fc
    return result;
}

// Address range: 0x100003308 - 0x10000367c
int64_t function_100003308(void) {
    struct _IO_FILE * v1 = _fopen("poke646", "rt"); // 0x100003324
    if (v1 == NULL) {
        // 0x100003340
        _abort();
    }
    // 0x100003344
    _fseek(v1, 0, 2);
    int32_t v2 = _ftell(v1); // 0x10000335c
    int64_t * v3 = _malloc(v2 + 1); // 0x100003378
    int64_t v4 = (int64_t)v3; // 0x100003378
    _fseek(v1, 0, 0);
    _fread(v3, 1, v2, v1);
    _fclose(v1);
    *(char *)(v4 + (int64_t)v2) = 0;
    g1 = 0;
    int32_t v5 = -v2; // 0x1000033d8
    int32_t v6 = 0; // 0x1000033e0
    if (v5 < 0 != (v2 & v5) < 0) {
        char * v7 = (char *)((int64_t)v6 + v4); // 0x1000033f0
        if (_isspace((int32_t)*v7) != 0) {
            // 0x100003408
            *v7 = 0;
            g1++;
        }
        // 0x100003434
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x1000033e8
            v7 = (char *)((int64_t)v6 + v4);
            if (_isspace((int32_t)*v7) != 0) {
                // 0x100003408
                *v7 = 0;
                g1++;
            }
            // 0x100003434
            v6++;
        }
    }
    // 0x100003444
    if (*(char *)(v4 + (int64_t)(v2 - 1)) != 0) {
        // 0x100003468
        g1++;
    }
    // 0x100003480
    _bzero(&g3, 0x2b10);
    g4 = (int64_t)_calloc(g1, 8);
    int64_t * v8 = _malloc(24 * g1); // 0x1000034c4
    g2 = (int64_t)v8;
    int32_t v9 = -g1; // 0x1000034f4
    if (v9 < 0 == (g1 & v9) < 0) {
        // 0x10000364c
        return _printf("read %d names\n", 8);
    }
    char * v10 = (char *)v8; // 0x100003308
    int32_t v11 = 0; // 0x100003634
    int32_t v12 = v2; // 0x100003308
    int64_t v13; // 0x100003308
    int32_t v14; // 0x100003308
    int32_t v15; // 0x100003568
    while (true) {
      lab_0x100003504:
        // 0x100003504
        v14 = v11;
        char * v16 = v10;
        int64_t * v17; // 0x100003308
        int64_t v18; // 0x100003308
        if (v14 == 0) {
            int64_t v19 = (int64_t)v16;
            int64_t * v20 = (int64_t *)(v19 + 8);
            *v20 = v4;
            v18 = v4;
            v17 = v20;
            v13 = v19;
        } else {
            int64_t v21 = *(int64_t *)(24 * (int64_t)(v14 - 1) + 8 + g2); // 0x100003534
            int64_t v22 = (int64_t)v12 + 1 + v21; // 0x100003540
            int64_t v23 = (int64_t)v16;
            int64_t * v24 = (int64_t *)(v23 + 8);
            *v24 = v22;
            v18 = v22;
            v17 = v24;
            v13 = v23;
        }
        // 0x100003560
        v15 = _strlen((char *)v18);
        *v16 = *(char *)*v17 - 97;
        char v25 = *(char *)(*v17 + (int64_t)(v15 - 1)) - 97; // 0x1000035a0
        *(char *)(v13 + 1) = v25;
        char v26 = *v16; // 0x1000035b0
        if (v26 < 0) {
            // 0x10000360c
            _printf("bad name %s: first/last char must be letter\n", (char *)8);
            _abort();
            goto lab_0x100003630;
        } else {
            int32_t v27 = v26; // 0x1000035c8
            if (v25 < 0 || v26 < 26 == (25 - v27 & v27) < 0) {
                // 0x10000360c
                _printf("bad name %s: first/last char must be letter\n", (char *)8);
                _abort();
                goto lab_0x100003630;
            } else {
                int32_t v28 = v25; // 0x1000035f8
                if (v25 < 26 == (25 - v28 & v28) < 0) {
                    // 0x10000360c
                    _printf("bad name %s: first/last char must be letter\n", (char *)8);
                    _abort();
                    goto lab_0x100003630;
                } else {
                    goto lab_0x100003630;
                }
            }
        }
    }
    // 0x10000364c
    return _printf("read %d names\n", 8);
  lab_0x100003630:
    // 0x100003630
    v11 = v14 + 1;
    int32_t v29 = v11 - g1; // 0x1000034f4
    v10 = (char *)(v13 + 24);
    v12 = v15;
    if (v29 < 0 == ((v29 ^ v11) & (g1 ^ v11)) < 0) {
        return _printf("read %d names\n", 8);
    }
    goto lab_0x100003504;
}

// Address range: 0x10000367c - 0x100003738
int64_t function_10000367c(void) {
    // 0x10000367c
    int64_t v1; // 0x10000367c
    int64_t v2 = _printf("%d:", v1); // 0x1000036b8
    int32_t result; // 0x1000036dc
    while (true) {
        // 0x1000036bc
        if (v2 == 0) {
            // 0x1000036f0
            result = _putchar(10);
            if (result != 0) {
                // break -> 0x10000372c
                break;
            }
        }
        // 0x1000036fc
        _printf(" %s", (char *)v1);
        v2 += 16;
    }
    // 0x10000372c
    return result;
}

// Address range: 0x100003738 - 0x100003914
int64_t function_100003738(void) {
    // 0x100003738
    int64_t result; // 0x100003738
    int64_t v1 = 0x100000000 * result;
    int64_t v2 = 424 * (v1 >> 32) + (int64_t)&g3 + 320; // 0x100003760
    int64_t v3 = v1 >> 30; // 0x100003764
    if (*(int32_t *)(v2 + v3) != 0) {
        // 0x100003908
        return result;
    }
    int32_t v4 = -1;
    int32_t v5 = -1;
    int64_t v6 = 0;
    int32_t v7; // 0x100003738
    int32_t v8; // 0x100003738
    int32_t v9; // 0x1000038a0
    int32_t v10; // 0x1000038a8
    bool v11; // 0x1000038ac
    int32_t v12; // 0x10000380c
    int32_t v13; // 0x100003814
    bool v14; // 0x100003818
    int64_t v15; // 0x10000385c
    if ((int32_t)result == 0) {
        // 0x100003854
        v15 = 424 * v6;
        v7 = v4;
        v8 = v5;
        if (*(int32_t *)(v3 + (int64_t)&g3 + 320 + v15) != 0) {
            // 0x100003888
            v9 = *(int32_t *)(v15 + (int64_t)&g3 + 208);
            v10 = v9 - v4;
            v11 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v4)) < 0;
            v7 = v11 ? v4 : v9;
            v8 = v11 ? v5 : (int32_t)v6;
        }
    } else {
        // 0x1000037c0
        v7 = v4;
        v8 = v5;
        if (*(int32_t *)(4 * v6 + v2) != 0) {
            // 0x1000037f4
            v12 = *(int32_t *)(424 * v6 + (int64_t)&g3 + 212);
            v13 = v12 - v4;
            v14 = v13 == 0 | v13 < 0 != ((v13 ^ v12) & (v12 ^ v4)) < 0;
            v7 = v14 ? v4 : v12;
            v8 = v14 ? v5 : (int32_t)v6;
        }
    }
    int32_t result2 = v8;
    int64_t v16 = v6 + 1;
    while (v16 != 26) {
        // 0x1000037ac
        v4 = v7;
        v5 = result2;
        v6 = v16;
        if ((int32_t)result == 0) {
            // 0x100003854
            v15 = 424 * v6;
            v7 = v4;
            v8 = v5;
            if (*(int32_t *)(v3 + (int64_t)&g3 + 320 + v15) != 0) {
                // 0x100003888
                v9 = *(int32_t *)(v15 + (int64_t)&g3 + 208);
                v10 = v9 - v4;
                v11 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v4)) < 0;
                v7 = v11 ? v4 : v9;
                v8 = v11 ? v5 : (int32_t)v6;
            }
        } else {
            // 0x1000037c0
            v7 = v4;
            v8 = v5;
            if (*(int32_t *)(4 * v6 + v2) != 0) {
                // 0x1000037f4
                v12 = *(int32_t *)(424 * v6 + (int64_t)&g3 + 212);
                v13 = v12 - v4;
                v14 = v13 == 0 | v13 < 0 != ((v13 ^ v12) & (v12 ^ v4)) < 0;
                v7 = v14 ? v4 : v12;
                v8 = v14 ? v5 : (int32_t)v6;
            }
        }
        // 0x1000038ec
        result2 = v8;
        v16 = v6 + 1;
    }
    // 0x100003908
    return result2;
}

// Address range: 0x100003914 - 0x10000397c
int64_t function_100003914(void) {
    // 0x100003958
    int64_t result; // 0x100003914
    int32_t * v1 = (int32_t *)(result + 16); // 0x100003968
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x10000397c - 0x1000039e8
int64_t function_10000397c(void) {
    // 0x10000397c
    int64_t result; // 0x10000397c
    if (*(int64_t *)(result + 8) == 0) {
        // branch -> 0x1000039c4
    }
    int32_t * v1 = (int32_t *)(result + 16); // 0x1000039d4
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x1000039e8 - 0x100003a5c
int64_t function_1000039e8(void) {
    // 0x1000039e8
    int64_t result; // 0x1000039e8
    if (result == 0) {
        // 0x100003a50
        return result;
    }
    int64_t v1 = result + 16; // 0x100003a14
    *(int64_t *)result = *(int64_t *)v1;
    int32_t * v2 = (int32_t *)v1; // 0x100003a24
    int32_t v3 = *v2 - 1; // 0x100003a28
    *v2 = v3;
    if (v3 == 0) {
        // 0x100003a40
        *(int64_t *)(result + 8) = 0;
    }
    // 0x100003a50
    return result;
}

// Address range: 0x100003a5c - 0x100003d5c
int64_t function_100003a5c(void) {
    int64_t * v1 = _calloc(1, 128); // 0x100003a74
    if ((int32_t)function_100003738() >= 0) {
        function_10000321c();
        function_100003914();
        while ((int32_t)function_100003738() >= 0) {
            // 0x100003aa8
            function_10000321c();
            function_100003914();
        }
    }
    // 0x100003ae4
    if ((int32_t)function_100003738() >= 0) {
        function_10000321c();
        function_10000397c();
        while ((int32_t)function_100003738() >= 0) {
            // 0x100003b04
            function_10000321c();
            function_10000397c();
        }
    }
    int64_t result = (int64_t)v1; // 0x100003a74
    int32_t v2 = 0;
    char * v3 = (char *)*v1; // 0x100003b44
    int32_t v4 = -v2;
    int32_t v5 = 0; // 0x100003b60
    char * v6 = v3; // 0x100003b60
    int64_t v7; // 0x100003b6c
    int32_t v8; // 0x100003b58
    if (v4 < 0 != (v2 & v4) < 0) {
        v7 = *(int64_t *)((int64_t)v6 + 16);
        while (v7 != 0) {
            // 0x100003b50
            v5++;
            v8 = v5 - v2;
            if (v8 < 0 == ((v8 ^ v5) & (v5 ^ v2)) < 0) {
                // break -> 0x100003ba0
                break;
            }
            v7 = *(int64_t *)((int64_t)(char *)v7 + 16);
        }
        return result;
    }
    while (v3 != NULL) {
        int32_t v9 = v4; // 0x100003bf0
        int32_t v10 = 0; // 0x100003bf0
        if ((int32_t)function_100003738() >= 0) {
            int32_t v11 = 0;
            int64_t v12 = function_10000321c(); // 0x100003c00
            int32_t v13 = v11; // 0x100003c14
            while (v12 != 0) {
                int32_t v14 = v11 + 1; // 0x100003c38
                *(int64_t *)(g4 + 8 * (int64_t)v11) = v12;
                int32_t v15 = v14; // 0x100003bf0
                v13 = v14;
                if ((int32_t)function_100003738() < 0) {
                    // break -> 0x100003c54
                    break;
                }
                v11 = v15;
                v12 = function_10000321c();
                v13 = v11;
            }
            // 0x100003c54
            v10 = v13;
            v9 = v10 - v2;
        }
        int32_t v16 = v10;
        int32_t v17 = v9;
        int32_t v18; // 0x100003a5c
        if (v17 == 0 || v17 < 0 != ((v17 ^ v16) & (v16 ^ v2)) < 0) {
            int32_t v19 = v16 - 1; // 0x100003d10
            int32_t v20 = v19; // 0x100003d20
            v18 = v2;
            if (v19 >= 0) {
                function_10000312c();
                int32_t v21 = v20 - 1; // 0x100003d10
                v20 = v21;
                v18 = v2;
                while (v21 >= 0) {
                    // 0x100003d28
                    function_10000312c();
                    v21 = v20 - 1;
                    v20 = v21;
                    v18 = v2;
                }
            }
        } else {
            // 0x100003c74
            if (v4 < 0 != (v2 & v4) < 0) {
                function_1000039e8();
                function_10000312c();
                int32_t v22 = 1; // 0x100003ca0
                int32_t v23 = v22 - v2; // 0x100003c7c
                int32_t v24 = v22; // 0x100003c84
                while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v2)) < 0) {
                    // 0x100003c8c
                    function_1000039e8();
                    function_10000312c();
                    v22 = v24 + 1;
                    v23 = v22 - v2;
                    v24 = v22;
                }
            }
            int32_t v25 = -v16; // 0x100003cbc
            v18 = -1;
            if (v25 < 0 != (v16 & v25) < 0) {
                function_100003914();
                int32_t v26 = 1; // 0x100003cf0
                int32_t v27 = v26 - v16; // 0x100003cbc
                int32_t v28 = v26; // 0x100003cc4
                v18 = -1;
                while (v27 < 0 != ((v27 ^ v26) & (v26 ^ v16)) < 0) {
                    // 0x100003ccc
                    function_100003914();
                    v26 = v28 + 1;
                    v27 = v26 - v16;
                    v28 = v26;
                    v18 = -1;
                }
            }
        }
        // 0x100003d4c
        v2 = v18 + 1;
        v3 = (char *)*v1;
        v4 = -v2;
        int32_t v29 = 0; // 0x100003b60
        v6 = v3;
        if (v4 < 0 != (v2 & v4) < 0) {
            v7 = *(int64_t *)((int64_t)v6 + 16);
            while (v7 != 0) {
                // 0x100003b50
                v5 = v29 + 1;
                v8 = v5 - v2;
                v29 = v5;
                if (v8 < 0 == ((v8 ^ v5) & (v5 ^ v2)) < 0) {
                    // break -> 0x100003ba0
                    break;
                }
                v7 = *(int64_t *)((int64_t)(char *)v7 + 16);
            }
            return result;
        }
    }
    // 0x100003bb4
    return result;
}

// Address range: 0x100003d5c - 0x100003e84
int64_t entry_point(void) {
    // 0x100003d5c
    function_100003308();
    int32_t v1 = 0; // 0x100003e30
    for (int32_t i = 0; i < 26; i++) {
        int32_t v2 = v1;
        _bzero(&g3, 0x2b10);
        int32_t v3 = -g1; // 0x100003db8
        if (v3 < 0 != (g1 & v3) < 0) {
            function_10000312c();
            int32_t v4 = 1; // 0x100003df0
            int32_t v5 = v4 - g1; // 0x100003db8
            int32_t v6 = v4; // 0x100003dc0
            while (v5 < 0 != ((v5 ^ v4) & (g1 ^ v4)) < 0) {
                // 0x100003dc8
                function_10000312c();
                v4 = v6 + 1;
                v5 = v4 - g1;
                v6 = v4;
            }
        }
        int64_t v7 = function_100003a5c(); // 0x100003e00
        int32_t * v8 = (int32_t *)(v7 + 16); // 0x100003e0c
        int32_t v9 = *v8; // 0x100003e0c
        int32_t v10 = v9 - v2; // 0x100003e14
        v1 = v2;
        if (v10 != 0 && v10 < 0 == ((v10 ^ v9) & (v9 ^ v2)) < 0) {
            // 0x100003e24
            function_10000367c();
            v1 = *v8;
        }
        // 0x100003e3c
        _free((int64_t *)v7);
    }
    // 0x100003e58
    _printf("longest found: %d\n", 0x2b10);
    return 0;
}

// Address range: 0x100003e84 - 0x100003e90
void function_100003e84(void) {
    // 0x100003e84
    _abort();
}

// Address range: 0x100003e90 - 0x100003e9c
void function_100003e90(int64_t * s, int32_t n) {
    // 0x100003e90
    _bzero(s, n);
}

// Address range: 0x100003e9c - 0x100003ea8
int64_t * function_100003e9c(int32_t nmemb, int32_t size) {
    // 0x100003e9c
    return _calloc(nmemb, size);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(struct _IO_FILE * stream) {
    // 0x100003ea8
    return _fclose(stream);
}

// Address range: 0x100003eb4 - 0x100003ec0
struct _IO_FILE * function_100003eb4(char * filename, char * modes) {
    // 0x100003eb4
    return _fopen(filename, modes);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ec0
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003ecc - 0x100003ed8
void function_100003ecc(int64_t * ptr) {
    // 0x100003ecc
    _free(ptr);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003ed8
    return _fseek(stream, off, whence);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(struct _IO_FILE * stream) {
    // 0x100003ee4
    return _ftell(stream);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(int32_t c) {
    // 0x100003ef0
    return _isspace(c);
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int32_t size) {
    // 0x100003efc
    return _malloc(size);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(int32_t c) {
    // 0x100003f14
    return _putchar(c);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * s) {
    // 0x100003f20
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 24

