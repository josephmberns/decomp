//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
float64_t function_100003f00(char * nptr);
void function_100003f0c(int64_t * ptr);
int64_t * function_100003f18(int32_t size);
int32_t function_100003f24(char * format, ...);
char * function_100003f30(int32_t category, char * locale);
int32_t function_100003f3c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strncpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
float64_t _atof(char * a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bc8 - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003bc8
    int64_t v1; // 0x100003bc8
    int32_t v2 = v1; // 0x100003bd8
    if (v2 == 1) {
        // 0x100003bf4
        _printf("Usage : %s <data points separated by spaces or commas>", (char *)v1);
        // 0x100003ee4
        return 0;
    }
    int64_t * v3 = _malloc(8 * v2 - 8); // 0x100003c30
    int64_t v4 = (int64_t)v3; // 0x100003c30
    int32_t v5 = 1 - v2;
    int128_t v6; // 0x100003bc8
    int64_t v7 = v6; // 0x100003c54
    int64_t v8; // 0x100003bc8
    int64_t v9; // 0x100003bc8
    int64_t v10; // 0x100003bc8
    float64_t v11; // 0x100003bc8
    float64_t v12; // 0x100003bc8
    int64_t v13; // 0x100003bc8
    float64_t v14; // 0x100003bc8
    float64_t v15; // 0x100003bc8
    float64_t v16; // bp-56, 0x100003bc8
    int32_t v17; // 0x100003bc8
    int32_t v18; // 0x100003bc8
    int64_t v19; // 0x100003bc8
    int64_t v20; // 0x100003bc8
    int64_t v21; // 0x100003bc8
    if (v5 < 0 != (v5 & v2) < 0) {
        // 0x100003c5c
        float64_t v22; // 0x100003bc8
        v8 = v22;
        v17 = 1;
        float64_t v23; // 0x100003bc8
        while (true) {
          lab_0x100003c5c:
            // 0x100003c5c
            v18 = v17;
            int64_t v24 = v8;
            int64_t * v25 = (int64_t *)(8 * (int64_t)v18 + v1); // 0x100003c64
            int32_t v26 = _strlen((char *)*v25); // 0x100003c68
            int64_t v27 = *v25; // 0x100003c7c
            int32_t v28 = v26 - 1; // 0x100003c84
            float64_t v29; // 0x100003bc8
            int64_t v30; // 0x100003bc8
            if (*(char *)(v27 + (int64_t)v28) == 44) {
                int64_t * v31 = _malloc(v26); // 0x100003ca4
                int64_t v32 = *v25; // 0x100003cb8
                ___strncpy_chk((int64_t)v31, v32, (int64_t)v28, -1);
                float64_t v33 = _atof((char *)v31); // 0x100003cd8
                *(int64_t *)((int64_t)(8 * v18 - 8) + v4) = v24;
                _free(v31);
                v29 = v33;
                v30 = v32;
            } else {
                float64_t v34 = _atof((char *)v27); // 0x100003d04
                *(int64_t *)((int64_t)(8 * v18 - 8) + v4) = v24;
                v29 = v34;
                v30 = v19;
            }
            // 0x100003d1c
            v21 = v30;
            v23 = v29;
            float64_t v35; // bp-48, 0x100003bc8
            if (v18 == 1) {
                int64_t v36 = *v3;
                v35 = v36;
                v16 = v36;
                v11 = v36;
                v12 = v36;
                v13 = v36;
                goto lab_0x100003e04;
            } else {
                float64_t v37 = v35; // 0x100003d5c
                int64_t v38 = (int64_t)(8 * v18 - 8) + v4; // 0x100003d6c
                float64_t * v39 = (float64_t *)v38; // 0x100003d6c
                if (v37 > *v39) {
                    // 0x100003d80
                    v9 = v37;
                } else {
                    // 0x100003d8c
                    v9 = *(int64_t *)v38;
                }
                // 0x100003da4
                v35 = v9;
                float64_t v40 = v16; // 0x100003dac
                float64_t v41 = *v39; // 0x100003dbc
                if (v40 == v41) {
                    // 0x100003ddc
                    v10 = *(int64_t *)v38;
                    goto lab_0x100003df4;
                } else {
                    v10 = v40;
                    if (v40 > v41 == v40 >= v41 == v40 <= v41) {
                        goto lab_0x100003df4;
                    } else {
                        // 0x100003ddc
                        v10 = *(int64_t *)v38;
                        goto lab_0x100003df4;
                    }
                }
            }
        }
      lab_0x100003c44:
        // 0x100003c44
        v14 = v11;
        v15 = v12;
        v7 = (float32_t)v23;
        v20 = v21;
    }
    // 0x100003e14
    _printf("\n%Max : %lf,Min : %lf,Range : %lf\n", v20, (float64_t)v7, (float64_t)(int64_t)v6, (float64_t)(int64_t)v6);
    _setlocale(0, (char *)0x100003fa2);
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003ee4
        return 0;
    }
    float64_t v42 = v15;
    int32_t v43 = 1; // 0x100003ed4
    float64_t v44 = *(float64_t *)((int64_t)(8 * v43 - 8) + v4); // 0x100003e84
    __asm_fcvtps(7.0 * (v44 - v42) / (v14 - v42));
    _printf("%lc", -94);
    v43++;
    while (v43 - v2 < 0 != ((v43 - v2 ^ v43) & (v43 ^ v2)) < 0) {
        // 0x100003e78
        v44 = *(float64_t *)((int64_t)(8 * v43 - 8) + v4);
        __asm_fcvtps(7.0 * (v44 - v42) / (v14 - v42));
        _printf("%lc", -94);
        v43++;
    }
    // 0x100003ee4
    return 0;
  lab_0x100003e04:;
    int32_t v45 = v18 + 1; // 0x100003e08
    int32_t v46 = v45 - v2; // 0x100003c4c
    v8 = v13;
    v17 = v45;
    v19 = v21;
    if (v46 < 0 == ((v46 ^ v45) & (v45 ^ v2)) < 0) {
        // break -> 0x100003c44
        goto lab_0x100003c44;
    }
    goto lab_0x100003c5c;
  lab_0x100003df4:
    // 0x100003df4
    v16 = v10;
    v11 = v10;
    v12 = v9;
    v13 = v10;
    goto lab_0x100003e04;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ef4
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f00 - 0x100003f0c
float64_t function_100003f00(char * nptr) {
    // 0x100003f00
    return _atof(nptr);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(int64_t * ptr) {
    // 0x100003f0c
    _free(ptr);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
char * function_100003f30(int32_t category, char * locale) {
    // 0x100003f30
    return _setlocale(category, locale);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * s) {
    // 0x100003f3c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

