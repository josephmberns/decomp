//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b60(void);
int64_t function_100003bec(void);
int64_t function_100003ee0(void);
void function_100003eec(int32_t status);
int32_t function_100003ef8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f04(char * filename, char * modes);
int32_t function_100003f10(struct _IO_FILE * stream);
float32_t function_100003f1c(float32_t a1);
int64_t * function_100003f28(int64_t * s, int32_t c, int32_t n);
void function_100003f34(char * s);
int32_t function_100003f40(char * format, ...);
int32_t function_100003f4c(char * s);

// --------------------- Global Variables ---------------------

float32_t * g1 = NULL; // 0x100008000
float32_t * g2 = NULL; // 0x100008024

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _getc(struct _IO_FILE * a1);
float32_t _log10f(float32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b60 - 0x100003bec
int64_t function_100003b60(void) {
    int64_t v1 = 1;
    float64_t v2; // 0x100003b60
    float64_t v3 = 1.0 / v2 + 1.0; // 0x100003ba4
    _log10f((float32_t)(int32_t)__asm_sshll(0.0f, 0));
    *(float32_t *)(4 * v1 + (int64_t)&g1 - 4) = (float32_t)v3;
    v1++;
    while (v1 != 10) {
        // 0x100003b8c
        v3 = 1.0 / v3 + 1.0;
        _log10f((float32_t)(int32_t)__asm_sshll(0.0f, 0));
        *(float32_t *)(4 * v1 + (int64_t)&g1 - 4) = (float32_t)v3;
        v1++;
    }
    // 0x100003bd8
    return (int64_t)&g1;
}

// Address range: 0x100003bec - 0x100003de8
int64_t function_100003bec(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c00
    int64_t v2; // 0x100003bec
    struct _IO_FILE * v3 = _fopen((char *)v2, "r"); // 0x100003c18
    if (v3 == NULL) {
        // 0x100003c34
        _perror("Can't open file");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003c48
    int64_t v4; // bp-60, 0x100003bec
    _memset(&v4, 0, 36);
    int32_t v5 = _getc(v3); // 0x100003c64
    int64_t v6 = &v4;
    float32_t v7 = 0.0f; // 0x100003c78
    if (v5 % 256 != 255) {
        float32_t v8 = 0.0f;
        int32_t v9 = v5; // 0x100003bec
        int32_t v10; // 0x100003bec
        int32_t v11; // 0x100003ca4
        int32_t v12; // 0x100003c84
        while (true) {
            // 0x100003c84
            v10 = 0x1000000 * v9;
            v12 = v10 >> 24;
            if (v10 < 0x31000000 == (48 - v12 & v12) < 0) {
                // 0x100003cb4
                v11 = v12 - 57;
                if (v11 == 0 || v11 < 0 != (56 - v12 & v12) < 0) {
                    // break -> 0x100003cd0
                    break;
                }
            }
            // 0x100003cc0
            v9 = _getc(v3);
        }
        int32_t * v13 = (int32_t *)(4 * (int64_t)(v12 - 49) + v6); // 0x100003ce0
        *v13 = *v13 + 1;
        uint32_t v14 = _getc(v3) % 256;
        while (v14 != 10 == (v14 != 255)) {
            // 0x100003cfc
            v14 = _getc(v3) % 256;
        }
        int32_t v15 = _getc(v3); // 0x100003c64
        float32_t v16 = (int32_t)v8 + 1; // 0x100003c78
        v7 = (int32_t)v8 + 1;
        while (v15 % 256 != 255) {
            // 0x100003c84
            v8 = v16;
            v9 = v15;
            while (true) {
                // 0x100003c84
                v10 = 0x1000000 * v9;
                v12 = v10 >> 24;
                if (v10 < 0x31000000 == (48 - v12 & v12) < 0) {
                    // 0x100003cb4
                    v11 = v12 - 57;
                    if (v11 == 0 || v11 < 0 != (56 - v12 & v12) < 0) {
                        // break -> 0x100003cd0
                        break;
                    }
                }
                // 0x100003cc0
                v9 = _getc(v3);
            }
            // 0x100003cd0
            v13 = (int32_t *)(4 * (int64_t)(v12 - 49) + v6);
            *v13 = *v13 + 1;
            v14 = _getc(v3) % 256;
            while (v14 != 10 == (v14 != 255)) {
                // 0x100003cfc
                v14 = _getc(v3) % 256;
            }
            // 0x100003c60
            v15 = _getc(v3);
            v16 = (int32_t)v8 + 1;
            v7 = (int32_t)v8 + 1;
        }
    }
    // 0x100003d4c
    _fclose(v3);
    for (int64_t i = 0; i < 9; i++) {
        int64_t v17 = 4 * i; // 0x100003d78
        float32_t v18 = *(float32_t *)(v17 + v6); // 0x100003d78
        *(float32_t *)(v17 + (int64_t)&g2) = v18 / v7;
    }
    // 0x100003db0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003dd0
        ___stack_chk_fail();
    }
    // 0x100003dd4
    return (int64_t)&g2;
}

// Address range: 0x100003de8 - 0x100003ee0
int64_t entry_point(void) {
    // 0x100003de8
    int64_t v1; // 0x100003de8
    if ((int32_t)v1 != 2) {
        // 0x100003e14
        _printf("Usage: benford <file>\n");
        // 0x100003ed0
        return 1;
    }
    // 0x100003e2c
    function_100003bec();
    function_100003b60();
    _puts("digit\tactual\texpected");
    for (int32_t i = 0; i < 9; i++) {
        // 0x100003e6c
        int128_t v2; // 0x100003de8
        _printf("%d\t%.3f\t%.3f\n", v1, (float64_t)(int64_t)v2, (float64_t)(int64_t)v2);
    }
    // 0x100003ed0
    return 0;
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t function_100003ee0(void) {
    // 0x100003ee0
    return ___stack_chk_fail();
}

// Address range: 0x100003eec - 0x100003ef8
void function_100003eec(int32_t status) {
    // 0x100003eec
    _exit(status);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(struct _IO_FILE * stream) {
    // 0x100003ef8
    return _fclose(stream);
}

// Address range: 0x100003f04 - 0x100003f10
struct _IO_FILE * function_100003f04(char * filename, char * modes) {
    // 0x100003f04
    return _fopen(filename, modes);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(struct _IO_FILE * stream) {
    // 0x100003f10
    return _getc(stream);
}

// Address range: 0x100003f1c - 0x100003f28
float32_t function_100003f1c(float32_t a1) {
    // 0x100003f1c
    return _log10f(a1);
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f28
    return _memset(s, c, n);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(char * s) {
    // 0x100003f34
    _perror(s);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _printf(format);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * s) {
    // 0x100003f4c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

