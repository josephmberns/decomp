//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bb8(void);
int64_t function_100003c00(void);
int64_t function_100003c18(void);
int64_t function_100003f28(void);
int32_t function_100003f34(struct _IO_FILE * stream);
char * function_100003f40(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003f4c(char * filename, char * modes);
int64_t * function_100003f58(int64_t * s, int32_t c, int32_t n);
void function_100003f64(char * s);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _fclose(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
struct _IO_FILE * _fopen(char * a1, char * a2);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bb8 - 0x100003c00
int64_t function_100003bb8(void) {
    // 0x100003bb8
    int64_t v1; // 0x100003bb8
    char v2 = v1; // 0x100003bbc
    int32_t v3 = v2; // 0x100003bbc
    int64_t result = 0; // 0x100003bd4
    if (v2 < 97 == (96 - v3 & v3) < 0) {
        int32_t v4 = v3 - 122; // 0x100003be0
        result = v4 == 0 | v4 < 0 != (121 - v3 & v3) < 0;
    }
    // 0x100003bf0
    return result;
}

// Address range: 0x100003c00 - 0x100003c18
int64_t function_100003c00(void) {
    // 0x100003c00
    int64_t v1; // 0x100003c00
    return (0x1000000 * (int32_t)v1 >> 24) - 97;
}

// Address range: 0x100003c18 - 0x100003e60
int64_t function_100003c18(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c30
    int64_t v2; // bp-144, 0x100003c18
    _memset(&v2, 0, 104);
    int64_t v3; // 0x100003c18
    if (*(char *)v3 != 0) {
        int64_t v4 = &v2;
        int32_t * v5; // 0x100003ca8
        if (function_100003bb8() % 2 != 0) {
            // 0x100003c98
            v5 = (int32_t *)((0x100000000 * function_100003c00() >> 30) + v4);
            *v5 = *v5 + 1;
        }
        // 0x100003cbc
        int64_t v6; // 0x100003c18
        int64_t v7 = v6 + 1; // 0x100003cc0
        v6 = v7;
        while (*(char *)v7 != 0) {
            // 0x100003c7c
            if (function_100003bb8() % 2 != 0) {
                // 0x100003c98
                v5 = (int32_t *)((0x100000000 * function_100003c00() >> 30) + v4);
                *v5 = *v5 + 1;
            }
            // 0x100003cbc
            v7 = v6 + 1;
            v6 = v7;
        }
    }
    struct _IO_FILE * v8 = (struct _IO_FILE *)v3; // 0x100003c44
    int64_t v9; // bp-225, 0x100003c18
    _memset(&v9, 0, 81);
    if (_fgets((char *)&v9, 80, v8) != NULL) {
        // 0x100003d00
        int64_t v10; // bp-332, 0x100003c18
        int64_t v11 = &v10;
        while (true) {
            // 0x100003d00
            _memset(&v10, 0, 104);
            char * v12 = (char *)&v9; // 0x100003d18
            while (true) {
              lab_0x100003d1c:;
                char * v13 = v12;
                switch (*v13) {
                    case 0: {
                        goto lab_0x100003e28;
                    }
                    case 10: {
                        int64_t v14 = (int64_t)v13;
                        if ((0x100000000 * v3 >> 32) + (int64_t)&v9 <= v14) {
                            // 0x100003d74
                            if (*(int32_t *)((4 * function_100003c00() & 0xfffffffc) + v11) >= 1) {
                                // 0x100003d94
                                _printf("%s", NULL);
                            }
                        }
                        // 0x100003e18
                        v12 = (char *)(v14 + 1);
                        goto lab_0x100003d1c;
                    }
                    default: {
                        // 0x100003db4
                        if (function_100003bb8() % 2 == 0) {
                            // break -> 0x100003e28
                            break;
                        }
                        int64_t v15 = 0x100000000 * function_100003c00() >> 30; // 0x100003dd8
                        int32_t * v16 = (int32_t *)(v15 + v11); // 0x100003ddc
                        int32_t v17 = *v16 + 1; // 0x100003de0
                        *v16 = v17;
                        int32_t v18 = *(int32_t *)(v15 + (int64_t)&v2); // 0x100003df0
                        int32_t v19 = v17 - v18; // 0x100003df4
                        if (v19 != 0 && v19 < 0 == ((v19 ^ v17) & (v18 ^ v17)) < 0) {
                            // break -> 0x100003e28
                            break;
                        }
                        // 0x100003e18
                        v12 = (char *)((int64_t)v13 + 1);
                        goto lab_0x100003d1c;
                    }
                }
            }
          lab_0x100003e28:
            // 0x100003e28
            if (_fgets((char *)&v9, 80, v8) == NULL) {
                // break -> 0x100003e2c
                break;
            }
        }
    }
    int64_t result = 0; // 0x100003e44
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e4c
        result = ___stack_chk_fail();
    }
    // 0x100003e50
    return result;
}

// Address range: 0x100003e60 - 0x100003f28
int64_t entry_point(void) {
    char * v1 = "unixdict.txt"; // 0x100003e84
    int64_t v2; // 0x100003e60
    if ((int32_t)v2 == 2) {
        // 0x100003e8c
        v1 = (char *)*(int64_t *)(v2 + 8);
    }
    struct _IO_FILE * v3 = _fopen(v1, "r"); // 0x100003ec0
    int64_t result; // 0x100003e60
    if (v3 == NULL) {
        // 0x100003edc
        _perror(v1);
        result = 1;
    } else {
        // 0x100003ef0
        function_100003c18();
        _fclose(v3);
        result = 0;
    }
    // 0x100003f18
    return result;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(void) {
    // 0x100003f28
    return ___stack_chk_fail();
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(struct _IO_FILE * stream) {
    // 0x100003f34
    return _fclose(stream);
}

// Address range: 0x100003f40 - 0x100003f4c
char * function_100003f40(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f40
    return _fgets(s, n, stream);
}

// Address range: 0x100003f4c - 0x100003f58
struct _IO_FILE * function_100003f4c(char * filename, char * modes) {
    // 0x100003f4c
    return _fopen(filename, modes);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f58
    return _memset(s, c, n);
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(char * s) {
    // 0x100003f64
    _perror(s);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

