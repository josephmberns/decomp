//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a30(void);
int64_t function_100003bd8(int64_t a1, int64_t * a2, int64_t a3);
int64_t function_100003d64(void);
int64_t function_100003dc8(int64_t a1);
int64_t function_100003f10(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f1c(int64_t a1);
int32_t function_100003f28(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000002; // 0x100003f70
int64_t g2 = 0x300000002; // 0x100003f78
int32_t g3 = 8; // 0x100003f80
float128_t g4 = 6.36598737388394823701663973294276408e-314L; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a30 - 0x100003bd8
int64_t function_100003a30(void) {
    // 0x100003a30
    int64_t v1; // 0x100003a30
    int64_t v2 = v1;
    int32_t v3 = v1; // 0x100003a48
    if (v3 == 0) {
        // 0x100003a6c
        *(int32_t *)v2 = (int32_t)v2 + 1;
        // 0x100003bcc
        return _printf("%2d  %s\n", v1, (char *)v1);
    }
    int32_t v4 = 1 - v3 - (int32_t)v1 + (int32_t)v1; // 0x100003ac0
    int32_t v5 = -v4; // 0x100003b14
    int64_t result; // 0x100003a30
    if (v4 != 0 && v5 < 0 == (v4 & v5) < 0) {
        // 0x100003bcc
        return result;
    }
    int64_t v6 = (0x100000000 * v1 >> 32) + v1; // 0x100003b2c
    int32_t v7 = 0; // 0x100003bb4
    ___memset_chk(v6, 46, (int64_t)(v4 + (int32_t)v1), -1);
    ___memset_chk(v6 + (int64_t)v7, 35, 0x100000000 * v1 >> 32, -1);
    v7++;
    int32_t v8 = v7 - v4; // 0x100003b14
    result = function_100003a30();
    while (v8 == 0 || v8 < 0 != ((v8 ^ v7) & (v7 ^ v4)) < 0) {
        // 0x100003b24
        ___memset_chk(v6, 46, (int64_t)(v4 + (int32_t)v1), -1);
        ___memset_chk(v6 + (int64_t)v7, 35, 0x100000000 * v1 >> 32, -1);
        v7++;
        v8 = v7 - v4;
        result = function_100003a30();
    }
    // 0x100003bcc
    return result;
}

// Address range: 0x100003bd8 - 0x100003d64
int64_t function_100003bd8(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t v1 = (int64_t)a2;
    _printf("%d cells and blocks [", v1);
    int32_t v2 = a3; // 0x100003c30
    int32_t v3 = -v2;
    int32_t v4; // 0x100003bd8
    int64_t v5; // bp-88, 0x100003bd8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003ca4
        _printf("]:\n");
        v4 = 0;
    } else {
        int32_t v6 = 0; // 0x100003c98
        uint32_t v7 = *(int32_t *)(4 * (int64_t)v6 + v1); // 0x100003c74
        *(int64_t *)((int64_t)&v5 - 16) = (int64_t)v7;
        _printf(v6 != 0 ? ", %d" : "%d");
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x100003c44
            v7 = *(int32_t *)(4 * (int64_t)v6 + v1);
            *(int64_t *)((int64_t)&v5 - 16) = (int64_t)v7;
            _printf(v6 != 0 ? ", %d" : "%d");
            v6++;
        }
        // 0x100003ca4
        _printf("]:\n");
        int32_t v8 = 0; // 0x100003cf4
        int32_t v9 = 0; // 0x100003ce4
        v9 += *(int32_t *)(4 * (int64_t)v8 + v1);
        v8++;
        int32_t v10 = v8 - v2; // 0x100003cc4
        v4 = v9;
        while (v10 < 0 != ((v10 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003cd4
            v9 += *(int32_t *)(4 * (int64_t)v8 + v1);
            v8++;
            v10 = v8 - v2;
            v4 = v9;
        }
    }
    int64_t v11 = 0x100000000 * a1 >> 32; // 0x100003bf4
    int32_t v12 = v11; // 0x100003d00
    int32_t v13 = v2 - 1 + v4; // 0x100003d10
    int32_t v14 = v12 - v13; // 0x100003d14
    if (v14 < 0 == ((v14 ^ v12) & (v13 ^ v12)) < 0) {
        // 0x100003d34
        v5 = (v11 + 1 & 0xffffffff) + 15 & 0x1fffffff0;
        return ___chkstk_darwin();
    }
    // 0x100003d24
    return function_100003dc8((int64_t)_printf("no solution\n"));
}

// Address range: 0x100003d64 - 0x100003dc8
int64_t function_100003d64(void) {
    // 0x100003d64
    int64_t v1; // 0x100003d64
    int64_t v2; // 0x100003d64
    int64_t v3 = (int64_t)&v1 - *(int64_t *)(v2 - 80); // 0x100003d6c
    int64_t * v4 = (int64_t *)(v2 - 72); // 0x100003d74
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 - 12); // 0x100003d7c
    ___memset_chk(v3, 46, (int64_t)*v5, -1);
    *(char *)(*v4 + (int64_t)*v5) = 0;
    *(int32_t *)(v2 - 60) = 0;
    return function_100003dc8(function_100003a30());
}

// Address range: 0x100003dc8 - 0x100003df8
int64_t function_100003dc8(int64_t a1) {
    int64_t result = a1; // 0x100003de0
    int64_t v1; // 0x100003dc8
    if (*(int64_t *)*(int64_t *)0x100004018 != *(int64_t *)(v1 - 8)) {
        // 0x100003de8
        result = ___stack_chk_fail(a1);
    }
    // 0x100003dec
    return result;
}

// Address range: 0x100003df8 - 0x100003f10
int64_t entry_point(void) {
    int64_t v1 = g1; // bp-32, 0x100003e30
    function_100003bd8(5, &v1, 2);
    _printf((char *)0x100003f6c);
    function_100003bd8(5, NULL, 0);
    _printf("\n");
    int32_t v2 = g3; // bp-64, 0x100003e7c
    function_100003bd8(10, (int64_t *)&v2, 1);
    _printf("\n");
    int64_t v3 = (float64_t)g4; // bp-48, 0x100003ea4
    function_100003bd8(15, &v3, 4);
    _printf("\n");
    int64_t v4 = g2; // bp-56, 0x100003ed4
    int64_t v5 = function_100003bd8(5, &v4, 2); // 0x100003ed8
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003ee8
    if (v6 != *(int64_t *)*(int64_t *)0x100004018) {
        // 0x100003efc
        ___stack_chk_fail(v5);
    }
    // 0x100003f00
    return 0;
}

// Address range: 0x100003f10 - 0x100003f1c
int64_t function_100003f10(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f10
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t function_100003f1c(int64_t a1) {
    // 0x100003f1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

