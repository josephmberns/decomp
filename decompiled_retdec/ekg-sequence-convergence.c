//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039bc(void);
int64_t function_1000039f4(void);
int64_t function_100003a78(void);
int64_t function_100003af0(void);
int64_t function_100003edc(int64_t a1);
int32_t function_100003ee8(char * format, ...);
void function_100003ef4(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

float128_t g1 = 1.06099789558144928672394041626691817e-313L; // 0x100003f00

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x1000039bc - 0x1000039f4
int64_t function_1000039bc(void) {
    // 0x1000039bc
    return 0;
}

// Address range: 0x1000039f4 - 0x100003a78
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    uint64_t v2 = v1;
    int64_t v3 = 0; // 0x100003a1c
    if (v2 == 0) {
        // 0x100003a6c
        return 0;
    }
    int32_t v4 = 0; // 0x100003a1c
    int64_t result = 1; // 0x100003a3c
    while (*(int32_t *)(4 * v3 + v1) != (int32_t)v1) {
        // 0x100003a0c
        v4++;
        v3 = v4;
        result = 0;
        if (v2 <= v3) {
            // break -> 0x100003a6c
            break;
        }
        result = 1;
    }
    // 0x100003a6c
    return result;
}

// Address range: 0x100003a78 - 0x100003af0
int64_t function_100003a78(void) {
    // 0x100003a78
    int64_t v1; // 0x100003a78
    int32_t result = v1; // 0x100003a7c
    int32_t v2 = v1; // 0x100003a80
    if (result == v2) {
        // 0x100003ae4
        return result;
    }
    int32_t result2 = v2; // 0x100003a98
    int32_t v3 = result;
    int32_t v4 = v3 - result2; // 0x100003aa8
    bool v5 = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (result2 ^ v3)) < 0; // 0x100003aac
    result2 -= (v5 ? v3 : 0);
    int32_t v6 = v5 ? v3 : v4;
    while (v6 != result2) {
        // 0x100003aa0
        v3 = v6;
        v4 = v3 - result2;
        v5 = v4 == 0 | v4 < 0 != ((v4 ^ v3) & (result2 ^ v3)) < 0;
        result2 -= (v5 ? v3 : 0);
        v6 = v5 ? v3 : v4;
    }
    // 0x100003ae4
    return result2;
}

// Address range: 0x100003af0 - 0x100003bbc
int64_t function_100003af0(void) {
    // 0x100003af0
    int64_t v1; // 0x100003af0
    uint64_t v2 = v1;
    int32_t v3 = v2; // 0x100003b24
    _qsort((int64_t *)v1, v3, 4, (int32_t (*)(int64_t *, int64_t *))0x1000039bc);
    _qsort((int64_t *)v1, v3, 4, (int32_t (*)(int64_t *, int64_t *))0x1000039bc);
    if (v2 == 0) {
        // 0x100003bac
        return 1;
    }
    int32_t v4 = 0; // 0x100003b54
    int64_t v5 = 0; // 0x100003b64
    int64_t result = 0; // 0x100003b7c
    while (*(int32_t *)(v5 + v1) == *(int32_t *)(v5 + v1)) {
        // 0x100003b44
        v4++;
        int64_t v6 = v4; // 0x100003b44
        result = 1;
        if (v2 <= v6) {
            // break -> 0x100003bac
            break;
        }
        v5 = 4 * v6;
        result = 0;
    }
    // 0x100003bac
    return result;
}

// Address range: 0x100003bbc - 0x100003edc
int64_t entry_point(void) {
    float128_t v1 = g1; // bp-56, 0x100003bec
    int64_t v2; // 0x100003cc4
    for (int64_t i = 0; i < 5; i++) {
        // 0x100003c14
        int64_t v3; // bp-2056, 0x100003bbc
        int64_t v4 = 400 * i + (int64_t)&v3; // 0x100003c28
        *(int32_t *)v4 = 1;
        int32_t v5 = *(int32_t *)(4 * i + (int64_t)&v1); // 0x100003c34
        *(int32_t *)(v4 | 4) = v5;
        uint32_t v6; // 0x100003bbc
        for (int64_t j = 2; j < 100; j++) {
            int32_t v7 = 2; // 0x100003bbc
            while (true) {
                // 0x100003c74
                v6 = v7;
                if ((int32_t)function_1000039f4() == 0) {
                    int32_t v8 = function_100003a78(); // 0x100003ccc
                    int32_t v9 = v8 - 1; // 0x100003ccc
                    if (v9 != 0 && v9 < 0 == (v8 & -v8) < 0) {
                        // break -> 0x100003cdc
                        break;
                    }
                }
                // 0x100003d04
                v7 = v6 + 1;
            }
            // 0x100003cdc
            *(int32_t *)(4 * j + v4) = v6;
        }
        // 0x100003d28
        v2 = v6;
        _printf("EKG(%2d): [", v2);
        for (int32_t j = 0; j < 30; j++) {
            // 0x100003d68
            _printf("%d ", v2);
        }
        // 0x100003db0
        _printf("\b]\n");
    }
    // 0x100003ddc
    int64_t v10; // bp-1256, 0x100003bbc
    int64_t v11 = &v10;
    int64_t v12 = 2;
    int32_t v13 = 2; // 0x100003bbc
    int64_t v14 = v2;
    int32_t v15; // 0x100003bbc
    while (true) {
        int32_t v16 = v13;
        uint64_t v17 = v12;
        int64_t v18 = 4 * v17; // 0x100003dfc
        int64_t v19; // bp-1656, 0x100003bbc
        int32_t v20 = *(int32_t *)(v18 + (int64_t)&v19); // 0x100003dfc
        int64_t v21 = v14; // 0x100003e14
        if (v20 == *(int32_t *)(v18 + v11)) {
            // 0x100003e1c
            v21 = v11;
            if ((int32_t)function_100003af0() != 0) {
                // break -> 0x100003e40
                break;
            }
        }
        // 0x100003e6c
        v14 = v21;
        v12 = v17 + 1;
        v13 = v16 + 1;
        if (v17 < 99 == (98 - v16 & (int32_t)v12) < 0) {
            // 0x100003e7c
            v15 = _printf("\nEKG5(5) and EKG(7) do not converge within %d terms\n", v14);
            goto lab_0x100003e9c;
        }
    }
    // 0x100003e40
    v15 = _printf("\nEKG(5) and EKG(7) converge at term %d\n", v11);
    goto lab_0x100003e9c;
  lab_0x100003e9c:;
    int64_t v22 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003eb0
    if (v22 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ec4
        ___stack_chk_fail((int64_t)v15);
    }
    // 0x100003ec8
    return 0;
}

// Address range: 0x100003edc - 0x100003ee8
int64_t function_100003edc(int64_t a1) {
    // 0x100003edc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * format, ...) {
    // 0x100003ee8
    return _printf(format);
}

// Address range: 0x100003ef4 - 0x100003f00
void function_100003ef4(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003ef4
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

