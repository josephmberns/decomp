//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000035ec(void);
int64_t function_10000368c(int64_t a1);
int64_t function_1000036bc(void);
int64_t function_10000379c(void);
int64_t function_100003840(void);
int64_t function_1000039ac(int64_t a1);
int64_t function_1000039d4(void);
int64_t function_100003a5c(void);
int64_t function_100003bbc(void);
int64_t function_100003e8c(char * a1, char * a2, int64_t a3, char * a4);
int64_t * function_100003e98(int32_t nmemb, int32_t size);
int32_t function_100003ea4(struct _IO_FILE * stream, char * format, ...);
void function_100003eb0(int64_t * ptr);
int64_t * function_100003ebc(int32_t size);
int32_t function_100003ec8(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000035ec - 0x10000368c
int64_t function_1000035ec(void) {
    // 0x1000035ec
    int64_t v1; // 0x1000035ec
    int32_t v2 = v1; // 0x1000035fc
    int64_t * v3 = _calloc((v2 + 31) / 32, 4); // 0x10000361c
    int64_t result = 0; // 0x100003630
    if (v3 != NULL) {
        // 0x10000364c
        *(int32_t *)v1 = v2;
        *(int64_t *)(v1 + 8) = (int64_t)v3;
        result = 1;
    }
    // 0x100003678
    return result;
}

// Address range: 0x10000368c - 0x1000036bc
int64_t function_10000368c(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1000036a0
    _free((int64_t *)*v1);
    *v1 = 0;
    return &g1;
}

// Address range: 0x1000036bc - 0x10000379c
int64_t function_1000036bc(void) {
    // 0x1000036bc
    int64_t v1; // 0x1000036bc
    uint32_t v2 = (int32_t)v1; // 0x1000036cc
    int64_t result; // 0x1000036bc
    if ((int32_t)v1 <= v2) {
        // 0x100003704
        result = ___assert_rtn("bit_array_set", "partition-an-integer-x-into-n-primes.c", 27, "index < b->size");
    }
    int32_t * v3 = (int32_t *)(*(int64_t *)(v1 + 8) + (v1 / 8 & 0x1ffffffc)); // 0x10000373c
    int32_t v4 = 1 << v2 % 32; // 0x10000374c
    int32_t v5 = *v3;
    *v3 = (uint64_t)v1 % 2 == 0 ? v5 & -1 - v4 : v5 | v4;
    return result;
}

// Address range: 0x10000379c - 0x100003840
int64_t function_10000379c(void) {
    // 0x10000379c
    int64_t v1; // 0x10000379c
    uint64_t v2 = v1;
    uint32_t v3 = (int32_t)v2; // 0x1000037ac
    if ((int32_t)v1 <= v3) {
        // 0x1000037d8
        ___assert_rtn("bit_array_get", "partition-an-integer-x-into-n-primes.c", 37, "index < b->size");
    }
    int32_t v4 = *(int32_t *)(*(int64_t *)(v1 + 8) + (v2 / 8 & 0x1ffffffc)); // 0x100003820
    return (v4 & 1 << v3 % 32) != 0;
}

// Address range: 0x100003840 - 0x1000039ac
int64_t function_100003840(void) {
    // 0x100003840
    if (function_1000035ec() % 2 == 0) {
        // 0x100003998
        return 0;
    }
    // 0x100003884
    int64_t v1; // 0x100003840
    uint32_t v2 = (int32_t)v1; // 0x100003850
    function_1000036bc();
    function_1000036bc();
    if (v2 <= 4 == (v2 != 4)) {
        // 0x100003978
        *(int32_t *)v1 = v2;
        // 0x100003998
        return 1;
    }
    int32_t v3 = 2;
    int32_t v4; // 0x100003840
    int32_t v5; // 0x100003840
    int32_t v6; // 0x100003954
    if (function_10000379c() % 2 == 0) {
        // 0x100003918
        v4 = 4;
        v5 = v4;
        if (v4 >= v2 != v4 != v2) {
            function_1000036bc();
            v6 = v5 + v3;
            v5 = v6;
            while (v6 >= v2 != v6 != v2) {
                // 0x100003930
                function_1000036bc();
                v6 = v5 + v3;
                v5 = v6;
            }
        }
    }
    int32_t v7 = v3 + 1; // 0x10000396c
    int32_t v8 = v7 * v7; // 0x1000038cc
    int32_t v9 = v8; // 0x1000038dc
    while (v8 >= v2 != v8 != v2) {
        // 0x1000038e4
        v3 = v7;
        if (function_10000379c() % 2 == 0) {
            // 0x100003918
            v4 = v9;
            v5 = v4;
            if (v4 >= v2 != v4 != v2) {
                function_1000036bc();
                v6 = v5 + v3;
                v5 = v6;
                while (v6 >= v2 != v6 != v2) {
                    // 0x100003930
                    function_1000036bc();
                    v6 = v5 + v3;
                    v5 = v6;
                }
            }
        }
        // 0x100003968
        v7 = v3 + 1;
        v8 = v7 * v7;
        v9 = v8;
    }
    // 0x100003978
    *(int32_t *)v1 = v2;
    // 0x100003998
    return 1;
}

// Address range: 0x1000039ac - 0x1000039d4
int64_t function_1000039ac(int64_t a1) {
    // 0x1000039ac
    return function_10000368c(a1 + 8);
}

// Address range: 0x1000039d4 - 0x100003a5c
int64_t function_1000039d4(void) {
    // 0x1000039d4
    int64_t v1; // 0x1000039d4
    uint32_t v2 = (int32_t)v1; // 0x1000039e4
    uint32_t v3 = (int32_t)v1;
    if (v3 <= v2 == (v3 != v2)) {
        // 0x100003a10
        ___assert_rtn("is_prime", "partition-an-integer-x-into-n-primes.c", 67, "n <= s->limit");
    }
    // 0x100003a34
    return function_10000379c() % 2 == 0;
}

// Address range: 0x100003a5c - 0x100003bbc
int64_t function_100003a5c(void) {
    // 0x100003a5c
    int64_t v1; // 0x100003a5c
    uint32_t v2 = (int32_t)v1; // 0x100003a6c
    uint32_t v3 = (int32_t)v1; // 0x100003a74
    int32_t * v4 = (int32_t *)v1; // 0x100003a78
    int64_t result; // 0x100003a5c
    if ((int32_t)v1 == 1) {
        // 0x100003a90
        if (v2 < v3) {
            // 0x100003ba8
            return 0;
        }
        // 0x100003aa8
        result = 0;
        if (function_1000039d4() % 2 != 0) {
            // 0x100003abc
            *v4 = v2;
            result = 1;
        }
    } else {
        // 0x100003afc
        if (v3 >= v2) {
            // 0x100003ba8
            return 0;
        }
        // 0x100003afc
        if (function_1000039d4() % 2 != 0) {
            // 0x100003b2c
            if (function_100003a5c() % 2 != 0) {
                // 0x100003b60
                *v4 = v3;
                result = 1;
                return result;
            }
        }
        int32_t v5 = v3 + 1; // 0x100003b88
        result = 0;
        while (v5 < v2) {
            int32_t v6 = v5;
            if (function_1000039d4() % 2 != 0) {
                // 0x100003b2c
                if (function_100003a5c() % 2 != 0) {
                    // 0x100003b60
                    *v4 = v6;
                    result = 1;
                    return result;
                }
            }
            // 0x100003b84
            v5 = v6 + 1;
            result = 0;
        }
    }
  lab_0x100003ba8:
    // 0x100003ba8
    return result;
}

// Address range: 0x100003bbc - 0x100003d54
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // 0x100003bbc
    uint32_t v2 = (int32_t)v1; // 0x100003bd0
    if (v2 == 0) {
        // 0x100003bf4
        ___assert_rtn("print_prime_partition", "partition-an-integer-x-into-n-primes.c", 93, "count > 0");
    }
    int64_t * v3 = _malloc(4 * v2); // 0x100003c20
    if (v3 == NULL) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c44
        // 0x100003d48
        return _fprintf((struct _IO_FILE *)v4, "Out of memory\n");
    }
    int32_t v5 = v1;
    if (function_100003a5c() % 2 == 0) {
        // 0x100003c78
        _printf("%u cannot be partitioned into %u primes.\n", v5, v2);
        // 0x100003d3c
        _free(v3);
        // 0x100003d48
        return &g1;
    }
    // 0x100003ca4
    _printf("%u = %u", v5, v2);
    int32_t v6 = 1; // 0x100003cec
    if (v2 > 1) {
        _printf(" + %u", v5);
        v6++;
        while (v6 != v2) {
            // 0x100003cf4
            _printf(" + %u", v5);
            v6++;
        }
    }
    // 0x100003d2c
    _printf((char *)0x100003fa5);
    // 0x100003d3c
    _free(v3);
    // 0x100003d48
    return &g1;
}

// Address range: 0x100003d54 - 0x100003e8c
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-48, 0x100003d74
    int64_t result; // 0x100003d54
    if (function_100003840() % 2 == 0) {
        // 0x100003d8c
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008, "Out of memory\n");
        result = 1;
    } else {
        // 0x100003db0
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_1000039ac((int64_t)&v1);
        result = 0;
    }
    // 0x100003e7c
    return result;
}

// Address range: 0x100003e8c - 0x100003e98
int64_t function_100003e8c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e8c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int32_t nmemb, int32_t size) {
    // 0x100003e98
    return _calloc(nmemb, size);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ea4
    return _fprintf(stream, format);
}

// Address range: 0x100003eb0 - 0x100003ebc
void function_100003eb0(int64_t * ptr) {
    // 0x100003eb0
    _free(ptr);
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t * function_100003ebc(int32_t size) {
    // 0x100003ebc
    return _malloc(size);
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(char * format, ...) {
    // 0x100003ec8
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

