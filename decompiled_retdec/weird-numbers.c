//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003948(void);
int64_t function_100003b8c(void);
int64_t function_100003c08(void);
int64_t function_100003d34(void);
int64_t * function_100003f4c(int32_t nmemb, int32_t size);
void function_100003f58(int64_t * ptr);
int64_t * function_100003f64(int32_t size);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003948 - 0x100003b8c
int64_t function_100003948(void) {
    // 0x100003948
    int64_t v1; // 0x100003948
    int32_t v2 = v1; // 0x100003954
    int32_t v3 = (0x100000000 * v1 >> 30) / 2; // 0x100003974
    int64_t * v4 = _malloc(v3); // 0x100003974
    int64_t v5 = (int64_t)v4; // 0x100003974
    int64_t * v6 = _malloc(v3); // 0x10000398c
    int64_t v7 = (int64_t)v6; // 0x10000398c
    *(int32_t *)v4 = 1;
    int32_t v8 = 4 - v2; // 0x1000039cc
    int32_t v9 = 1; // 0x1000039d4
    int32_t v10 = 0; // 0x1000039d4
    if (v8 == 0 || v8 < 0 != (v8 & v2) < 0) {
        int32_t v11 = 1;
        int32_t v12 = 0;
        int32_t v13 = 2;
        int32_t v14 = v11; // 0x1000039f8
        int32_t v15 = v12; // 0x1000039f8
        int32_t v16; // 0x100003a08
        int32_t v17; // 0x100003a20
        if (v2 % v13 == 0) {
            // 0x100003a00
            v16 = v2 / v13;
            v17 = v11 + 1;
            *(int32_t *)(4 * (int64_t)v11 + v5) = v13;
            v14 = v17;
            v15 = v12;
            if (v13 != v16) {
                // 0x100003a44
                *(int32_t *)(4 * (int64_t)v12 + v7) = v16;
                v14 = v17;
                v15 = v12 + 1;
            }
        }
        int32_t v18 = v15;
        int32_t v19 = v14;
        int32_t v20 = v13 + 1; // 0x100003a70
        int32_t v21 = v20 * v20; // 0x1000039c4
        int32_t v22 = v21 - v2; // 0x1000039cc
        v9 = v19;
        v10 = v18;
        while (v22 == 0 || v22 < 0 != ((v22 ^ v21) & (v21 ^ v2)) < 0) {
            // 0x1000039dc
            v11 = v19;
            v12 = v18;
            v13 = v20;
            v14 = v11;
            v15 = v12;
            if (v2 % v13 == 0) {
                // 0x100003a00
                v16 = v2 / v13;
                v17 = v11 + 1;
                *(int32_t *)(4 * (int64_t)v11 + v5) = v13;
                v14 = v17;
                v15 = v12;
                if (v13 != v16) {
                    // 0x100003a44
                    *(int32_t *)(4 * (int64_t)v12 + v7) = v16;
                    v14 = v17;
                    v15 = v12 + 1;
                }
            }
            // 0x100003a6c
            v18 = v15;
            v19 = v14;
            v20 = v13 + 1;
            v21 = v20 * v20;
            v22 = v21 - v2;
            v9 = v19;
            v10 = v18;
        }
    }
    int64_t result = (int64_t)_malloc(4 * (v10 + v9)); // 0x100003a94
    int32_t v23 = -v10; // 0x100003aac
    int32_t v24 = 0; // 0x100003ab4
    if (v23 < 0 != (v10 & v23) < 0) {
        int64_t v25 = 4 * (int64_t)v24; // 0x100003ac4
        *(int32_t *)(v25 + result) = *(int32_t *)(v25 + v7);
        v24++;
        while (v24 - v10 < 0 != ((v24 - v10 ^ v24) & (v24 ^ v10)) < 0) {
            // 0x100003abc
            v25 = 4 * (int64_t)v24;
            *(int32_t *)(v25 + result) = *(int32_t *)(v25 + v7);
            v24++;
        }
    }
    int32_t v26 = -v9; // 0x100003af8
    int32_t v27 = 0; // 0x100003b00
    if (v26 < 0 == (v9 & v26) < 0) {
        // 0x100003b48
        _free(v4);
        _free(v6);
        return result;
    }
    int32_t v28 = *(int32_t *)((int64_t)(4 * ((v27 ^ 0x3fffffff) + v9)) + v5); // 0x100003b1c
    *(int32_t *)((int64_t)(4 * (v27 + v10)) + result) = v28;
    v27++;
    while (v27 - v9 < 0 != ((v27 - v9 ^ v27) & (v27 ^ v9)) < 0) {
        // 0x100003b08
        v28 = *(int32_t *)((int64_t)(4 * ((v27 ^ 0x3fffffff) + v9)) + v5);
        *(int32_t *)((int64_t)(4 * (v27 + v10)) + result) = v28;
        v27++;
    }
    // 0x100003b48
    _free(v4);
    _free(v6);
    return result;
}

// Address range: 0x100003b8c - 0x100003c08
int64_t function_100003b8c(void) {
    // 0x100003b8c
    int64_t v1; // 0x100003b8c
    uint64_t v2 = v1;
    int32_t v3 = 0; // 0x100003bb8
    int32_t v4 = 0; // 0x100003bb8
    int32_t v5; // 0x100003b8c
    int32_t v6; // 0x100003b98
    int32_t v7; // 0x100003bf4
    if (v2 == 0) {
        // 0x100003bec
        v6 = v1;
        v5 = 0;
        v7 = v5 - v6;
        return !((v7 == 0 | v7 < 0 != ((v7 ^ v5) & (v5 ^ v6)) < 0));
    }
    v4 += *(int32_t *)v1;
    v3++;
    int64_t v8 = v3; // 0x100003ba8
    while (v2 > v8) {
        // 0x100003bc0
        v4 += *(int32_t *)(4 * v8 + v1);
        v3++;
        v8 = v3;
    }
    // 0x100003bec
    v6 = v1;
    v5 = v4;
    v7 = v5 - v6;
    return !((v7 == 0 | v7 < 0 != ((v7 ^ v5) & (v5 ^ v6)) < 0));
}

// Address range: 0x100003c08 - 0x100003d34
int64_t function_100003c08(void) {
    // 0x100003c08
    int64_t v1; // 0x100003c08
    if (v1 == 0) {
        // 0x100003d20
        return 0;
    }
    int32_t v2 = v1; // 0x100003c1c
    int32_t v3 = v1;
    int32_t v4 = v2 - v3; // 0x100003c68
    if (v4 < 0 != ((v4 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003d20
        return function_100003c08() % 2;
    }
    // 0x100003c98
    if (v2 == v3) {
        // 0x100003d20
        return 1;
    }
    int64_t result = 1; // 0x100003cd8
    if (function_100003c08() % 2 == 0) {
        // 0x100003ce0
        result = function_100003c08() % 2;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d34 - 0x100003e78
int64_t function_100003d34(void) {
    // 0x100003d34
    int64_t v1; // 0x100003d34
    int32_t v2 = v1; // 0x100003d40
    int64_t result = (int64_t)_calloc(v2, 1); // 0x100003d4c
    int32_t v3 = 2 - v2; // 0x100003d68
    float128_t v4; // 0x100003d34
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e60
        _free((int64_t *)(int64_t)(float64_t)v4);
        return result;
    }
    int32_t v5 = 2;
    char * v6 = (char *)((int64_t)v5 + result); // 0x100003d84
    float128_t v7; // 0x100003d34
    float128_t v8 = v7; // 0x100003d88
    int32_t v9; // 0x100003d34
    int32_t v10; // 0x100003e08
    int32_t v11; // 0x100003e38
    int32_t v12; // 0x100003e08
    int64_t v13; // 0x100003d98
    if (*v6 % 2 == 0) {
        // 0x100003d94
        v13 = function_100003948();
        if (function_100003b8c() % 2 == 0) {
            // 0x100003dc4
            *v6 = 1;
            v8 = (int128_t)v13;
        } else {
            // 0x100003ddc
            v8 = (int128_t)v13;
            if (function_100003c08() % 2 != 0) {
                // 0x100003e00
                v10 = v5 - v2;
                v9 = v5;
                v8 = (int128_t)v13;
                if (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
                    *(char *)((int64_t)v9 + result) = 1;
                    v11 = v9 + v5;
                    v12 = v11 - v2;
                    v9 = v11;
                    v8 = (int128_t)v13;
                    while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
                        // 0x100003e18
                        *(char *)((int64_t)v9 + result) = 1;
                        v11 = v9 + v5;
                        v12 = v11 - v2;
                        v9 = v11;
                        v8 = (int128_t)v13;
                    }
                }
            }
        }
    }
    int32_t v14 = v5 + 2; // 0x100003e54
    int32_t v15 = v14 - v2; // 0x100003d68
    v4 = v8;
    while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
        // 0x100003d78
        v5 = v14;
        v6 = (char *)((int64_t)v5 + result);
        if (*v6 % 2 == 0) {
            // 0x100003d94
            v13 = function_100003948();
            if (function_100003b8c() % 2 == 0) {
                // 0x100003dc4
                *v6 = 1;
                v8 = (int128_t)v13;
            } else {
                // 0x100003ddc
                v8 = (int128_t)v13;
                if (function_100003c08() % 2 != 0) {
                    // 0x100003e00
                    v10 = v5 - v2;
                    v9 = v5;
                    v8 = (int128_t)v13;
                    if (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
                        *(char *)((int64_t)v9 + result) = 1;
                        v11 = v9 + v5;
                        v12 = v11 - v2;
                        v9 = v11;
                        v8 = (int128_t)v13;
                        while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
                            // 0x100003e18
                            *(char *)((int64_t)v9 + result) = 1;
                            v11 = v9 + v5;
                            v12 = v11 - v2;
                            v9 = v11;
                            v8 = (int128_t)v13;
                        }
                    }
                }
            }
        }
        // 0x100003e50
        v14 = v5 + 2;
        v15 = v14 - v2;
        v4 = v8;
    }
    // 0x100003e60
    _free((int64_t *)(int64_t)(float64_t)v4);
    return result;
}

// Address range: 0x100003e78 - 0x100003f4c
int64_t entry_point(void) {
    int64_t v1 = function_100003d34(); // 0x100003e8c
    _printf("The first 25 weird numbers:\n");
    int32_t v2 = 2; // 0x100003e78
    int32_t v3 = 0;
    int32_t v4 = v3; // 0x100003ee0
    int64_t v5; // 0x100003e78
    if (*(char *)(v1 + (int64_t)v2) % 2 == 0) {
        // 0x100003ee8
        _printf("%d ", v5);
        v4 = v3 + 1;
    }
    // 0x100003f18
    v2 += 2;
    while (v4 < 25 != (24 - v4 & v4) < 0) {
        // 0x100003ed0
        v3 = v4;
        v4 = v3;
        if (*(char *)(v1 + (int64_t)v2) % 2 == 0) {
            // 0x100003ee8
            _printf("%d ", v5);
            v4 = v3 + 1;
        }
        // 0x100003f18
        v2 += 2;
    }
    // 0x100003f28
    _printf((char *)0x100003f9d);
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int64_t * function_100003f4c(int32_t nmemb, int32_t size) {
    // 0x100003f4c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f58 - 0x100003f64
void function_100003f58(int64_t * ptr) {
    // 0x100003f58
    _free(ptr);
}

// Address range: 0x100003f64 - 0x100003f70
int64_t * function_100003f64(int32_t size) {
    // 0x100003f64
    return _malloc(size);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

