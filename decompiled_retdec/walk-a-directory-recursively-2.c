//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_FTS {
    struct _ftsent * e0;
    struct _ftsent * e1;
    struct _ftsent ** e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t (*e8)(int64_t *, int64_t *);
    int32_t e9;
};

struct _ftsent {
    struct _ftsent * e0;
    struct _ftsent * e1;
    struct _ftsent * e2;
    int32_t e3;
    int64_t * e4;
    char * e5;
    char * e6;
    int32_t e7;
    int32_t e8;
    int16_t e9;
    int16_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int16_t e14;
    int16_t e15;
    int16_t e16;
    int16_t e17;
    struct stat * e18;
    char e19[1];
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c64(void);
int64_t function_100003ca0(int64_t a1);
void function_100003ed8(int32_t status, int32_t errnum, char * format, ...);
int64_t function_100003ee4(int64_t a1);
void function_100003ef0(int32_t status, char * format, ...);
int32_t function_100003efc(char * pattern, char * name, int32_t flags);
int32_t function_100003f08(struct _TYPEDEF_FTS * a1);
struct _TYPEDEF_FTS * function_100003f14(char ** a1, int32_t a2, int32_t (*a3)(struct _ftsent **, struct _ftsent **));
struct _ftsent * function_100003f20(struct _TYPEDEF_FTS * a1);
int32_t function_100003f2c(char * s);
int32_t function_100003f38(char * s1, char * s2);
void function_100003f44(char * format, ...);
void function_100003f50(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void ___error(int32_t a1, int32_t a2, char * a3, ...);
int64_t ___stack_chk_fail(int64_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fnmatch(char * a1, char * a2, int32_t a3);
int32_t _fts_close(struct _TYPEDEF_FTS * a1);
struct _TYPEDEF_FTS * _fts_open(char ** a1, int32_t a2, int32_t (*a3)(struct _ftsent **, struct _ftsent **));
struct _ftsent * _fts_read(struct _TYPEDEF_FTS * a1);
int32_t _puts(char * a1);
int32_t _strcmp(char * a1, char * a2);
void _warn(char * a1, ...);
void _warnx(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c64 - 0x100003ca0
int64_t function_100003c64(void) {
    // 0x100003c64
    int64_t v1; // 0x100003c64
    return _strcmp((char *)(v1 + 104), (char *)(v1 + 104));
}

// Address range: 0x100003ca0 - 0x100003e80
int64_t function_100003ca0(int64_t a1) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003cb4
    int64_t v2; // bp-40, 0x100003ca0
    struct _TYPEDEF_FTS * v3 = _fts_open((char **)&v2, 10, (int32_t (*)(struct _ftsent **, struct _ftsent **))0x100003c64); // 0x100003ce0
    int64_t v4 = 10; // 0x100003cf4
    if (v3 == NULL) {
        // 0x100003cfc
        _err(1, "fts_open");
        v4 = (int64_t)"fts_open";
    }
    struct _ftsent * v5 = _fts_read(v3); // 0x100003d14
    int64_t v6 = (int64_t)v5; // 0x100003d14
    int64_t v7 = v4; // 0x100003d28
    char * v8 = (char *)0x100003c64; // 0x100003d28
    int64_t v9 = v6; // 0x100003d28
    if (v5 == NULL) {
      lab_0x100003e00:
        // 0x100003e00
        ___error((int32_t)v9, (int32_t)v7, v8);
        if (g1 != 0) {
            // 0x100003e18
            _err(1, "fts_read");
        }
        int32_t v10 = _fts_close(v3); // 0x100003e2c
        int64_t v11 = v10; // 0x100003e38
        if (v10 < 0) {
            // 0x100003e40
            _err(1, "fts_close");
            v11 = &g1;
        }
        int64_t result = v11; // 0x100003e68
        if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
            // 0x100003e70
            result = ___stack_chk_fail(v11);
        }
        // 0x100003d50
        return result;
    }
    int64_t result2 = v6;
    int16_t * v12 = (int16_t *)(result2 + 88); // 0x100003d34
    uint64_t v13 = (int64_t)*v12 + 0xfffffffc & 0xffffffff; // 0x100003d3c
    while (v13 >= 6 == (v13 != 6)) {
        int64_t v14 = result2 + 104; // 0x100003d98
        char * v15 = (char *)v14; // 0x100003da0
        int64_t v16; // 0x100003ca0
        if (_fnmatch((char *)v16, v15, 4) == 0) {
            // 0x100003db4
            _puts((char *)*(int64_t *)(result2 + 48));
        }
        // 0x100003dc4
        if (*v12 == 2) {
            // 0x100003ddc
            _warnx("%s: cycle in directory tree", v15);
        }
        struct _ftsent * v17 = _fts_read(v3); // 0x100003d14
        v7 = v14;
        v8 = (char *)4;
        v9 = 0;
        if (v17 == NULL) {
            goto lab_0x100003e00;
        }
        result2 = (int64_t)v17;
        v12 = (int16_t *)(result2 + 88);
        v13 = (int64_t)*v12 + 0xfffffffc & 0xffffffff;
    }
    // 0x100003d50
    return result2;
}

// Address range: 0x100003e9c - 0x100003ed8
int64_t entry_point(void) {
    // 0x100003e9c
    function_100003ca0(0);
    return 0;
}

// Address range: 0x100003ed8 - 0x100003ee4
void function_100003ed8(int32_t status, int32_t errnum, char * format, ...) {
    // 0x100003ed8
    ___error(status, errnum, format);
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(int64_t a1) {
    // 0x100003ee4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef0 - 0x100003efc
void function_100003ef0(int32_t status, char * format, ...) {
    // 0x100003ef0
    _err(status, format);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(char * pattern, char * name, int32_t flags) {
    // 0x100003efc
    return _fnmatch(pattern, name, flags);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(struct _TYPEDEF_FTS * a1) {
    // 0x100003f08
    return _fts_close(a1);
}

// Address range: 0x100003f14 - 0x100003f20
struct _TYPEDEF_FTS * function_100003f14(char ** a1, int32_t a2, int32_t (*a3)(struct _ftsent **, struct _ftsent **)) {
    // 0x100003f14
    return _fts_open(a1, a2, a3);
}

// Address range: 0x100003f20 - 0x100003f2c
struct _ftsent * function_100003f20(struct _TYPEDEF_FTS * a1) {
    // 0x100003f20
    return _fts_read(a1);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * s) {
    // 0x100003f2c
    return _puts(s);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * s1, char * s2) {
    // 0x100003f38
    return _strcmp(s1, s2);
}

// Address range: 0x100003f44 - 0x100003f50
void function_100003f44(char * format, ...) {
    // 0x100003f44
    _warn(format);
}

// Address range: 0x100003f50 - 0x100003f5c
void function_100003f50(char * format, ...) {
    // 0x100003f50
    _warnx(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

