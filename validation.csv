`/* 2009-09-27 <kaz@kylheku.com> */
#define ANIMATE_VT100_POSIX
#include <stdio.h>
#include <string.h>
#ifdef ANIMATE_VT100_POSIX
#include <time.h>
#endif

char world_7x14[2][512] = {
  {
    "+-----------+\n"
    "|tH.........|\n"
    "|.   .      |\n"
    "|   ...     |\n"
    "|.   .      |\n"
    "|Ht.. ......|\n"
    "+-----------+\n"
  }
};

void next_world(const char *in, char *out, int w, int h)
{
  int i;

  for (i = 0; i < w*h; i++) {
    switch (in[i]) {
    case ' ': out[i] = ' '; break;
    case 't': out[i] = '.'; break;
    case 'H': out[i] = 't'; break;
    case '.': {
      int hc = (in[i-w-1] == 'H') + (in[i-w] == 'H') + (in[i-w+1] == 'H') +
               (in[i-1]   == 'H')                    + (in[i+1]   == 'H') +
               (in[i+w-1] == 'H') + (in[i+w] == 'H') + (in[i+w+1] == 'H');
      out[i] = (hc == 1 || hc == 2) ? 'H' : '.';
      break;
    }
    default:
      out[i] = in[i];
    }
  }
  out[i] = in[i];
}

int main()
{
  int f;

  for (f = 0; ; f = 1 - f) {
    puts(world_7x14[f]);
    next_world(world_7x14[f], world_7x14[1-f], 14, 7);
#ifdef ANIMATE_VT100_POSIX
    printf("\x1b[%dA", 8);
    printf("\x1b[%dD", 14);
    {
      static const struct timespec ts = { 0, 100000000 };
      nanosleep(&ts, 0);
    }
#endif
  }

  return 0;
}
`,`#include "wireworld.h"



void _next_world(long param_1,long param_2,int param_3,int param_4)

{
  char cVar1;
  undefined uVar2;
  int local_1c;
  
  for (local_1c = 0; local_1c < param_3 * param_4; local_1c = local_1c + 1) {
    cVar1 = *(char *)(param_1 + local_1c);
    if (cVar1 == ' ') {
      *(undefined *)(param_2 + local_1c) = 0x20;
    }
    else if (cVar1 == '.') {
      cVar1 = (*(char *)(param_1 + ((local_1c - param_3) + -1)) == 'H') +
              (*(char *)(param_1 + (local_1c - param_3)) == 'H') +
              (*(char *)(param_1 + ((local_1c - param_3) + 1)) == 'H') +
              (*(char *)(param_1 + (local_1c + -1)) == 'H') +
              (*(char *)(param_1 + (local_1c + 1)) == 'H') +
              (*(char *)(param_1 + (local_1c + param_3 + -1)) == 'H') +
              (*(char *)(param_1 + (local_1c + param_3)) == 'H') +
              (*(char *)(param_1 + (local_1c + param_3 + 1)) == 'H');
      uVar2 = 0x48;
      if (cVar1 != '\x01' && cVar1 != '\x02') {
        uVar2 = 0x2e;
      }
      *(undefined *)(param_2 + local_1c) = uVar2;
    }
    else if (cVar1 == 'H') {
      *(undefined *)(param_2 + local_1c) = 0x74;
    }
    else if (cVar1 == 't') {
      *(undefined *)(param_2 + local_1c) = 0x2e;
    }
    else {
      *(undefined *)(param_2 + local_1c) = *(undefined *)(param_1 + local_1c);
    }
  }
  *(undefined *)(param_2 + local_1c) = *(undefined *)(param_1 + local_1c);
  return;
}



void entry(void)

{
  int local_18;
  
  local_18 = 0;
  do {
    _puts(_world_7x14 + (long)local_18 * 0x200);
    _next_world(_world_7x14 + (long)local_18 * 0x200,_world_7x14 + (long)(1 - local_18) * 0x200,0xe,
                7);
    _printf("\x1b[%dA");
    _printf("\x1b[%dD");
    _nanosleep((timespec *)&DAT_100003f90,(timespec *)0x0);
    local_18 = 1 - local_18;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _nanosleep(timespec *param_1,timespec *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__nanosleep_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef unsigned char bool;

#define TRUE 1
#define FALSE 0
#define MILLION 1000000LL
#define BILLION 1000 * MILLION
#define MAX_COUNT 103LL*10000*10000 + 11*9 + 1

int digitSum[10000];

void init() {
    int i = 9999, s, t, a, b, c, d;
    for (a = 9; a >= 0; --a) {
        for (b = 9; b >= 0; --b) {
            s = a + b;
            for (c = 9; c >= 0; --c) {
                t = s + c;
                for (d = 9; d >= 0; --d) {
                    digitSum[i] = t + d;
                    --i;
                }
            }
        }
    }
}

void sieve(bool *sv) {
    int a, b, c;
    long long s, n = 0;
    for (a = 0; a < 103; ++a) {
        for (b = 0; b < 10000; ++b) {
            s = digitSum[a] + digitSum[b] + n;
            for (c = 0; c < 10000; ++c) {
                sv[digitSum[c]+s] = TRUE;
                ++s;
            }
            n += 10000;
        }
    }
}

int main() {
    long long count = 0, limit = 1;
    clock_t begin = clock(), end;
    bool *p, *sv = (bool*) calloc(MAX_COUNT, sizeof(bool));
    init();
    sieve(sv);
    printf("Sieving took %lf seconds.\n", (double)(clock() - begin) / CLOCKS_PER_SEC);
    printf("\nThe first 50 self numbers are:\n");
    for (p = sv; p < sv + MAX_COUNT; ++p) {
        if (!*p) {
            if (++count <= 50) {
                printf("%ld ", p-sv);
            } else {
                printf("\n\n     Index  Self number\n");
                break;
            }
        }
    }
    count = 0;
    for (p = sv; p < sv + MAX_COUNT; ++p) {
        if (!*p) {
            if (++count == limit) {
                printf("%10lld  %11ld\n", count, p-sv);
                limit *= 10;
                if (limit == 10 * BILLION) break;
            }
        }
    }
    free(sv);
    printf("\nOverall took %lf seconds.\n", (double)(clock() - begin) / CLOCKS_PER_SEC);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a28(void);
int64_t function_100003b54(void);
int64_t * function_100003ed8(int32_t nmemb, int32_t size);
int32_t function_100003ee4(void);
void function_100003ef0(int64_t * ptr);
int32_t function_100003efc(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _clock(void);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a28 - 0x100003b54
int64_t function_100003a28(void) {
    int32_t v1 = 0x270f; // 0x100003af4
    for (int32_t i = 9; i > -1; i--) {
        int32_t v2 = 9;
        int32_t v3 = 9;
        int32_t v4 = v2 + i + v3; // 0x100003aac
        int32_t v5 = 9;
        *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
        v1--;
        int32_t v6 = v5 - 1; // 0x100003acc
        int32_t v7 = v1; // 0x100003acc
        while (v5 != 0) {
            // 0x100003ad4
            v5 = v6;
            *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
            v1 = v7 - 1;
            v6 = v5 - 1;
            v7 = v1;
        }
        int32_t v8 = v3 - 1; // 0x100003a9c
        while (v3 != 0) {
            // 0x100003aa4
            v3 = v8;
            v4 = v2 + i + v3;
            v5 = 9;
            *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
            v1--;
            v6 = v5 - 1;
            v7 = v1;
            while (v5 != 0) {
                // 0x100003ad4
                v5 = v6;
                *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
                v1 = v7 - 1;
                v6 = v5 - 1;
                v7 = v1;
            }
            // 0x100003b14
            v8 = v3 - 1;
        }
        int32_t v9 = v2 - 1; // 0x100003a6c
        while (v2 != 0) {
            // 0x100003a74
            v2 = v9;
            v3 = 9;
            v4 = v2 + i + v3;
            v5 = 9;
            *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
            v1--;
            v6 = v5 - 1;
            v7 = v1;
            while (v5 != 0) {
                // 0x100003ad4
                v5 = v6;
                *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
                v1 = v7 - 1;
                v6 = v5 - 1;
                v7 = v1;
            }
            // 0x100003b14
            v8 = v3 - 1;
            while (v3 != 0) {
                // 0x100003aa4
                v3 = v8;
                v4 = v2 + i + v3;
                v5 = 9;
                *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1) = v4 + v5;
                v1--;
                v6 = v5 - 1;
                v7 = v1;
                while (v5 != 0) {
                    // 0x100003ad4
                    v5 = v6;
                    *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1) = v4 + v5;
                    v1 = v7 - 1;
                    v6 = v5 - 1;
                    v7 = v1;
                }
                // 0x100003b14
                v8 = v3 - 1;
            }
            // 0x100003b28
            v9 = v2 - 1;
        }
    }
    // 0x100003b4c
    int64_t result; // 0x100003a28
    return result;
}

// Address range: 0x100003b54 - 0x100003c6c
int64_t function_100003b54(void) {
    int64_t v1 = 0; // 0x100003c34
    int32_t v2 = 0;
    int32_t * v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1); // 0x100003ba8
    int32_t v4 = 0;
    int32_t v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1); // 0x100003bb0
    int64_t v6 = v1 + (int64_t)(v5 + *v3); // 0x100003b54
    int32_t v7 = 0;
    int32_t v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1); // 0x100003bf4
    int64_t result; // 0x100003b54
    *(char *)(v6 + result + (int64_t)v8) = 1;
    int32_t v9 = v7 + 1; // 0x100003c20
    v6++;
    while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
        // 0x100003be4
        v7 = v9;
        v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *(char *)(v6 + result + (int64_t)v8) = 1;
        v9 = v7 + 1;
        v6++;
    }
    // 0x100003c2c
    v1 += 0x2710;
    int32_t v10 = v4 + 1; // 0x100003c44
    while (v4 < 0x270f != (0x270e - v4 & v10) < 0) {
        // 0x100003b9c
        v4 = v10;
        v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1);
        v6 = v1 + (int64_t)(v5 + *v3);
        v7 = 0;
        v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *(char *)(v6 + result + (int64_t)v8) = 1;
        v9 = v7 + 1;
        v6++;
        while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
            // 0x100003be4
            v7 = v9;
            v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
            *(char *)(v6 + result + (int64_t)v8) = 1;
            v9 = v7 + 1;
            v6++;
        }
        // 0x100003c2c
        v1 += 0x2710;
        v10 = v4 + 1;
    }
    int32_t v11 = v2 + 1; // 0x100003c58
    while (v2 < 102 != (101 - v2 & v11) < 0) {
        // 0x100003b84
        v2 = v11;
        v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1);
        v4 = 0;
        v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1);
        v6 = v1 + (int64_t)(v5 + *v3);
        v7 = 0;
        v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *(char *)(v6 + result + (int64_t)v8) = 1;
        v9 = v7 + 1;
        v6++;
        while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
            // 0x100003be4
            v7 = v9;
            v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
            *(char *)(v6 + result + (int64_t)v8) = 1;
            v9 = v7 + 1;
            v6++;
        }
        // 0x100003c2c
        v1 += 0x2710;
        v10 = v4 + 1;
        while (v4 < 0x270f != (0x270e - v4 & v10) < 0) {
            // 0x100003b9c
            v4 = v10;
            v5 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1);
            v6 = v1 + (int64_t)(v5 + *v3);
            v7 = 0;
            v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
            *(char *)(v6 + result + (int64_t)v8) = 1;
            v9 = v7 + 1;
            v6++;
            while (v7 < 0x270f != (0x270e - v7 & v9) < 0) {
                // 0x100003be4
                v7 = v9;
                v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
                *(char *)(v6 + result + (int64_t)v8) = 1;
                v9 = v7 + 1;
                v6++;
            }
            // 0x100003c2c
            v1 += 0x2710;
            v10 = v4 + 1;
        }
        // 0x100003c54
        v11 = v2 + 1;
    }
    // 0x100003c64
    return result;
}

// Address range: 0x100003c6c - 0x100003ed8
int64_t entry_point(void) {
    // 0x100003c6c
    _clock();
    int64_t * v1 = _calloc(0x65ed8764, 1); // 0x100003ca4
    function_100003a28();
    function_100003b54();
    _clock();
    int128_t v2; // 0x100003c6c
    _printf("Sieving took %lf seconds.\n", (float64_t)(int64_t)v2);
    _printf("\nThe first 50 self numbers are:\n");
    if (v1 >= (int64_t *)-0x265ed8764) {
        // 0x100003e90
        _free(v1);
        _clock();
        _printf("\nOverall took %lf seconds.\n", (float64_t)(int64_t)v2);
        return 0;
    }
    int64_t v3 = (int64_t)v1;
    uint64_t v4 = v3 + 0x265ed8764; // 0x100003d14
    int64_t v5 = v3; // 0x100003d9c
    char * v6 = (char *)v1; // 0x100003c6c
    int64_t v7 = 0; // 0x100003d44
    while (true) {
        int64_t v8 = v7;
        v7 = v8;
        if (*v6 == 0) {
            // 0x100003d40
            v7 = v8 + 1;
            int64_t v9 = v8 - 49; // 0x100003d4c
            if (v9 != 0 && v9 < 0 == (v7 & 48 - v8) < 0) {
                // break -> 0x100003d80
                break;
            }
            // 0x100003d5c
            _printf("%ld ", 1);
        }
        // 0x100003d98
        v5++;
        v6 = (char *)v5;
        if (v4 <= v5) {
            goto lab_0x100003de0;
        }
    }
    // 0x100003d80
    _printf("\n\n     Index  Self number\n");
  lab_0x100003de0:;
    int64_t v10 = 1;
    int64_t v11 = 0;
    int64_t v12 = v10; // 0x100003df0
    int64_t v13 = v11; // 0x100003df0
    int64_t v14; // 0x100003dfc
    int64_t v15; // 0x100003e48
    int64_t v16; // 0x100003c6c
    if (*(char *)v3 == 0) {
        // 0x100003df8
        v14 = v11 + 1;
        v12 = v10;
        v13 = v14;
        if (v14 == v10) {
            // 0x100003e18
            _printf("%10lld  %11ld\n", 1, (int32_t)v16);
            v15 = 10 * v10;
            v12 = v15;
            v13 = v10;
            if (v15 == 0x2540be400) {
                // break -> 0x100003e90
                break;
            }
        }
    }
    int64_t v17 = v3 + 1; // 0x100003e84
    int64_t v18 = v17; // 0x100003dd8
    while (v4 > v17) {
        // 0x100003de0
        v10 = v12;
        v11 = v13;
        v12 = v10;
        v13 = v11;
        if (*(char *)v18 == 0) {
            // 0x100003df8
            v14 = v11 + 1;
            v12 = v10;
            v13 = v14;
            if (v14 == v10) {
                // 0x100003e18
                _printf("%10lld  %11ld\n", 1, (int32_t)v16);
                v15 = 10 * v10;
                v12 = v15;
                v13 = v10;
                if (v15 == 0x2540be400) {
                    // break -> 0x100003e90
                    break;
                }
            }
        }
        // 0x100003e80
        v17 = v18 + 1;
        v18 = v17;
    }
    // 0x100003e90
    _free(v1);
    _clock();
    _printf("\nOverall took %lf seconds.\n", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003ed8 - 0x100003ee4
int64_t * function_100003ed8(int32_t nmemb, int32_t size) {
    // 0x100003ed8
    return _calloc(nmemb, size);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(void) {
    // 0x100003ee4
    return _clock();
}

// Address range: 0x100003ef0 - 0x100003efc
void function_100003ef0(int64_t * ptr) {
    // 0x100003ef0
    _free(ptr);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(char * format, ...) {
    // 0x100003efc
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <getopt.h>

#define NUMLETTERS 26
#define BUFSIZE 4096

char *get_input(void);

int main(int argc, char *argv[])
{
    char const usage[] = "Usage: vinigere [-d] key";
    char sign = 1;
    char const plainmsg[] = "Plain text:  ";
    char const cryptmsg[] = "Cipher text: ";
    bool encrypt = true;
    int opt;

    while ((opt = getopt(argc, argv, "d")) != -1) {
        switch (opt) {
        case 'd':
            sign = -1;
            encrypt = false;
            break;
        default:
            fprintf(stderr, "Unrecogized command line argument:'-%i'\n", opt);
            fprintf(stderr, "\n%s\n", usage);
            return 1;
        }
    }

    if (argc - optind != 1) {
        fprintf(stderr, "%s requires one argument and one only\n", argv[0]);
        fprintf(stderr, "\n%s\n", usage);
        return 1;
    }


    // Convert argument into array of shifts
    char const *const restrict key = argv[optind];
    size_t const keylen = strlen(key);
    char shifts[keylen];

    char const *restrict plaintext = NULL;
    for (size_t i = 0; i < keylen; i++) {
        if (!(isalpha(key[i]))) {
            fprintf(stderr, "Invalid key\n");
            return 2;
        }
        char const charcase = (isupper(key[i])) ? 'A' : 'a';
        // If decrypting, shifts will be negative.
        // This line would turn "bacon" into {1, 0, 2, 14, 13}
        shifts[i] = (key[i] - charcase) * sign;
    }

    do {
        fflush(stdout);
        // Print "Plain text: " if encrypting and "Cipher text:  " if
        // decrypting
        printf("%s", (encrypt) ? plainmsg : cryptmsg);
        plaintext = get_input();
        if (plaintext == NULL) {
            fprintf(stderr, "Error getting input\n");
            return 4;
        }
    } while (strcmp(plaintext, "") == 0); // Reprompt if entry is empty

    size_t const plainlen = strlen(plaintext);

    char* const restrict ciphertext = calloc(plainlen + 1, sizeof *ciphertext);
    if (ciphertext == NULL) {
        fprintf(stderr, "Memory error\n");
        return 5;
    }

    for (size_t i = 0, j = 0; i < plainlen; i++) {
        // Skip non-alphabetical characters
        if (!(isalpha(plaintext[i]))) {
            ciphertext[i] = plaintext[i];
            continue;
        }
        // Check case
        char const charcase = (isupper(plaintext[i])) ? 'A' : 'a';
        // Wrapping conversion algorithm
        ciphertext[i] = ((plaintext[i] + shifts[j] - charcase + NUMLETTERS) % NUMLETTERS) + charcase;
        j = (j+1) % keylen;
    }
    ciphertext[plainlen] = '\0';
    printf("%s%s\n", (encrypt) ? cryptmsg : plainmsg, ciphertext);

    free(ciphertext);
    // Silence warnings about const not being maintained in cast to void*
    free((char*) plaintext);
    return 0;
}
char *get_input(void) {

    char *const restrict buf = malloc(BUFSIZE * sizeof (char));
    if (buf == NULL) {
        return NULL;
    }

    fgets(buf, BUFSIZE, stdin);

    // Get rid of newline
    size_t const len = strlen(buf);
    if (buf[len - 1] == '\n') buf[len - 1] = '\0';

    return buf;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003988(void);
int64_t function_100003d48(int64_t a1);
int64_t function_100003d90(void);
int64_t function_100003e3c(void);
int64_t * function_100003e48(int32_t nmemb, int32_t size);
int32_t function_100003e54(struct _IO_FILE * stream);
char * function_100003e60(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003e6c(struct _IO_FILE * stream, char * format, ...);
void function_100003e78(int64_t * ptr);
int32_t function_100003e84(int32_t argc, char ** argv, char * shortopts);
int32_t function_100003e90(int32_t c);
int32_t function_100003e9c(int32_t c);
int64_t * function_100003ea8(int32_t size);
int32_t function_100003eb4(char * format, ...);
int32_t function_100003ec0(char * s1, char * s2);
int32_t function_100003ecc(char * s);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f89
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fflush(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _getopt(int32_t a1, char ** a2, char * a3);
int32_t _isalpha(int32_t a1);
int32_t _isupper(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003764 - 0x100003988
int64_t entry_point(void) {
    // 0x100003764
    int64_t v1; // 0x100003764
    int32_t v2 = v1; // 0x10000378c
    while (true) {
      lab_0x1000037f8:;
        // 0x1000037f8
        char ** v3; // 0x100003790
        switch (_getopt(v2, v3, "d")) {
            case -1: {
                int32_t v4 = *(int32_t *)*(int64_t *)0x100004078; // 0x1000038bc
                if (v4 + 1 == v2) {
                    // 0x10000393c
                    _strlen((char *)*(int64_t *)(8 * (int64_t)v4 + v1));
                    return ___chkstk_darwin();
                }
                int64_t * v5 = (int64_t *)*(int64_t *)0x100004018; // 0x1000038e0
                _fprintf((struct _IO_FILE *)*v5, "%s requires one argument and one only\n", "d");
                int32_t v6 = _fprintf((struct _IO_FILE *)*v5, "\n%s\n", "d"); // 0x100003928
                return function_100003d48((int64_t)v6);
            }
            case 100: {
                goto lab_0x1000037f8;
            }
            default: {
                goto lab_0x100003844;
            }
        }
    }
  lab_0x100003844:;
    int64_t * v7 = (int64_t *)*(int64_t *)0x100004018; // 0x100003850
    _fprintf((struct _IO_FILE *)*v7, "Unrecogized command line argument:'-%i'\n", (int64_t)"d");
    int32_t v8 = _fprintf((struct _IO_FILE *)*v7, "\n%s\n", "d"); // 0x100003898
    return function_100003d48((int64_t)v8);
}

// Address range: 0x100003988 - 0x100003d48
int64_t function_100003988(void) {
    // 0x100003988
    int64_t v1; // 0x100003988
    int64_t v2; // 0x100003988
    int64_t v3 = (int64_t)&v1 - *(int64_t *)(v2 - 248); // 0x100003990
    int64_t * v4 = (int64_t *)(v2 - 240); // 0x100003998
    *v4 = v3;
    int64_t * v5 = (int64_t *)(v2 - 160); // 0x1000039a0
    *v5 = 0;
    int64_t * v6 = (int64_t *)(v2 - 168); // 0x1000039a4
    *v6 = 0;
    int64_t * v7 = (int64_t *)(v2 - 136); // 0x1000039b0
    int64_t v8; // 0x100003988
    int64_t v9; // 0x100003988
    char * v10; // 0x100003988
    int64_t v11; // 0x100003988
    int64_t v12; // 0x100003988
    int64_t * v13; // 0x100003988
    int64_t * v14; // 0x100003b48
    int64_t * v15; // 0x100003b5c
    int64_t * v16; // 0x100003ba0
    int64_t * v17; // 0x100003ba4
    char * v18; // 0x100003988
    int64_t v19; // 0x100003988
    if (*v7 == 0) {
      lab_0x100003a80:
        // 0x100003a80
        v10 = (char *)(v2 - 114);
        v11 = v2 - 80;
        v12 = v2 - 96;
        v13 = (int64_t *)(v3 - 16);
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004028);
        int64_t v20 = *v10 % 2 == 0 ? v12 : v11;
        *(int64_t *)(v2 - 256) = v20;
        *v13 = v20;
        int64_t v21; // 0x100003988
        _printf("%s", (char *)v21);
        int64_t v22 = function_100003d90(); // 0x100003ad4
        *v5 = v22;
        while (v22 != 0) {
            // 0x100003b20
            if (_strcmp((char *)v22, (char *)&g1) != 0) {
                int32_t v23 = _strlen((char *)*v5); // 0x100003b44
                v14 = (int64_t *)(v2 - 184);
                *v14 = (int64_t)v23;
                int64_t * v24 = _calloc(v23 + 1, 1); // 0x100003b58
                v15 = (int64_t *)(v2 - 192);
                *v15 = (int64_t)v24;
                if (v24 == NULL) {
                    int64_t v25 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003b7c
                    int32_t v26 = _fprintf((struct _IO_FILE *)v25, "Memory error\n"); // 0x100003b88
                    *(int32_t *)(v2 - 100) = 5;
                    *(int32_t *)(v2 - 172) = 1;
                    v19 = v26;
                    return function_100003d48(v19);
                } else {
                    // 0x100003ba0
                    v16 = (int64_t *)(v2 - 200);
                    *v16 = 0;
                    v17 = (int64_t *)(v2 - 208);
                    *v17 = 0;
                    uint64_t v27 = *v16; // 0x100003bac
                    uint64_t v28 = *v14; // 0x100003bb0
                    v8 = v28;
                    if (v27 < v28) {
                        // 0x100003bc4
                        v18 = (char *)(v2 - 209);
                        v9 = v27;
                        goto lab_0x100003bc4_2;
                    } else {
                        goto lab_0x100003cb4;
                    }
                }
            }
            _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004028);
            v20 = *v10 % 2 == 0 ? v12 : v11;
            *(int64_t *)(v2 - 256) = v20;
            *v13 = v20;
            _printf("%s", (char *)(int64_t)&g1);
            v22 = function_100003d90();
            *v5 = v22;
        }
        int64_t v29 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003af8
        int32_t v30 = _fprintf((struct _IO_FILE *)v29, "Error getting input\n"); // 0x100003b04
        *(int32_t *)(v2 - 100) = 4;
        *(int32_t *)(v2 - 172) = 1;
        // 0x100003d3c
        return function_100003d48((int64_t)v30);
    }
    int64_t * v31 = (int64_t *)(v2 - 128); // 0x1000039c4
    int64_t v32 = 0; // 0x100003a70
    while (_isalpha((int32_t)*(char *)(*v31 + v32)) != 0) {
        char v33 = _isupper((int32_t)*(char *)(*v6 + *v31)) == 0 ? 97 : 65; // 0x100003a40
        *(char *)(v2 - 173) = v33;
        int64_t v34 = *v6; // 0x100003a48
        char v35 = *(char *)(v2 - 113); // 0x100003a58
        *(char *)(v34 + *v4) = (*(char *)(v34 + *v31) - v33) * v35;
        v32 = *v6 + 1;
        *v6 = v32;
        if (v32 >= *v7) {
            goto lab_0x100003a80;
        }
    }
    int32_t v36 = _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004018, "Invalid key\n"); // 0x1000039f8
    *(int32_t *)(v2 - 100) = 2;
    *(int32_t *)(v2 - 172) = 1;
    v19 = v36;
  lab_0x100003d3c:
    // 0x100003d3c
    return function_100003d48(v19);
  lab_0x100003cb4:
    // 0x100003cb4
    *(char *)(*v15 + v8) = 0;
    int64_t v37 = *v10 % 2 == 0 ? v11 : v12;
    *(int64_t *)(v2 - 264) = v37;
    *v13 = v37;
    *(int64_t *)(v3 - 8) = *v15;
    _printf("%s%s\n", (char *)1, (char *)v2);
    _free((int64_t *)*v15);
    _free((int64_t *)*v5);
    *(int32_t *)(v2 - 100) = 0;
    *(int32_t *)(v2 - 172) = 1;
    v19 = &g2;
    return function_100003d48(v19);
  lab_0x100003bc4_2:
    // 0x100003bc4
    if (_isalpha((int32_t)*(char *)(*v5 + v9)) == 0) {
        int64_t v38 = *v15; // 0x100003bf4
        int64_t v39; // 0x100003988
        char v40; // 0x100003988
        *(char *)(v38 + v39) = v40;
        goto lab_0x100003ca4;
    } else {
        unsigned char v41 = _isupper((int32_t)*(char *)(*v16 + *v5)) == 0 ? 97 : 65; // 0x100003c38
        *v18 = v41;
        int64_t v42 = *v16; // 0x100003c40
        char v43 = *(char *)(v42 + *v5); // 0x100003c44
        char v44 = *(char *)(*v17 + *v4); // 0x100003c4c
        int64_t v45 = *v15; // 0x100003c78
        *(char *)(v45 + v42) = v41 + (char)((26 - (int32_t)v41 + (int32_t)v43 + (int32_t)v44) % 26);
        *v17 = (*v17 + 1) % *v7;
        goto lab_0x100003ca4;
    }
  lab_0x100003ca4:;
    int64_t v46 = *v16 + 1; // 0x100003ca8
    *v16 = v46;
    uint64_t v47 = *v14; // 0x100003bb0
    v9 = v46;
    v8 = v47;
    if (v46 < v47) {
        goto lab_0x100003bc4_2;
    } else {
        goto lab_0x100003cb4;
    }
}

// Address range: 0x100003d48 - 0x100003d90
int64_t function_100003d48(int64_t a1) {
    // 0x100003d48
    int64_t v1; // 0x100003d48
    int32_t v2 = *(int32_t *)(v1 - 100); // 0x100003d48
    int32_t * v3 = (int32_t *)(v1 - 268); // 0x100003d50
    *v3 = v2;
    int32_t result = v2; // 0x100003d6c
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v1 - 24)) {
        // 0x100003d74
        ___stack_chk_fail();
        result = *v3;
    }
    // 0x100003d78
    return result;
}

// Address range: 0x100003d90 - 0x100003e3c
int64_t function_100003d90(void) {
    int64_t * v1 = _malloc(0x1000); // 0x100003da0
    if (v1 == NULL) {
        // 0x100003e2c
        return 0;
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004020; // 0x100003dd0
    _fgets((char *)v1, 0x1000, (struct _IO_FILE *)v2);
    int32_t v3 = _strlen((char *)v1); // 0x100003de0
    int64_t result = (int64_t)v1; // 0x100003de8
    char * v4 = (char *)(result - 1 + (int64_t)v3); // 0x100003df4
    if (*v4 == 10) {
        // 0x100003e08
        *v4 = 0;
    }
    // 0x100003e2c
    return result;
}

// Address range: 0x100003e3c - 0x100003e48
int64_t function_100003e3c(void) {
    // 0x100003e3c
    return ___stack_chk_fail();
}

// Address range: 0x100003e48 - 0x100003e54
int64_t * function_100003e48(int32_t nmemb, int32_t size) {
    // 0x100003e48
    return _calloc(nmemb, size);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(struct _IO_FILE * stream) {
    // 0x100003e54
    return _fflush(stream);
}

// Address range: 0x100003e60 - 0x100003e6c
char * function_100003e60(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003e60
    return _fgets(s, n, stream);
}

// Address range: 0x100003e6c - 0x100003e78
int32_t function_100003e6c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e6c
    return _fprintf(stream, format);
}

// Address range: 0x100003e78 - 0x100003e84
void function_100003e78(int64_t * ptr) {
    // 0x100003e78
    _free(ptr);
}

// Address range: 0x100003e84 - 0x100003e90
int32_t function_100003e84(int32_t argc, char ** argv, char * shortopts) {
    // 0x100003e84
    return _getopt(argc, argv, shortopts);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(int32_t c) {
    // 0x100003e90
    return _isalpha(c);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(int32_t c) {
    // 0x100003e9c
    return _isupper(c);
}

// Address range: 0x100003ea8 - 0x100003eb4
int64_t * function_100003ea8(int32_t size) {
    // 0x100003ea8
    return _malloc(size);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(char * format, ...) {
    // 0x100003eb4
    return _printf(format);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(char * s1, char * s2) {
    // 0x100003ec0
    return _strcmp(s1, s2);
}

// Address range: 0x100003ecc - 0x100003ed8
int32_t function_100003ecc(char * s) {
    // 0x100003ecc
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include<stdio.h>

int main (void)
{
    int i;
    for (i = 1; i <= 100; i++)
    {
        if (!(i % 15))
            printf ("FizzBuzz");
        else if (!(i % 3))
            printf ("Fizz");
        else if (!(i % 5))
            printf ("Buzz");
        else
            printf ("%d", i);

        printf("\n");
    }
    return 0;
}
`,`#include "fizzbuzz-6.h"



undefined8 entry(void)

{
  int local_18;
  
  for (local_18 = 1; local_18 < 0x65; local_18 = local_18 + 1) {
    if (local_18 % 0xf == 0) {
      _printf("FizzBuzz");
    }
    else if (local_18 % 3 == 0) {
      _printf("Fizz");
    }
    else if (local_18 % 5 == 0) {
      _printf("Buzz");
    }
    else {
      _printf("%d");
    }
    _printf("\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdint.h>

void to_seq(uint64_t x, uint8_t *out)
{
	int i, j;
	for (i = 9; i > 0; i--) {
		if (x & 127ULL << i * 7) break;
	}
	for (j = 0; j <= i; j++)
		out[j] = ((x >> ((i - j) * 7)) & 127) | 128;

	out[i] ^= 128;
}

uint64_t from_seq(uint8_t *in)
{
	uint64_t r = 0;

	do {
		r = (r << 7) | (uint64_t)(*in & 127);
	} while (*in++ & 128);

	return r;
}

int main()
{
	uint8_t s[10];
	uint64_t x[] = { 0x7f, 0x4000, 0, 0x3ffffe, 0x1fffff, 0x200000, 0x3311a1234df31413ULL};

	int i, j;
	for (j = 0; j < sizeof(x)/8; j++) {
		to_seq(x[j], s);
		printf("seq from %llx: [ ", x[j]);

		i = 0;
		do { printf("%02x ", s[i]); } while ((s[i++] & 128));
		printf("] back: %llx\n", from_seq(s));
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c80(void);
int64_t function_100003d70(void);
int64_t function_100003f4c(int64_t a1);
int64_t * function_100003f58(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f64(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c80 - 0x100003d70
int64_t function_100003c80(void) {
    int32_t v1 = 9; // 0x100003ce0
    int64_t v2 = 9;
    int32_t v3; // 0x100003c80
    int64_t result; // 0x100003c80
    while ((127 << 7 * v2 & result) == 0) {
        int64_t v4 = v2 - 1;
        v1--;
        v3 = v1;
        if (v4 == 0) {
            goto lab_0x100003cec;
        }
        v2 = v4;
    }
    // 0x100003cec
    v3 = v2;
  lab_0x100003cec:;
    int32_t v5 = v3;
    int32_t v6 = -v5; // 0x100003cfc
    if (v5 == 0 || v6 < 0 != (v5 & v6) < 0) {
        int32_t v7 = 0;
        *(char *)(result + (int64_t)v7) = (char)(result >> (int64_t)(7 * (v5 - v7))) | -128;
        int32_t v8 = v7 + 1; // 0x100003d44
        int32_t v9 = v8 - v5; // 0x100003cfc
        while (v9 == 0 || v9 < 0 != ((v9 ^ v8) & (v8 ^ v5)) < 0) {
            // 0x100003d0c
            v7 = v8;
            *(char *)(result + (int64_t)v7) = (char)(result >> (int64_t)(7 * (v5 - v7))) | -128;
            v8 = v7 + 1;
            v9 = v8 - v5;
        }
    }
    char * v10 = (char *)(result + (int64_t)v5); // 0x100003d5c
    *v10 = *v10 ^ -128;
    return result;
}

// Address range: 0x100003d70 - 0x100003dd0
int64_t function_100003d70(void) {
    int64_t result = 0; // 0x100003d7c
    int64_t v1; // 0x100003d70
    unsigned char v2 = *(char *)v1;
    result = 128 * result | (int64_t)(v2 % 128);
    v1++;
    while (v2 <= -1) {
        // 0x100003d80
        v2 = *(char *)v1;
        result = 128 * result | (int64_t)(v2 % 128);
        v1++;
    }
    // 0x100003dc4
    return result;
}

// Address range: 0x100003dd0 - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003dd0
    int64_t v1; // bp-96, 0x100003dd0
    _memset(&v1, 0, 56);
    v1 = 127;
    int64_t v2; // bp-34, 0x100003dd0
    int64_t v3 = &v2; // 0x100003e68
    int32_t v4; // 0x100003f00
    for (int32_t i = 0; i < 7; i++) {
        // 0x100003e58
        function_100003c80();
        _printf("seq from %llx: [ ", v3);
        int32_t v5 = 0;
        _printf("%02x ", (int32_t)v3);
        int32_t v6 = v5 + 1; // 0x100003ee0
        while (*(char *)((int64_t)v5 + v3) <= -1) {
            // 0x100003e98
            v5 = v6;
            _printf("%02x ", (int32_t)v3);
            v6 = v5 + 1;
        }
        // 0x100003ee8
        function_100003d70();
        v4 = _printf("] back: %llx\n", v3);
    }
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f24
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f38
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003f3c
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int64_t function_100003f4c(int64_t a1) {
    // 0x100003f4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f58
    return _memset(s, c, n);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <err.h>

char response[] = "HTTP/1.1 200 OK\r\n"
"Content-Type: text/html; charset=UTF-8\r\n\r\n"
"<!DOCTYPE html><html><head><title>Bye-bye baby bye-bye</title>"
"<style>body { background-color: #111 }"
"h1 { font-size:4cm; text-align: center; color: black;"
" text-shadow: 0 0 2mm red}</style></head>"
"<body><h1>Goodbye, world!</h1></body></html>\r\n";

int main()
{
  int one = 1, client_fd;
  struct sockaddr_in svr_addr, cli_addr;
  socklen_t sin_len = sizeof(cli_addr);

  int sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0)
    err(1, "can't open socket");

  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(int));

  int port = 8080;
  svr_addr.sin_family = AF_INET;
  svr_addr.sin_addr.s_addr = INADDR_ANY;
  svr_addr.sin_port = htons(port);

  if (bind(sock, (struct sockaddr *) &svr_addr, sizeof(svr_addr)) == -1) {
    close(sock);
    err(1, "Can't bind");
  }

  listen(sock, 5);
  while (1) {
    client_fd = accept(sock, (struct sockaddr *) &cli_addr, &sin_len);
    printf("got connection\n");

    if (client_fd == -1) {
      perror("Can't accept");
      continue;
    }

    write(client_fd, response, sizeof(response) - 1); /*-1:'\0'*/
    close(client_fd);
  }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ec8(void);
int32_t function_100003eec(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_100003ef8(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_100003f04(int32_t fd);
void function_100003f10(int32_t status, char * format, ...);
int32_t function_100003f1c(int32_t fd, int32_t n);
void function_100003f28(char * s);
int32_t function_100003f34(char * format, ...);
int32_t function_100003f40(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t optlen);
int32_t function_100003f4c(int32_t domain, int32_t type, int32_t protocol);
int32_t function_100003f58(int32_t fd, int64_t * buf, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int32_t _accept(int32_t a1, struct sockaddr * a2, int32_t * a3);
int32_t _bind(int32_t a1, struct sockaddr * a2, int32_t a3);
int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _listen(int32_t a1, int32_t a2);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _setsockopt(int32_t a1, int32_t a2, int32_t a3, int64_t * a4, int32_t a5);
int32_t _socket(int32_t a1, int32_t a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003d68 - 0x100003ec8
int64_t entry_point(void) {
    int32_t v1 = 1; // bp-64, 0x100003d90
    int32_t v2 = 16; // bp-72, 0x100003d98
    int32_t v3 = _socket(2, 1, 0); // 0x100003da0
    if (v3 < 0) {
        // 0x100003dbc
        _err(1, "can't open socket");
    }
    // 0x100003dcc
    _setsockopt(v3, 0xffff, 4, (int64_t *)&v1, 4);
    function_100003ec8();
    int64_t v4; // bp-40, 0x100003d68
    if (_bind(v3, (struct sockaddr *)&v4, 16) == -1) {
        // 0x100003e3c
        _close(v3);
        _err(1, "Can't bind");
    }
    // 0x100003e54
    _listen(v3, 5);
    while (true) {
        // 0x100003e64
        int64_t v5; // bp-56, 0x100003d68
        int32_t v6 = _accept(v3, (struct sockaddr *)&v5, &v2); // 0x100003e70
        _printf("got connection\n");
        if (v6 == -1) {
            // 0x100003e98
            _perror("Can't accept");
        } else {
            // 0x100003ea8
            _write(v6, (int64_t *)"HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=UTF-8\r\n\r\n<!DOCTYPE html><html><head><title>Bye-bye baby bye-bye</title><style>body { background-color: #111 }h1 { font-size:4cm; text-align: center; color: black; text-shadow: 0 0 2mm red}</style></head><body><h1>Goodbye, world!</h1></body></html>\r\n", 299);
            _close(v6);
        }
    }
}

// Address range: 0x100003ec8 - 0x100003eec
int64_t function_100003ec8(void) {
    // 0x100003ec8
    int64_t v1; // 0x100003ec8
    uint64_t v2 = v1;
    return v2 / 256 % 256 | 256 * v2 & 0xff00;
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x100003eec
    return _accept(fd, addr, addr_len);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x100003ef8
    return _bind(fd, addr, len);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(int32_t fd) {
    // 0x100003f04
    return _close(fd);
}

// Address range: 0x100003f10 - 0x100003f1c
void function_100003f10(int32_t status, char * format, ...) {
    // 0x100003f10
    _err(status, format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(int32_t fd, int32_t n) {
    // 0x100003f1c
    return _listen(fd, n);
}

// Address range: 0x100003f28 - 0x100003f34
void function_100003f28(char * s) {
    // 0x100003f28
    _perror(s);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t optlen) {
    // 0x100003f40
    return _setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(int32_t domain, int32_t type, int32_t protocol) {
    // 0x100003f4c
    return _socket(domain, type, protocol);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(int32_t fd, int64_t * buf, int32_t n) {
    // 0x100003f58
    return _write(fd, buf, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>

int main(int c, char *v[])
{
	int days[] = {31,29,31,30,31,30,31,31,30,31,30,31};
	int m, y, w;

	if (c < 2 || (y = atoi(v[1])) <= 1700) return 1;
 	days[1] -= (y % 4) || (!(y % 100) && (y % 400));
	w = y * 365 + (y - 1) / 4 - (y - 1) / 100 + (y - 1) / 400 + 6;

	for(m = 0; m < 12; m++) {
		w = (w + days[m]) % 7;
		printf("%d-%02d-%d\n", y, m + 1,
			days[m] + (w < 5 ? -2 : 5) - w);
	}

	return 0;
}
`,`#include "last-friday-of-each-month.h"



undefined4 entry(int param_1,long param_2)

{
  uint uVar1;
  void *pvVar2;
  uint local_6c;
  uint local_68;
  int local_5c;
  undefined4 local_4c;
  undefined auStack_48 [4];
  int local_44;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memcpy(auStack_48,&DAT_100003f6c,0x30);
  if (1 < param_1) {
    uVar1 = _atoi(*(char **)(param_2 + 8));
    pvVar2 = (void *)(ulong)uVar1;
    if (0x6a4 < (int)uVar1) {
      local_68 = 1;
      if ((int)uVar1 % 4 == 0) {
        local_6c = 0;
        if ((int)uVar1 % 100 == 0) {
          local_6c = (uint)((int)uVar1 % 400 != 0);
        }
        local_68 = local_6c;
      }
      local_44 = local_44 - local_68;
      for (local_5c = 0; local_5c < 0xc; local_5c = local_5c + 1) {
        uVar1 = _printf("%d-%02d-%d\n");
        pvVar2 = (void *)(ulong)uVar1;
      }
      local_4c = 0;
      goto LAB_100003f00;
    }
  }
  local_4c = 1;
LAB_100003f00:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return local_4c;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(pvVar2);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdbool.h>

bool a(bool in)
{
  printf("I am a\n");
  return in;
}

bool b(bool in)
{
  printf("I am b\n");
  return in;
}

#define TEST(X,Y,O)						\
  do {								\
    x = a(X) O b(Y);						\
    printf(#X " " #O " " #Y " = %s\n\n", x ? "true" : "false");	\
  } while(false);

int main()
{
  bool x;

  TEST(false, true, &&); // b is not evaluated
  TEST(true, false, ||); // b is not evaluated
  TEST(true, false, &&); // b is evaluated
  TEST(false, false, ||); // b is evaluated

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cac(uint32_t a1);
int64_t function_100003ce4(uint32_t a1);
int32_t function_100003f2c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cac - 0x100003ce4
int64_t function_100003cac(uint32_t a1) {
    // 0x100003cac
    _printf("I am a\n");
    return a1 % 2;
}

// Address range: 0x100003ce4 - 0x100003d1c
int64_t function_100003ce4(uint32_t a1) {
    // 0x100003ce4
    _printf("I am b\n");
    return a1 % 2;
}

// Address range: 0x100003d1c - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003d1c
    if (function_100003cac(0) % 2 != 0) {
        // 0x100003d4c
        function_100003ce4(1);
    }
    // 0x100003d60
    int64_t v1; // 0x100003d1c
    char * v2 = (char *)v1; // 0x100003da0
    _printf("false && true = %s\n\n", v2);
    if (function_100003cac(1) % 2 == 0) {
        // 0x100003dc8
        function_100003ce4(0);
    }
    // 0x100003ddc
    _printf("true || false = %s\n\n", v2);
    if (function_100003cac(1) % 2 != 0) {
        // 0x100003e44
        function_100003ce4(0);
    }
    // 0x100003e58
    _printf("true && false = %s\n\n", v2);
    if (function_100003cac(0) % 2 == 0) {
        // 0x100003ec0
        function_100003ce4(0);
    }
    // 0x100003ed4
    _printf("false || false = %s\n\n", v2);
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

/* The language task, implemented with pthreads for POSIX systems. */

/* Each rendezvous_t will be accepted by a single thread, and entered
 * by one or more threads.  accept_func() only returns an integer and
 * is always run within the entering thread's context to simplify
 * handling the arguments and return value.  This somewhat unlike an
 * Ada rendezvous and is a subset of the Ada rendezvous functionality.
 * Ada's in and out parameters can be simulated via the void pointer
 * passed to accept_func() to update variables owned by both the
 * entering and accepting threads, if a suitable struct with pointers
 * to those variables is used. */
typedef struct rendezvous {
    pthread_mutex_t lock;        /* A mutex/lock to use with the CVs.        */
    pthread_cond_t cv_entering;  /* Signaled when a thread enters.           */
    pthread_cond_t cv_accepting; /* Signaled when accepting thread is ready. */
    pthread_cond_t cv_done;      /* Signaled when accept_func() finishes.    */
    int (*accept_func)(void*);   /* The function to run when accepted.       */
    int entering;                /* Number of threads trying to enter.       */
    int accepting;               /* True if the accepting thread is ready.   */
    int done;                    /* True if accept_func() is done.           */
} rendezvous_t;

/* Static initialization for rendezvous_t. */
#define RENDEZVOUS_INITILIZER(accept_function) {   \
        .lock         = PTHREAD_MUTEX_INITIALIZER, \
        .cv_entering  = PTHREAD_COND_INITIALIZER,  \
        .cv_accepting = PTHREAD_COND_INITIALIZER,  \
        .cv_done      = PTHREAD_COND_INITIALIZER,  \
        .accept_func  = accept_function,           \
        .entering     = 0,                         \
        .accepting    = 0,                         \
        .done         = 0,                         \
    }

int enter_rendezvous(rendezvous_t *rv, void* data)
{
    /* Arguments are passed in and out of the rendezvous via
     * (void*)data, and the accept_func() return value is copied and
     * returned to the caller (entering thread).  A data struct with
     * pointers to variables in both the entering and accepting
     * threads can be used to simulate Ada's in and out parameters, if
     * needed. */
    pthread_mutex_lock(&rv->lock);

    rv->entering++;
    pthread_cond_signal(&rv->cv_entering);

    while (!rv->accepting) {
        /* Nothing is accepting yet, keep waiting.  pthreads will
         * queue all waiting entries.  The loop is needed to handle
         * both race conditions and spurious wakeups. */
        pthread_cond_wait(&rv->cv_accepting, &rv->lock);
    }

    /* Call accept_func() and copy the return value before leaving
     * the mutex. */
    int ret = rv->accept_func(data);

    /* This signal is needed so that the accepting thread will wait
     * for the rendezvous to finish before trying to accept again. */
    rv->done = 1;
    pthread_cond_signal(&rv->cv_done);

    rv->entering--;
    rv->accepting = 0;
    pthread_mutex_unlock(&rv->lock);

    return ret;
}

void accept_rendezvous(rendezvous_t *rv)
{
    /* This accept function does not take in or return parameters.
     * That is handled on the entry side.  This is only for
     * synchronization. */
    pthread_mutex_lock(&rv->lock);
    rv->accepting = 1;

    while (!rv->entering) {
        /* Nothing to accept yet, keep waiting. */
        pthread_cond_wait(&rv->cv_entering, &rv->lock);
    }

    pthread_cond_signal(&rv->cv_accepting);

    while (!rv->done) {
        /* Wait for accept_func() to finish. */
        pthread_cond_wait(&rv->cv_done, &rv->lock);
    }
    rv->done = 0;

    rv->accepting = 0;
    pthread_mutex_unlock(&rv->lock);
}

/* The printer use case task implemented using the above rendezvous
 * implementation.  Since C doesn't have exceptions, return values are
 * used to signal out of ink errors. */

typedef struct printer {
    rendezvous_t rv;
    struct printer *backup;
    int id;
    int remaining_lines;
} printer_t;

typedef struct print_args {
    struct printer *printer;
    const char* line;
} print_args_t;

int print_line(printer_t *printer, const char* line) {
    print_args_t args;
    args.printer = printer;
    args.line = line;
    return enter_rendezvous(&printer->rv, &args);
}

int accept_print(void* data) {
    /* This is called within the rendezvous, so everything is locked
     * and okay to modify. */
    print_args_t *args = (print_args_t*)data;
    printer_t *printer = args->printer;
    const char* line = args->line;

    if (printer->remaining_lines) {
        /* Print the line, character by character. */
        printf("%d: ", printer->id);
        while (*line != '\0') {
            putchar(*line++);
        }
        putchar('\n');
        printer->remaining_lines--;
        return 1;
    }
    else if (printer->backup) {
        /* "Requeue" this rendezvous with the backup printer. */
        return print_line(printer->backup, line);
    }
    else {
        /* Out of ink, and no backup available. */
        return -1;
    }
}

printer_t backup_printer = {
    .rv = RENDEZVOUS_INITILIZER(accept_print),
    .backup = NULL,
    .id = 2,
    .remaining_lines = 5,
};

printer_t main_printer = {
    .rv = RENDEZVOUS_INITILIZER(accept_print),
    .backup = &backup_printer,
    .id = 1,
    .remaining_lines = 5,
};

void* printer_thread(void* thread_data) {
    printer_t *printer = (printer_t*) thread_data;
    while (1) {
        accept_rendezvous(&printer->rv);
    }
}

typedef struct poem {
    char* name;
    char* lines[];
} poem_t;

poem_t humpty_dumpty = {
    .name = "Humpty Dumpty",
    .lines = {
        "Humpty Dumpty sat on a wall.",
        "Humpty Dumpty had a great fall.",
        "All the king's horses and all the king's men",
        "Couldn't put Humpty together again.",
        ""
    },
};

poem_t mother_goose = {
    .name = "Mother Goose",
    .lines = {
        "Old Mother Goose",
        "When she wanted to wander,",
        "Would ride through the air",
        "On a very fine gander.",
        "Jack's mother came in,",
        "And caught the goose soon,",
        "And mounting its back,",
        "Flew up to the moon.",
        ""
    },
};

void* poem_thread(void* thread_data) {
    poem_t *poem = (poem_t*)thread_data;

    for (unsigned i = 0; poem->lines[i] != ""; i++) {
        int ret = print_line(&main_printer, poem->lines[i]);
        if (ret < 0) {
            printf("      %s out of ink!\n", poem->name);
            exit(1);
        }
    }
    return NULL;
}

int main(void)
{
    pthread_t threads[4];

    pthread_create(&threads[0], NULL, poem_thread,    &humpty_dumpty);
    pthread_create(&threads[1], NULL, poem_thread,    &mother_goose);
    pthread_create(&threads[2], NULL, printer_thread, &main_printer);
    pthread_create(&threads[3], NULL, printer_thread, &backup_printer);

    pthread_join(threads[0], NULL);
    pthread_join(threads[1], NULL);
    pthread_cancel(threads[2]);
    pthread_cancel(threads[3]);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038f4(void);
int64_t function_10000396c(int64_t a1, int64_t a2);
int64_t function_1000039b8(void);
int64_t function_100003a6c(int64_t a1, int64_t a2);
int64_t function_100003aa8(void);
int64_t function_100003bb4(void);
int64_t function_100003bdc(void);
int64_t function_100003da0(int64_t a1);
void function_100003dac(int32_t status);
int32_t function_100003db8(char * format, ...);
int32_t function_100003dc4(int32_t th);
int32_t function_100003dd0(int64_t * cond);
int32_t function_100003ddc(int64_t * cond, int64_t * mutex);
int32_t function_100003de8(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
int32_t function_100003df4(int32_t th, int64_t ** thread_return);
int32_t function_100003e00(int64_t * mutex);
int32_t function_100003e0c(int64_t * mutex);
int32_t function_100003e18(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x20726568746f4d00; // 0x100003ec5
int64_t g2 = 0x32aaaba7; // 0x100008000
int64_t g3 = 0x32aaaba7; // 0x1000080f8
int64_t g4 = 0x10000000003ec6; // 0x100008220

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _pthread_cancel(int32_t a1);
int32_t _pthread_cond_signal(int64_t * a1);
int32_t _pthread_cond_wait(int64_t * a1, int64_t * a2);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
int32_t _pthread_join(int32_t a1, int64_t ** a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038f4 - 0x10000396c
int64_t function_1000038f4(void) {
    // 0x1000038f4
    int64_t result; // 0x1000038f4
    int64_t * v1 = (int64_t *)result; // 0x10000390c
    _pthread_mutex_lock(v1);
    int32_t * v2 = (int32_t *)(result + 216); // 0x100003914
    *v2 = *v2 + 1;
    _pthread_cond_signal((int64_t *)(result + 64));
    if (*(int32_t *)(result + 220) != 0) {
        // 0x10000395c
        return result;
    }
    _pthread_cond_wait((int64_t *)(result + 112), v1);
    // 0x100003948
    while (*(int32_t *)(result + 220) == 0) {
        // 0x100003948
        _pthread_cond_wait((int64_t *)(result + 112), v1);
    }
    // 0x10000395c
    return result;
}

// Address range: 0x10000396c - 0x1000039b8
int64_t function_10000396c(int64_t a1, int64_t a2) {
    // 0x10000396c
    int64_t v1; // 0x10000396c
    int64_t * v2 = (int64_t *)(v1 - 8); // 0x100003970
    *(int32_t *)(*v2 + 224) = 1;
    _pthread_cond_signal((int64_t *)(*v2 + 160));
    int32_t * v3 = (int32_t *)(*v2 + 216); // 0x10000398c
    *v3 = *v3 - 1;
    *(int32_t *)(*v2 + 220) = 0;
    _pthread_mutex_unlock((int64_t *)*v2);
    return v1 & 0xffffffff;
}

// Address range: 0x1000039b8 - 0x100003a6c
int64_t function_1000039b8(void) {
    // 0x1000039b8
    int64_t v1; // 0x1000039b8
    int64_t * v2 = (int64_t *)v1; // 0x1000039cc
    _pthread_mutex_lock(v2);
    int32_t * v3 = (int32_t *)(v1 + 220); // 0x1000039d8
    *v3 = 1;
    int32_t * v4 = (int32_t *)(v1 + 216); // 0x1000039e4
    if (*v4 == 0) {
        _pthread_cond_wait((int64_t *)(v1 + 64), v2);
        // 0x1000039f8
        while (*v4 == 0) {
            // 0x1000039f8
            _pthread_cond_wait((int64_t *)(v1 + 64), v2);
        }
    }
    // 0x100003a0c
    _pthread_cond_signal((int64_t *)(v1 + 112));
    int32_t * v5 = (int32_t *)(v1 + 224); // 0x100003a20
    if (*v5 != 0) {
        // 0x100003a48
        *v5 = 0;
        *v3 = 0;
        return _pthread_mutex_unlock(v2);
    }
    _pthread_cond_wait((int64_t *)(v1 + 160), v2);
    // 0x100003a34
    while (*v5 == 0) {
        // 0x100003a34
        _pthread_cond_wait((int64_t *)(v1 + 160), v2);
    }
    // 0x100003a48
    *v5 = 0;
    *v3 = 0;
    return _pthread_mutex_unlock(v2);
}

// Address range: 0x100003a6c - 0x100003aa8
int64_t function_100003a6c(int64_t a1, int64_t a2) {
    // 0x100003a6c
    return function_1000038f4();
}

// Address range: 0x100003aa8 - 0x100003bb4
int64_t function_100003aa8(void) {
    // 0x100003aa8
    int64_t v1; // 0x100003aa8
    int64_t v2 = *(int64_t *)(v1 + 8); // 0x100003ad0
    int32_t * v3 = (int32_t *)(v1 + 244); // 0x100003adc
    if (*v3 == 0) {
        int64_t v4 = *(int64_t *)(v1 + 232); // 0x100003b6c
        int64_t result = 0xffffffff; // 0x100003b78
        if (v4 != 0) {
            // 0x100003b80
            result = function_100003a6c(v4, v2) & 0xffffffff;
        }
        // 0x100003ba4
        return result;
    }
    // 0x100003af0
    _printf("%d: ", v1);
    char v5 = *(char *)v2; // 0x100003b18
    int64_t v6 = v2; // 0x100003b24
    if (v5 != 0) {
        v6++;
        _putchar((int32_t)v5);
        char v7 = *(char *)v6; // 0x100003b18
        while (v7 != 0) {
            // 0x100003b2c
            v6++;
            _putchar((int32_t)v7);
            v7 = *(char *)v6;
        }
    }
    // 0x100003b44
    _putchar(10);
    *v3 = *v3 - 1;
    // 0x100003ba4
    return 1;
}

// Address range: 0x100003bb4 - 0x100003bdc
int64_t function_100003bb4(void) {
    while (true) {
        // 0x100003bd0
        function_1000039b8();
    }
}

// Address range: 0x100003bdc - 0x100003ca0
int64_t function_100003bdc(void) {
    // 0x100003bdc
    int64_t v1; // 0x100003bdc
    int64_t v2 = v1 + 8; // 0x100003c00
    int64_t v3 = *(int64_t *)v2; // 0x100003c08
    if (v3 == (int64_t)&g1) {
        // 0x100003c90
        return 0;
    }
    int32_t v4 = 0; // 0x100003c1c
    int64_t v5 = v3;
    while ((int32_t)function_100003a6c((int64_t)&g3, v5) >= 0) {
        // 0x100003bfc
        v4++;
        int64_t v6 = *(int64_t *)(8 * (int64_t)v4 + v2); // 0x100003c08
        if (v6 == (int64_t)&g1) {
            // 0x100003c90
            return 0;
        }
        v5 = v6;
    }
    // 0x100003c58
    _printf("      %s out of ink!\n", (char *)v5);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003ca0 - 0x100003da0
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cb4
    int32_t v2; // bp-56, 0x100003ca0
    int64_t v3 = &v2; // 0x100003cc4
    _pthread_create(&v2, NULL, (int64_t * (*)(int64_t *))0x100003bdc, (int64_t *)")>");
    _pthread_create((int32_t *)(v3 + 8), NULL, (int64_t * (*)(int64_t *))0x100003bdc, &g4);
    _pthread_create((int32_t *)(v3 + 16), NULL, (int64_t * (*)(int64_t *))0x100003bb4, &g3);
    _pthread_create((int32_t *)(v3 + 24), NULL, (int64_t * (*)(int64_t *))0x100003bb4, &g2);
    _pthread_join(v2, NULL);
    int32_t v4; // 0x100003ca0
    _pthread_join(v4, NULL);
    _pthread_cancel(v4);
    int32_t v5 = _pthread_cancel(v4); // 0x100003d68
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d8c
        ___stack_chk_fail((int64_t)v5);
    }
    // 0x100003d90
    return 0;
}

// Address range: 0x100003da0 - 0x100003dac
int64_t function_100003da0(int64_t a1) {
    // 0x100003da0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003dac - 0x100003db8
void function_100003dac(int32_t status) {
    // 0x100003dac
    _exit(status);
}

// Address range: 0x100003db8 - 0x100003dc4
int32_t function_100003db8(char * format, ...) {
    // 0x100003db8
    return _printf(format);
}

// Address range: 0x100003dc4 - 0x100003dd0
int32_t function_100003dc4(int32_t th) {
    // 0x100003dc4
    return _pthread_cancel(th);
}

// Address range: 0x100003dd0 - 0x100003ddc
int32_t function_100003dd0(int64_t * cond) {
    // 0x100003dd0
    return _pthread_cond_signal(cond);
}

// Address range: 0x100003ddc - 0x100003de8
int32_t function_100003ddc(int64_t * cond, int64_t * mutex) {
    // 0x100003ddc
    return _pthread_cond_wait(cond, mutex);
}

// Address range: 0x100003de8 - 0x100003df4
int32_t function_100003de8(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003de8
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003df4 - 0x100003e00
int32_t function_100003df4(int32_t th, int64_t ** thread_return) {
    // 0x100003df4
    return _pthread_join(th, thread_return);
}

// Address range: 0x100003e00 - 0x100003e0c
int32_t function_100003e00(int64_t * mutex) {
    // 0x100003e00
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003e0c - 0x100003e18
int32_t function_100003e0c(int64_t * mutex) {
    // 0x100003e0c
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003e18 - 0x100003e24
int32_t function_100003e18(int32_t c) {
    // 0x100003e18
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 19

`
`/*
 * RosettaCode example: Statistics/Normal distribution in C
 *
 * The random number generator rand() of the standard C library is obsolete
 * and should not be used in more demanding applications. There are plenty
 * libraries with advanced features (eg. GSL) with functions to calculate
 * the mean, the standard deviation, generating random numbers etc.
 * However, these features are not the core of the standard C library.
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>


#define NMAX 10000000


double mean(double* values, int n)
{
    int i;
    double s = 0;

    for ( i = 0; i < n; i++ )
        s += values[i];
    return s / n;
}


double stddev(double* values, int n)
{
    int i;
    double average = mean(values,n);
    double s = 0;

    for ( i = 0; i < n; i++ )
        s += (values[i] - average) * (values[i] - average);
    return sqrt(s / (n - 1));
}

/*
 * Normal random numbers generator - Marsaglia algorithm.
 */
double* generate(int n)
{
    int i;
    int m = n + n % 2;
    double* values = (double*)calloc(m,sizeof(double));
    double average, deviation;

    if ( values )
    {
        for ( i = 0; i < m; i += 2 )
        {
            double x,y,rsq,f;
            do {
                x = 2.0 * rand() / (double)RAND_MAX - 1.0;
                y = 2.0 * rand() / (double)RAND_MAX - 1.0;
                rsq = x * x + y * y;
            }while( rsq >= 1. || rsq == 0. );
            f = sqrt( -2.0 * log(rsq) / rsq );
            values[i]   = x * f;
            values[i+1] = y * f;
        }
    }
    return values;
}


void printHistogram(double* values, int n)
{
    const int width = 50;
    int max = 0;

    const double low   = -3.05;
    const double high  =  3.05;
    const double delta =  0.1;

    int i,j,k;
    int nbins = (int)((high - low) / delta);
    int* bins = (int*)calloc(nbins,sizeof(int));
    if ( bins != NULL )
    {
        for ( i = 0; i < n; i++ )
        {
            int j = (int)( (values[i] - low) / delta );
            if ( 0 <= j  &&  j < nbins )
                bins[j]++;
        }

        for ( j = 0; j < nbins; j++ )
            if ( max < bins[j] )
                max = bins[j];

        for ( j = 0; j < nbins; j++ )
        {
            printf("(%5.2f, %5.2f) |", low + j * delta, low + (j + 1) * delta );
            k = (int)( (double)width * (double)bins[j] / (double)max );
            while(k-- > 0) putchar('*');
            printf("  %-.1f%%", bins[j] * 100.0 / (double)n);
            putchar('\n');
        }

        free(bins);
    }
}


int main(void)
{
    double* seq;

    srand((unsigned int)time(NULL));

    if ( (seq = generate(NMAX)) != NULL )
    {
        printf("mean = %g, stddev = %g\n\n", mean(seq,NMAX), stddev(seq,NMAX));
        printHistogram(seq,NMAX);
        free(seq);

        printf("\n%s\n", "press enter");
        getchar();
        return EXIT_SUCCESS;
    }
    return EXIT_FAILURE;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003820(void);
int64_t function_1000038a0(void);
int64_t function_100003958(void);
int64_t function_100003b08(void);
int64_t * function_100003ebc(int32_t nmemb, int32_t size);
void function_100003ec8(int64_t * ptr);
int32_t function_100003ed4(void);
float64_t function_100003ee0(float64_t a1);
int32_t function_100003eec(char * format, ...);
int32_t function_100003ef8(int32_t c);
int32_t function_100003f04(void);
void function_100003f10(int32_t seed);
int32_t function_100003f1c(int32_t * timer);

// --------------------- Global Variables ---------------------

float64_t g1 = 2147483647.0; // 0x100003f28
float64_t g2 = 0.1; // 0x100003f30
float64_t g3 = -3.05; // 0x100003f38
float64_t g4 = 50.0; // 0x100003f48
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _getchar(void);
float64_t _log(float64_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003820 - 0x1000038a0
int64_t function_100003820(void) {
    // 0x100003820
    int64_t result; // 0x100003820
    int32_t v1 = result; // 0x100003828
    int32_t v2 = 0; // 0x100003838
    while (v2 - v1 < 0 != ((v2 - v1 ^ v2) & (v2 ^ v1)) < 0) {
        // 0x10000383c
        v2++;
    }
    // 0x100003880
    __asm_sshll(0.0f, 0);
    return result;
}

// Address range: 0x1000038a0 - 0x100003958
int64_t function_1000038a0(void) {
    // 0x1000038a0
    int64_t v1; // 0x1000038a0
    int32_t v2 = v1; // 0x1000038b0
    int64_t result = function_100003820(); // 0x1000038bc
    int32_t v3 = 0; // 0x1000038d0
    while (v3 - v2 < 0 != ((v3 - v2 ^ v3) & (v3 ^ v2)) < 0) {
        // 0x1000038d4
        v3++;
    }
    // 0x100003934
    return result;
}

// Address range: 0x100003958 - 0x100003b08
int64_t function_100003958(void) {
    // 0x100003958
    int64_t v1; // 0x100003958
    int32_t v2 = v1; // 0x100003964
    int32_t v3 = v2 - 2 * v2 / 2 + v2; // 0x100003980
    int64_t * v4 = _calloc(v3, 8); // 0x100003990
    int64_t result = (int64_t)v4; // 0x100003990
    if (v4 == NULL) {
        // 0x100003af8
        return result;
    }
    int32_t v5 = -v3; // 0x1000039bc
    if (v5 < 0 == (v3 & v5) < 0) {
        // 0x100003af8
        return result;
    }
    int32_t v6 = 0; // 0x100003ae8
    float64_t v7 = 2.0 * (float64_t)_rand() / g1 - 1.0; // 0x1000039fc
    float64_t v8 = 2.0 * (float64_t)_rand() / g1 - 1.0; // 0x100003a20
    float64_t v9 = v7 * v7 + v8 * v8; // 0x100003a3c
    bool v10 = false; // 0x100003a50
    bool v11 = false; // 0x100003a50
    if (v9 != 1.0) {
        v10 = v9 > 1.0;
        v11 = v9 >= 1.0 == v9 <= 1.0;
    }
    // 0x1000039d0
    while (v9 == 0.0 || v10 == v11) {
        // 0x1000039d0
        v7 = 2.0 * (float64_t)_rand() / g1 - 1.0;
        v8 = 2.0 * (float64_t)_rand() / g1 - 1.0;
        v9 = v7 * v7 + v8 * v8;
        v10 = false;
        v11 = false;
        if (v9 != 1.0) {
            v10 = v9 > 1.0;
            v11 = v9 >= 1.0 == v9 <= 1.0;
        }
    }
    // 0x100003a88
    int128_t v12; // 0x100003958
    float64_t v13 = _log((float64_t)(int64_t)v12); // 0x100003a8c
    float64_t v14 = sqrt(-2.0 * v9 / v9); // 0x100003aa4
    *(float64_t *)(8 * (int64_t)v6 + result) = v7 * v14;
    *(float64_t *)((int64_t)(8 * v6 | 8) + result) = v8 * v14;
    v6 += 2;
    int32_t v15 = v6 - v3; // 0x1000039bc
    int64_t v16 = (float32_t)v13; // 0x1000039c4
    while (v15 < 0 != ((v15 ^ v6) & (v6 ^ v3)) < 0) {
        v7 = 2.0 * (float64_t)_rand() / g1 - 1.0;
        v8 = 2.0 * (float64_t)_rand() / g1 - 1.0;
        v9 = v7 * v7 + v8 * v8;
        v10 = false;
        v11 = false;
        if (v9 != 1.0) {
            v10 = v9 > 1.0;
            v11 = v9 >= 1.0 == v9 <= 1.0;
        }
        // 0x1000039d0
        while (v9 == 0.0 || v10 == v11) {
            // 0x1000039d0
            v7 = 2.0 * (float64_t)_rand() / g1 - 1.0;
            v8 = 2.0 * (float64_t)_rand() / g1 - 1.0;
            v9 = v7 * v7 + v8 * v8;
            v10 = false;
            v11 = false;
            if (v9 != 1.0) {
                v10 = v9 > 1.0;
                v11 = v9 >= 1.0 == v9 <= 1.0;
            }
        }
        // 0x100003a88
        v13 = _log((float64_t)v16);
        v14 = sqrt(-2.0 * v9 / v9);
        *(float64_t *)(8 * (int64_t)v6 + result) = v7 * v14;
        *(float64_t *)((int64_t)(8 * v6 | 8) + result) = v8 * v14;
        v6 += 2;
        v15 = v6 - v3;
        v16 = (float32_t)v13;
    }
    // 0x100003af8
    return result;
}

// Address range: 0x100003b08 - 0x100003de4
int64_t function_100003b08(void) {
    int64_t * v1 = _calloc(60, 4); // 0x100003b5c
    int64_t result = (int64_t)v1; // 0x100003b5c
    if (v1 == NULL) {
        // 0x100003dd8
        return result;
    }
    // 0x100003b80
    int64_t v2; // 0x100003b08
    int32_t v3 = v2; // 0x100003b18
    int32_t v4 = -v3; // 0x100003b88
    int32_t v5 = 0; // 0x100003b90
    if (v4 < 0 != (v4 & v3) < 0) {
        float64_t v6 = *(float64_t *)(8 * (int64_t)v5 + v2); // 0x100003ba0
        int32_t v7 = (v6 - g3) / g2; // 0x100003bbc
        int32_t v8 = -v7; // 0x100003bcc
        int32_t * v9; // 0x100003c00
        if (v7 == 0 || v8 < 0 != (v7 & v8) < 0) {
            if (v7 < 60 != (59 - v7 & v7) < 0) {
                // 0x100003bf4
                v9 = (int32_t *)(4 * (int64_t)v7 + result);
                *v9 = *v9 + 1;
            }
        }
        // 0x100003c14
        v5++;
        while (v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v5 ^ v3)) < 0) {
            // 0x100003b98
            v6 = *(float64_t *)(8 * (int64_t)v5 + v2);
            v7 = (v6 - g3) / g2;
            v8 = -v7;
            if (v7 == 0 || v8 < 0 != (v7 & v8) < 0) {
                if (v7 < 60 != (59 - v7 & v7) < 0) {
                    // 0x100003bf4
                    v9 = (int32_t *)(4 * (int64_t)v7 + result);
                    *v9 = *v9 + 1;
                }
            }
            // 0x100003c14
            v5++;
        }
    }
    int32_t v10 = 0; // 0x100003cd4
    v10++;
    float64_t v11 = g3 + g2 * (float64_t)v10; // 0x100003cdc
    int128_t v12; // 0x100003b08
    _printf("(%5.2f, %5.2f) |", (float64_t)(int64_t)__asm_sshll(0.0f, 0), (float64_t)(int64_t)v12);
    __asm_sshll(0.0f, 0);
    __asm_sshll(0.0f, 0);
    int32_t v13 = v11 * g4 / v11; // 0x100003d30
    int32_t v14 = v13; // 0x100003d50
    int32_t v15; // 0x100003b08
    if (v13 >= 1) {
        v15 = v14;
        _putchar(42);
        v14 = v15 - 1;
        while (v15 >= 2) {
            // 0x100003d58
            v15 = v14;
            _putchar(42);
            v14 = v15 - 1;
        }
    }
    int128_t v16 = __asm_sshll(0.0f, 0); // 0x100003d74
    int128_t v17 = __asm_sshll(0.0f, 0); // 0x100003d90
    _printf("  %-.1f%%", (float64_t)(int64_t)v16);
    _putchar(10);
    int64_t v18 = v17; // 0x100003ca4
    while (v10 != 60) {
        // 0x100003cac
        v10++;
        v11 = g3 + g2 * (float64_t)v10;
        _printf("(%5.2f, %5.2f) |", (float64_t)(int64_t)__asm_sshll(0.0f, 0), (float64_t)v18);
        __asm_sshll(0.0f, 0);
        __asm_sshll(0.0f, 0);
        v13 = v11 * g4 / v11;
        v14 = v13;
        if (v13 >= 1) {
            v15 = v14;
            _putchar(42);
            v14 = v15 - 1;
            while (v15 >= 2) {
                // 0x100003d58
                v15 = v14;
                _putchar(42);
                v14 = v15 - 1;
            }
        }
        // 0x100003d64
        v16 = __asm_sshll(0.0f, 0);
        v17 = __asm_sshll(0.0f, 0);
        _printf("  %-.1f%%", (float64_t)(int64_t)v16);
        _putchar(10);
        v18 = v17;
    }
    // 0x100003dcc
    _free(v1);
    // 0x100003dd8
    return &g5;
}

// Address range: 0x100003de4 - 0x100003ebc
int64_t entry_point(void) {
    // 0x100003de4
    _srand(_time(NULL));
    int64_t v1 = function_100003958(); // 0x100003e10
    int64_t result = 1; // 0x100003e24
    if (v1 != 0) {
        // 0x100003e2c
        function_100003820();
        function_1000038a0();
        int128_t v2; // 0x100003de4
        _printf("mean = %g, stddev = %g\n\n", (float64_t)(int64_t)v2, (float64_t)(int64_t)v2);
        function_100003b08();
        _free((int64_t *)v1);
        _printf("\n%s\n", (char *)0x989680);
        _getchar();
        result = 0;
    }
    // 0x100003eac
    return result;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t * function_100003ebc(int32_t nmemb, int32_t size) {
    // 0x100003ebc
    return _calloc(nmemb, size);
}

// Address range: 0x100003ec8 - 0x100003ed4
void function_100003ec8(int64_t * ptr) {
    // 0x100003ec8
    _free(ptr);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(void) {
    // 0x100003ed4
    return _getchar();
}

// Address range: 0x100003ee0 - 0x100003eec
float64_t function_100003ee0(float64_t a1) {
    // 0x100003ee0
    return _log(a1);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(char * format, ...) {
    // 0x100003eec
    return _printf(format);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(int32_t c) {
    // 0x100003ef8
    return _putchar(c);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(void) {
    // 0x100003f04
    return _rand();
}

// Address range: 0x100003f10 - 0x100003f1c
void function_100003f10(int32_t seed) {
    // 0x100003f10
    _srand(seed);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(int32_t * timer) {
    // 0x100003f1c
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdio.h>
#include <stdlib.h>

#define SWAP(a,b) do{t=(a);(a)=(b);(b)=t;}while(0)

void _mr_unrank1(int rank, int n, int *vec) {
    int t, q, r;
    if (n < 1) return;

    q = rank / n;
    r = rank % n;
    SWAP(vec[r], vec[n-1]);
    _mr_unrank1(q, n-1, vec);
}

int _mr_rank1(int n, int *vec, int *inv) {
    int s, t;
    if (n < 2) return 0;

    s = vec[n-1];
    SWAP(vec[n-1], vec[inv[n-1]]);
    SWAP(inv[s], inv[n-1]);
    return s + n * _mr_rank1(n-1, vec, inv);
}

/* Fill the integer array <vec> (of size <n>) with the
 * permutation at rank <rank>.
 */
void get_permutation(int rank, int n, int *vec) {
    int i;
    for (i = 0; i < n; ++i) vec[i] = i;
    _mr_unrank1(rank, n, vec);
}

/* Return the rank of the current permutation of array <vec>
 * (of size <n>).
 */
int get_rank(int n, int *vec) {
    int i, r, *v, *inv;

    v = malloc(n * sizeof(int));
    inv = malloc(n * sizeof(int));

    for (i = 0; i < n; ++i) {
        v[i] = vec[i];
        inv[vec[i]] = i;
    }
    r = _mr_rank1(n, v, inv);
    free(inv);
    free(v);
    return r;
}

int main(int argc, char *argv[]) {
    int i, r, tv[4];

    for (r = 0; r < 24; ++r) {
        printf("%3d: ", r);
        get_permutation(r, 4, tv);

        for (i = 0; i < 4; ++i) {
            if (0 == i) printf("[ ");
            else printf(", ");
            printf("%d", tv[i]);
        }
        printf(" ] = %d\n", get_rank(4, tv));
    }
}
`,`#include "permutations-rank-of-a-permutation.h"



void __mr_unrank1(int param_1,int param_2,long param_3)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  
  if (0 < param_2) {
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = param_1 / param_2;
    }
    iVar3 = 0;
    if (param_2 != 0) {
      iVar3 = param_1 / param_2;
    }
    param_1 = param_1 - iVar3 * param_2;
    uVar1 = *(undefined4 *)(param_3 + (long)param_1 * 4);
    *(undefined4 *)(param_3 + (long)param_1 * 4) =
         *(undefined4 *)(param_3 + (long)(param_2 + -1) * 4);
    *(undefined4 *)(param_3 + (long)(param_2 + -1) * 4) = uVar1;
    __mr_unrank1(iVar2,param_2 + -1,param_3);
  }
  return;
}



int __mr_rank1(int param_1,long param_2,long param_3)

{
  undefined4 uVar1;
  int iVar2;
  undefined4 local_14;
  
  if (param_1 < 2) {
    local_14 = 0;
  }
  else {
    local_14 = *(int *)(param_2 + (long)(param_1 + -1) * 4);
    uVar1 = *(undefined4 *)(param_2 + (long)(param_1 + -1) * 4);
    *(undefined4 *)(param_2 + (long)(param_1 + -1) * 4) =
         *(undefined4 *)(param_2 + (long)*(int *)(param_3 + (long)(param_1 + -1) * 4) * 4);
    *(undefined4 *)(param_2 + (long)*(int *)(param_3 + (long)(param_1 + -1) * 4) * 4) = uVar1;
    uVar1 = *(undefined4 *)(param_3 + (long)local_14 * 4);
    *(undefined4 *)(param_3 + (long)local_14 * 4) =
         *(undefined4 *)(param_3 + (long)(param_1 + -1) * 4);
    *(undefined4 *)(param_3 + (long)(param_1 + -1) * 4) = uVar1;
    iVar2 = __mr_rank1(param_1 + -1,param_2,param_3);
    local_14 = local_14 + param_1 * iVar2;
  }
  return local_14;
}



void _get_permutation(undefined4 param_1,int param_2,long param_3)

{
  undefined4 local_24;
  
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    *(int *)(param_3 + (long)local_24 * 4) = local_24;
  }
  __mr_unrank1(param_1,param_2,param_3);
  return;
}



undefined4 _get_rank(int param_1,long param_2)

{
  undefined4 uVar1;
  void *pvVar2;
  void *pvVar3;
  undefined4 local_24;
  
  pvVar2 = _malloc((long)param_1 << 2);
  pvVar3 = _malloc((long)param_1 << 2);
  for (local_24 = 0; local_24 < param_1; local_24 = local_24 + 1) {
    *(undefined4 *)((long)pvVar2 + (long)local_24 * 4) =
         *(undefined4 *)(param_2 + (long)local_24 * 4);
    *(int *)((long)pvVar3 + (long)*(int *)(param_2 + (long)local_24 * 4) * 4) = local_24;
  }
  uVar1 = __mr_rank1(param_1,pvVar2,pvVar3);
  _free(pvVar3);
  _free(pvVar2);
  return uVar1;
}



undefined4 entry(ulong param_1)

{
  uint uVar1;
  int local_40;
  int local_3c;
  undefined auStack_28 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_40 = 0; local_40 < 0x18; local_40 = local_40 + 1) {
    _printf("%3d: ");
    _get_permutation(local_40,4,auStack_28);
    for (local_3c = 0; local_3c < 4; local_3c = local_3c + 1) {
      if (local_3c == 0) {
        _printf("[ ");
      }
      else {
        _printf(", ");
      }
      _printf("%d");
    }
    _get_rank(4,auStack_28);
    uVar1 = _printf(" ] = %d\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

// See https://en.wikipedia.org/wiki/Divisor_function
unsigned int divisor_count(unsigned int n) {
    unsigned int total = 1;
    // Deal with powers of 2 first
    for (; (n & 1) == 0; n >>= 1) {
        ++total;
    }
    // Odd prime factors up to the square root
    for (unsigned int p = 3; p * p <= n; p += 2) {
        unsigned int count = 1;
        for (; n % p == 0; n /= p) {
            ++count;
        }
        total *= count;
    }
    // If n > 1 then it's prime
    if (n > 1) {
        total *= 2;
    }
    return total;
}

int main() {
    const unsigned int limit = 100;
    unsigned int n;

    printf("Count of divisors for the first %d positive integers:\n", limit);
    for (n = 1; n <= limit; ++n) {
        printf("%3d", divisor_count(n));
        if (n % 20 == 0) {
            printf("\n");
        }
    }

    return 0;
}
`,`#include "tau-function.h"



int _divisor_count(uint param_1)

{
  uint uVar1;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 1;
  for (local_4 = param_1; (local_4 & 1) == 0; local_4 = local_4 >> 1) {
    local_8 = local_8 + 1;
  }
  for (local_c = 3; local_c * local_c <= local_4; local_c = local_c + 2) {
    local_10 = 1;
    uVar1 = local_4;
    while( true ) {
      local_4 = uVar1;
      uVar1 = 0;
      if (local_c != 0) {
        uVar1 = local_4 / local_c;
      }
      if (local_4 != uVar1 * local_c) break;
      local_10 = local_10 + 1;
      uVar1 = 0;
      if (local_c != 0) {
        uVar1 = local_4 / local_c;
      }
    }
    local_8 = local_8 * local_10;
  }
  if (1 < local_4) {
    local_8 = local_8 << 1;
  }
  return local_8;
}



undefined8 entry(void)

{
  uint local_1c;
  
  _printf("Count of divisors for the first %d positive integers:\n");
  for (local_1c = 1; local_1c < 0x65; local_1c = local_1c + 1) {
    _divisor_count(local_1c);
    _printf("%3d");
    if (local_1c % 0x14 == 0) {
      _printf("\n");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

void reverse(char *p) {
    size_t len = strlen(p);
    char *r = p + len - 1;
    while (p < r) {
        *p ^= *r;
        *r ^= *p;
        *p++ ^= *r--;
    }
}

void to_bt(int n, char *b) {
    static char d[] = { '0', '+', '-' };
    static int v[] = { 0, 1, -1 };

    char *ptr = b;
    *ptr = 0;

    while (n) {
        int r = n % 3;
        if (r < 0) {
            r += 3;
        }

        *ptr = d[r];
        *(++ptr) = 0;

        n -= v[r];
        n /= 3;
    }

    reverse(b);
}

int from_bt(const char *a) {
    int n = 0;

    while (*a != '\0') {
        n *= 3;
        if (*a == '+') {
            n++;
        } else if (*a == '-') {
            n--;
        }
        a++;
    }

    return n;
}

char last_char(char *ptr) {
    char c;

    if (ptr == NULL || *ptr == '\0') {
        return '\0';
    }

    while (*ptr != '\0') {
        ptr++;
    }
    ptr--;

    c = *ptr;
    *ptr = 0;
    return c;
}

void add(const char *b1, const char *b2, char *out) {
    if (*b1 != '\0' && *b2 != '\0') {
        char c1[16];
        char c2[16];
        char ob1[16];
        char ob2[16];
        char d[3] = { 0, 0, 0 };
        char L1, L2;

        strcpy(c1, b1);
        strcpy(c2, b2);
        L1 = last_char(c1);
        L2 = last_char(c2);
        if (L2 < L1) {
            L2 ^= L1;
            L1 ^= L2;
            L2 ^= L1;
        }

        if (L1 == '-') {
            if (L2 == '0') {
                d[0] = '-';
            }
            if (L2 == '-') {
                d[0] = '+';
                d[1] = '-';
            }
        }
        if (L1 == '+') {
            if (L2 == '0') {
                d[0] = '+';
            }
            if (L2 == '-') {
                d[0] = '0';
            }
            if (L2 == '+') {
                d[0] = '-';
                d[1] = '+';
            }
        }
        if (L1 == '0') {
            if (L2 == '0') {
                d[0] = '0';
            }
        }

        add(c1, &d[1], ob1);
        add(ob1, c2, ob2);
        strcpy(out, ob2);

        d[1] = 0;
        strcat(out, d);
    } else if (*b1 != '\0') {
        strcpy(out, b1);
    } else if (*b2 != '\0') {
        strcpy(out, b2);
    } else {
        *out = '\0';
    }
}

void unary_minus(const char *b, char *out) {
    while (*b != '\0') {
        if (*b == '-') {
            *out++ = '+';
            b++;
        } else if (*b == '+') {
            *out++ = '-';
            b++;
        } else {
            *out++ = *b++;
        }
    }
    *out = '\0';
}

void subtract(const char *b1, const char *b2, char *out) {
    char buf[16];
    unary_minus(b2, buf);
    add(b1, buf, out);
}

void mult(const char *b1, const char *b2, char *out) {
    char r[16] = "0";
    char t[16];
    char c1[16];
    char c2[16];
    char *ptr = c2;

    strcpy(c1, b1);
    strcpy(c2, b2);

    reverse(c2);

    while (*ptr != '\0') {
        if (*ptr == '+') {
            add(r, c1, t);
            strcpy(r, t);
        }
        if (*ptr == '-') {
            subtract(r, c1, t);
            strcpy(r, t);
        }
        strcat(c1, "0");

        ptr++;
    }

    ptr = r;
    while (*ptr == '0') {
        ptr++;
    }
    strcpy(out, ptr);
}

int main() {
    const char *a = "+-0++0+";
    char b[16];
    const char *c = "+-++-";
    char t[16];
    char d[16];

    to_bt(-436, b);
    subtract(b, c, t);
    mult(a, t, d);

    printf("      a: %14s %10d\n", a, from_bt(a));
    printf("      b: %14s %10d\n", b, from_bt(b));
    printf("      c: %14s %10d\n", c, from_bt(c));
    printf("a*(b-c): %14s %10d\n", d, from_bt(d));

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000034a8(void);
int64_t function_10000355c(void);
int64_t function_100003644(void);
int64_t function_1000036ec(void);
int64_t function_10000378c(void);
int64_t function_100003a90(void);
int64_t function_100003b6c(void);
int64_t function_100003be4(void);
int64_t function_100003ee4(int64_t a1);
int64_t function_100003ef0(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003efc(int64_t * a1, int64_t a2, int64_t a3);
int32_t function_100003f08(char * format, ...);
int32_t function_100003f14(char * s);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.37151510003798341204753020576746259e-322L; // 0x100003f20
int64_t g2 = 0x302b2b302d2b0030; // 0x100003f30
int32_t * g3 = (int32_t *)0x100000000; // 0x100008004

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcat_chk(int64_t a1, int64_t a2, int64_t a3);
int64_t ___strcpy_chk(int64_t * a1, int64_t a2, int64_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000034a8 - 0x10000355c
int64_t function_1000034a8(void) {
    // 0x1000034a8
    int64_t v1; // 0x1000034a8
    char * v2 = (char *)v1; // 0x1000034b4
    int64_t result = _strlen(v2); // 0x1000034bc
    int64_t v3 = v1 - 1 + result;
    char * v4 = (char *)v3;
    int64_t v5 = v3; // 0x1000034ec
    if (v2 >= v4) {
        // 0x100003550
        return result;
    }
    char * v6 = v2;
    char v7 = *v6 ^ *v4;
    *v6 = v7;
    char v8 = *v4 ^ v7;
    *v4 = v8;
    char * v9 = (char *)((int64_t)v6 + 1); // 0x10000353c
    *v6 = *v6 ^ v8;
    v5--;
    char * v10 = (char *)v5;
    while (v9 < v10) {
        // 0x1000034f4
        v6 = v9;
        v7 = *v6 ^ *v10;
        *v6 = v7;
        v8 = *v10 ^ v7;
        *v10 = v8;
        v9 = (char *)((int64_t)v6 + 1);
        *v6 = *v6 ^ v8;
        v5--;
        v10 = (char *)v5;
    }
    // 0x100003550
    return result;
}

// Address range: 0x10000355c - 0x100003644
int64_t function_10000355c(void) {
    // 0x10000355c
    int64_t v1; // 0x10000355c
    int32_t v2 = v1; // 0x100003568
    char * v3 = (char *)v1; // 0x100003574
    *v3 = 0;
    if (v2 == 0) {
        // 0x100003630
        return function_1000034a8();
    }
    char * v4 = v3; // 0x100003590
    int32_t v5 = v2 % 3;
    int64_t v6 = v5 < 0 ? v5 + 3 : v5; // 0x1000035d4
    *v4 = *(char *)(v6 + (int64_t)"0+-");
    v4 = (char *)((int64_t)v4 + 1);
    *v4 = 0;
    int32_t v7 = v2 - *(int32_t *)(4 * v6 + (int64_t)&g3); // 0x100003614
    int32_t v8 = v7 / 3; // 0x100003590
    while (v7 >= 3) {
        // 0x100003598
        v5 = v8 % 3;
        v6 = v5 < 0 ? v5 + 3 : v5;
        *v4 = *(char *)(v6 + (int64_t)"0+-");
        v4 = (char *)((int64_t)v4 + 1);
        *v4 = 0;
        int32_t v9 = *(int32_t *)(4 * v6 + (int64_t)&g3); // 0x10000360c
        v7 = v8 - v9;
        v8 = v7 / 3;
    }
    // 0x100003630
    return function_1000034a8();
}

// Address range: 0x100003644 - 0x1000036ec
int64_t function_100003644(void) {
    // 0x100003644
    int64_t v1; // 0x100003644
    char v2 = *(char *)v1; // 0x100003658
    if (v2 == 0) {
        // 0x1000036e0
        return 0;
    }
    int32_t v3 = 0; // 0x100003674
    int32_t v4 = v3; // 0x100003644
    switch (v2) {
        case 43: {
            // 0x100003694
            v4 = v3 + 1;
            // break -> 0x1000036d0
            break;
        }
        case 45: {
            // 0x1000036bc
            v4 = v3 - 1;
            // break -> 0x1000036d0
            break;
        }
    }
    int32_t result = v4;
    int64_t v5; // 0x100003644
    int64_t v6 = v5 + 1; // 0x1000036d4
    char v7 = *(char *)v6; // 0x100003658
    while (v7 != 0) {
        // 0x10000366c
        v3 = 3 * result;
        v4 = v3;
        switch (v7) {
            case 43: {
                // 0x100003694
                v4 = v3 + 1;
                // break -> 0x1000036d0
                break;
            }
            case 45: {
                // 0x1000036bc
                v4 = v3 - 1;
                // break -> 0x1000036d0
                break;
            }
        }
        // 0x1000036d0
        result = v4;
        v6++;
        v7 = *(char *)v6;
    }
    // 0x1000036e0
    return result;
}

// Address range: 0x1000036ec - 0x10000378c
int64_t function_1000036ec(void) {
    // 0x1000036ec
    int64_t v1; // 0x1000036ec
    if (v1 == 0 || (char)v1 == 0) {
        // 0x100003780
        return 0;
    }
    // 0x1000036ec
    int64_t v2; // 0x1000036ec
    int64_t v3 = v2;
    v2 = v3 + 1;
    while (*(char *)v3 != 0) {
        // 0x10000372c
        v3 = v2;
        v2 = v3 + 1;
    }
    char * v4 = (char *)(v3 - 1); // 0x100003764
    *v4 = 0;
    // 0x100003780
    return (int64_t)*v4 & 0xffffffff;
}

// Address range: 0x10000378c - 0x100003a90
int64_t function_10000378c(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000037a0
    int64_t v2; // 0x10000378c
    int64_t v3; // 0x10000378c
    if ((char)v2 == 0) {
        if ((char)v2 == 0) {
            // 0x100003a4c
            *(char *)v2 = 0;
        } else {
            // 0x100003a38
            v3 = ___strcpy_chk((int64_t *)v2, v2, -1);
        }
    } else {
        if ((char)v2 == 0) {
            // 0x100003a0c
            v3 = ___strcpy_chk((int64_t *)v2, v2, -1);
        } else {
            int16_t v4 = 0; // bp-116, 0x1000037e4
            int64_t v5; // bp-40, 0x10000378c
            ___strcpy_chk(&v5, v2, 16);
            int64_t v6; // bp-56, 0x10000378c
            ___strcpy_chk(&v6, v2, 16);
            int64_t v7 = function_1000036ec(); // 0x10000381c
            int32_t v8 = 0x1000000 * (int32_t)v7 >> 24; // 0x100003828
            int64_t v9 = function_1000036ec(); // 0x10000382c
            int32_t v10 = 0x1000000 * (int32_t)v9 >> 24; // 0x100003830
            int32_t v11 = v10 - v8; // 0x10000383c
            uint32_t v12 = v11 < 0 == ((v11 ^ v10) & 0x1000000 * (int32_t)(v9 ^ v7)) < 0 ? v8 : v10;
            uint32_t v13 = v11 < 0 == ((v11 ^ v10) & 0x1000000 * (int32_t)(v9 ^ v7)) < 0 ? v10 : v8;
            switch ((char)v12) {
                case 45: {
                    switch ((char)v13) {
                        case 48: {
                        }
                        case 45: {
                            v4 = v13 % 256 == 45 ? 43 : 45;
                            // break -> 0x100003998
                            break;
                        }
                    }
                    // break -> 0x100003998
                    break;
                }
                case 43: {
                    switch ((char)v13) {
                        case 48: {
                        }
                        case 45: {
                        }
                        case 43: {
                            uint32_t v14 = v13 % 256;
                            v4 = v14 == 43 ? 45 : v14 == 45 ? 48 : 43;
                            // break -> 0x100003998
                            break;
                        }
                    }
                    // break -> 0x100003998
                    break;
                }
                default: {
                    if (v12 % 256 == 48 == v13 % 256 == 48) {
                        // 0x100003988
                        v4 = 48;
                    }
                    // break -> 0x100003998
                    break;
                }
            }
            // 0x100003998
            function_10000378c();
            function_10000378c();
            int64_t v15; // bp-88, 0x10000378c
            ___strcpy_chk((int64_t *)v2, (int64_t)&v15, -1);
            v3 = ___strcat_chk(v2, (int64_t)&v4, -1);
        }
    }
    int64_t result = v3; // 0x100003a78
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003a80
        result = ___stack_chk_fail(v3);
    }
    // 0x100003a84
    return result;
}

// Address range: 0x100003a90 - 0x100003b6c
int64_t function_100003a90(void) {
    // 0x100003a90
    char * v1; // 0x100003a90
    int64_t result; // 0x100003a90
    while (true) {
        // 0x100003aa0
        int64_t v2; // 0x100003a90
        v1 = (char *)v2;
        int64_t v3; // 0x100003a90
        char v4 = *(char *)v3; // 0x100003aa4
        switch (v4) {
            case 0: {
                // 0x100003b5c
                *v1 = 0;
                return result;
            }
            case 45: {
                // 0x100003ad0
                *v1 = 43;
                // break -> 0x100003b58
                break;
            }
            case 43: {
                // 0x100003b0c
                *v1 = 45;
                // break -> 0x100003b58
                break;
            }
            default: {
                // 0x100003b30
                *v1 = v4;
                // break -> 0x100003b58
                break;
            }
        }
        // 0x100003b58
        v3++;
        v2++;
    }
    // 0x100003b5c
    *v1 = 0;
    return result;
}

// Address range: 0x100003b6c - 0x100003be4
int64_t function_100003b6c(void) {
    // 0x100003b6c
    function_100003a90();
    int64_t v1 = function_10000378c(); // 0x100003bb0
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003bc0
    int64_t result = v1; // 0x100003bcc
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003bd4
        result = ___stack_chk_fail(v1);
    }
    // 0x100003bd8
    return result;
}

// Address range: 0x100003be4 - 0x100003d90
int64_t function_100003be4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003bf8
    float128_t v2 = g1; // bp-48, 0x100003c18
    int64_t v3; // bp-80, 0x100003be4
    int64_t v4; // 0x100003be4
    ___strcpy_chk(&v3, v4, 16);
    int64_t v5; // bp-96, 0x100003be4
    ___strcpy_chk(&v5, v4, 16);
    function_1000034a8();
    int64_t v6; // bp-64, 0x100003be4
    int64_t v7 = &v6;
    char * v8 = (char *)&v5; // 0x100003c54
    int64_t v9; // 0x100003be4
    int64_t v10; // 0x100003be4
    int64_t v11; // 0x100003d44
    int64_t v12; // 0x100003d5c
    int64_t result; // 0x100003be4
    while (true) {
        char * v13 = v8;
        char v14 = *v13;
        char v15 = v14; // 0x100003be4
        switch (v14) {
            case 0: {
                // 0x100003d1c
                v10 = &v2;
                v11 = v10;
                v9 = v10;
                if (*(char *)&v2 == 48) {
                    v11++;
                    v9 = v11;
                    while (*(char *)v11 == 48) {
                        // 0x100003d40
                        v11++;
                        v9 = v11;
                    }
                }
                // 0x100003d50
                v12 = ___strcpy_chk((int64_t *)v4, v9, -1);
                result = v12;
                if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
                    // 0x100003d80
                    result = ___stack_chk_fail(v12);
                }
                // 0x100003d84
                return result;
            }
            case 43: {
                // 0x100003c88
                function_10000378c();
                ___strcpy_chk((int64_t *)&v2, v7, 16);
                v15 = *v13;
                // break -> 0x100003cb4
                break;
            }
        }
        // 0x100003cb4
        if (v15 == 45) {
            // 0x100003ccc
            function_100003b6c();
            ___strcpy_chk((int64_t *)&v2, v7, 16);
        }
        // 0x100003cf8
        ___strcat_chk((int64_t)&v3, (int64_t)&g2, 16);
        v8 = (char *)((int64_t)v13 + 1);
    }
    // 0x100003d1c
    v10 = &v2;
    v11 = v10;
    v9 = v10;
    if (*(char *)&v2 == 48) {
        v11++;
        v9 = v11;
        while (*(char *)v11 == 48) {
            // 0x100003d40
            v11++;
            v9 = v11;
        }
    }
    // 0x100003d50
    v12 = ___strcpy_chk((int64_t *)v4, v9, -1);
    result = v12;
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d80
        result = ___stack_chk_fail(v12);
    }
    // 0x100003d84
    return result;
}

// Address range: 0x100003d90 - 0x100003ee4
int64_t entry_point(void) {
    // 0x100003d90
    function_10000355c();
    function_100003b6c();
    int64_t v1; // bp-72, 0x100003d90
    int64_t v2 = &v1; // 0x100003df4
    function_100003be4();
    function_100003644();
    int64_t v3; // bp-56, 0x100003d90
    _printf("      a: %14s %10d\n", &v3, v2);
    function_100003644();
    _printf("      b: %14s %10d\n", &v3, v2);
    function_100003644();
    _printf("      c: %14s %10d\n", &v3, v2);
    function_100003644();
    int32_t v4 = _printf("a*(b-c): %14s %10d\n", &v3, v2); // 0x100003eac
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ebc
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ed0
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003ed4
    return 0;
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(int64_t a1) {
    // 0x100003ee4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t function_100003ef0(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ef0
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003efc
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * s) {
    // 0x100003f14
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdio.h>
#include <time.h>

int main() {
    int i, j, ms = 250;
    const char *a = "|/-\\";
    time_t start, now;
    struct timespec delay;
    delay.tv_sec = 0;
    delay.tv_nsec = ms * 1000000L;
    printf("\033[?25l");  // hide the cursor
    time(&start);
    while(1) {
        for (i = 0; i < 4; i++) {
            printf("\033[2J");          // clear terminal
            printf("\033[0;0H");        // place cursor at top left corner
            for (j = 0; j < 80; j++) {  // 80 character terminal width, say
                printf("%c", a[i]);
            }
            fflush(stdout);
            nanosleep(&delay, NULL);
        }
        // stop after 20 seconds, say
        time(&now);
        if (difftime(now, start) >= 20) break;
    }
    printf("\033[?25h"); // restore the cursor
    return 0;
}
`,`#include "spinning-rod-animation-text.h"



undefined8 entry(void)

{
  double dVar1;
  timespec local_48;
  time_t local_38;
  time_t local_30;
  char *local_28;
  undefined4 local_20;
  int local_1c;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = 0xfa;
  local_28 = "|/-\\";
  local_48.tv_sec = 0;
  local_48.tv_nsec = 250000000;
  _printf("\x1b[?25l");
  _time(&local_30);
  do {
    for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
      _printf("\x1b[2J");
      _printf("\x1b[0;0H");
      for (local_1c = 0; local_1c < 0x50; local_1c = local_1c + 1) {
        _printf("%c");
      }
      _fflush(*(FILE **)PTR____stdoutp_100004000);
      _nanosleep(&local_48,(timespec *)0x0);
    }
    _time(&local_38);
    dVar1 = _difftime(local_38,local_30);
  } while (dVar1 < 20.0);
  _printf("\x1b[?25h");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _difftime(time_t param_1,time_t param_2)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__difftime_100004008)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _nanosleep(timespec *param_1,timespec *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__nanosleep_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004028)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

size_t upper_bound(const int* array, size_t n, int value) {
    size_t start = 0;
    while (n > 0) {
        size_t step = n / 2;
        size_t index = start + step;
        if (value >= array[index]) {
            start = index + 1;
            n -= step + 1;
        } else {
            n = step;
        }
    }
    return start;
}

int* bins(const int* limits, size_t nlimits, const int* data, size_t ndata) {
    int* result = calloc(nlimits + 1, sizeof(int));
    if (result == NULL)
        return NULL;
    for (size_t i = 0; i < ndata; ++i)
        ++result[upper_bound(limits, nlimits, data[i])];
    return result;
}

void print_bins(const int* limits, size_t n, const int* bins) {
    if (n == 0)
        return;
    printf("           < %3d: %2d\n", limits[0], bins[0]);
    for (size_t i = 1; i < n; ++i)
        printf(">= %3d and < %3d: %2d\n", limits[i - 1], limits[i], bins[i]);
    printf(">= %3d          : %2d\n", limits[n - 1], bins[n]);
}

int main() {
    const int limits1[] = {23, 37, 43, 53, 67, 83};
    const int data1[] = {95, 21, 94, 12, 99, 4,  70, 75, 83, 93, 52, 80, 57,
                         5,  53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47, 16,
                         8,  9,  32, 84, 7,  87, 46, 19, 30, 37, 96, 6,  98,
                         40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55};

    printf("Example 1:\n");
    size_t n = sizeof(limits1) / sizeof(int);
    int* b = bins(limits1, n, data1, sizeof(data1) / sizeof(int));
    if (b == NULL) {
        fprintf(stderr, "Out of memory\n");
        return EXIT_FAILURE;
    }
    print_bins(limits1, n, b);
    free(b);

    const int limits2[] = {14, 18, 249, 312, 389, 392, 513, 591, 634, 720};
    const int data2[] = {
        445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77,  323, 525,
        570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47,
        731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267,
        248, 477, 549, 238, 62,  678, 98,  534, 622, 907, 406, 714, 184, 391,
        913, 42,  560, 247, 346, 860, 56,  138, 546, 38,  985, 948, 58,  213,
        799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917,
        313, 845, 426, 9,   457, 628, 410, 723, 354, 895, 881, 953, 677, 137,
        397, 97,  854, 740, 83,  216, 421, 94,  517, 479, 292, 963, 376, 981,
        480, 39,  257, 272, 157, 5,   316, 395, 787, 942, 456, 242, 759, 898,
        576, 67,  298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692,
        698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40,
        54,  901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427,
        876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23,
        707, 467, 33,  670, 921, 180, 991, 396, 160, 436, 717, 918, 8,   374,
        101, 684, 727, 749};

    printf("\nExample 2:\n");
    n = sizeof(limits2) / sizeof(int);
    b = bins(limits2, n, data2, sizeof(data2) / sizeof(int));
    if (b == NULL) {
        fprintf(stderr, "Out of memory\n");
        return EXIT_FAILURE;
    }
    print_bins(limits2, n, b);
    free(b);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000363c(void);
int64_t function_1000036e8(void);
int64_t function_1000037b8(void);
int64_t function_100003ab8(int64_t a1);
int64_t * function_100003ac4(int32_t nmemb, int32_t size);
int32_t function_100003ad0(struct _IO_FILE * stream, char * format, ...);
void function_100003adc(int64_t * ptr);
int64_t * function_100003ae8(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003af4(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x150000005f; // 0x100003b88
int64_t g2 = 0x120000000e; // 0x100003c50
int64_t g3 = 0x32e000001bd; // 0x100003c78
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000363c - 0x1000036e8
int64_t function_10000363c(void) {
    // 0x10000363c
    int64_t v1; // 0x10000363c
    int32_t v2 = v1; // 0x100003648
    if (v1 == 0) {
        // 0x1000036dc
        return 0;
    }
    int64_t result = 0; // 0x100003660
    int64_t v3; // 0x10000363c
    int64_t v4 = v3 / 2; // 0x100003670
    int64_t v5 = v4 + result; // 0x100003680
    int32_t v6 = *(int32_t *)(4 * v5 + v1); // 0x100003694
    int32_t v7 = v2 - v6; // 0x100003698
    int64_t v8 = result; // 0x1000036a0
    int64_t v9 = v4; // 0x1000036a0
    if (v7 < 0 == ((v7 ^ v2) & (v6 ^ v2)) < 0) {
        // 0x1000036a8
        v8 = v5 + 1;
        v9 = v3 + -1 - v4;
    }
    // 0x1000036d8
    result = v8;
    while (v9 != 0) {
        uint64_t v10 = v9;
        v4 = v10 / 2;
        v5 = v4 + result;
        v6 = *(int32_t *)(4 * v5 + v1);
        v7 = v2 - v6;
        v8 = result;
        v9 = v4;
        if (v7 < 0 == ((v7 ^ v2) & (v6 ^ v2)) < 0) {
            // 0x1000036a8
            v8 = v5 + 1;
            v9 = v10 + -1 - v4;
        }
        // 0x1000036d8
        result = v8;
    }
    // 0x1000036dc
    return result;
}

// Address range: 0x1000036e8 - 0x1000037b8
int64_t function_1000036e8(void) {
    // 0x1000036e8
    int64_t v1; // 0x1000036e8
    int64_t * v2 = _calloc((int32_t)v1 + 1, 4); // 0x100003710
    if (v2 == NULL) {
        // 0x1000037a8
        return 0;
    }
    int64_t result = (int64_t)v2; // 0x100003710
    if (v1 == 0) {
        // 0x1000037a8
        return result;
    }
    int64_t v3 = 0; // 0x10000374c
    int32_t * v4 = (int32_t *)(4 * function_10000363c() + result); // 0x10000377c
    *v4 = *v4 + 1;
    while (v3 + 1 != v1) {
        // 0x100003754
        v3++;
        v4 = (int32_t *)(4 * function_10000363c() + result);
        *v4 = *v4 + 1;
    }
    // 0x1000037a8
    return result;
}

// Address range: 0x1000037b8 - 0x1000038ec
int64_t function_1000037b8(void) {
    // 0x1000037b8
    int64_t v1; // 0x1000037b8
    if (v1 == 0) {
        // 0x1000038e0
        int64_t result; // 0x1000037b8
        return result;
    }
    // 0x1000037e8
    _printf("           < %3d: %2d\n", v1, v1);
    if (v1 == 1) {
        // 0x1000038e0
        return _printf(">= %3d          : %2d\n", v1, v1);
    }
    int64_t v2 = 1; // 0x100003834
    _printf(">= %3d and < %3d: %2d\n", v1, v1, v1);
    while (v2 + 1 != v1) {
        // 0x10000383c
        v2++;
        _printf(">= %3d and < %3d: %2d\n", v1, v1, v1);
    }
    // 0x1000038e0
    return _printf(">= %3d          : %2d\n", v1, v1);
}

// Address range: 0x1000038ec - 0x100003ab8
int64_t entry_point(void) {
    // 0x1000038ec
    int64_t v1; // bp-256, 0x1000038ec
    _memcpy(&v1, &g1, 200);
    _printf("Example 1:\n");
    int64_t v2 = function_1000036e8(); // 0x10000396c
    int64_t result; // 0x1000038ec
    int64_t v3; // 0x1000038ec
    if (v2 == 0) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003990
        result = 1;
        v3 = _fprintf((struct _IO_FILE *)v4, "Out of memory\n");
    } else {
        // 0x1000039ac
        function_1000037b8();
        _free((int64_t *)v2);
        int64_t v5; // bp-296, 0x1000038ec
        _memcpy(&v5, &g2, 40);
        int64_t v6; // bp-1096, 0x1000038ec
        _memcpy(&v6, &g3, 800);
        _printf("\nExample 2:\n");
        int64_t v7 = function_1000036e8(); // 0x100003a18
        if (v7 == 0) {
            int64_t v8 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003a3c
            result = 1;
            v3 = _fprintf((struct _IO_FILE *)v8, "Out of memory\n");
        } else {
            // 0x100003a58
            function_1000037b8();
            _free((int64_t *)v7);
            result = 0;
            v3 = &g4;
        }
    }
    int64_t v9 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003a8c
    if (v9 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003aa0
        ___stack_chk_fail(v3);
    }
    // 0x100003aa4
    return result;
}

// Address range: 0x100003ab8 - 0x100003ac4
int64_t function_100003ab8(int64_t a1) {
    // 0x100003ab8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ac4 - 0x100003ad0
int64_t * function_100003ac4(int32_t nmemb, int32_t size) {
    // 0x100003ac4
    return _calloc(nmemb, size);
}

// Address range: 0x100003ad0 - 0x100003adc
int32_t function_100003ad0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ad0
    return _fprintf(stream, format);
}

// Address range: 0x100003adc - 0x100003ae8
void function_100003adc(int64_t * ptr) {
    // 0x100003adc
    _free(ptr);
}

// Address range: 0x100003ae8 - 0x100003af4
int64_t * function_100003ae8(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ae8
    return _memcpy(dest, src, n);
}

// Address range: 0x100003af4 - 0x100003b00
int32_t function_100003af4(char * format, ...) {
    // 0x100003af4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char * lang_url = "http://www.rosettacode.org/w/api.php?action=query&"
		"list=categorymembers&cmtitle=Category:Programming_Languages&"
		"cmlimit=500&format=json";
const char * cat_url = "http://www.rosettacode.org/w/index.php?title=Special:Categories&limit=5000";

#define BLOCK 1024
char *get_page(const char *url)
{
	char cmd[1024];
	char *ptr, *buf;
	int bytes_read = 1, len = 0;
	sprintf(cmd, "wget -q \"%s\" -O -", url);
	FILE *fp = popen(cmd, "r");
	if (!fp) return 0;
	for (ptr = buf = 0; bytes_read > 0; ) {
		buf = realloc(buf, 1 + (len += BLOCK));
		if (!ptr) ptr = buf;
		bytes_read = fread(ptr, 1, BLOCK, fp);
		if (bytes_read <= 0) break;
		ptr += bytes_read;
	}
	*++ptr = '\0';
	return buf;
}

char ** get_langs(char *buf, int *l)
{
	char **arr = 0;
	for (*l = 0; (buf = strstr(buf, "Category:")) && (buf += 9); ++*l)
		for (	(*l)[arr = realloc(arr, sizeof(char*)*(1 + *l))] = buf;
			*buf != '"' || (*buf++ = 0);
			buf++);

	return arr;
}

typedef struct { const char *name; int count; } cnt_t;
cnt_t * get_cats(char *buf, char ** langs, int len, int *ret_len)
{
	char str[1024], *found;
	cnt_t *list = 0;
	int i, llen = 0;
	for (i = 0; i < len; i++) {
		sprintf(str, "/wiki/Category:%s", langs[i]);
		if (!(found = strstr(buf, str))) continue;
		buf = found + strlen(str);

		if (!(found = strstr(buf, "</a> ("))) continue;
		list = realloc(list, sizeof(cnt_t) * ++llen);
		list[llen - 1].name = langs[i];
		list[llen - 1].count = strtol(found + 6, 0, 10);
	}
	*ret_len = llen;
	return list;
}

int _scmp(const void *a, const void *b)
{
	int x = ((const cnt_t*)a)->count, y = ((const cnt_t*)b)->count;
	return x < y ? -1 : x > y;
}

int main()
{
	int len, clen;
	char ** langs = get_langs(get_page(lang_url), &len);
	cnt_t *cats = get_cats(get_page(cat_url), langs, len, &clen);
	qsort(cats, clen, sizeof(cnt_t), _scmp);
	while (--clen >= 0)
		printf("%4d %s\n", cats[clen].count, cats[clen].name);

	return 0;
}
`,`#include "rosetta-code-rank-languages-by-popularity-1.h"



void * _get_page(void)

{
  FILE *pFVar1;
  size_t sVar2;
  int local_450;
  int local_44c;
  void *local_448;
  void *local_440;
  void *local_430;
  char acStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_44c = 1;
  local_450 = 0;
  ___sprintf_chk(acStack_428,0,0x400,"wget -q \"%s\" -O -");
  pFVar1 = _popen(acStack_428,"r");
  if (pFVar1 == (FILE *)0x0) {
    local_430 = (void *)0x0;
  }
  else {
    local_448 = (void *)0x0;
    local_440 = (void *)0x0;
    while (0 < local_44c) {
      local_448 = _realloc(local_448,(long)(local_450 + 0x401));
      if (local_440 == (void *)0x0) {
        local_440 = local_448;
      }
      sVar2 = _fread(local_440,1,0x400,pFVar1);
      local_44c = (int)sVar2;
      if (local_44c < 1) break;
      local_440 = (void *)((long)local_440 + (long)local_44c);
      local_450 = local_450 + 0x400;
    }
    *(undefined *)((long)local_440 + 1) = 0;
    local_430 = local_448;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return local_430;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void * _get_langs(char *param_1,int *param_2)

{
  int iVar1;
  bool bVar2;
  void *local_28;
  char *local_18;
  
  local_28 = (void *)0x0;
  *param_2 = 0;
  local_18 = param_1;
  while( true ) {
    local_18 = _strstr(local_18,"Category:");
    bVar2 = false;
    if (local_18 != (char *)0x0) {
      local_18 = local_18 + 9;
      bVar2 = local_18 != (char *)0x0;
    }
    if (!bVar2) break;
    iVar1 = *param_2;
    local_28 = _realloc(local_28,(long)(*param_2 + 1) * 8);
    *(char **)((long)local_28 + (long)iVar1 * 8) = local_18;
    for (; *local_18 != '\"'; local_18 = local_18 + 1) {
    }
    *local_18 = '\0';
    *param_2 = *param_2 + 1;
    local_18 = local_18 + 1;
  }
  return local_28;
}



void * _get_cats(char *param_1,long param_2,int param_3,int *param_4)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  int local_460;
  int local_45c;
  void *local_458;
  char *local_430;
  char acStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_458 = (void *)0x0;
  local_460 = 0;
  local_430 = param_1;
  for (local_45c = 0; local_45c < param_3; local_45c = local_45c + 1) {
    ___sprintf_chk(acStack_428,0,0x400,"/wiki/Category:%s");
    pcVar1 = _strstr(local_430,acStack_428);
    if (pcVar1 != (char *)0x0) {
      sVar2 = _strlen(acStack_428);
      local_430 = pcVar1 + sVar2;
      pcVar1 = _strstr(local_430,"</a> (");
      if (pcVar1 != (char *)0x0) {
        local_458 = _realloc(local_458,(long)(local_460 + 1) * 0x10);
        *(undefined8 *)((long)local_458 + (long)local_460 * 0x10) =
             *(undefined8 *)(param_2 + (long)local_45c * 8);
        lVar3 = _strtol(pcVar1 + 6,(char **)0x0,10);
        *(int *)((long)local_458 + (long)local_460 * 0x10 + 8) = (int)lVar3;
        local_460 = local_460 + 1;
      }
    }
  }
  *param_4 = local_460;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return local_458;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



uint __scmp(long param_1,long param_2)

{
  undefined4 local_1c;
  
  if (*(int *)(param_1 + 8) < *(int *)(param_2 + 8)) {
    local_1c = 0xffffffff;
  }
  else {
    local_1c = (uint)(*(int *)(param_2 + 8) < *(int *)(param_1 + 8));
  }
  return local_1c;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  void *pvVar3;
  int local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = 0;
  uVar1 = _get_page(_lang_url);
  uVar1 = _get_langs(uVar1,&local_18);
  uVar2 = _get_page(_cat_url);
  pvVar3 = (void *)_get_cats(uVar2,uVar1,local_18,&local_1c);
  _qsort(pvVar3,(long)local_1c,0x10,(int *)__scmp);
  while (local_1c = local_1c + -1, -1 < local_1c) {
    _printf("%4d %s\n");
  }
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fread(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e28. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fread_100004018)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _popen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e34. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__popen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004040)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strstr(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strstr_100004048)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _strtol(char *param_1,char **param_2,int param_3)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__strtol_100004050)(param_1,param_2,param_3);
  return lVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double *cholesky(double *A, int n) {
    double *L = (double*)calloc(n * n, sizeof(double));
    if (L == NULL)
        exit(EXIT_FAILURE);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < (i+1); j++) {
            double s = 0;
            for (int k = 0; k < j; k++)
                s += L[i * n + k] * L[j * n + k];
            L[i * n + j] = (i == j) ?
                           sqrt(A[i * n + i] - s) :
                           (1.0 / L[j * n + j] * (A[i * n + j] - s));
        }

    return L;
}

void show_matrix(double *A, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            printf("%2.5f ", A[i * n + j]);
        printf("\n");
    }
}

int main() {
    int n = 3;
    double m1[] = {25, 15, -5,
                   15, 18,  0,
                   -5,  0, 11};
    double *c1 = cholesky(m1, n);
    show_matrix(c1, n);
    printf("\n");
    free(c1);

    n = 4;
    double m2[] = {18, 22,  54,  42,
                   22, 70,  86,  62,
                   54, 86, 174, 134,
                   42, 62, 134, 106};
    double *c2 = cholesky(m2, n);
    show_matrix(c2, n);
    free(c2);

    return 0;
}
`,`#include "cholesky-decomposition.h"



void * _cholesky(long param_1,int param_2)

{
  void *pvVar1;
  undefined8 local_48;
  undefined4 local_3c;
  undefined8 local_38;
  undefined4 local_30;
  undefined4 local_2c;
  
  pvVar1 = _calloc((long)(param_2 * param_2),8);
  if (pvVar1 == (void *)0x0) {
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  for (local_2c = 0; local_2c < param_2; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < local_2c + 1; local_30 = local_30 + 1) {
      local_38 = 0.0;
      for (local_3c = 0; local_3c < local_30; local_3c = local_3c + 1) {
        local_38 = (double)NEON_fmadd(*(undefined8 *)
                                       ((long)pvVar1 + (long)(local_2c * param_2 + local_3c) * 8),
                                      *(undefined8 *)
                                       ((long)pvVar1 + (long)(local_30 * param_2 + local_3c) * 8),
                                      local_38);
      }
      if (local_2c == local_30) {
        local_48 = SQRT(*(double *)(param_1 + (long)(local_2c * param_2 + local_2c) * 8) - local_38)
        ;
      }
      else {
        local_48 = (1.0 / *(double *)((long)pvVar1 + (long)(local_30 * param_2 + local_30) * 8)) *
                   (*(double *)(param_1 + (long)(local_2c * param_2 + local_30) * 8) - local_38);
      }
      *(double *)((long)pvVar1 + (long)(local_2c * param_2 + local_30) * 8) = local_48;
    }
  }
  return pvVar1;
}



ulong _show_matrix(ulong param_1,int param_2)

{
  uint uVar1;
  int local_24;
  int local_20;
  
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
      _printf("%2.5f ");
    }
    uVar1 = _printf("\n");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined8 entry(void)

{
  void *pvVar1;
  undefined auStack_f0 [128];
  undefined auStack_70 [72];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_70,&DAT_100003ed8,0x48);
  pvVar1 = (void *)_cholesky(auStack_70,3);
  _show_matrix(pvVar1,3);
  _printf("\n");
  _free(pvVar1);
  _memcpy(auStack_f0,&DAT_100003f20,0x80);
  pvVar1 = (void *)_cholesky(auStack_f0,4);
  _show_matrix(pvVar1,4);
  _free(pvVar1);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>	// for exit()
#include <signal.h>
#include <time.h>	// for clock()
#include <unistd.h>	// for POSIX usleep()

volatile sig_atomic_t gotint = 0;

void handleSigint() {
    /*
     * Signal safety: It is not safe to call clock(), printf(),
     * or exit() inside a signal handler. Instead, we set a flag.
     */
    gotint = 1;
}

int main() {
    clock_t startTime = clock();
    signal(SIGINT, handleSigint);
    int i=0;
    for (;;) {
        if (gotint)
            break;
        usleep(500000);
        if (gotint)
            break;
	printf("%d\n", ++i);
    }
    clock_t endTime = clock();
    double td = (endTime - startTime) / (double)CLOCKS_PER_SEC;
    printf("Program has run for %5.3f seconds\n", td);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e44(void);
int32_t function_100003f40(void);
int32_t function_100003f4c(char * format, ...);
void (*function_100003f58(int32_t sig, void (*handler)(int32_t)))(int32_t);
int32_t function_100003f64(int32_t useconds);

// --------------------- Global Variables ---------------------

void (*g1)(int32_t) = (void (*)(int32_t))0x52800028b0000029; // 0x100003e44
int32_t g2 = -0x1120531; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _clock(void);
int32_t _printf(char * a1, ...);
void (*_signal(int32_t a1, void (*a2)(int32_t)))(int32_t);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e44 - 0x100003e54
int64_t function_100003e44(void) {
    // 0x100003e44
    g2 = 1;
    int64_t result; // 0x100003e44
    return result;
}

// Address range: 0x100003e54 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003e54
    _clock();
    _signal(2, (void (*)(int32_t))&g1);
    int128_t v1; // 0x100003e54
    if (g2 != 0) {
        // 0x100003ef0
        _clock();
        _printf("Program has run for %5.3f seconds\n", (float64_t)(int64_t)v1);
        return 0;
    }
    _usleep(0x7a120);
    while (g2 == 0) {
        // 0x100003ec8
        _printf("%d\n", (int64_t)&g1);
        if (g2 != 0) {
            // break -> 0x100003ef0
            break;
        }
        _usleep(0x7a120);
    }
    // 0x100003ef0
    _clock();
    _printf("Program has run for %5.3f seconds\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(void) {
    // 0x100003f40
    return _clock();
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
void (*function_100003f58(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x100003f58
    return _signal(sig, handler);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(int32_t useconds) {
    // 0x100003f64
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`const char   foo     = 'a';
const double pi      = 3.14159;
const double minsize = 10;
const double maxsize = 10;

// On pointers
const int *       ptrToConst;      // The value is constant, but the pointer may change.
int const *       ptrToConst;      // The value is constant, but the pointer may change. (Identical to the above.)
int       * const constPtr;        // The pointer is constant, but the value may change.
int const * const constPtrToConst; // Both the pointer and value are constant.

// On parameters
int main(const int    argc, // note that here, the "const", applied to the integer argument itself,
                            // is kind of pointless, as arguments are passed by value, so
                            // it does not affect any code outside of the function
         const char** argv)
{
    /* ... */
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003f70 - 0x100003f88
int64_t entry_point(void) {
    // 0x100003f70
    return 0;
}

// --------------------- Meta-Information ---------------------

// Detected functions: 1

`
`#include <stdio.h>
#include <string.h>

void nb(int cells, int total_block_size, int* blocks, int block_count,
        char* output, int offset, int* count) {
    if (block_count == 0) {
        printf("%2d  %s\n", ++*count, output);
        return;
    }
    int block_size = blocks[0];
    int max_pos = cells - (total_block_size + block_count - 1);
    total_block_size -= block_size;
    cells -= block_size + 1;
    ++blocks;
    --block_count;
    for (int i = 0; i <= max_pos; ++i, --cells) {
        memset(output + offset, '.', max_pos + block_size);
        memset(output + offset + i, '#', block_size);
        nb(cells, total_block_size, blocks, block_count, output,
           offset + block_size + i + 1, count);
    }
}

void nonoblock(int cells, int* blocks, int block_count) {
    printf("%d cells and blocks [", cells);
    for (int i = 0; i < block_count; ++i)
        printf(i == 0 ? "%d" : ", %d", blocks[i]);
    printf("]:\n");
    int total_block_size = 0;
    for (int i = 0; i < block_count; ++i)
        total_block_size += blocks[i];
    if (cells < total_block_size + block_count - 1) {
        printf("no solution\n");
        return;
    }
    char output[cells + 1];
    memset(output, '.', cells);
    output[cells] = '\0';
    int count = 0;
    nb(cells, total_block_size, blocks, block_count, output, 0, &count);
}

int main() {
    int blocks1[] = {2, 1};
    nonoblock(5, blocks1, 2);
    printf("\n");

    nonoblock(5, NULL, 0);
    printf("\n");

    int blocks2[] = {8};
    nonoblock(10, blocks2, 1);
    printf("\n");

    int blocks3[] = {2, 3, 2, 3};
    nonoblock(15, blocks3, 4);
    printf("\n");

    int blocks4[] = {2, 3};
    nonoblock(5, blocks4, 2);

    return 0;
}
`,`#include "nonoblock.h"



ulong _nb(ulong param_1,int param_2,int *param_3,int param_4,long param_5,int param_6,int *param_7)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int local_4c;
  int local_14;
  
  if (param_4 == 0) {
    *param_7 = *param_7 + 1;
    uVar3 = _printf("%2d  %s\n");
    param_1 = (ulong)uVar3;
  }
  else {
    iVar1 = *param_3;
    iVar2 = (int)param_1 - (param_2 + param_4 + -1);
    local_14 = (int)param_1 - (iVar1 + 1);
    for (local_4c = 0; local_4c <= iVar2; local_4c = local_4c + 1) {
      ___memset_chk(param_5 + param_6,0x2e,(long)(iVar2 + iVar1));
      ___memset_chk(param_5 + param_6 + (long)local_4c,0x23,(long)iVar1,0xffffffffffffffff);
      param_1 = _nb(local_14,param_2 - iVar1,param_3 + 1,param_4 + -1,param_5,
                    param_6 + iVar1 + local_4c + 1,param_7);
      local_14 = local_14 + -1;
    }
  }
  return param_1;
}



void _nonoblock(int param_1,long param_2,int param_3)

{
  char *pcVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  ulong local_60;
  long local_58;
  undefined4 local_4c [3];
  undefined *local_40;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  long local_28;
  int local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_2c = param_3;
  local_28 = param_2;
  local_1c = param_1;
  _printf("%d cells and blocks [");
  for (local_30 = 0; local_30 < local_2c; local_30 = local_30 + 1) {
    pcVar1 = "%d";
    if (local_30 != 0) {
      pcVar1 = ", %d";
    }
    _printf(pcVar1);
  }
  iVar2 = _printf("]:\n");
  local_34 = 0;
  for (local_38 = 0; local_38 < local_2c; local_38 = local_38 + 1) {
    local_34 = local_34 + *(int *)(local_28 + (long)local_38 * 4);
  }
  if (local_1c < local_34 + local_2c + -1) {
    uVar3 = _printf("no solution\n");
    uVar4 = (ulong)uVar3;
  }
  else {
    local_60 = (ulong)(local_1c + 1) + 0xf & 0xfffffffffffffff0;
    local_40 = (undefined *)&local_60;
    (*(code *)PTR____chkstk_darwin_100004000)(iVar2);
    local_58 = (long)&local_60 - local_60;
    ___memset_chk(local_58,0x2e,(long)local_1c,0xffffffffffffffff);
    *(undefined *)(local_58 + local_1c) = 0;
    local_4c[0] = 0;
    uVar4 = _nb(local_1c,local_34,local_28,local_2c,local_58,0,local_4c);
  }
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar4);
  }
  return;
}



undefined8 entry(void)

{
  undefined4 local_40;
  undefined4 local_3c;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_3c = 0;
  local_20 = 0x100000002;
  _nonoblock(5,&local_20);
  _printf("\n");
  _nonoblock(5,0,0);
  _printf("\n");
  local_40 = 8;
  _nonoblock(10,&local_40,1);
  _printf("\n");
  uStack_28 = 0x300000002;
  local_30 = 0x300000002;
  _nonoblock(0xf,&local_30,4);
  _printf("\n");
  local_38 = 0x300000002;
  _nonoblock(5,&local_38,2);
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct stirling_cache_tag {
    int max;
    int* values;
} stirling_cache;

int stirling_number2(stirling_cache* sc, int n, int k) {
    if (k == n)
        return 1;
    if (k == 0 || k > n || n > sc->max)
        return 0;
    return sc->values[n*(n-1)/2 + k - 1];
}

bool stirling_cache_create(stirling_cache* sc, int max) {
    int* values = calloc(max * (max + 1)/2, sizeof(int));
    if (values == NULL)
        return false;
    sc->max = max;
    sc->values = values;
    for (int n = 1; n <= max; ++n) {
        for (int k = 1; k < n; ++k) {
            int s1 = stirling_number2(sc, n - 1, k - 1);
            int s2 = stirling_number2(sc, n - 1, k);
            values[n*(n-1)/2 + k - 1] = s1 + s2 * k;
        }
    }
    return true;
}

void stirling_cache_destroy(stirling_cache* sc) {
    free(sc->values);
    sc->values = NULL;
}

void print_stirling_numbers(stirling_cache* sc, int max) {
    printf("Stirling numbers of the second kind:\nn/k");
    for (int k = 0; k <= max; ++k)
        printf(k == 0 ? "%2d" : "%8d", k);
    printf("\n");
    for (int n = 0; n <= max; ++n) {
        printf("%2d ", n);
        for (int k = 0; k <= n; ++k)
            printf(k == 0 ? "%2d" : "%8d", stirling_number2(sc, n, k));
        printf("\n");
    }
}

int main() {
    stirling_cache sc = { 0 };
    const int max = 12;
    if (!stirling_cache_create(&sc, max)) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    print_stirling_numbers(&sc, max);
    stirling_cache_destroy(&sc);
    return 0;
}
`,`#include "stirling-numbers-of-the-second-kind.h"



undefined4 _stirling_number2(int *param_1,int param_2,int param_3)

{
  undefined4 local_4;
  
  if (param_3 == param_2) {
    local_4 = 1;
  }
  else if (((param_3 == 0) || (param_2 < param_3)) || (*param_1 < param_2)) {
    local_4 = 0;
  }
  else {
    local_4 = *(undefined4 *)
               (*(long *)(param_1 + 2) + (long)((param_2 * (param_2 + -1)) / 2 + param_3 + -1) * 4);
  }
  return local_4;
}



undefined _stirling_cache_create(int *param_1,int param_2)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  int local_38;
  int local_34;
  undefined local_11;
  
  pvVar3 = _calloc((long)((param_2 * (param_2 + 1)) / 2),4);
  if (pvVar3 == (void *)0x0) {
    local_11 = 0;
  }
  else {
    *param_1 = param_2;
    *(void **)(param_1 + 2) = pvVar3;
    for (local_34 = 1; local_34 <= param_2; local_34 = local_34 + 1) {
      for (local_38 = 1; local_38 < local_34; local_38 = local_38 + 1) {
        iVar1 = _stirling_number2(param_1,local_34 + -1,local_38 + -1);
        iVar2 = _stirling_number2(param_1,local_34 + -1,local_38);
        *(int *)((long)pvVar3 + (long)((local_34 * (local_34 + -1)) / 2 + local_38 + -1) * 4) =
             iVar1 + iVar2 * local_38;
      }
    }
    local_11 = 1;
  }
  return local_11;
}



void _stirling_cache_destroy(long param_1)

{
  _free(*(void **)(param_1 + 8));
  *(undefined8 *)(param_1 + 8) = 0;
  return;
}



int _print_stirling_numbers(undefined8 param_1,int param_2)

{
  char *pcVar1;
  int iVar2;
  int local_28;
  int local_24;
  int local_20;
  
  _printf("Stirling numbers of the second kind:\nn/k");
  for (local_20 = 0; local_20 <= param_2; local_20 = local_20 + 1) {
    pcVar1 = "%2d";
    if (local_20 != 0) {
      pcVar1 = "%8d";
    }
    _printf(pcVar1);
  }
  iVar2 = _printf("\n");
  for (local_24 = 0; local_24 <= param_2; local_24 = local_24 + 1) {
    _printf("%2d ");
    for (local_28 = 0; local_28 <= local_24; local_28 = local_28 + 1) {
      pcVar1 = "%2d";
      if (local_28 != 0) {
        pcVar1 = "%8d";
      }
      _stirling_number2(param_1,local_24,local_28);
      _printf(pcVar1);
    }
    iVar2 = _printf("\n");
  }
  return iVar2;
}



bool entry(void)

{
  bool bVar1;
  ulong uVar2;
  undefined8 local_28;
  undefined8 local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_28 = 0;
  local_20 = 0;
  uVar2 = _stirling_cache_create(&local_28);
  bVar1 = (uVar2 & 1) != 0;
  if (bVar1) {
    _print_stirling_numbers(&local_28,0xc);
    _stirling_cache_destroy(&local_28);
  }
  else {
    _fprintf(*(FILE **)PTR____stderrp_100004000,"Out of memory\n");
  }
  return !bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int countDivisors(int n) {
    int i, count;
    if (n < 2) return 1;
    count = 2; // 1 and n
    for (i = 2; i <= n/2; ++i) {
        if (n%i == 0) ++count;
    }
    return count;
}

int main() {
    int n, d, maxDiv = 0, count = 0;
    printf("The first 20 anti-primes are:\n");
    for (n = 1; count < 20; ++n) {
        d = countDivisors(n);
        if (d > maxDiv) {
            printf("%d ", n);
            maxDiv = d;
            count++;
        }
    }
    printf("\n");
    return 0;
}
`,`#include "anti-primes.h"



int _countDivisors(int param_1)

{
  int iVar1;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_4;
  
  if (param_1 < 2) {
    local_4 = 1;
  }
  else {
    local_10 = 2;
    for (local_c = 2; local_c <= param_1 / 2; local_c = local_c + 1) {
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = param_1 / local_c;
      }
      if (param_1 == iVar1 * local_c) {
        local_10 = local_10 + 1;
      }
    }
    local_4 = local_10;
  }
  return local_4;
}



undefined8 entry(void)

{
  int iVar1;
  int local_24;
  int local_20;
  int local_18;
  
  local_20 = 0;
  local_24 = 0;
  _printf("The first 20 anti-primes are:\n");
  local_18 = 1;
  while (local_24 < 0x14) {
    iVar1 = _countDivisors(local_18);
    if (local_20 < iVar1) {
      _printf("%d ");
      local_24 = local_24 + 1;
      local_20 = iVar1;
    }
    local_18 = local_18 + 1;
  }
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void pascaltriangle(unsigned int n)
{
  unsigned int c, i, j, k;

  for(i=0; i < n; i++) {
    c = 1;
    for(j=1; j <= 2*(n-1-i); j++) printf(" ");
    for(k=0; k <= i; k++) {
      printf("%3d ", c);
      c = c * (i-k)/(k+1);
    }
    printf("\n");
  }
}

int main()
{
  pascaltriangle(8);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e34(void);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e34 - 0x100003f60
int64_t function_100003e34(void) {
    // 0x100003e34
    int64_t v1; // 0x100003e34
    int32_t v2 = v1; // 0x100003e40
    if (v2 == 0) {
        // 0x100003f54
        int64_t result; // 0x100003e34
        return result;
    }
    uint32_t v3 = 0;
    uint32_t v4 = 2 * ((v3 ^ 0x7fffffff) + v2); // 0x100003e8c
    int32_t v5; // 0x100003e34
    int32_t v6; // 0x100003eb4
    if (v4 != 0) {
        _printf(" ");
        v6 = 2;
        v5 = v6;
        while (v6 >= v4 != v6 != v4) {
            // 0x100003ea0
            _printf(" ");
            v6 = v5 + 1;
            v5 = v6;
        }
    }
    // 0x100003ec8
    int32_t v7; // 0x100003e34
    int32_t v8; // 0x100003f14
    if (v3 == 0 != v3 != 0) {
        _printf("%3d ", v1);
        v8 = 1;
        v7 = v8;
        while (v3 <= v8 != v3 != v8) {
            // 0x100003ee0
            _printf("%3d ", v1);
            v8 = v7 + 1;
            v7 = v8;
        }
    }
    int32_t result2 = _printf((char *)0x100003fa3); // 0x100003f3c
    int32_t v9 = v3 + 1; // 0x100003f48
    while (v9 != v2) {
        // 0x100003e74
        v3 = v9;
        v4 = 2 * ((v3 ^ 0x7fffffff) + v2);
        if (v4 != 0) {
            _printf(" ");
            v6 = 2;
            v5 = v6;
            while (v6 >= v4 != v6 != v4) {
                // 0x100003ea0
                _printf(" ");
                v6 = v5 + 1;
                v5 = v6;
            }
        }
        // 0x100003ec8
        if (v3 == 0 != v3 != 0) {
            _printf("%3d ", v1);
            v8 = 1;
            v7 = v8;
            while (v3 <= v8 != v3 != v8) {
                // 0x100003ee0
                _printf("%3d ", v1);
                v8 = v7 + 1;
                v7 = v8;
            }
        }
        // 0x100003f34
        result2 = _printf((char *)0x100003fa3);
        v9 = v3 + 1;
    }
    // 0x100003f54
    return result2;
}

// Address range: 0x100003f60 - 0x100003f90
int64_t entry_point(void) {
    // 0x100003f60
    function_100003e34();
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>



int number_of_digits(int x){
    int NumberOfDigits;
    for(NumberOfDigits=0;x!=0;NumberOfDigits++){
        x=x/10;
    }
    return NumberOfDigits;
}

int* convert_array(char array[], int NumberOfElements)  //converts integer arguments from char to int
{
    int *convertedArray=malloc(NumberOfElements*sizeof(int));
    int originalElement, convertedElement;

    for(convertedElement=0, originalElement=0; convertedElement<NumberOfElements; convertedElement++)
    {
       convertedArray[convertedElement]=atoi(&array[originalElement]);
       originalElement+=number_of_digits(convertedArray[convertedElement])+1; //computes where is the beginning of the next element

    }
    return convertedArray;
}



int isSorted(int array[], int numberOfElements){
    int sorted=1;
    for(int counter=0;counter<numberOfElements;counter++){
        if(counter!=0 && array[counter-1]>array[counter]) sorted--;

    }
    return sorted;
}
int main(int argc, char* argv[])
{
    int* convertedArray;


    convertedArray=convert_array(*(argv+1), argc-1);



    if(isSorted(convertedArray, argc-1)==1) printf("Did you forgot to turn on your brain?! This array is already sorted!\n");
    else if(argc-1<=10) printf("Am I really supposed to sort this? Sort it by yourself!\n");
    else printf("Am I really supposed to sort this? Bhahahaha!\n");
    free(convertedArray);
    return 0;



}
`,`#include "jortsort.h"



int _number_of_digits(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0;
  for (local_4 = param_1; local_4 != 0; local_4 = local_4 / 10) {
    local_8 = local_8 + 1;
  }
  return local_8;
}



void * _convert_array(long param_1,int param_2)

{
  int iVar1;
  void *pvVar2;
  undefined4 local_30;
  undefined4 local_2c;
  
  pvVar2 = _malloc((long)param_2 << 2);
  local_2c = 0;
  for (local_30 = 0; local_30 < param_2; local_30 = local_30 + 1) {
    iVar1 = _atoi((char *)(param_1 + local_2c));
    *(int *)((long)pvVar2 + (long)local_30 * 4) = iVar1;
    iVar1 = _number_of_digits(*(undefined4 *)((long)pvVar2 + (long)local_30 * 4));
    local_2c = local_2c + iVar1 + 1;
  }
  return pvVar2;
}



int _isSorted(long param_1,int param_2)

{
  undefined4 local_14;
  undefined4 local_10;
  
  local_10 = 1;
  for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
    if ((local_14 != 0) &&
       (*(int *)(param_1 + (long)local_14 * 4) < *(int *)(param_1 + (long)(local_14 + -1) * 4))) {
      local_10 = local_10 + -1;
    }
  }
  return local_10;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = (void *)_convert_array(*(undefined8 *)(param_2 + 8),param_1 + -1);
  iVar1 = _isSorted(pvVar2,param_1 + -1);
  if (iVar1 == 1) {
    _printf("Did you forgot to turn on your brain?! This array is already sorted!\n");
  }
  else if (param_1 + -1 < 0xb) {
    _printf("Am I really supposed to sort this? Sort it by yourself!\n");
  }
  else {
    _printf("Am I really supposed to sort this? Bhahahaha!\n");
  }
  _free(pvVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

/* returns 0 if no match, 1 if matched, -1 if matched and at end */
int s_cmp(const char *a, const char *b)
{
        char c1 = 0, c2 = 0;
        while (c1 == c2) {
                c1 = *(a++);
                if ('\0' == (c2 = *(b++)))
                        return c1 == '\0' ? -1 : 1;
        }
        return 0;
}

/* returns times matched */
int s_match(const char *a, const char *b)
{
        int i = 0, count = 0;
        printf("matching %s' with %s':\n", a, b);

        while (a[i] != '\0') {
                switch (s_cmp(a + i, b)) {
                case -1:
                        printf("matched: pos %d (at end)\n\n", i);
                        return ++count;
                case 1:
                        printf("matched: pos %d\n", i);
                        ++count;
                        break;
                }
                i++;
        }
        printf("end match\n\n");
        return count;
}

int main()
{
        s_match("A Short String", "ort S");
        s_match("aBaBaBaBa", "aBa");
        s_match("something random", "Rand");

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cd0(void);
int64_t function_100003d78(void);
int32_t function_100003f08(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cd0 - 0x100003d78
int64_t function_100003cd0(void) {
    int32_t v1 = 0; // 0x100003ce4
    int32_t v2 = 0; // 0x100003ce4
    int64_t result = 0; // 0x100003cf8
    while ((v2 ^ v1) % 256 == 0) {
        // 0x100003d00
        int64_t v3; // 0x100003cd0
        v1 = (int32_t)*(char *)v3;
        int64_t v4; // 0x100003cd0
        char v5 = *(char *)v4; // 0x100003d20
        v2 = v5;
        v4++;
        v3++;
        if (v5 == 0) {
            // 0x100003d3c
            result = v1 % 256 != 0 ? 1 : 0xffffffff;
            return result;
        }
        result = 0;
    }
  lab_0x100003d6c:
    // 0x100003d6c
    return result;
}

// Address range: 0x100003d78 - 0x100003ea4
int64_t function_100003d78(void) {
    // 0x100003d78
    int64_t v1; // 0x100003d78
    _printf("matching %s' with %s':\n", (char *)v1, (char *)v1);
    int32_t v2 = 0; // 0x100003dcc
    int32_t v3 = 0; // 0x100003dcc
    if (*(char *)v1 == 0) {
        // 0x100003e7c
        _printf("end match\n\n");
        // 0x100003e94
        return 0;
    }
    int32_t v4; // 0x100003d78
    while (true) {
        // 0x100003dd4
        v4 = v2;
        int32_t v5 = v4; // 0x100003d78
        switch ((int32_t)v6) {
            case -1: {
                // 0x100003e10
                _printf("matched: pos %d (at end)\n\n", v1);
                // 0x100003e94
                return v4 + 1;
            }
            case 1: {
                // 0x100003e40
                _printf("matched: pos %d\n", v1);
                v5 = v4 + 1;
                // break -> 0x100003e6c
                break;
            }
        }
        // 0x100003e6c
        v2 = v5;
        v3++;
        int32_t result = v2; // 0x100003dcc
        if (*(char *)(v1 + (int64_t)v3) == 0) {
            // 0x100003e7c
            _printf("end match\n\n");
            // 0x100003e94
            return result;
        }
    }
    // 0x100003e10
    _printf("matched: pos %d (at end)\n\n", v1);
    // 0x100003e94
    return v4 + 1;
}

// Address range: 0x100003ea4 - 0x100003f08
int64_t entry_point(void) {
    // 0x100003ea4
    function_100003d78();
    function_100003d78();
    function_100003d78();
    return 0;
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`   #include<stdlib.h>
   #include<ctype.h>
   #include<stdio.h>

   int** oddMagicSquare(int n) {
        if (n < 3 || n % 2 == 0)
            return NULL;

        int value = 0;
        int squareSize = n * n;
        int c = n / 2, r = 0,i;

        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        while (++value <= squareSize) {
            result[r][c] = value;
            if (r == 0) {
                if (c == n - 1) {
                    r++;
                } else {
                    r = n - 1;
                    c++;
                }
            } else if (c == n - 1) {
                r--;
                c = 0;
            } else if (result[r - 1][c + 1] == 0) {
                r--;
                c++;
            } else {
                r++;
            }
        }
        return result;
    }

    int** singlyEvenMagicSquare(int n) {
        if (n < 6 || (n - 2) % 4 != 0)
            return NULL;

        int size = n * n;
        int halfN = n / 2;
        int subGridSize = size / 4, i;

        int** subGrid = oddMagicSquare(halfN);
        int gridFactors[] = {0, 2, 3, 1};
        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                int grid = (r / halfN) * 2 + (c / halfN);
                result[r][c] = subGrid[r % halfN][c % halfN];
                result[r][c] += gridFactors[grid] * subGridSize;
            }
        }

        int nColsLeft = halfN / 2;
        int nColsRight = nColsLeft - 1;

        for (int r = 0; r < halfN; r++)
            for (int c = 0; c < n; c++) {
                if (c < nColsLeft || c >= n - nColsRight
                        || (c == nColsLeft && r == nColsLeft)) {

                    if (c == 0 && r == nColsLeft)
                        continue;

                    int tmp = result[r][c];
                    result[r][c] = result[r + halfN][c];
                    result[r + halfN][c] = tmp;
                }
            }

        return result;
    }
	
	int numDigits(int n){
		int count = 1;
		
		while(n>=10){
			n /= 10;
			count++;
		}
		
		return count;
	}
	
	void printMagicSquare(int** square,int rows){
		int i,j;
		
		for(i=0;i<rows;i++){
			for(j=0;j<rows;j++){
				printf("%*s%d",rows - numDigits(square[i][j]),"",square[i][j]);
			}
			printf("\n");
		}
		printf("\nMagic constant: %d ", (rows * rows + 1) * rows / 2);
	}
	
	int main(int argC,char* argV[])
	{
		int n;
		
		if(argC!=2||isdigit(argV[1][0])==0)
			printf("Usage : %s <integer specifying rows in magic square>",argV[0]);
		else{
			n = atoi(argV[1]);
			printMagicSquare(singlyEvenMagicSquare(n),n);
		}
		return 0;
	}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036cc(void);
int64_t function_1000038ec(void);
int64_t function_100003ccc(void);
int64_t function_100003d20(void);
int64_t function_100003ef4(void);
int32_t function_100003f00(char * nptr);
int32_t function_100003f0c(int32_t c);
int64_t * function_100003f18(int32_t size);
int32_t function_100003f24(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.24399158193054463022276442972641766e-314L; // 0x100003f30

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _atoi(char * a1);
int32_t _isdigit(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000036cc - 0x1000038ec
int64_t function_1000036cc(void) {
    // 0x1000036cc
    int64_t v1; // 0x1000036cc
    int32_t v2 = v1; // 0x1000036d8
    if (v2 < 3 != (2 - v2 & v2) < 0) {
        // 0x1000038dc
        return 0;
    }
    int32_t v3 = v2 / 2; // 0x1000036f8
    if (2 * v3 == v2) {
        // 0x1000038dc
        return 0;
    }
    int64_t result = (int64_t)_malloc(8 * v2); // 0x10000374c
    int32_t v4 = -v2; // 0x100003764
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v5 = 0; // 0x100003794
        *(int64_t *)(8 * (int64_t)v5 + result) = (int64_t)_malloc(4 * v2);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003774
            *(int64_t *)(8 * (int64_t)v5 + result) = (int64_t)_malloc(4 * v2);
            v5++;
        }
    }
    int32_t v6 = v2 * v2; // 0x100003728
    int32_t v7 = 1 - v6; // 0x1000037b4
    if (v7 != 0 && v7 < 0 == (v7 & v6) < 0) {
        // 0x1000038dc
        return result;
    }
    int32_t v8 = v2 - 1;
    int32_t v9 = 1; // 0x1000037a8
    int32_t v10 = v3;
    int32_t v11 = 0;
    int64_t v12 = *(int64_t *)(8 * (int64_t)v11 + result); // 0x1000037d0
    *(int32_t *)(4 * (int64_t)v10 + v12) = v9;
    int32_t v13; // 0x1000036cc
    int32_t v14; // 0x1000036cc
    int64_t v15; // 0x100003878
    if (v11 == 0) {
        // 0x1000037f0
        v13 = v10 + (int32_t)(v10 != v8);
        v14 = v10 == v8 ? 1 : v8;
    } else {
        if (v10 == v8) {
            // 0x100003858
            v13 = 0;
            v14 = v11 - 1;
        } else {
            // 0x10000386c
            v15 = *(int64_t *)((int64_t)(8 * v11 - 8) + result);
            if (*(int32_t *)(v15 + (int64_t)(4 * v10 + 4)) == 0) {
                // 0x100003898
                v13 = v10 + 1;
                v14 = v11 - 1;
            } else {
                // 0x1000038b4
                v13 = v10;
                v14 = v11 + 1;
            }
        }
    }
    // 0x1000038cc
    v9++;
    while (v9 - v6 == 0 || v9 - v6 < 0 != ((v9 - v6 ^ v9) & (v9 ^ v6)) < 0) {
        // 0x1000037c4
        v10 = v13;
        v11 = v14;
        v12 = *(int64_t *)(8 * (int64_t)v11 + result);
        *(int32_t *)(4 * (int64_t)v10 + v12) = v9;
        if (v11 == 0) {
            // 0x1000037f0
            v13 = v10 + (int32_t)(v10 != v8);
            v14 = v10 == v8 ? 1 : v8;
        } else {
            if (v10 == v8) {
                // 0x100003858
                v13 = 0;
                v14 = v11 - 1;
            } else {
                // 0x10000386c
                v15 = *(int64_t *)((int64_t)(8 * v11 - 8) + result);
                if (*(int32_t *)(v15 + (int64_t)(4 * v10 + 4)) == 0) {
                    // 0x100003898
                    v13 = v10 + 1;
                    v14 = v11 - 1;
                } else {
                    // 0x1000038b4
                    v13 = v10;
                    v14 = v11 + 1;
                }
            }
        }
        // 0x1000038cc
        v9++;
    }
    // 0x1000038dc
    return result;
}

// Address range: 0x1000038ec - 0x100003ccc
int64_t function_1000038ec(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003900
    int64_t v2; // 0x1000038ec
    int32_t v3 = v2; // 0x100003908
    if (v3 < 6 != (5 - v3 & v3) < 0) {
        // 0x100003cbc
        return 0;
    }
    int32_t v4 = v3 - 2; // 0x100003924
    if (v4 != 4 * v4 / 4) {
        // 0x100003cbc
        return 0;
    }
    int32_t v5 = v3 / 2; // 0x100003968
    int64_t v6 = function_1000036cc(); // 0x100003984
    float128_t v7 = g1; // bp-48, 0x100003998
    int64_t result = (int64_t)_malloc(8 * v3); // 0x1000039a4
    int32_t v8 = -v3;
    if (v8 < 0 != (v8 & v3) < 0) {
        int32_t v9 = 0; // 0x1000039ec
        *(int64_t *)(8 * (int64_t)v9 + result) = (int64_t)_malloc(4 * v3);
        v9++;
        while (v9 - v3 < 0 != ((v9 - v3 ^ v9) & (v9 ^ v3)) < 0) {
            // 0x1000039cc
            *(int64_t *)(8 * (int64_t)v9 + result) = (int64_t)_malloc(4 * v3);
            v9++;
        }
        int64_t v10 = &v7;
        int32_t v11 = 0; // 0x100003af0
        int64_t * v12 = (int64_t *)(8 * (int64_t)v11 + result); // 0x100003a94
        int32_t v13 = 0; // 0x100003adc
        int64_t v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5))); // 0x100003a70
        int32_t v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5))); // 0x100003a88
        int64_t v16 = 4 * (int64_t)v13; // 0x100003a9c
        *(int32_t *)(*v12 + v16) = v15;
        int32_t v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10); // 0x100003aa8
        int32_t * v18 = (int32_t *)(*v12 + v16); // 0x100003ac8
        *v18 = *v18 + v17 * v3 * v3 / 4;
        v13++;
        while (v13 - v3 < 0 != ((v13 - v3 ^ v13) & (v13 ^ v3)) < 0) {
            // 0x100003a38
            v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5)));
            v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5)));
            v16 = 4 * (int64_t)v13;
            *(int32_t *)(*v12 + v16) = v15;
            v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10);
            v18 = (int32_t *)(*v12 + v16);
            *v18 = *v18 + v17 * v3 * v3 / 4;
            v13++;
        }
        // 0x100003aec
        v11++;
        while (v11 - v3 < 0 != ((v11 - v3 ^ v11) & (v11 ^ v3)) < 0) {
            // 0x100003a38
            v12 = (int64_t *)(8 * (int64_t)v11 + result);
            v13 = 0;
            v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5)));
            v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5)));
            v16 = 4 * (int64_t)v13;
            *(int32_t *)(*v12 + v16) = v15;
            v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10);
            v18 = (int32_t *)(*v12 + v16);
            *v18 = *v18 + v17 * v3 * v3 / 4;
            v13++;
            while (v13 - v3 < 0 != ((v13 - v3 ^ v13) & (v13 ^ v3)) < 0) {
                // 0x100003a38
                v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5)));
                v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5)));
                v16 = 4 * (int64_t)v13;
                *(int32_t *)(*v12 + v16) = v15;
                v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10);
                v18 = (int32_t *)(*v12 + v16);
                *v18 = *v18 + v17 * v3 * v3 / 4;
                v13++;
            }
            // 0x100003aec
            v11++;
        }
    }
    int32_t v19; // 0x1000038ec
    int32_t v20; // 0x1000038ec
    int32_t v21; // 0x1000038ec
    int32_t v22; // 0x100003b04
    int64_t * v23; // 0x1000038ec
    int64_t * v24; // 0x1000038ec
    if (v3 > 1 != (v5 & -v5) < 0) {
        // 0x100003b40
        v22 = v3 / 4;
        int32_t v25 = v3 + 1 - v22;
        int32_t v26 = 0; // 0x100003c78
        while (true) {
            // 0x100003b40
            v21 = v26;
            if (v8 < 0 != (v8 & v3) < 0) {
                // 0x100003b58
                v23 = (int64_t *)(8 * (int64_t)v21 + result);
                v24 = (int64_t *)((int64_t)(8 * (v21 + v5)) + result);
                v19 = 0;
                while (true) {
                  lab_0x100003b58:
                    // 0x100003b58
                    v20 = v19;
                    int32_t v27 = v20 - v22; // 0x100003b60
                    if (v27 < 0 == ((v27 ^ v20) & (v20 ^ v22)) < 0) {
                        int32_t v28 = v20 - v25; // 0x100003b80
                        if (v21 == v22 == v20 == v22 || v28 < 0 == ((v28 ^ v20) & (v20 ^ v25)) < 0) {
                            goto lab_0x100003bc0;
                        } else {
                            goto lab_0x100003c60;
                        }
                    } else {
                        goto lab_0x100003bc0;
                    }
                }
            }
          lab_0x100003c74:
            // 0x100003c74
            v26 = v21 + 1;
            int32_t v29 = v26 - v5; // 0x100003b28
            if (v29 < 0 == ((v29 ^ v26) & (v26 ^ v5)) < 0) {
                // break -> 0x100003c90
                break;
            }
        }
    }
    // 0x100003c90
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003cb8
        ___stack_chk_fail();
    }
    // 0x100003cbc
    return result;
  lab_0x100003bc0:
    if (v21 == v22 != (v20 == 0)) {
        int64_t v30 = 4 * (int64_t)v20; // 0x100003c00
        int32_t * v31 = (int32_t *)(*v23 + v30); // 0x100003c00
        *v31 = *(int32_t *)(*v24 + v30);
        *(int32_t *)(*v24 + v30) = *v31;
    }
    goto lab_0x100003c60;
  lab_0x100003c60:;
    int32_t v32 = v20 + 1; // 0x100003c64
    int32_t v33 = v32 - v3; // 0x100003b48
    v19 = v32;
    if (v33 < 0 == ((v33 ^ v32) & (v32 ^ v3)) < 0) {
        // break -> 0x100003c74
        goto lab_0x100003c74;
    }
    goto lab_0x100003b58;
}

// Address range: 0x100003ccc - 0x100003d20
int64_t function_100003ccc(void) {
    // 0x100003ccc
    int64_t v1; // 0x100003ccc
    int32_t v2 = v1; // 0x100003cd0
    int32_t result = 1; // 0x100003cec
    if (v2 < 10 != (9 - v2 & v2) < 0) {
        // 0x100003d14
        return 1;
    }
    int32_t v3 = v2;
    int32_t v4 = v3 / 10; // 0x100003cfc
    result++;
    while (v3 < 100 == (9 - v4 & v4) < 0) {
        // 0x100003cf4
        v3 = v4;
        v4 = v3 / 10;
        result++;
    }
    // 0x100003d14
    return result;
}

// Address range: 0x100003d20 - 0x100003e54
int64_t function_100003d20(void) {
    // 0x100003d20
    int64_t v1; // 0x100003d20
    int32_t v2 = v1; // 0x100003d30
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e10
        return _printf("\nMagic constant: %d ", v1);
    }
    int32_t v4 = 0; // 0x100003e04
    int32_t v5 = 0; // 0x100003de4
    function_100003ccc();
    _printf("%*s%d", v1, (char *)v1, v1);
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003d74
        function_100003ccc();
        _printf("%*s%d", v1, (char *)v1, v1);
        v5++;
    }
    // 0x100003df0
    _printf("\n");
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d74
        v5 = 0;
        function_100003ccc();
        _printf("%*s%d", v1, (char *)v1, v1);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003d74
            function_100003ccc();
            _printf("%*s%d", v1, (char *)v1, v1);
            v5++;
        }
        // 0x100003df0
        _printf("\n");
        v4++;
    }
    // 0x100003e10
    return _printf("\nMagic constant: %d ", v1);
}

// Address range: 0x100003e54 - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003e54
    int64_t v1; // 0x100003e54
    if ((int32_t)v1 != 2) {
        // 0x100003ea0
        _printf("Usage : %s <integer specifying rows in magic square>", (char *)v1);
        // 0x100003ee4
        return 0;
    }
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x100003e84
    if (_isdigit((int32_t)*(char *)*v2) == 0) {
        // 0x100003ea0
        _printf("Usage : %s <integer specifying rows in magic square>", (char *)v1);
        // 0x100003ee4
        return 0;
    }
    // 0x100003ec0
    _atoi((char *)*v2);
    function_1000038ec();
    function_100003d20();
    // 0x100003ee4
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(void) {
    // 0x100003ef4
    return ___stack_chk_fail();
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * nptr) {
    // 0x100003f00
    return _atoi(nptr);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(int32_t c) {
    // 0x100003f0c
    return _isdigit(c);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>

int pancake(int n) {
    int gap = 2, sum = 2, adj = -1;
    while (sum < n) {
        adj++;
        gap = gap * 2 - 1;
        sum += gap;
    }
    return n + adj;
}

int main() {
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 1; j < 6; j++) {
            int n = i * 5 + j;
            printf("p(%2d) = %2d  ", n, pancake(n));
        }
        printf("\n");
    }
    return 0;
}
`,`#include "pancake-numbers.h"



int _pancake(int param_1)

{
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_8 = 2;
  local_10 = -1;
  for (local_c = 2; local_c < param_1; local_c = local_c + local_8) {
    local_10 = local_10 + 1;
    local_8 = local_8 * 2 + -1;
  }
  return param_1 + local_10;
}



undefined8 entry(void)

{
  int local_1c;
  int local_18;
  
  for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
    for (local_1c = 1; local_1c < 6; local_1c = local_1c + 1) {
      _pancake(local_18 * 5 + local_1c);
      _printf("p(%2d) = %2d  ");
    }
    _printf("\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h>

typedef struct{
	int a,b,c;
	int perimeter;
	double area;
}triangle;

typedef struct elem{
	triangle t;
	struct elem* next;
}cell;

typedef cell* list;

void addAndOrderList(list *a,triangle t){
	list iter,temp;
	int flag = 0;
	
	if(*a==NULL){
		*a = (list)malloc(sizeof(cell));
		(*a)->t = t;
		(*a)->next = NULL;
	}
	
	else{
		temp = (list)malloc(sizeof(cell));

			iter = *a;
			while(iter->next!=NULL){
				if(((iter->t.area<t.area)||(iter->t.area==t.area && iter->t.perimeter<t.perimeter)||(iter->t.area==t.area && iter->t.perimeter==t.perimeter && iter->t.a<=t.a))
				&&
				(iter->next==NULL||(t.area<iter->next->t.area || t.perimeter<iter->next->t.perimeter || t.a<iter->next->t.a))){
					temp->t = t;
					temp->next = iter->next;
					iter->next = temp;
					flag = 1;
					break;
				}

				iter = iter->next;
			}
			
			if(flag!=1){
				temp->t = t;
				temp->next = NULL;
				iter->next = temp;
			}
	}
}

int gcd(int a,int b){
	if(b!=0)
		return gcd(b,a%b);
	return a;
}

void calculateArea(triangle *t){
	(*t).perimeter = (*t).a + (*t).b + (*t).c;
	(*t).area = sqrt(0.5*(*t).perimeter*(0.5*(*t).perimeter - (*t).a)*(0.5*(*t).perimeter - (*t).b)*(0.5*(*t).perimeter - (*t).c));
}

list generateTriangleList(int maxSide,int *count){
	int a,b,c;
	triangle t;
	list herons = NULL;
	
	*count = 0;
	
	for(a=1;a<=maxSide;a++){
		for(b=1;b<=a;b++){
			for(c=1;c<=b;c++){
				if(c+b > a && gcd(gcd(a,b),c)==1){
					t = (triangle){a,b,c};
					calculateArea(&t);
					if(t.area/(int)t.area == 1){
						addAndOrderList(&herons,t);
						(*count)++;
					}	
				}
			}
		}
	}
	
	return herons;
}

void printList(list a,int limit,int area){
	list iter = a;
	int count = 1;
	
	printf("\nDimensions\tPerimeter\tArea");
	
	while(iter!=NULL && count!=limit+1){
		if(area==-1 ||(area==iter->t.area)){
			printf("\n%d x %d x %d\t%d\t\t%d",iter->t.a,iter->t.b,iter->t.c,iter->t.perimeter,(int)iter->t.area);
			count++;
		}
		iter = iter->next;
	}
}

int main(int argC,char* argV[])
{
	int count;
	list herons = NULL;
	
	if(argC!=4)
		printf("Usage : %s <Max side, max triangles to print and area, -1 for area to ignore>",argV[0]);
	else{
		herons = generateTriangleList(atoi(argV[1]),&count);
		printf("Triangles found : %d",count);
		(atoi(argV[3])==-1)?printf("\nPrinting first %s triangles.",argV[2]):printf("\nPrinting triangles with area %s square units.",argV[3]);
		printList(herons,atoi(argV[2]),atoi(argV[3]));
		free(herons);
	}
	return 0;
}
`,`#include "heronian-triangles.h"



void _addAndOrderList(long *param_1,int *param_2)

{
  bool bVar1;
  void *pvVar2;
  undefined8 *puVar3;
  undefined8 uVar4;
  int *local_28;
  
  bVar1 = false;
  if (*param_1 == 0) {
    pvVar2 = _malloc(0x20);
    *param_1 = (long)pvVar2;
    puVar3 = (undefined8 *)*param_1;
    uVar4 = *(undefined8 *)param_2;
    puVar3[1] = *(undefined8 *)(param_2 + 2);
    *puVar3 = uVar4;
    puVar3[2] = *(undefined8 *)(param_2 + 4);
    *(undefined8 *)(*param_1 + 0x18) = 0;
  }
  else {
    puVar3 = (undefined8 *)_malloc(0x20);
    for (local_28 = (int *)*param_1; *(long *)(local_28 + 6) != 0;
        local_28 = *(int **)(local_28 + 6)) {
      if ((((*(double *)(local_28 + 4) < *(double *)(param_2 + 4)) ||
           ((*(double *)(local_28 + 4) == *(double *)(param_2 + 4) && (local_28[3] < param_2[3]))))
          || ((*(double *)(local_28 + 4) == *(double *)(param_2 + 4) &&
              ((local_28[3] == param_2[3] && (*local_28 <= *param_2)))))) &&
         ((*(long *)(local_28 + 6) == 0 ||
          (((*(double *)(param_2 + 4) < *(double *)(*(long *)(local_28 + 6) + 0x10) ||
            (param_2[3] < *(int *)(*(long *)(local_28 + 6) + 0xc))) ||
           (*param_2 < **(int **)(local_28 + 6))))))) {
        uVar4 = *(undefined8 *)param_2;
        puVar3[1] = *(undefined8 *)(param_2 + 2);
        *puVar3 = uVar4;
        puVar3[2] = *(undefined8 *)(param_2 + 4);
        puVar3[3] = *(undefined8 *)(local_28 + 6);
        *(undefined8 **)(local_28 + 6) = puVar3;
        bVar1 = true;
        break;
      }
    }
    if (!bVar1) {
      uVar4 = *(undefined8 *)param_2;
      puVar3[1] = *(undefined8 *)(param_2 + 2);
      *puVar3 = uVar4;
      puVar3[2] = *(undefined8 *)(param_2 + 4);
      puVar3[3] = 0;
      *(undefined8 **)(local_28 + 6) = puVar3;
    }
  }
  return;
}



int _gcd(int param_1,int param_2)

{
  int iVar1;
  int local_14;
  
  local_14 = param_1;
  if (param_2 != 0) {
    iVar1 = 0;
    if (param_2 != 0) {
      iVar1 = param_1 / param_2;
    }
    local_14 = _gcd(param_2,param_1 - iVar1 * param_2);
  }
  return local_14;
}



void _calculateArea(int *param_1)

{
  double dVar1;
  double dVar2;
  double dVar3;
  
  param_1[3] = *param_1 + param_1[1] + param_1[2];
  dVar2 = (double)NEON_fnmsub(0x3fe0000000000000,(double)(long)param_1[3],(double)(long)*param_1);
  dVar3 = (double)NEON_fnmsub(0x3fe0000000000000,(double)(long)param_1[3],(double)(long)param_1[1]);
  dVar1 = (double)NEON_fnmsub(0x3fe0000000000000,(double)(long)param_1[3],(double)(long)param_1[2]);
  *(double *)(param_1 + 4) = SQRT((double)(long)param_1[3] * 0.5 * dVar2 * dVar3 * dVar1);
  return;
}



undefined8 _generateTriangleList(int param_1,int *param_2)

{
  int iVar1;
  undefined8 uVar2;
  undefined8 local_90;
  ulong uStack_88;
  double local_80;
  int local_70;
  int iStack_6c;
  uint uStack_68;
  undefined4 uStack_64;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  ulong uStack_48;
  double local_40;
  uint local_2c;
  int local_28;
  int local_24;
  int *local_20;
  int local_14;
  
  local_58 = 0;
  *param_2 = 0;
  local_20 = param_2;
  local_14 = param_1;
  for (local_24 = 1; local_24 <= local_14; local_24 = local_24 + 1) {
    for (local_28 = 1; local_28 <= local_24; local_28 = local_28 + 1) {
      for (local_2c = 1; (int)local_2c <= local_28; local_2c = local_2c + 1) {
        if (local_24 < (int)(local_2c + local_28)) {
          uVar2 = _gcd(local_24,local_28);
          iVar1 = _gcd(uVar2,local_2c);
          if (iVar1 == 1) {
            local_70 = local_24;
            iStack_6c = local_28;
            uStack_68 = local_2c;
            uStack_64 = 0;
            local_60 = 0;
            uStack_48 = (ulong)local_2c;
            local_50 = CONCAT44(local_28,local_24);
            local_40 = 0.0;
            _calculateArea(&local_50);
            if (local_40 / (double)(int)local_40 == 1.0) {
              uStack_88 = uStack_48;
              local_90 = local_50;
              local_80 = local_40;
              _addAndOrderList(&local_58,&local_90);
              *local_20 = *local_20 + 1;
            }
          }
        }
      }
    }
  }
  return local_58;
}



int _printList(long param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int local_2c;
  long local_28;
  
  local_2c = 1;
  iVar2 = _printf("\nDimensions\tPerimeter\tArea");
  local_28 = param_1;
  while( true ) {
    bVar1 = false;
    if (local_28 != 0) {
      bVar1 = local_2c != param_2 + 1;
    }
    if (!bVar1) break;
    if ((param_3 == -1) || ((double)(long)param_3 == *(double *)(local_28 + 0x10))) {
      iVar2 = _printf("\n%d x %d x %d\t%d\t\t%d");
      local_2c = local_2c + 1;
    }
    local_28 = *(long *)(local_28 + 0x18);
  }
  return iVar2;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  undefined local_24 [4];
  long local_20;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = param_2;
  local_18 = param_1;
  if (param_1 == 4) {
    iVar1 = _atoi(*(char **)(param_2 + 8));
    pvVar3 = (void *)_generateTriangleList(iVar1,local_24);
    _printf("Triangles found : %d");
    iVar1 = _atoi(*(char **)(local_20 + 0x18));
    if (iVar1 == -1) {
      _printf("\nPrinting first %s triangles.");
    }
    else {
      _printf("\nPrinting triangles with area %s square units.");
    }
    iVar1 = _atoi(*(char **)(local_20 + 0x10));
    iVar2 = _atoi(*(char **)(local_20 + 0x18));
    _printList(pvVar3,iVar1,iVar2);
    _free(pvVar3);
  }
  else {
    _printf("Usage : %s <Max side, max triangles to print and area, -1 for area to ignore>");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>

/* size of "members", in bytes */
#define SIZEOF_MEMB (sizeof(int))
#define NMEMB 100

int main()
{
  int *ints = malloc(SIZEOF_MEMB*NMEMB);
  /* realloc can be used to increase or decrease an already
     allocated memory (same as malloc if ints is NULL) */
  ints = realloc(ints, sizeof(int)*(NMEMB+1));
  /* calloc set the memory to 0s */
  int *int2 = calloc(NMEMB, SIZEOF_MEMB);
  /* all use the same free */
  free(ints); free(int2);
  return 0;
}
`,`#include "memory-allocation-1.h"



undefined4 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  
  pvVar1 = _malloc(400);
  pvVar1 = _realloc(pvVar1,0x194);
  pvVar2 = _calloc(100,4);
  _free(pvVar1);
  _free(pvVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004018)();
  return pvVar1;
}


`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>


#define MAXLEN 100
typedef char TWord[MAXLEN];


typedef struct Node {
    TWord word;
    struct Node *next;
} Node;


int is_ordered_word(const TWord word) {
    assert(word != NULL);
    int i;

    for (i = 0; word[i] != '\0'; i++)
        if (word[i] > word[i + 1] && word[i + 1] != '\0')
            return 0;

    return 1;
}


Node* list_prepend(Node* words_list, const TWord new_word) {
    assert(new_word != NULL);
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL)
        exit(EXIT_FAILURE);

    strcpy(new_node->word, new_word);
    new_node->next = words_list;
    return new_node;
}


Node* list_destroy(Node *words_list) {
    while (words_list != NULL) {
        Node *temp = words_list;
        words_list = words_list->next;
        free(temp);
    }

    return words_list;
}


void list_print(Node *words_list) {
    while (words_list != NULL) {
        printf("\n%s", words_list->word);
        words_list = words_list->next;
    }
}


int main() {
    FILE *fp = fopen("unixdict.txt", "r");
    if (fp == NULL)
        return EXIT_FAILURE;

    Node *words = NULL;
    TWord line;
    unsigned int max_len = 0;

    while (fscanf(fp, "%99s\n", line) != EOF) {
        if (strlen(line) > max_len && is_ordered_word(line)) {
            max_len = strlen(line);
            words = list_destroy(words);
            words = list_prepend(words, line);
        } else if (strlen(line) == max_len && is_ordered_word(line)) {
            words = list_prepend(words, line);
        }
    }

    fclose(fp);
    list_print(words);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ac4(void);
int64_t function_100003bc0(void);
int64_t function_100003c6c(void);
int64_t function_100003cc4(void);
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003ec8(void);
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3);
void function_100003ee0(int32_t status);
int32_t function_100003eec(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ef8(char * filename, char * modes);
void function_100003f04(int64_t * ptr);
int32_t function_100003f10(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f1c(int32_t size);
int32_t function_100003f28(char * format, ...);
int32_t function_100003f34(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ac4 - 0x100003bc0
int64_t function_100003ac4(void) {
    // 0x100003ac4
    int64_t v1; // 0x100003ac4
    if (v1 == 0) {
        // 0x100003af4
        ___assert_rtn("is_ordered_word", "ordered-words-1.c", 18, "word != NULL");
    }
    int32_t v2 = 0; // 0x100003b1c
    char v3 = *(char *)(v1 + (int64_t)v2); // 0x100003b28
    int64_t result = 1; // 0x100003b34
    while (v3 != 0) {
        int32_t v4 = v3; // 0x100003b44
        v2++;
        char v5 = *(char *)(v1 + (int64_t)v2); // 0x100003b54
        int32_t v6 = v4 - (int32_t)v5; // 0x100003b58
        result = 0;
        if (v5 != 0 && v6 != 0 && v6 < 0 == ((v6 ^ v4) & (int32_t)(v5 ^ v3)) < 0) {
            // break -> 0x100003bb0
            break;
        }
        v3 = *(char *)(v1 + (int64_t)v2);
        result = 1;
    }
    // 0x100003bb0
    return result;
}

// Address range: 0x100003bc0 - 0x100003c6c
int64_t function_100003bc0(void) {
    // 0x100003bc0
    int64_t v1; // 0x100003bc0
    if (v1 == 0) {
        // 0x100003bf4
        ___assert_rtn("list_prepend", "ordered-words-1.c", 30, "new_word != NULL");
    }
    int64_t * v2 = _malloc(112); // 0x100003c1c
    if (v2 == NULL) {
        // 0x100003c38
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v2; // 0x100003c1c
    ___strcpy_chk(result, v1, 100);
    return result;
}

// Address range: 0x100003c6c - 0x100003cc4
int64_t function_100003c6c(void) {
    // 0x100003c6c
    int64_t v1; // 0x100003c6c
    if (v1 == 0) {
        // 0x100003cb4
        return 0;
    }
    int64_t v2; // 0x100003c6c
    int64_t v3 = *(int64_t *)(v2 + 104); // 0x100003ca0
    _free((int64_t *)v2);
    v2 = v3;
    while (v3 != 0) {
        // 0x100003c94
        v3 = *(int64_t *)(v2 + 104);
        _free((int64_t *)v2);
        v2 = v3;
    }
    // 0x100003cb4
    return 0;
}

// Address range: 0x100003cc4 - 0x100003d20
int64_t function_100003cc4(void) {
    // 0x100003cc4
    int64_t v1; // 0x100003cc4
    if (v1 == 0) {
        // 0x100003d14
        return 0;
    }
    int32_t result = _printf("\n%s", (char *)v1); // 0x100003d00
    int64_t v2; // 0x100003cc4
    int64_t v3 = *(int64_t *)(v2 + 104); // 0x100003d08
    // 0x100003cec
    while (v3 != 0) {
        // 0x100003cec
        result = _printf("\n%s", (char *)v1);
        v3 += 104;
    }
    // 0x100003d14
    return result;
}

// Address range: 0x100003d20 - 0x100003ebc
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("unixdict.txt", "r"); // 0x100003d50
    int64_t result = 1; // 0x100003d64
    int64_t v2; // bp-124, 0x100003d20
    int32_t v3; // 0x100003d20
    int32_t v4; // 0x100003d20
    int32_t v5; // 0x100003d20
    uint64_t v6; // 0x100003db8
    char ** v7; // 0x100003d9c
    if (v1 != NULL) {
        // 0x100003d84
        int64_t v8; // 0x100003d20
        v7 = (char **)v8;
        if (_fscanf(v1, "%99s\n", v7) != -1) {
            // 0x100003db0
            v3 = 0;
            while (true) {
              lab_0x100003db0:
                // 0x100003db0
                v4 = v3;
                uint64_t v9 = (int64_t)_strlen((char *)&v2); // 0x100003db4
                v6 = (int64_t)v4;
                if (v9 == v6 || v9 < v6) {
                    goto lab_0x100003e18;
                } else {
                    // 0x100003dcc
                    if ((int32_t)function_100003ac4() == 0) {
                        goto lab_0x100003e18;
                    } else {
                        int32_t v10 = _strlen((char *)&v2); // 0x100003dec
                        function_100003c6c();
                        function_100003bc0();
                        v5 = v10;
                        goto lab_0x100003e64;
                    }
                }
            }
        }
      lab_0x100003e68:
        // 0x100003e68
        _fclose(v1);
        function_100003cc4();
        result = 0;
    }
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e94
    if (v11 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003ea8
        ___stack_chk_fail();
    }
    // 0x100003eac
    return result;
  lab_0x100003e18:;
    int32_t v12 = _strlen((char *)&v2); // 0x100003e1c
    v5 = v4;
    if ((int64_t)v12 == v6) {
        // 0x100003e34
        v5 = v4;
        if ((int32_t)function_100003ac4() != 0) {
            // 0x100003e4c
            function_100003bc0();
            v5 = v4;
        }
    }
    goto lab_0x100003e64;
  lab_0x100003e64:
    // 0x100003e64
    v3 = v5;
    if (_fscanf(v1, "%99s\n", v7) == -1) {
        // break -> 0x100003e68
        goto lab_0x100003e68;
    }
    goto lab_0x100003db0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003ebc
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(void) {
    // 0x100003ec8
    return ___stack_chk_fail();
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ed4
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ee0 - 0x100003eec
void function_100003ee0(int32_t status) {
    // 0x100003ee0
    _exit(status);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(struct _IO_FILE * stream) {
    // 0x100003eec
    return _fclose(stream);
}

// Address range: 0x100003ef8 - 0x100003f04
struct _IO_FILE * function_100003ef8(char * filename, char * modes) {
    // 0x100003ef8
    return _fopen(filename, modes);
}

// Address range: 0x100003f04 - 0x100003f10
void function_100003f04(int64_t * ptr) {
    // 0x100003f04
    _free(ptr);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f10
    return _fscanf(stream, format);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t * function_100003f1c(int32_t size) {
    // 0x100003f1c
    return _malloc(size);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * s) {
    // 0x100003f34
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include<stdio.h>

int main()
{
	char ch, str[100];
	int i;
	
	do{
		printf("\nEnter the string :");
		fgets(str,100,stdin);
		for(i=0;str[i]!=00;i++)
		{
			if(str[i]=='#'||str[i]==';')
			{
				str[i]=00;
				break;
			}
		}
		printf("\nThe modified string is : %s",str);
		printf("\nDo you want to repeat (y/n): ");
		scanf("%c",&ch);
		fflush(stdin);
	}while(ch=='y'||ch=='Y');
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f18(int64_t a1);
int32_t function_100003f24(struct _IO_FILE * stream);
char * function_100003f30(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003f3c(char * format, ...);
int32_t function_100003f48(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fflush(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003f18
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003da0
    while (true) {
      lab_0x100003db0:
        // 0x100003db0
        _printf("\nEnter the string :");
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003dc4
        int64_t v3; // bp-124, 0x100003d8c
        _fgets((char *)&v3, 100, (struct _IO_FILE *)v2);
        int32_t v4 = 0; // 0x100003dd8
        while (true) {
          lab_0x100003ddc:;
            int32_t v5 = v4;
            char * v6 = (char *)((int64_t)v5 + (int64_t)&v3);
            switch (*v6) {
                case 0: {
                    goto lab_0x100003e58;
                }
                case 35: {
                    // 0x100003e30
                    *v6 = 0;
                    goto lab_0x100003e58;
                }
                case 59: {
                    // 0x100003e30
                    *v6 = 0;
                    goto lab_0x100003e58;
                }
                default: {
                    // 0x100003e48
                    v4 = v5 + 1;
                    goto lab_0x100003ddc;
                }
            }
        }
        goto lab_0x100003e58;
    }
  lab_0x100003ee4:;
    // 0x100003ee4
    int32_t v7; // 0x100003ea0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f04
        ___stack_chk_fail((int64_t)v7);
    }
    // 0x100003f08
    return 0;
  lab_0x100003e58:
    // 0x100003e58
    _printf("\nThe modified string is : %s", (char *)100);
    _printf("\nDo you want to repeat (y/n): ");
    _scanf("%c", (char *)100);
    v7 = _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010);
    int32_t v8; // 0x100003d8c
    if ((v8 & 223 || 32) != 121) {
        // break -> 0x100003ee4
        goto lab_0x100003ee4;
    }
    goto lab_0x100003db0;
}

// Address range: 0x100003f18 - 0x100003f24
int64_t function_100003f18(int64_t a1) {
    // 0x100003f18
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(struct _IO_FILE * stream) {
    // 0x100003f24
    return _fflush(stream);
}

// Address range: 0x100003f30 - 0x100003f3c
char * function_100003f30(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f30
    return _fgets(s, n, stream);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* for ASCII only */
static char code[128] = { 0 };
void add_code(const char *s, int c)
{
	while (*s) {
		code[(int)*s] = code[0x20 ^ (int)*s] = c;
		s++;
	}
}

void init()
{
	static const char *cls[] =
		{ "AEIOU", "", "BFPV", "CGJKQSXZ", "DT", "L", "MN", "R", 0};
	int i;
	for (i = 0; cls[i]; i++)
		add_code(cls[i], i - 1);
}

/* returns a static buffer; user must copy if want to save
   result across calls */
const char* soundex(const char *s)
{
	static char out[5];
	int c, prev, i;

	out[0] = out[4] = 0;
	if (!s || !*s) return out;

	out[0] = *s++;

	/* first letter, though not coded, can still affect next letter: Pfister */
	prev = code[(int)out[0]];
	for (i = 1; *s && i < 4; s++) {
		if ((c = code[(int)*s]) == prev) continue;

		if (c == -1) prev = 0;	/* vowel as separator */
		else if (c > 0) {
			out[i++] = c + '0';
			prev = c;
		}
	}
	while (i < 4) out[i++] = '0';
	return out;
}

int main()
{
	int i;
	const char *sdx, *names[][2] = {
		{"Soundex",	"S532"},
		{"Example",	"E251"},
		{"Sownteks",	"S532"},
		{"Ekzampul",	"E251"},
		{"Euler",	"E460"},
		{"Gauss",	"G200"},
		{"Hilbert",	"H416"},
		{"Knuth",	"K530"},
		{"Lloyd",	"L300"},
		{"Lukasiewicz",	"L222"},
		{"Ellery",	"E460"},
		{"Ghosh",	"G200"},
		{"Heilbronn",	"H416"},
		{"Kant",	"K530"},
		{"Ladd",	"L300"},
		{"Lissajous",	"L222"},
		{"Wheaton",	"W350"},
		{"Burroughs",	"B620"},
		{"Burrows",	"B620"},
		{"O'Hara",	"O600"},
		{"Washington",	"W252"},
		{"Lee",		"L000"},
		{"Gutierrez",	"G362"},
		{"Pfister",	"P236"},
		{"Jackson",	"J250"},
		{"Tymczak",	"T522"},
		{"VanDeusen",	"V532"},
		{"Ashcraft",	"A261"},
		{0, 0}
	};

	init();

	puts("  Test name  Code  Got\n----------------------");
	for (i = 0; names[i][0]; i++) {
		sdx = soundex(names[i][0]);
		printf("%11s  %s  %s ", names[i][0], names[i][1], sdx);
		printf("%s\n", strcmp(sdx, names[i][1]) ? "not ok" : "ok");
	}

	return 0;
}
`,`#include "soundex.h"



void _add_code(char *param_1,undefined param_2)

{
  char *local_8;
  
  for (local_8 = param_1; *local_8 != '\0'; local_8 = local_8 + 1) {
    (&DAT_100008048)[(int)((int)*local_8 ^ 0x20)] = param_2;
    (&DAT_100008048)[*local_8] = param_2;
  }
  return;
}



void _init(void)

{
  int local_14;
  
  for (local_14 = 0; (&PTR_s_AEIOU_100008000)[local_14] != (undefined *)0x0; local_14 = local_14 + 1
      ) {
    _add_code((&PTR_s_AEIOU_100008000)[local_14],local_14 + -1);
  }
  return;
}



undefined1 * _soundex(char *param_1)

{
  char cVar1;
  char cVar2;
  long lVar3;
  int local_1c;
  char *local_10;
  
  DAT_1000080cc = 0;
  DAT_1000080c8 = '\0';
  if ((param_1 != (char *)0x0) && (*param_1 != '\0')) {
    DAT_1000080c8 = *param_1;
    cVar1 = (&DAT_100008048)[DAT_1000080c8];
    local_1c = 1;
    for (local_10 = param_1 + 1; *local_10 != '\0' && local_1c < 4; local_10 = local_10 + 1) {
      cVar2 = (&DAT_100008048)[*local_10];
      if (cVar2 != cVar1) {
        if (cVar2 == -1) {
          cVar1 = '\0';
        }
        else if ('\0' < cVar2) {
          lVar3 = (long)local_1c;
          local_1c = local_1c + 1;
          (&DAT_1000080c8)[lVar3] = cVar2 + '0';
          cVar1 = cVar2;
        }
      }
    }
    while (local_1c < 4) {
      lVar3 = (long)local_1c;
      local_1c = local_1c + 1;
      (&DAT_1000080c8)[lVar3] = 0x30;
    }
  }
  return &DAT_1000080c8;
}



undefined8 entry(void)

{
  int iVar1;
  char *pcVar2;
  int local_200;
  long alStack_1f8 [58];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(alStack_1f8,&PTR_s_Soundex_100004030,0x1d0);
  _init();
  iVar1 = _puts("  Test name  Code  Got\n----------------------");
  local_200 = 0;
  while (alStack_1f8[(long)local_200 * 2] != 0) {
    pcVar2 = (char *)_soundex(alStack_1f8[(long)local_200 * 2]);
    _printf("%11s  %s  %s ");
    _strcmp(pcVar2,(char *)alStack_1f8[(long)local_200 * 2 + 1]);
    iVar1 = _printf("%s\n");
    local_200 = local_200 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003db4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dcc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dd8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003de4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <locale.h>

bool *sieve(uint64_t limit) {
    uint64_t i, p;
    limit++;
    // True denotes composite, false denotes prime.
    bool *c = calloc(limit, sizeof(bool)); // all false by default
    c[0] = true;
    c[1] = true;
    for (i = 4; i < limit; i += 2) c[i] = true;
    p = 3; // Start from 3.
    while (true) {
        uint64_t p2 = p * p;
        if (p2 >= limit) break;
        for (i = p2; i < limit; i += 2 * p) c[i] = true;
        while (true) {
            p += 2;
            if (!c[p]) break;
        }
    }
    return c;
}

typedef struct {
    char digs[20];
    int count;
} digits;

digits getDigits(uint64_t n) {
    if (n == 0) return (digits){ {0}, 1 };
    digits d;
    d.count = 0;
    while (n > 0) {
        d.digs[d.count++] = n % 10;
        n = n / 10;
    }
    return d; // note digits are in reverse order
}

int main() {
    const uint64_t limit = 10000000000;
    uint64_t i, j, pc = 0, p1, p2, p3, key1, key2, key3;
    int k, count, count2;
    digits d;
    bool *c = sieve(limit);
    for (i = 0; i < limit; ++i) {
        if (!c[i]) ++pc;
    }
    uint64_t *primes = (uint64_t *)malloc(pc * sizeof(uint64_t));
    for (i = 0, j = 0; i < limit; ++i) {
        if (!c[i]) primes[j++] = i;
    }
    free(c);
    uint64_t orm25[25];
    int counts[2];
    j = limit/10;
    for (i = 0; i < pc-2; ++i) {
        p1 = primes[i];
        p2 = primes[i+1];
        p3 = primes[i+2];
        if ((p2 - p1) % 18 || (p3 - p2) % 18) continue;
        key1 = 1;
        d = getDigits(p1);
        for (k = 0; k < d.count; ++k) key1 *= primes[d.digs[k]];
        key2 = 1;
        d = getDigits(p2);
        for (k = 0; k < d.count; ++k) key2 *= primes[d.digs[k]];
        if (key1 != key2) continue;
        key3 = 1;
        d = getDigits(p3);
        for (k = 0; k < d.count; ++k) key3 *= primes[d.digs[k]];
        if (key2 == key3) {
            if (count < 25) orm25[count] = p1;
            if (p1 >= j) {
                counts[count2++] = count;
                j *= 10;
            }
            ++count;
        }
    }
    counts[count2] = count;
    printf("Smallest members of first 25 Ormiston triples:\n");
    setlocale(LC_NUMERIC, "");
    for (i = 0; i < 25; ++i) {
        printf("%'10ld  ", orm25[i]);
        if (!((i+1) % 5)) printf("\n");
    }
    printf("\n");
    j = limit/10;
    for (i = 0; i < 2; ++i) {
        printf("%'d Ormiston triples before %'ld\n", counts[i], j);
        j *= 10;
        printf("\n");
    }
    free(primes);
    return 0;
}
`,`#include "ormiston-triples.h"



undefined * _sieve(long param_1)

{
  size_t sVar1;
  undefined *puVar2;
  long local_28;
  ulong local_20;
  
  sVar1 = param_1 + 1;
  puVar2 = (undefined *)_calloc(sVar1,1);
  *puVar2 = 1;
  puVar2[1] = 1;
  for (local_20 = 4; local_20 < sVar1; local_20 = local_20 + 2) {
    puVar2[local_20] = 1;
  }
  local_28 = 3;
  while (local_20 = local_28 * local_28, local_20 < sVar1) {
    for (; local_20 < sVar1; local_20 = local_20 + local_28 * 2) {
      puVar2[local_20] = 1;
    }
    do {
      local_28 = local_28 + 2;
    } while ((puVar2[local_28] & 1) != 0);
  }
  return puVar2;
}



void _getDigits(undefined8 *param_1,ulong param_2)

{
  int iVar1;
  ulong local_8;
  
  if (param_2 == 0) {
    *param_1 = 0;
    param_1[1] = 0;
    param_1[2] = 0;
    *(undefined4 *)((long)param_1 + 0x14) = 1;
  }
  else {
    *(undefined4 *)((long)param_1 + 0x14) = 0;
    for (local_8 = param_2; local_8 != 0; local_8 = local_8 / 10) {
      iVar1 = *(int *)((long)param_1 + 0x14);
      *(int *)((long)param_1 + 0x14) = iVar1 + 1;
      *(char *)((long)param_1 + (long)iVar1) = (char)local_8 + (char)(local_8 / 10) * -10;
    }
  }
  return;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  void *pvVar2;
  void *pvVar3;
  ulong uVar4;
  long lVar5;
  long lVar6;
  int local_1bc;
  int local_1b8;
  int local_1b4;
  long local_1b0;
  long local_1a8;
  long local_1a0;
  long local_180;
  ulong local_178;
  ulong local_170;
  undefined8 local_158;
  undefined8 uStack_150;
  undefined8 local_148;
  undefined8 local_140;
  undefined8 uStack_138;
  undefined8 local_130;
  undefined8 local_128;
  undefined8 uStack_120;
  undefined8 local_118;
  int aiStack_110 [2];
  ulong auStack_108 [25];
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_180 = 0;
  pvVar2 = (void *)_sieve();
  for (local_170 = 0; local_170 < 10000000000; local_170 = local_170 + 1) {
    if ((*(byte *)((long)pvVar2 + local_170) & 1) == 0) {
      local_180 = local_180 + 1;
    }
  }
  pvVar3 = _malloc(local_180 << 3);
  local_178 = 0;
  for (local_170 = 0; local_170 < 10000000000; local_170 = local_170 + 1) {
    if ((*(byte *)((long)pvVar2 + local_170) & 1) == 0) {
      *(ulong *)((long)pvVar3 + local_178 * 8) = local_170;
      local_178 = local_178 + 1;
    }
  }
  _free(pvVar2);
  local_178 = 1000000000;
  for (local_170 = 0; local_170 < local_180 - 2U; local_170 = local_170 + 1) {
    uVar4 = *(ulong *)((long)pvVar3 + local_170 * 8);
    lVar5 = *(long *)((long)pvVar3 + (local_170 + 1) * 8);
    lVar6 = *(long *)((long)pvVar3 + (local_170 + 2) * 8);
    if (((lVar5 - uVar4) % 0x12 == 0) && ((ulong)(lVar6 - lVar5) % 0x12 == 0)) {
      local_1a0 = 1;
      _getDigits(&local_128,uVar4);
      uStack_38 = uStack_120;
      local_40 = local_128;
      local_30 = local_118;
      uVar1 = local_30;
      for (local_1b4 = 0; local_30._4_4_ = (int)((ulong)local_118 >> 0x20),
          local_1b4 < local_30._4_4_; local_1b4 = local_1b4 + 1) {
        local_1a0 = local_1a0 *
                    *(long *)((long)pvVar3 + (long)*(char *)((long)&local_40 + (long)local_1b4) * 8)
        ;
      }
      local_1a8 = 1;
      local_30 = uVar1;
      _getDigits(&local_140,lVar5);
      uStack_38 = uStack_138;
      local_40 = local_140;
      local_30 = local_130;
      uVar1 = local_30;
      for (local_1b4 = 0; local_30._4_4_ = (int)((ulong)local_130 >> 0x20),
          local_1b4 < local_30._4_4_; local_1b4 = local_1b4 + 1) {
        local_1a8 = local_1a8 *
                    *(long *)((long)pvVar3 + (long)*(char *)((long)&local_40 + (long)local_1b4) * 8)
        ;
      }
      local_30 = uVar1;
      if (local_1a0 == local_1a8) {
        local_1b0 = 1;
        _getDigits(&local_158,lVar6);
        uStack_38 = uStack_150;
        local_40 = local_158;
        local_30 = local_148;
        uVar1 = local_30;
        for (local_1b4 = 0; local_30._4_4_ = (int)((ulong)local_148 >> 0x20),
            local_1b4 < local_30._4_4_; local_1b4 = local_1b4 + 1) {
          local_1b0 = local_1b0 *
                      *(long *)((long)pvVar3 +
                               (long)*(char *)((long)&local_40 + (long)local_1b4) * 8);
        }
        local_30 = uVar1;
        if (local_1a8 == local_1b0) {
          if (local_1b8 < 0x19) {
            auStack_108[local_1b8] = uVar4;
          }
          if (local_178 <= uVar4) {
            lVar5 = (long)local_1bc;
            local_1bc = local_1bc + 1;
            aiStack_110[lVar5] = local_1b8;
            local_178 = local_178 * 10;
          }
          local_1b8 = local_1b8 + 1;
        }
      }
    }
  }
  aiStack_110[local_1bc] = local_1b8;
  _printf("Smallest members of first 25 Ormiston triples:\n");
  _setlocale(4,"");
  for (local_170 = 0; local_170 < 0x19; local_170 = local_170 + 1) {
    _printf("%\'10ld  ");
    if ((local_170 + 1) % 5 == 0) {
      _printf("\n");
    }
  }
  _printf("\n");
  for (local_170 = 0; local_170 < 2; local_170 = local_170 + 1) {
    _printf("%\'d Ormiston triples before %\'ld\n");
    _printf("\n");
  }
  _free(pvVar3);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004030)();
  return;
}


`
`#include <stdio.h>

#define TRUE 1
#define FALSE 0
#define MAX 120

typedef int bool;

bool is_prime(int n) {
    int d = 5;
    if (n < 2) return FALSE;
    if (!(n % 2)) return n == 2;
    if (!(n % 3)) return n == 3;
    while (d *d <= n) {
        if (!(n % d)) return FALSE;
        d += 2;
        if (!(n % d)) return FALSE;
        d += 4;
    }
    return TRUE;
}

int count_prime_factors(int n) {
    int count = 0, f = 2;
    if (n == 1) return 0;
    if (is_prime(n)) return 1;
    while (TRUE) {
        if (!(n % f)) {
            count++;
            n /= f;
            if (n == 1) return count;
            if (is_prime(n)) f = n;
        }
        else if (f >= 3) f += 2;
        else f = 3;
    }
}

int main() {
    int i, n, count = 0;
    printf("The attractive numbers up to and including %d are:\n", MAX);
    for (i = 1; i <= MAX; ++i) {
        n = count_prime_factors(i);
        if (is_prime(n)) {
            printf("%4d", i);
            if (!(++count % 20)) printf("\n");
        }
    }
    printf("\n");
    return 0;
}
`,`#include "attractive-numbers.h"



bool _is_prime(int param_1)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  int local_c;
  
  local_c = 5;
  if (param_1 < 2) {
    bVar3 = false;
  }
  else if (param_1 % 2 == 0) {
    bVar3 = param_1 == 2;
  }
  else if (param_1 % 3 == 0) {
    bVar3 = param_1 == 3;
  }
  else {
    for (; local_c * local_c <= param_1; local_c = local_c + 6) {
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = param_1 / local_c;
      }
      if (param_1 == iVar1 * local_c) {
        return false;
      }
      iVar1 = local_c + 2;
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = param_1 / iVar1;
      }
      if (param_1 == iVar2 * iVar1) {
        return false;
      }
    }
    bVar3 = true;
  }
  return bVar3;
}



int _count_prime_factors(int param_1)

{
  int iVar1;
  int iVar2;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  
  local_1c = 0;
  local_20 = 2;
  if (param_1 == 1) {
    local_14 = 0;
  }
  else {
    iVar1 = _is_prime(param_1);
    local_18 = param_1;
    if (iVar1 == 0) {
      while( true ) {
        while( true ) {
          iVar1 = 0;
          if (local_20 != 0) {
            iVar1 = local_18 / local_20;
          }
          if (local_18 == iVar1 * local_20) break;
          if (local_20 < 3) {
            local_20 = 3;
          }
          else {
            local_20 = local_20 + 2;
          }
        }
        local_1c = local_1c + 1;
        iVar1 = 0;
        if (local_20 != 0) {
          iVar1 = local_18 / local_20;
        }
        local_14 = local_1c;
        if (iVar1 == 1) break;
        iVar2 = _is_prime(iVar1);
        local_18 = iVar1;
        if (iVar2 != 0) {
          local_20 = iVar1;
        }
      }
    }
    else {
      local_14 = 1;
    }
  }
  return local_14;
}



undefined8 entry(void)

{
  undefined4 uVar1;
  int iVar2;
  int local_20;
  int local_18;
  
  local_20 = 0;
  _printf("The attractive numbers up to and including %d are:\n");
  for (local_18 = 1; local_18 < 0x79; local_18 = local_18 + 1) {
    uVar1 = _count_prime_factors(local_18);
    iVar2 = _is_prime(uVar1);
    if (iVar2 != 0) {
      _printf("%4d");
      local_20 = local_20 + 1;
      if (local_20 % 0x14 == 0) {
        _printf("\n");
      }
    }
  }
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

void main() {
    printf ("clearing screen");
    getchar();
    system("cls");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int32_t function_100003f70(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(char * command);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int32_t _printf(char * a1, ...);
int32_t _system(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f44 - 0x100003f70
int64_t entry_point(int64_t a1) {
    // 0x100003f44
    _printf("clearing screen");
    _getchar();
    return _system("cls");
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(void) {
    // 0x100003f70
    return _getchar();
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * command) {
    // 0x100003f88
    return _system(command);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <string.h>

char trans[] = "___#_##_";

#define v(i) (cell[i] != '_')
int evolve(char cell[], char backup[], int len)
{
	int i, diff = 0;

	for (i = 0; i < len; i++) {
		/* use left, self, right as binary number bits for table index */
		backup[i] = trans[ v(i-1) * 4 + v(i) * 2 + v(i + 1) ];
		diff += (backup[i] != cell[i]);
	}

	strcpy(cell, backup);
	return diff;
}

int main()
{
	char	c[] = "_###_##_#_#_#_#__#__\n",
		b[] = "____________________\n";

	do { printf(c + 1); } while (evolve(c + 1, b + 1, sizeof(c) - 3));
	return 0;
}
`,`#include "one-dimensional-cellular-automata-1.h"



int _evolve(long param_1,long param_2,int param_3)

{
  int local_2c;
  int local_28;
  
  local_2c = 0;
  for (local_28 = 0; local_28 < param_3; local_28 = local_28 + 1) {
    *(char *)(param_2 + local_28) =
         _trans[(int)((uint)(*(char *)(param_1 + local_28) != '_') * 2 +
                      (uint)(*(char *)(param_1 + (local_28 + -1)) != '_') * 4 +
                     (uint)(*(char *)(param_1 + (local_28 + 1)) != '_'))];
    local_2c = local_2c + (uint)(*(char *)(param_2 + local_28) != *(char *)(param_1 + local_28));
  }
  ___strcpy_chk(param_1,param_2,0xffffffffffffffff);
  return local_2c;
}



undefined8 entry(void)

{
  int iVar1;
  char local_50 [32];
  char local_30 [24];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  builtin_strncpy(local_30,"_###_##_#_#_#_#__#__\n",0x16);
  builtin_strncpy(local_50,"____________________\n",0x16);
  do {
    _printf(local_30 + 1);
    iVar1 = _evolve(local_30 + 1,local_50 + 1,0x13);
  } while (iVar1 != 0);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int i;

#define sum(i, lo_byname, hi_byname, term)      \
  ({                                            \
  int lo = lo_byname;                           \
  int hi = hi_byname;                           \
                                                \
  double temp = 0;                              \
  for (i = lo; i <= hi; ++i)                    \
    temp += term;                               \
  temp;                                         \
  })

int main () {
    printf("%f\n", sum(i, 1, 100, 1.0 / i));
    return 0;
}
`,`#include "jensens-device-2.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  for (__i = 1; __i < 0x65; __i = __i + 1) {
  }
  _printf("%f\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef enum {
  TRITTRUE,  /* In this enum, equivalent to integer value 0 */
  TRITMAYBE, /* In this enum, equivalent to integer value 1 */
  TRITFALSE  /* In this enum, equivalent to integer value 2 */
} trit;

/* We can trivially find the result of the operation by passing
   the trinary values as indeces into the lookup tables' arrays. */
trit tritNot[3] = {TRITFALSE , TRITMAYBE, TRITTRUE};
trit tritAnd[3][3] = { {TRITTRUE, TRITMAYBE, TRITFALSE},
                       {TRITMAYBE, TRITMAYBE, TRITFALSE},
                       {TRITFALSE, TRITFALSE, TRITFALSE} };

trit tritOr[3][3] = { {TRITTRUE, TRITTRUE, TRITTRUE},
                      {TRITTRUE, TRITMAYBE, TRITMAYBE},
                      {TRITTRUE, TRITMAYBE, TRITFALSE} };

trit tritThen[3][3] = { { TRITTRUE, TRITMAYBE, TRITFALSE},
                        { TRITTRUE, TRITMAYBE, TRITMAYBE},
                        { TRITTRUE, TRITTRUE, TRITTRUE } };

trit tritEquiv[3][3] = { { TRITTRUE, TRITMAYBE, TRITFALSE},
                         { TRITMAYBE, TRITMAYBE, TRITMAYBE},
                         { TRITFALSE, TRITMAYBE, TRITTRUE } };

/* Everything beyond here is just demonstration */

const char* tritString[3] = {"T", "?", "F"};

void demo_binary_op(trit operator[3][3], const char* name)
{
  trit operand1 = TRITTRUE; /* Declare. Initialize for CYA */
  trit operand2 = TRITTRUE; /* Declare. Initialize for CYA */

  /* Blank line */
  printf("\n");

  /* Demo this operator */
  for( operand1 = TRITTRUE; operand1 <= TRITFALSE; ++operand1 )
  {
    for( operand2 = TRITTRUE; operand2 <= TRITFALSE; ++operand2 )
    {
      printf("%s %s %s: %s\n", tritString[operand1],
                               name,
                               tritString[operand2],
                               tritString[operator[operand1][operand2]]);
    }
  }

}

int main()
{
  trit op1 = TRITTRUE; /* Declare. Initialize for CYA */
  trit op2 = TRITTRUE; /* Declare. Initialize for CYA */

  /* Demo 'not' */
  for( op1 = TRITTRUE; op1 <= TRITFALSE; ++op1 )
  {
    printf("Not %s: %s\n", tritString[op1], tritString[tritNot[op1]]);
  }
  demo_binary_op(tritAnd, "And");
  demo_binary_op(tritOr, "Or");
  demo_binary_op(tritThen, "Then");
  demo_binary_op(tritEquiv, "Equiv");


  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d88(void);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d88 - 0x100003e7c
int64_t function_100003d88(void) {
    // 0x100003d88
    _printf("\n");
    int32_t result; // 0x100003e44
    for (int32_t i = 0; i < 3; i++) {
        for (int32_t j = 0; j < 3; j++) {
            // 0x100003de8
            int64_t v1; // 0x100003d88
            result = _printf("%s %s %s: %s\n", (char *)v1, (char *)v1, (char *)v1, (char *)v1);
        }
    }
    // 0x100003e70
    return result;
}

// Address range: 0x100003e7c - 0x100003f68
int64_t entry_point(void) {
    for (int32_t i = 0; i < 3; i++) {
        // 0x100003eb0
        int64_t v1; // 0x100003e7c
        _printf("Not %s: %s\n", (char *)v1, (char *)v1);
    }
    // 0x100003f08
    function_100003d88();
    function_100003d88();
    function_100003d88();
    function_100003d88();
    return 0;
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

void transpose(void *dest, void *src, int src_h, int src_w)
{
	int i, j;
	double (*d)[src_h] = dest, (*s)[src_w] = src;
	for (i = 0; i < src_h; i++)
		for (j = 0; j < src_w; j++)
			d[j][i] = s[i][j];
}

int main()
{
	int i, j;
	double a[3][5] = {{ 0, 1, 2, 3, 4 },
			  { 5, 6, 7, 8, 9 },
			  { 1, 0, 0, 0, 42}};
	double b[5][3];
	transpose(b, a, 3, 5);

	for (i = 0; i < 5; i++)
		for (j = 0; j < 3; j++)
			printf("%g%c", b[i][j], j == 2 ? '\n' : ' ');
	return 0;
}
`,`#include "matrix-transposition-1.h"



void _transpose(long param_1,long param_2,uint param_3,uint param_4)

{
  undefined4 local_20;
  undefined4 local_1c;
  
  for (local_1c = 0; local_1c < (int)param_3; local_1c = local_1c + 1) {
    for (local_20 = 0; local_20 < (int)param_4; local_20 = local_20 + 1) {
      *(undefined8 *)(param_1 + (long)local_20 * (ulong)param_3 * 8 + (long)local_1c * 8) =
           *(undefined8 *)(param_2 + (long)local_1c * (ulong)param_4 * 8 + (long)local_20 * 8);
    }
  }
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  int local_124;
  int local_120;
  undefined auStack_118 [120];
  undefined auStack_a0 [120];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_a0,&DAT_100003f20,0x78);
  uVar2 = _transpose(auStack_118,auStack_a0,3,5);
  for (local_120 = 0; local_120 < 5; local_120 = local_120 + 1) {
    for (local_124 = 0; local_124 < 3; local_124 = local_124 + 1) {
      uVar1 = _printf("%g%c");
      uVar2 = (ulong)uVar1;
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int m_bits, n_bits;
int *cache;

int ackermann(int m, int n)
{
        int idx, res;
        if (!m) return n + 1;

        if (n >= 1<<n_bits) {
                printf("%d, %d\n", m, n);
                idx = 0;
        } else {
                idx = (m << n_bits) + n;
                if (cache[idx]) return cache[idx];
        }

        if (!n) res = ackermann(m - 1, 1);
        else    res = ackermann(m - 1, ackermann(m, n - 1));

        if (idx) cache[idx] = res;
        return res;
}
int main()
{
        int m, n;

        m_bits = 3;
        n_bits = 20;  /* can save n values up to 2**20 - 1, that's 1 meg */
        cache = malloc(sizeof(int) * (1 << (m_bits + n_bits)));
        memset(cache, 0, sizeof(int) * (1 << (m_bits + n_bits)));

        for (m = 0; m <= 4; m++)
                for (n = 0; n < 6 - m; n++)
                        printf("A(%d, %d) = %d\n", m, n, ackermann(m, n));

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c50(void);
int64_t function_100003f6c(int64_t a1, int32_t a2, int64_t a3, int64_t a4);
int64_t * function_100003f78(int32_t size);
int32_t function_100003f84(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int32_t * g2 = (int32_t *)0x200000000; // 0x100008008
int32_t * g3; // 0x10000800c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int32_t a2, int64_t a3, int64_t a4);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c50 - 0x100003dec
int64_t function_100003c50(void) {
    // 0x100003c50
    int64_t v1; // 0x100003c50
    int32_t v2 = v1; // 0x100003c5c
    int32_t v3 = v1; // 0x100003c60
    if (v2 == 0) {
        // 0x100003ddc
        return v3 + 1;
    }
    uint32_t v4 = *(int32_t *)&g3; // 0x100003c94
    int32_t v5 = 1 << v4; // 0x100003c9c
    int32_t v6 = v3 - v5; // 0x100003ca0
    int32_t v7; // 0x100003c50
    if (v6 < 0 == ((v6 ^ v3) & (v5 ^ v3)) < 0) {
        // 0x100003cb0
        _printf("%d, %d\n", v1, v1);
        v7 = 0;
    } else {
        int32_t v8 = (v2 << v4) + v3; // 0x100003cf8
        int32_t result = *(int32_t *)(g1 + 4 * (int64_t)v8); // 0x100003d10
        v7 = v8;
        if (result != 0) {
            // 0x100003ddc
            return result;
        }
    }
    int64_t v9 = function_100003c50(); // 0x100003d50
    if (v3 != 0) {
        // 0x100003d70
        v9 = function_100003c50();
    }
    int32_t result2 = v9;
    if (v7 != 0) {
        // 0x100003db4
        *(int32_t *)(g1 + 4 * (int64_t)v7) = result2;
    }
    // 0x100003ddc
    return result2;
}

// Address range: 0x100003dec - 0x100003f6c
int64_t entry_point(void) {
    // 0x100003dec
    *(int32_t *)&g2 = 3;
    *(int32_t *)&g3 = 20;
    int64_t v1 = (int64_t)_malloc(0x2000000); // 0x100003e58
    g1 = v1;
    int32_t v2 = *(int32_t *)&g3; // 0x100003e84
    int64_t v3 = 4 * (int64_t)(1 << v2 + *(int32_t *)&g2); // 0x100003e98
    ___memset_chk(v1, 0, v3, -1);
    int32_t v4 = 0;
    int32_t v5 = 6 - v4; // 0x100003ed4
    int32_t v6 = -v5; // 0x100003ed8
    int32_t v7 = 0; // 0x100003ee0
    int32_t v8; // 0x100003f3c
    int32_t v9; // 0x100003ed8
    if (v6 < 0 != (v5 & v6) < 0) {
        function_100003c50();
        _printf("A(%d, %d) = %d\n", (int64_t)v7, v3, -1);
        v8 = v7 + 1;
        v9 = v8 - v5;
        v7 = v8;
        while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v5)) < 0) {
            // 0x100003ee8
            function_100003c50();
            _printf("A(%d, %d) = %d\n", (int64_t)v7, v3, -1);
            v8 = v7 + 1;
            v9 = v8 - v5;
            v7 = v8;
        }
    }
    int32_t v10 = v4 + 1; // 0x100003f50
    while (v4 == 3 || v4 < 3 != (2 - v4 & v10) < 0) {
        // 0x100003ec8
        v4 = v10;
        v5 = 6 - v4;
        v6 = -v5;
        v7 = 0;
        if (v6 < 0 != (v5 & v6) < 0) {
            function_100003c50();
            _printf("A(%d, %d) = %d\n", (int64_t)v7, v3, -1);
            v8 = v7 + 1;
            v9 = v8 - v5;
            v7 = v8;
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v5)) < 0) {
                // 0x100003ee8
                function_100003c50();
                _printf("A(%d, %d) = %d\n", (int64_t)v7, v3, -1);
                v8 = v7 + 1;
                v9 = v8 - v5;
                v7 = v8;
            }
        }
        // 0x100003f4c
        v10 = v4 + 1;
    }
    // 0x100003f5c
    return 0;
}

// Address range: 0x100003f6c - 0x100003f78
int64_t function_100003f6c(int64_t a1, int32_t a2, int64_t a3, int64_t a4) {
    // 0x100003f6c
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f78 - 0x100003f84
int64_t * function_100003f78(int32_t size) {
    // 0x100003f78
    return _malloc(size);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <complex.h>
#include <math.h>

typedef double complex cplx;

void quad_root
(double a, double b, double c, cplx * ra, cplx *rb)
{
	double d, e;
	if (!a) {
		*ra = b ? -c / b : 0;
		*rb = 0;
		return;
	}
	if (!c) {
		*ra = 0;
		*rb = -b / a;
		return;
	}

	b /= 2;
	if (fabs(b) > fabs(c)) {
		e = 1 - (a / b) * (c / b);
		d = sqrt(fabs(e)) * fabs(b);
	} else {
		e = (c > 0) ? a : -a;
		e = b * (b / fabs(c)) - e;
		d = sqrt(fabs(e)) * sqrt(fabs(c));
	}

	if (e < 0) {
		e = fabs(d / a);
		d = -b / a;
		*ra = d + I * e;
		*rb = d - I * e;
		return;
	}

	d = (b >= 0) ? d : -d;
	e = (d - b) / a;
	d = e ? (c / e) / a : 0;
	*ra = d;
	*rb = e;
	return;
}

int main()
{
	cplx ra, rb;
	quad_root(1, 1e12 + 1, 1e12, &ra, &rb);
	printf("(%g + %g i), (%g + %g i)\n",
		creal(ra), cimag(ra), creal(rb), cimag(rb));

	quad_root(1e300, -1e307 + 1, 1e300, &ra, &rb);
	printf("(%g + %g i), (%g + %g i)\n",
		creal(ra), cimag(ra), creal(rb), cimag(rb));

	return 0;
}
`,`#include "roots-of-a-quadratic-function-1.h"



void _quad_root(double param_1,double param_2,double param_3,double *param_4,double *param_5)

{
  double dVar1;
  double local_58;
  double local_50;
  double local_48;
  double local_40;
  double local_38;
  double local_30;
  
  if (param_1 == 0.0) {
    if (param_2 == 0.0) {
      local_40 = 0.0;
    }
    else {
      local_40 = -param_3 / param_2;
    }
    *param_4 = local_40;
    param_4[1] = 0.0;
    *param_5 = 0.0;
    param_5[1] = 0.0;
  }
  else if (param_3 == 0.0) {
    *param_4 = 0.0;
    param_4[1] = 0.0;
    *param_5 = -param_2 / param_1;
    param_5[1] = 0.0;
  }
  else {
    param_2 = param_2 / 2.0;
    if (ABS(param_2) <= ABS(param_3)) {
      local_48 = param_1;
      if (param_3 <= 0.0) {
        local_48 = -param_1;
      }
      local_38 = (double)NEON_fnmsub(param_2,param_2 / ABS(param_3),local_48);
      local_30 = SQRT(ABS(local_38)) * SQRT(ABS(param_3));
    }
    else {
      local_38 = (double)NEON_fmsub(param_1 / param_2,param_3 / param_2,0x3ff0000000000000);
      local_30 = SQRT(ABS(local_38)) * ABS(param_2);
    }
    if (0.0 <= local_38) {
      if (param_2 < 0.0) {
        local_50 = -local_30;
      }
      else {
        local_50 = local_30;
      }
      dVar1 = (local_50 - param_2) / param_1;
      if (dVar1 == 0.0) {
        local_58 = 0.0;
      }
      else {
        local_58 = (param_3 / dVar1) / param_1;
      }
      *param_4 = local_58;
      param_4[1] = 0.0;
      *param_5 = dVar1;
      param_5[1] = 0.0;
    }
    else {
      dVar1 = ABS(local_30 / param_1);
      *param_4 = -param_2 / param_1 + dVar1 * 0.0;
      param_4[1] = dVar1 * 1.0;
      *param_5 = -param_2 / param_1 - dVar1 * 0.0;
      param_5[1] = -(dVar1 * 1.0);
    }
  }
  return;
}



undefined4 entry(void)

{
  undefined local_38 [16];
  undefined local_28 [20];
  undefined4 local_14;
  
  local_14 = 0;
  _quad_root(0x3ff0000000000000,0x426d1a94a2002000,0x426d1a94a2000000);
  _printf("(%g + %g i), (%g + %g i)\n");
  _quad_root(0x7e37e43c8800759c,0xffac7b1f3cac7433,local_28,local_38);
  _printf("(%g + %g i), (%g + %g i)\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#define D_INVALID -1
#define D_UP       1
#define D_DOWN     2
#define D_RIGHT    3
#define D_LEFT     4

const long values[] = {
    0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
};

const char *colors[] = {
    "39", "31", "32", "33", "34", "35", "36", "37", "91", "92", "93", "94"
};

struct gamestate_struct__ {
    int grid[4][4];
    int have_moved;
    long total_score;
    long score_last_move;
    int blocks_in_play;
} game;

struct termios oldt, newt;

void do_draw(void)
{
    printf("\033[2J\033[HScore: %ld", game.total_score);
    if (game.score_last_move)
        printf(" (+%ld)", game.score_last_move);
    printf("\n");

    for (int i = 0; i < 25; ++i)
        printf("-");
    printf("\n");

    for (int y = 0; y < 4; ++y) {
        printf("|");
        for (int x = 0; x < 4; ++x) {
            if (game.grid[x][y])
                printf("\033[7m\033[%sm%*zd \033[0m|", colors[game.grid[x][y]],
                        4, values[game.grid[x][y]]);
            else
                printf("%*s |", 4, "");
        }
        printf("\n");
    }

    for (int i = 0; i < 25; ++i) {
        printf("-");
    }
    printf("\n");
}

void do_merge(int d)
{
/* These macros look pretty scary, but mainly demonstrate some space saving */
#define MERGE_DIRECTION(_v1, _v2, _xs, _xc, _xi, _ys, _yc, _yi, _x, _y)     \
    do {                                                                    \
        for (int _v1 = _xs; _v1 _xc; _v1 += _xi) {                          \
            for (int _v2 = _ys; _v2 _yc; _v2 += _yi) {                      \
                if (game.grid[x][y] && (game.grid[x][y] ==                  \
                                    game.grid[x + _x][y + _y])) {           \
                    game.grid[x][y] += (game.have_moved = 1);               \
                    game.grid[x + _x][y + _y] = (0 * game.blocks_in_play--);\
                    game.score_last_move += values[game.grid[x][y]];        \
                    game.total_score += values[game.grid[x][y]];            \
                }                                                           \
            }                                                               \
        }                                                                   \
    } while (0)

    game.score_last_move = 0;

    switch (d) {
        case D_LEFT:
            MERGE_DIRECTION(x, y, 0, < 3, 1, 0, < 4, 1, 1, 0);
            break;
        case D_RIGHT:
            MERGE_DIRECTION(x, y, 3, > 0, -1, 0, < 4, 1, -1, 0);
            break;
        case D_DOWN:
            MERGE_DIRECTION(y, x, 3, > 0, -1, 0, < 4, 1, 0, -1);
            break;
        case D_UP:
            MERGE_DIRECTION(y, x, 0, < 3, 1, 0, < 4, 1, 0, 1);
            break;
    }

#undef MERGE_DIRECTION
}

void do_gravity(int d)
{
#define GRAVITATE_DIRECTION(_v1, _v2, _xs, _xc, _xi, _ys, _yc, _yi, _x, _y) \
    do {                                                                    \
        int break_cond = 0;                                                 \
        while (!break_cond) {                                               \
            break_cond = 1;                                                 \
            for (int _v1 = _xs; _v1 _xc; _v1 += _xi) {                      \
                for (int _v2 = _ys; _v2 _yc; _v2 += _yi) {                  \
                    if (!game.grid[x][y] && game.grid[x + _x][y + _y]) {    \
                        game.grid[x][y] = game.grid[x + _x][y + _y];        \
                        game.grid[x + _x][y + _y] = break_cond = 0;         \
                        game.have_moved = 1;                                \
                    }                                                       \
                }                                                           \
            }                                                               \
            do_draw(); usleep(40000);                                       \
        }                                                                   \
    } while (0)

    switch (d) {
        case D_LEFT:
            GRAVITATE_DIRECTION(x, y, 0, < 3, 1, 0, < 4, 1, 1, 0);
            break;
        case D_RIGHT:
            GRAVITATE_DIRECTION(x, y, 3, > 0, -1, 0, < 4, 1, -1, 0);
            break;
        case D_DOWN:
            GRAVITATE_DIRECTION(y, x, 3, > 0, -1, 0, < 4, 1, 0, -1);
            break;
        case D_UP:
            GRAVITATE_DIRECTION(y, x, 0, < 3, 1, 0, < 4, 1, 0, 1);
            break;
    }

#undef GRAVITATE_DIRECTION
}

int do_check_end_condition(void)
{
    int ret = -1;
    for (int x = 0; x < 4; ++x) {
        for (int y = 0; y < 4; ++y) {
            if (values[game.grid[x][y]] == 2048)
                return 1;
            if (!game.grid[x][y] ||
                  ((x + 1 < 4) && (game.grid[x][y] == game.grid[x + 1][y])) ||
                  ((y + 1 < 4) && (game.grid[x][y] == game.grid[x][y + 1])))
                ret = 0;
        }
    }
    return ret;
}

int do_tick(int d)
{
    game.have_moved = 0;
    do_gravity(d);
    do_merge(d);
    do_gravity(d);
    return game.have_moved;
}

void do_newblock(void) {
    if (game.blocks_in_play >= 16) return;

    int bn = rand() % (16 - game.blocks_in_play);
    int pn = 0;

    for (int x = 0; x < 4; ++x) {
        for (int y = 0; y < 4; ++y) {
            if (game.grid[x][y])
                continue;

            if (pn == bn){
                game.grid[x][y] = rand() % 10 ? 1 : 2;
                game.blocks_in_play += 1;
                return;
            }
            else {
                ++pn;
            }
        }
    }
}

int main(void)
{
    /* Initialize terminal settings */
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);

    srand(time(NULL));
    memset(&game, 0, sizeof(game));
    do_newblock();
    do_newblock();
    do_draw();

    while (1) {
        int found_valid_key, direction, value;
        do {
            found_valid_key = 1;
            direction       = D_INVALID;
            value           = getchar();
            switch (value) {
                case 'h': case 'a':
                    direction = D_LEFT;
                    break;
                case 'l': case 'd':
                    direction = D_RIGHT;
                    break;
                case 'j': case 's':
                    direction = D_DOWN;
                    break;
                case 'k': case 'w':
                    direction = D_UP;
                    break;
                case 'q':
                    goto game_quit;
                    break;
                case 27:
                    if (getchar() == 91) {
                        value = getchar();
                        switch (value) {
                            case 65:
                                direction = D_UP;
                                break;
                            case 66:
                                direction = D_DOWN;
                                break;
                            case 67:
                                direction = D_RIGHT;
                                break;
                            case 68:
                                direction = D_LEFT;
                                break;
                            default:
                                found_valid_key = 0;
                                break;
                        }
                    }
                    break;
                default:
                    found_valid_key = 0;
                    break;
            }
        }  while (!found_valid_key);

        do_tick(direction);
        if (game.have_moved != 0){
                do_newblock();
        }
        do_draw();

        switch (do_check_end_condition()) {
            case -1:
                goto game_lose;
            case 1:
                goto game_win;
            case 0:
                break;
        }
    }

    if (0)
game_lose:
    printf("You lose!\n");
    goto game_quit;
    if (0)
game_win:
    printf("You win!\n");
    goto game_quit;
    if (0)
game_quit:

    /* Restore terminal settings */
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct termios {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char e4;
    char e5[1];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_1000027fc(void);
int64_t function_100002a40(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);
int64_t function_1000030dc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_1000036a8(void);
int64_t function_10000384c(void);
int64_t function_100003898(void);
int32_t function_100003e30(void);
int64_t * function_100003e3c(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003e48(int64_t * s, int32_t c, int32_t n);
int32_t function_100003e54(char * format, ...);
int32_t function_100003e60(void);
void function_100003e6c(int32_t seed);
int32_t function_100003e78(int32_t fd, struct termios * termios_p);
int32_t function_100003e84(int32_t fd, int32_t optional_actions, struct termios * termios_p);
int32_t function_100003e90(int32_t * timer);
int32_t function_100003e9c(int32_t useconds);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100003ea8
char * g2 = "\x1b[2J\x1b[HScore: %ld"; // 0x100003f2c
char * g3 = "\x1b[7m\x1b[%sm%*zd \x1b[0m|"; // 0x100003f4c
int64_t g4 = 0x100000cfeedfacf; // 0x100008060
int32_t g5 = 0; // 0x1000080a0
int64_t g6 = 0; // 0x1000080b0
int32_t g7 = 0; // 0x1000080b8
struct termios * g8 = NULL; // 0x1000080c0
int64_t g9 = 0; // 0x1000080d8
struct termios * g10 = (struct termios *)5; // 0x100008108
int32_t g11;

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _tcgetattr(int32_t a1, struct termios * a2);
int32_t _tcsetattr(int32_t a1, int32_t a2, struct termios * a3);
int32_t _time(int32_t * a1);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000027fc - 0x100002a40
int64_t function_1000027fc(void) {
    // 0x1000027fc
    _printf((char *)&g2);
    int64_t v1; // 0x1000027fc
    if (g6 != 0) {
        // 0x100002844
        _printf(" (+%ld)", (int32_t)v1);
    }
    // 0x100002868
    _printf("\n");
    for (int32_t i = 0; i < 25; i++) {
        // 0x100002890
        _printf("-");
    }
    // 0x1000028b0
    _printf("\n");
    int64_t v2 = 0;
    _printf("|");
    int64_t v3 = 4 * v2 + (int64_t)&g4; // 0x10000290c
    for (int64_t i = 0; i < 4; i++) {
        // 0x100002900
        if (*(int32_t *)(v3 + 16 * i) == 0) {
            // 0x100002990
            _printf("%*s |", v1, (char *)v1);
        } else {
            // 0x100002928
            _printf((char *)&g3);
        }
    }
    // 0x1000029cc
    _printf("\n");
    v2++;
    int32_t v4 = 0; // 0x1000028d0
    while (v2 != 4) {
        // 0x1000028d8
        _printf("|");
        v3 = 4 * v2 + (int64_t)&g4;
        for (int64_t i = 0; i < 4; i++) {
            // 0x100002900
            if (*(int32_t *)(v3 + 16 * i) == 0) {
                // 0x100002990
                _printf("%*s |", v1, (char *)v1);
            } else {
                // 0x100002928
                _printf((char *)&g3);
            }
        }
        // 0x1000029cc
        _printf("\n");
        v2++;
        v4 = 0;
    }
    _printf("-");
    int32_t v5 = v4 + 1; // 0x100002a1c
    v4 = v5;
    while (v5 != 25) {
        // 0x100002a08
        _printf("-");
        v5 = v4 + 1;
        v4 = v5;
    }
    // 0x100002a28
    return _printf("\n");
}

// Address range: 0x100002a40 - 0x1000030cc
int64_t function_100002a40(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8) {
    // 0x100002a40
    g6 = 0;
    int64_t result; // 0x100002a40
    return result;
}

// Address range: 0x1000030dc - 0x100003698
int64_t function_1000030dc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1000030dc
    int64_t result; // 0x1000030dc
    return result;
}

// Address range: 0x1000036a8 - 0x10000384c
int64_t function_1000036a8(void) {
    int32_t v1 = 0;
    int32_t v2 = -1;
    int32_t v3; // 0x1000036a8
    int64_t result; // 0x1000036a8
    int32_t v4; // 0x1000036a8
    int32_t v5; // 0x1000036a8
    int64_t v6; // 0x1000036f8
    int32_t v7; // 0x100003700
    while (true) {
        int32_t v8 = v1;
        v6 = 16 * (int64_t)v8 + (int64_t)&g4;
        v1 = v8 + 1;
        int64_t v9 = 16 * (int64_t)v1 + (int64_t)&g4;
        v4 = 0;
        while (true) {
          lab_0x1000036ec:
            // 0x1000036ec
            v5 = v4;
            int64_t v10 = 4 * (int64_t)v5; // 0x100003700
            v7 = *(int32_t *)(v10 + v6);
            int64_t v11 = *(int64_t *)(8 * (int64_t)v7 + (int64_t)&g1); // 0x10000370c
            result = 1;
            if (v11 == 2048) {
                return result;
            }
            if (v7 == 0) {
                goto lab_0x100003804;
            } else {
                // 0x100003754
                v3 = v2;
                if (v8 < 3 == (v1 & 2 - v8) < 0) {
                    goto lab_0x1000037ac;
                } else {
                    // 0x10000376c
                    if (v7 == *(int32_t *)(v9 + v10)) {
                        goto lab_0x100003804;
                    } else {
                        goto lab_0x1000037ac;
                    }
                }
            }
        }
      lab_0x100003824:
        // 0x100003824
        if (v8 < 3 == (v1 & 2 - v8) < 0) {
            // 0x100003834
            result = v2;
            return result;
        }
    }
  lab_0x100003840:
    // 0x100003840
    return result;
  lab_0x100003804:;
    int32_t v12 = v5 + 1; // 0x100003814
    int32_t v13 = 2 - v5 & v12; // 0x100003808
    int32_t v14 = v5 - 3; // 0x100003808
    int32_t v15 = v12; // 0x100003808
    int32_t v16 = 0; // 0x100003808
    goto lab_0x100003810;
  lab_0x100003810:
    // 0x100003810
    v2 = v16;
    v4 = v15;
    if (v14 < 0 == v13 < 0) {
        // break -> 0x100003824
        goto lab_0x100003824;
    }
    goto lab_0x1000036ec;
  lab_0x1000037ac:;
    int32_t v17 = v5 + 1;
    int32_t v18 = v5 - 3;
    int32_t v19 = v17 & 2 - v5;
    v13 = v19;
    v14 = v18;
    v15 = v17;
    v16 = v3;
    if (v18 < 0 == v19 < 0) {
        goto lab_0x100003810;
    } else {
        // 0x1000037c4
        v13 = v19;
        v14 = v18;
        v15 = v17;
        v16 = v3;
        if (v7 == *(int32_t *)(v6 + (int64_t)(4 * v5 + 4))) {
            goto lab_0x100003804;
        } else {
            goto lab_0x100003810;
        }
    }
}

// Address range: 0x10000384c - 0x100003898
int64_t function_10000384c(void) {
    // 0x10000384c
    g5 = 0;
    function_1000030dc((int64_t)&g4, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11);
    function_100002a40((int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11);
    function_1000030dc((int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11, (int64_t)&g11);
    return g5;
}

// Address range: 0x100003898 - 0x100003a08
int64_t function_100003898(void) {
    int32_t v1 = g7; // 0x1000038ac
    if (v1 < 16 == (15 - v1 & v1) < 0) {
        // 0x1000039fc
        int64_t result; // 0x100003898
        return result;
    }
    int32_t result2 = _rand(); // 0x1000038c4
    int32_t v2 = 0;
    uint64_t v3 = 0;
    int64_t v4 = 16 * v3 + (int64_t)&g4; // 0x100003934
    int32_t v5 = 0;
    int32_t v6 = 0;
    uint64_t v7 = 0;
    int32_t * v8 = (int32_t *)(v4 + 4 * v7);
    int32_t v9 = v5; // 0x100003948
    if (*v8 == 0) {
        if (v5 == result2 % (16 - g7)) {
            // break (via goto) -> 0x10000396c
            goto lab_0x10000396c;
        }
        // 0x1000039c4
        v9 = v5 + 1;
    }
    int64_t v10 = v7 + 1;
    int32_t v11 = v6 + 1; // 0x100003920
    while (v7 < 3 != (2 - v6 & (int32_t)v10) < 0) {
        // 0x100003928
        v5 = v9;
        v6 = v11;
        v7 = v10;
        v8 = (int32_t *)(v4 + 4 * v7);
        v9 = v5;
        if (*v8 == 0) {
            if (v5 == result2 % (16 - g7)) {
                // break (via goto) -> 0x10000396c
                goto lab_0x10000396c;
            }
            // 0x1000039c4
            v9 = v5 + 1;
        }
        // 0x1000039d8
        v10 = v7 + 1;
        v11 = v6 + 1;
    }
    int64_t v12 = v3 + 1;
    int32_t v13 = v2 + 1; // 0x100003904
    while (v3 < 3 != (2 - v2 & (int32_t)v12) < 0) {
        // 0x100003914
        v2 = v13;
        v3 = v12;
        v4 = 16 * v3 + (int64_t)&g4;
        v5 = v9;
        v6 = 0;
        v7 = 0;
        v8 = (int32_t *)(v4 + 4 * v7);
        v9 = v5;
        if (*v8 == 0) {
            if (v5 == result2 % (16 - g7)) {
                // break (via goto) -> 0x10000396c
                goto lab_0x10000396c;
            }
            // 0x1000039c4
            v9 = v5 + 1;
        }
        // 0x1000039d8
        v10 = v7 + 1;
        v11 = v6 + 1;
        while (v7 < 3 != (2 - v6 & (int32_t)v10) < 0) {
            // 0x100003928
            v5 = v9;
            v6 = v11;
            v7 = v10;
            v8 = (int32_t *)(v4 + 4 * v7);
            v9 = v5;
            if (*v8 == 0) {
                if (v5 == result2 % (16 - g7)) {
                    // break (via goto) -> 0x10000396c
                    goto lab_0x10000396c;
                }
                // 0x1000039c4
                v9 = v5 + 1;
            }
            // 0x1000039d8
            v10 = v7 + 1;
            v11 = v6 + 1;
        }
        // 0x1000039ec
        v12 = v3 + 1;
        v13 = v2 + 1;
    }
    // 0x1000039fc
    return result2;
  lab_0x10000396c:;
    int32_t result3 = _rand(); // 0x10000396c
    *v8 = result3 % 10 == 0 ? 2 : 1;
    g7++;
    // 0x1000039fc
    return result3;
}

// Address range: 0x100003a08 - 0x100003cac
int64_t entry_point(int64_t a1) {
    // 0x100003a08
    _tcgetattr(0, (struct termios *)&g10);
    _memcpy((int64_t *)&g8, (int64_t *)&g10, 72);
    g9 &= -265;
    _tcsetattr(0, 0, (struct termios *)&g8);
    _srand(_time(NULL));
    _memset(&g4, 0, 96);
    function_100003898();
    function_100003898();
    function_1000027fc();
    int32_t result = _getchar(); // 0x100003ab4
    while (result >= 119 == (result != 119)) {
        // 0x100003aa4
        result = _getchar();
    }
    // 0x100003ad8
    return result;
}

// Address range: 0x100003e30 - 0x100003e3c
int32_t function_100003e30(void) {
    // 0x100003e30
    return _getchar();
}

// Address range: 0x100003e3c - 0x100003e48
int64_t * function_100003e3c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e3c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003e48 - 0x100003e54
int64_t * function_100003e48(int64_t * s, int32_t c, int32_t n) {
    // 0x100003e48
    return _memset(s, c, n);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(char * format, ...) {
    // 0x100003e54
    return _printf(format);
}

// Address range: 0x100003e60 - 0x100003e6c
int32_t function_100003e60(void) {
    // 0x100003e60
    return _rand();
}

// Address range: 0x100003e6c - 0x100003e78
void function_100003e6c(int32_t seed) {
    // 0x100003e6c
    _srand(seed);
}

// Address range: 0x100003e78 - 0x100003e84
int32_t function_100003e78(int32_t fd, struct termios * termios_p) {
    // 0x100003e78
    return _tcgetattr(fd, termios_p);
}

// Address range: 0x100003e84 - 0x100003e90
int32_t function_100003e84(int32_t fd, int32_t optional_actions, struct termios * termios_p) {
    // 0x100003e84
    return _tcsetattr(fd, optional_actions, termios_p);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(int32_t * timer) {
    // 0x100003e90
    return _time(timer);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(int32_t useconds) {
    // 0x100003e9c
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include<time.h>
#include<stdio.h>
#include<stdlib.h>
int main(){
  time_t my_time = time(NULL);
  printf("%s", ctime(&my_time));
  return 0;
}
`,`#include "system-time.h"



undefined4 entry(void)

{
  time_t local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = _time((time_t *)0x0);
  _ctime(&local_20);
  _printf("%s");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _ctime(time_t *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__ctime_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004010)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned long long xint;
typedef unsigned uint;
typedef struct {
	uint x, y; // x > y always
	xint value;
} sum_t;

xint *cube;
uint n_cubes;

sum_t *pq;
uint pq_len, pq_cap;

void add_cube(void)
{
	uint x = n_cubes++;
	cube = realloc(cube, sizeof(xint) * (n_cubes + 1));
	cube[n_cubes] = (xint) n_cubes*n_cubes*n_cubes;
	if (x < 2) return; // x = 0 or 1 is useless

	if (++pq_len >= pq_cap) {
		if (!(pq_cap *= 2)) pq_cap = 2;
		pq = realloc(pq, sizeof(*pq) * pq_cap);
	}

	sum_t tmp = (sum_t) { x, 1, cube[x] + 1 };
	// upheap
	uint i, j;
	for (i = pq_len; i >= 1 && pq[j = i>>1].value > tmp.value; i = j)
		pq[i] = pq[j];

	pq[i] = tmp;
}

void next_sum(void)
{
redo:	while (!pq_len || pq[1].value >= cube[n_cubes]) add_cube();

	sum_t tmp = pq[0] = pq[1];	// pq[0] always stores last seen value
	if (++tmp.y >= tmp.x) {		// done with this x; throw it away
		tmp = pq[pq_len--];
		if (!pq_len) goto redo;	// refill empty heap
	} else
		tmp.value += cube[tmp.y] - cube[tmp.y-1];

	uint i, j;
	// downheap
	for (i = 1; (j = i<<1) <= pq_len; pq[i] = pq[j], i = j) {
		if (j < pq_len && pq[j+1].value < pq[j].value) ++j;
		if (pq[j].value >= tmp.value) break;
	}
	pq[i] = tmp;
}

uint next_taxi(sum_t *hist)
{
	do next_sum(); while (pq[0].value != pq[1].value);

	uint len = 1;
	hist[0] = pq[0];
	do {
		hist[len++] = pq[1];
		next_sum();
	} while (pq[0].value == pq[1].value);

	return len;
}

int main(void)
{
	uint i, l;
	sum_t x[10];
	for (i = 1; i <= 2006; i++) {
		l = next_taxi(x);
		if (25 < i && i < 2000) continue;
		printf("%4u:%10llu", i, x[0].value);
		while (l--) printf(" = %4u^3 + %4u^3", x[l].x, x[l].y);
		putchar('\n');
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038a4(void);
int64_t function_100003ad0(void);
int64_t function_100003d3c(void);
int64_t function_100003f5c(void);
int32_t function_100003f68(char * format, ...);
int32_t function_100003f74(int32_t c);
int64_t * function_100003f80(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int32_t * g2 = (int32_t *)0x200000000; // 0x100008008
int64_t g3 = 0x4b800000012; // 0x100008010
int32_t * g4 = (int32_t *)0x200085; // 0x100008018
int32_t * g5; // 0x10000801c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x1000038a4 - 0x100003ad0
int64_t function_1000038a4(void) {
    uint32_t v1 = *(int32_t *)&g2; // 0x1000038bc
    *(int32_t *)&g2 = v1 + 1;
    int64_t result = (int64_t)_realloc((int64_t *)g1, 8 * v1 + 16); // 0x1000038f4
    g1 = result;
    int64_t v2 = (int64_t)*(int32_t *)&g2; // 0x100003904
    *(int64_t *)(8 * v2 + result) = v2 * v2 * v2;
    if (v1 < 2) {
        // 0x100003ac4
        return result;
    }
    int32_t v3 = *(int32_t *)&g5 + 1; // 0x100003948
    *(int32_t *)&g5 = v3;
    uint32_t v4 = *(int32_t *)&g4; // 0x100003958
    int64_t v5; // 0x1000038a4
    int32_t v6; // 0x1000038a4
    int64_t result2; // 0x1000038a4
    if (v3 < v4) {
        // 0x10000393c
        v5 = g3;
        v6 = v3;
        result2 = result;
    } else {
        int32_t v7 = 2 * v4; // 0x100003978
        int32_t v8 = v7 == 0 ? 2 : v7;
        *(int32_t *)&g4 = v8;
        int64_t v9 = (int64_t)_realloc((int64_t *)g3, 16 * v8); // 0x1000039cc
        g3 = v9;
        v5 = v9;
        v6 = *(int32_t *)&g5;
        result2 = v9;
    }
    uint64_t v10 = *(int64_t *)(g1 + 8 * (int64_t)v1) + 1; // 0x100003a00
    if (v6 == 0) {
        // 0x100003aa8
        *(float128_t *)v5 = (float128_t)(int128_t)v1;
        // 0x100003ac4
        return result2;
    }
    uint32_t v11 = v6;
    uint32_t v12 = v11 / 2; // 0x100003a48
    int64_t v13 = 16 * (int64_t)v12 + v5;
    uint64_t v14 = *(int64_t *)(v13 + 8); // 0x100003a54
    int64_t v15 = v11;
    while (v14 >= v10 == (v14 != v10)) {
        // 0x100003a78
        *(float128_t *)(16 * v15 + v5) = *(float128_t *)v13;
        if (v11 < 2) {
            // 0x100003aa8
            *(float128_t *)v5 = (float128_t)(int128_t)v1;
            // 0x100003ac4
            return result2;
        }
        v11 = v12;
        v12 = v11 / 2;
        v13 = 16 * (int64_t)v12 + v5;
        v14 = *(int64_t *)(v13 + 8);
        v15 = v11;
    }
    // 0x100003aa8
    *(float128_t *)(16 * v15 + v5) = (float128_t)(int128_t)v1;
    // 0x100003ac4
    return result2;
}

// Address range: 0x100003ad0 - 0x100003d3c
int64_t function_100003ad0(void) {
    int64_t v1; // 0x100003ad0
    int64_t v2 = v1; // 0x100003ae0
    uint64_t v3; // 0x100003b30
    while (true) {
        // 0x100003ae4
        if (*(int32_t *)&g5 != 0) {
            // 0x100003b44
            v3 = *(int64_t *)(8 * (int64_t)*(int32_t *)&g2 + g1);
            if (*(int64_t *)(g3 + 24) < v3) {
                // break -> 0x100003b58
                break;
            }
        }
        // 0x100003b50
        v2 = function_1000038a4();
    }
    int64_t result = v2;
    float128_t v4 = *(float128_t *)(g3 + 16); // 0x100003b68
    *(float128_t *)g3 = v4;
    int32_t v5; // 0x100003ad0
    uint32_t v6 = v5 + 1; // 0x100003b7c
    // 0x100003ad0
    int32_t v7; // 0x100003bb4
    float128_t v8; // 0x100003bbc
    while (v6 >= (int32_t)(float32_t)v4) {
        uint32_t v9 = *(int32_t *)&g5; // 0x100003bac
        v7 = v9 - 1;
        *(int32_t *)&g5 = v7;
        if (v7 != 0) {
            // 0x100003c18
            v8 = *(float128_t *)(16 * (int64_t)v9 + g3);
            goto lab_0x100003c18_2;
        }
        v2 = result;
        while (true) {
            // 0x100003ae4
            if (*(int32_t *)&g5 != 0) {
                // 0x100003b44
                v3 = *(int64_t *)(8 * (int64_t)*(int32_t *)&g2 + g1);
                if (*(int64_t *)(g3 + 24) < v3) {
                    // break -> 0x100003b58
                    break;
                }
            }
            // 0x100003b50
            v2 = function_1000038a4();
        }
        // 0x100003b58
        result = v2;
        v4 = *(float128_t *)(g3 + 16);
        *(float128_t *)g3 = v4;
        v6++;
    }
    int64_t v10 = *(int64_t *)(g1 + (int64_t)(8 * v6 - 8)); // 0x100003c00
    v7 = *(int32_t *)&g5;
    v8 = v4;
    int64_t v11; // 0x100003ad0
    int64_t v12 = *(int64_t *)(g1 + 8 * (int64_t)v6) + v11 - v10; // 0x100003c14
    goto lab_0x100003c18_2;
  lab_0x100003c18_2:;
    uint32_t v13 = v7; // 0x100003c38
    if (v13 <= 2 == (v13 != 2)) {
        // 0x100003d18
        *(float128_t *)(16 + g3) = v8;
        return result;
    }
    int64_t v14 = g3 + 8;
    int32_t v15 = 1; // 0x100003ad0
    int32_t v16 = 2;
    int32_t v17 = v16; // 0x100003c64
    uint32_t v18; // 0x100003c7c
    uint64_t v19; // 0x100003c84
    uint64_t v20; // 0x100003c94
    if (v13 > 2) {
        // 0x100003c6c
        v18 = v16 | 1;
        v19 = *(int64_t *)(16 * (int64_t)v18 + v14);
        v20 = *(int64_t *)(16 * (int64_t)v16 + v14);
        v17 = v19 < v20 ? v18 : v16;
    }
    int64_t v21 = 16 * (int64_t)v17 + g3; // 0x100003cc8
    int32_t v22 = v15; // 0x100003cdc
    while (*(int64_t *)(v21 + 8) < v12) {
        // 0x100003cec
        *(float128_t *)(16 * (int64_t)v15 + g3) = *(float128_t *)v21;
        uint32_t v23 = 2 * v17; // 0x100003c28
        uint32_t v24 = *(int32_t *)&g5; // 0x100003c38
        v15 = v17;
        v22 = v17;
        if (v23 >= v24 == (v23 != v24)) {
            // break -> 0x100003d18
            break;
        }
        v16 = v23;
        v17 = v16;
        if (v23 < v24) {
            // 0x100003c6c
            v18 = v16 | 1;
            v19 = *(int64_t *)(16 * (int64_t)v18 + v14);
            v20 = *(int64_t *)(16 * (int64_t)v16 + v14);
            v17 = v19 < v20 ? v18 : v16;
        }
        // 0x100003cb8
        v21 = 16 * (int64_t)v17 + g3;
        v22 = v15;
    }
    // 0x100003d18
    *(float128_t *)(16 * (int64_t)v22 + g3) = v8;
    return result;
}

// Address range: 0x100003d3c - 0x100003e0c
int64_t function_100003d3c(void) {
    function_100003ad0();
    int64_t v1 = g3;
    // 0x100003d3c
    while (*(int64_t *)(v1 + 8) != *(int64_t *)(v1 + 24)) {
        // 0x100003d50
        function_100003ad0();
        v1 = g3;
    }
    // 0x100003d80
    int64_t v2; // 0x100003d3c
    *(float128_t *)v2 = *(float128_t *)v1;
    uint32_t v3 = 1;
    int32_t result = v3 + 1; // 0x100003db0
    float128_t v4 = *(float128_t *)(v1 + 16); // 0x100003dc4
    *(float128_t *)(16 * (int64_t)v3 + v2) = v4;
    function_100003ad0();
    int64_t v5 = g3;
    while (*(int64_t *)(v5 + 8) == *(int64_t *)(v5 + 24)) {
        // 0x100003da4
        v3 = result;
        result = v3 + 1;
        v4 = *(float128_t *)(v5 + 16);
        *(float128_t *)(16 * (int64_t)v3 + v2) = v4;
        function_100003ad0();
        v5 = g3;
    }
    // 0x100003dfc
    return result;
}

// Address range: 0x100003e0c - 0x100003f5c
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e20
    int64_t v2; // 0x100003e0c
    int32_t v3 = v2;
    int32_t v4 = 1; // 0x100003f1c
    int64_t v5 = function_100003d3c(); // 0x100003e50
    int32_t v6; // 0x100003e0c
    int32_t v7; // 0x100003e54
    int32_t v8; // 0x100003eb4
    if (v4 >= 2000) {
        // 0x100003e88
        v7 = v5;
        _printf("%4u:%10llu", v3, v2);
        v6 = v7;
        if (v7 != 0) {
            v8 = v6 - 1;
            _printf(" = %4u^3 + %4u^3", v3, (int32_t)v2);
            v6 = v8;
            while (v8 != 0) {
                // 0x100003ecc
                v8 = v6 - 1;
                _printf(" = %4u^3 + %4u^3", v3, (int32_t)v2);
                v6 = v8;
            }
        }
        // 0x100003f0c
        _putchar(10);
    }
    // 0x100003f18
    v4++;
    while (v4 >= 2006 != v4 != 2006) {
        // 0x100003e4c
        v5 = function_100003d3c();
        if (v4 >= 2000) {
            // 0x100003e88
            v7 = v5;
            _printf("%4u:%10llu", v3, v2);
            v6 = v7;
            if (v7 != 0) {
                v8 = v6 - 1;
                _printf(" = %4u^3 + %4u^3", v3, (int32_t)v2);
                v6 = v8;
                while (v8 != 0) {
                    // 0x100003ecc
                    v8 = v6 - 1;
                    _printf(" = %4u^3 + %4u^3", v3, (int32_t)v2);
                    v6 = v8;
                }
            }
            // 0x100003f0c
            _putchar(10);
        }
        // 0x100003f18
        v4++;
    }
    // 0x100003f28
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f48
        ___stack_chk_fail();
    }
    // 0x100003f4c
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(void) {
    // 0x100003f5c
    return ___stack_chk_fail();
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(int32_t c) {
    // 0x100003f74
    return _putchar(c);
}

// Address range: 0x100003f80 - 0x100003f8c
int64_t * function_100003f80(int64_t * ptr, int32_t size) {
    // 0x100003f80
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

int pangram(const char *s)
{
	int c, mask = (1 << 26) - 1;
	while ((c = (*s++)) != '\0') /* 0x20 converts lowercase to upper */
		if ((c &= ~0x20) <= 'Z' && c >= 'A')
			mask &= ~(1 << (c - 'A'));

	return !mask;
}

int main()
{
	int i;
	const char *s[] = {	"The quick brown fox jumps over lazy dogs.",
				"The five boxing wizards dump quickly.",  };

	for (i = 0; i < 2; i++)
		printf("%s: %s\n", pangram(s[i]) ? "yes" : "no ", s[i]);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d94(void);
int64_t function_100003f28(void);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d94 - 0x100003e38
int64_t function_100003d94(void) {
    // 0x100003d94
    int64_t v1; // 0x100003d94
    char v2 = *(char *)v1; // 0x100003db4
    if (v2 == 0) {
        // 0x100003e20
        return false;
    }
    int32_t v3 = 0x3ffffff;
    int32_t v4 = v2;
    int32_t v5 = v4 & -33; // 0x100003dd0
    int32_t v6 = v5 - 90; // 0x100003dd8
    int32_t v7 = v3; // 0x100003de0
    int32_t v8; // 0x100003dec
    if (v6 == 0 || v6 < 0 != (89 - v5 & v4) < 0) {
        // 0x100003de8
        v8 = v5 - 65;
        v7 = v3;
        if (v8 < 0 == (64 - v5 & v4) < 0) {
            // 0x100003dfc
            v7 = v3 & (-1 << v8) - 1;
        }
    }
    // 0x100003e1c
    int64_t v9; // 0x100003d94
    int64_t v10 = v9 + 1;
    int32_t v11 = v7;
    char v12 = *(char *)v10; // 0x100003db4
    while (v12 != 0) {
        // 0x100003dcc
        v3 = v11;
        v4 = v12;
        v5 = v4 & -33;
        v6 = v5 - 90;
        v7 = v3;
        if (v6 == 0 || v6 < 0 != (89 - v5 & v4) < 0) {
            // 0x100003de8
            v8 = v5 - 65;
            v7 = v3;
            if (v8 < 0 == (64 - v5 & v4) < 0) {
                // 0x100003dfc
                v7 = v3 & (-1 << v8) - 1;
            }
        }
        // 0x100003e1c
        v10++;
        v11 = v7;
        v12 = *(char *)v10;
    }
    // 0x100003e20
    return v11 == 0;
}

// Address range: 0x100003e38 - 0x100003f28
int64_t entry_point(void) {
    for (int32_t i = 0; i < 2; i++) {
        // 0x100003e84
        function_100003d94();
        int64_t v1; // 0x100003e38
        _printf("%s: %s\n", (char *)v1, (char *)v1);
    }
    int64_t v2 = *(int64_t *)0x100004008; // 0x100003efc
    if (*(int64_t *)v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f14
        ___stack_chk_fail();
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(void) {
    // 0x100003f28
    return ___stack_chk_fail();
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
   int user1 = 0, user2 = 0;
   int *a1, **array, row;

   printf("Enter two integers.  Space delimited, please:  ");
   scanf("%d %d",&user1, &user2);

   a1 = malloc(user1*user2*sizeof(int));
   array = malloc(user1*sizeof(int*));
   for (row=0; row<user1; row++) array[row]=a1+row*user2;

   array[user1/2][user2/2] = user1 + user2;
   printf("array[%d][%d] is %d\n",user1/2,user2/2,array[user1/2][user2/2]);
   free(array);
   free(a1);
   return 0;
}
`,`#include "create-a-two-dimensional-array-at-runtime-3.h"



undefined8 entry(void)

{
  void *pvVar1;
  undefined8 *puVar2;
  int local_3c;
  
  _printf("Enter two integers.  Space delimited, please:  ");
  _scanf("%d %d");
  pvVar1 = _malloc(0);
  puVar2 = (undefined8 *)_malloc(0);
  for (local_3c = 0; local_3c < 0; local_3c = local_3c + 1) {
    puVar2[local_3c] = pvVar1;
  }
  *(undefined4 *)*puVar2 = 0;
  _printf("array[%d][%d] is %d\n");
  _free(puVar2);
  _free(pvVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdio.h>

int primes[] = {
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
    101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,
    211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331
};
#define PCOUNT (sizeof(primes) / sizeof(int))

bool isPrime(int n) {
    int i;

    if (n < 2) {
        return false;
    }

    for (i = 0; i < PCOUNT; i++) {
        if (n == primes[i]) {
            return true;
        }
        if (n % primes[i] == 0) {
            return false;
        }
        if (n < primes[i] * primes[i]) {
            return true;
        }
    }

    for (i = primes[PCOUNT - 1] + 2; i * i <= n; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }

    return true;
}

int main() {
    int beg, end;
    int i, count;

    // safe primes
    ///////////////////////////////////////////
    beg = 2;
    end = 1000000;
    count = 0;
    printf("First 35 safe primes:\n");
    for (i = beg; i < end; i++) {
        if (isPrime(i) && isPrime((i - 1) / 2)) {
            if (count < 35) {
                printf("%d ", i);
            }
            count++;
        }
    }
    printf("\nThere are  %d safe primes below  %d\n", count, end);

    beg = end;
    end = end * 10;
    for (i = beg; i < end; i++) {
        if (isPrime(i) && isPrime((i - 1) / 2)) {
            count++;
        }
    }
    printf("There are %d safe primes below %d\n", count, end);

    // unsafe primes
    ///////////////////////////////////////////
    beg = 2;
    end = 1000000;
    count = 0;
    printf("\nFirst 40 unsafe primes:\n");
    for (i = beg; i < end; i++) {
        if (isPrime(i) && !isPrime((i - 1) / 2)) {
            if (count < 40) {
                printf("%d ", i);
            }
            count++;
        }
    }
    printf("\nThere are  %d unsafe primes below  %d\n", count, end);

    beg = end;
    end = end * 10;
    for (i = beg; i < end; i++) {
        if (isPrime(i) && !isPrime((i - 1) / 2)) {
            count++;
        }
    }
    printf("There are %d unsafe primes below %d\n", count, end);

    return 0;
}
`,`#include "safe-primes-and-unsafe-primes.h"



undefined _isPrime(int param_1)

{
  int iVar1;
  int iVar2;
  uint local_c;
  undefined local_1;
  
  if (param_1 < 2) {
    local_1 = 0;
  }
  else {
    for (local_c = 0; local_c < 0x43; local_c = local_c + 1) {
      if (param_1 == *(int *)(&_primes + (long)(int)local_c * 4)) {
        return 1;
      }
      iVar1 = *(int *)(&_primes + (long)(int)local_c * 4);
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = param_1 / iVar1;
      }
      if (param_1 == iVar2 * iVar1) {
        return 0;
      }
      if (param_1 < *(int *)(&_primes + (long)(int)local_c * 4) *
                    *(int *)(&_primes + (long)(int)local_c * 4)) {
        return 1;
      }
    }
    for (local_c = DAT_100008108 + 2; (int)(local_c * local_c) <= param_1; local_c = local_c + 2) {
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = param_1 / (int)local_c;
      }
      if (param_1 == iVar1 * local_c) {
        return 0;
      }
    }
    local_1 = 1;
  }
  return local_1;
}



undefined8 entry(void)

{
  ulong uVar1;
  int local_24;
  int local_20;
  
  local_24 = 0;
  _printf("First 35 safe primes:\n");
  for (local_20 = 2; local_20 < 1000000; local_20 = local_20 + 1) {
    uVar1 = _isPrime(local_20);
    if (((uVar1 & 1) != 0) && (uVar1 = _isPrime((local_20 + -1) / 2), (uVar1 & 1) != 0)) {
      if (local_24 < 0x23) {
        _printf("%d ");
      }
      local_24 = local_24 + 1;
    }
  }
  _printf("\nThere are  %d safe primes below  %d\n");
  for (local_20 = 1000000; local_20 < 10000000; local_20 = local_20 + 1) {
    uVar1 = _isPrime(local_20);
    if ((uVar1 & 1) != 0) {
      _isPrime((local_20 + -1) / 2);
    }
  }
  _printf("There are %d safe primes below %d\n");
  local_24 = 0;
  _printf("\nFirst 40 unsafe primes:\n");
  for (local_20 = 2; local_20 < 1000000; local_20 = local_20 + 1) {
    uVar1 = _isPrime(local_20);
    if (((uVar1 & 1) != 0) && (uVar1 = _isPrime((local_20 + -1) / 2), (uVar1 & 1) == 0)) {
      if (local_24 < 0x28) {
        _printf("%d ");
      }
      local_24 = local_24 + 1;
    }
  }
  _printf("\nThere are  %d unsafe primes below  %d\n");
  for (local_20 = 1000000; local_20 < 10000000; local_20 = local_20 + 1) {
    uVar1 = _isPrime(local_20);
    if ((uVar1 & 1) != 0) {
      _isPrime((local_20 + -1) / 2);
    }
  }
  _printf("There are %d unsafe primes below %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

int qselect(int *v, int len, int k)
{
#	define SWAP(a, b) { tmp = v[a]; v[a] = v[b]; v[b] = tmp; }
	int i, st, tmp;

	for (st = i = 0; i < len - 1; i++) {
		if (v[i] > v[len-1]) continue;
		SWAP(i, st);
		st++;
	}

	SWAP(len-1, st);

	return k == st	?v[st]
			:st > k	? qselect(v, st, k)
				: qselect(v + st, len - st, k - st);
}

int main(void)
{
#	define N (sizeof(x)/sizeof(x[0]))
	int x[] = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};
	int y[N];

	int i;
	for (i = 0; i < 10; i++) {
		memcpy(y, x, sizeof(x)); // qselect modifies array
		printf("%d: %d\n", i, qselect(y, 10, i));
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cbc(void);
int64_t function_100003f54(int64_t a1);
int64_t * function_100003f60(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f6c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x800000009; // 0x100003f78

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cbc - 0x100003e6c
int64_t function_100003cbc(void) {
    // 0x100003cbc
    int64_t v1; // 0x100003cbc
    int32_t v2 = v1; // 0x100003ccc
    int32_t v3 = v2 - 1; // 0x100003ce8
    int32_t v4 = 1 - v2; // 0x100003cec
    int32_t * v5 = (int32_t *)((4 * v1 + 0xfffffffc & 0xfffffffc) + v1);
    int32_t v6 = 0; // 0x100003cf4
    int32_t v7 = 0; // 0x100003cf4
    if (v4 < 0 != (v4 & v3) < 0) {
        int32_t v8 = 0;
        int32_t * v9 = (int32_t *)(4 * (int64_t)v6 + v1); // 0x100003d04
        int32_t v10 = *v9; // 0x100003d04
        int32_t v11 = *v5; // 0x100003d14
        int32_t v12 = v10 - v11; // 0x100003d18
        int32_t v13 = v8; // 0x100003d20
        int32_t * v14; // 0x100003d44
        if (v12 == 0 || v12 < 0 != ((v12 ^ v10) & (v11 ^ v10)) < 0) {
            // 0x100003d2c
            v14 = (int32_t *)(4 * (int64_t)v8 + v1);
            *v9 = *v14;
            *v14 = v10;
            v13 = v8 + 1;
        }
        int32_t v15 = v13;
        v6++;
        int32_t v16 = v6 - v3; // 0x100003cec
        v7 = v15;
        while (v16 < 0 != ((v16 ^ v6) & (v6 ^ v3)) < 0) {
            // 0x100003cfc
            v8 = v15;
            v9 = (int32_t *)(4 * (int64_t)v6 + v1);
            v10 = *v9;
            v11 = *v5;
            v12 = v10 - v11;
            v13 = v8;
            if (v12 == 0 || v12 < 0 != ((v12 ^ v10) & (v11 ^ v10)) < 0) {
                // 0x100003d2c
                v14 = (int32_t *)(4 * (int64_t)v8 + v1);
                *v9 = *v14;
                *v14 = v10;
                v13 = v8 + 1;
            }
            // 0x100003d74
            v15 = v13;
            v6++;
            v16 = v6 - v3;
            v7 = v15;
        }
    }
    int32_t v17 = *v5; // 0x100003d90
    int32_t * v18 = (int32_t *)(4 * (int64_t)v7 + v1); // 0x100003da0
    *v5 = *v18;
    *v18 = v17;
    int32_t result = v17; // 0x100003dd4
    if (v7 != (int32_t)v1) {
        // 0x100003df0
        result = function_100003cbc();
    }
    // 0x100003e5c
    return result;
}

// Address range: 0x100003e6c - 0x100003f54
int64_t entry_point(void) {
    // 0x100003e6c
    int64_t v1; // bp-64, 0x100003e6c
    _memcpy(&v1, &g1, 40);
    int32_t v2; // 0x100003f08
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003ebc
        int64_t v3; // bp-104, 0x100003e6c
        _memcpy(&v3, &v1, 40);
        function_100003cbc();
        v2 = _printf("%d: %d\n", 10, i);
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f2c
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f40
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int64_t function_100003f54(int64_t a1) {
    // 0x100003f54
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t * function_100003f60(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f60
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

int main(int argc, char *argv[])
{
        if(argc == 99)
                return 99;
        if(argv[0] != NULL){
                argv[0] = NULL;
                argc = 0;
        }
        argc = main(argc + 1, argv);
        printf("%d bottle%c of beer on the wall\n", argc, argc == 1?'\0': 's');
        printf("%d bottle%c of beer\n", argc, argc == 1?'\0': 's');
        printf("Take one down, pass it around\n");
        printf("%d bottle%c of beer on the wall\n\n", argc - 1, (argc - 1) == 1?'\0': 's');
        return argc - 1;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f24(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003da8 - 0x100003f24
int64_t entry_point(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    if ((int32_t)v1 == 99) {
        // 0x100003f14
        return 99;
    }
    if (v1 != 0) {
        // 0x100003df8
        *(int64_t *)v1 = 0;
    }
    int64_t v2 = entry_point(); // 0x100003e14
    char v3 = v1; // 0x100003e64
    _printf("%d bottle%c of beer on the wall\n", v1, v3);
    _printf("%d bottle%c of beer\n", v1, v3);
    _printf("Take one down, pass it around\n");
    _printf("%d bottle%c of beer on the wall\n\n", v1, v3);
    // 0x100003f14
    return v2 + 0xffffffff & 0xffffffff;
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

char *rtrim(const char *s)
{
  while( isspace(*s) || !isprint(*s) ) ++s;
  return strdup(s);
}

char *ltrim(const char *s)
{
  char *r = strdup(s);
  if (r != NULL)
  {
    char *fr = r + strlen(s) - 1;
    while( (isspace(*fr) || !isprint(*fr) || *fr == 0) && fr >= r) --fr;
    *++fr = 0;
  }
  return r;
}

char *trim(const char *s)
{
  char *r = rtrim(s);
  char *f = ltrim(r);
  free(r);
  return f;
}

const char *a = "     this is a string      ";

int main()
{
  char *b = rtrim(a);
  char *c = ltrim(a);
  char *d = trim(a);

  printf("'%s'\n'%s'\n'%s'\n", b, c, d);

  free(b);
  free(c);
  free(d);
  return 0;
}
`,`#include "strip-whitespace-from-a-string-top-and-tail.h"



void _rtrim(char *param_1)

{
  bool bVar1;
  int iVar2;
  char *local_18;
  
  local_18 = param_1;
  while( true ) {
    iVar2 = _isspace((int)*local_18);
    bVar1 = true;
    if (iVar2 == 0) {
      iVar2 = _isprint((int)*local_18);
      bVar1 = iVar2 == 0;
    }
    if (!bVar1) break;
    local_18 = local_18 + 1;
  }
  _strdup(local_18);
  return;
}



char * _ltrim(char *param_1)

{
  char *pcVar1;
  bool bVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  char *local_28;
  
  pcVar4 = _strdup(param_1);
  if (pcVar4 != (char *)0x0) {
    sVar5 = _strlen(param_1);
    local_28 = pcVar4 + sVar5;
    do {
      pcVar1 = local_28;
      local_28 = pcVar1 + -1;
      iVar3 = _isspace((int)*local_28);
      if (((iVar3 != 0) || (iVar3 = _isprint((int)*local_28), iVar3 == 0)) ||
         (bVar2 = false, *local_28 == '\0')) {
        bVar2 = pcVar4 <= local_28;
      }
    } while (bVar2);
    *pcVar1 = '\0';
  }
  return pcVar4;
}



undefined8 _trim(undefined8 param_1)

{
  void *pvVar1;
  undefined8 uVar2;
  
  pvVar1 = (void *)_rtrim(param_1);
  uVar2 = _ltrim(pvVar1);
  _free(pvVar1);
  return uVar2;
}



undefined4 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  void *pvVar3;
  
  pvVar1 = (void *)_rtrim(_a);
  pvVar2 = (void *)_ltrim(_a);
  pvVar3 = (void *)_trim(_a);
  _printf("\'%s\'\n\'%s\'\n\'%s\'\n");
  _free(pvVar1);
  _free(pvVar2);
  _free(pvVar3);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isprint(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isprint_100004008)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isspace(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isspace_100004010)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004020)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004028)();
  return sVar1;
}


`
`#include <stdio.h>

int circle_sort_inner(int *start, int *end)
{
	int *p, *q, t, swapped;

	if (start == end) return 0;

	// funny "||" on next line is for the center element of odd-lengthed array
	for (swapped = 0, p = start, q = end; p<q || (p==q && ++q); p++, q--)
		if (*p > *q)
			t = *p, *p = *q, *q = t, swapped = 1;

	// q == p-1 at this point
	return swapped | circle_sort_inner(start, q) | circle_sort_inner(p, end);
}

//helper function to show arrays before each call
void circle_sort(int *x, int n)
{
	do {
		int i;
		for (i = 0; i < n; i++) printf("%d ", x[i]);
		putchar('\n');
	} while (circle_sort_inner(x, x + (n - 1)));
}

int main(void)
{
	int x[] = {5, -1, 101, -4, 0, 1, 8, 6, 2, 3};
	circle_sort(x, sizeof(x) / sizeof(*x));

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca0(void);
int64_t function_100003e24(void);
int64_t function_100003f4c(int64_t a1);
int64_t * function_100003f58(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f64(char * format, ...);
int32_t function_100003f70(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xfffffffb; // 0x100003f80

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca0 - 0x100003e24
int64_t function_100003ca0(void) {
    // 0x100003e14
    return 0;
    int32_t v1 = 0; // 0x100003cc4
    int32_t v2; // 0x100003ca0
    while (true) {
        // 0x100003cec
        int64_t v3; // 0x100003ca0
        int64_t v4 = v3;
        v2 = v1;
        int64_t v5; // 0x100003ca0
        int32_t * v6 = (int32_t *)v5;
        int32_t * v7 = (int32_t *)v4;
        int32_t * v8 = v7; // 0x100003d04
        if (v6 >= v7) {
            if (v6 != v7) {
                // break -> 0x100003dd8
                break;
            }
            int64_t v9 = v4 + 4; // 0x100003d30
            v8 = (int32_t *)v9;
            if (v9 == 0) {
                // break -> 0x100003dd8
                break;
            }
        }
        int32_t * v10 = v8;
        int32_t v11 = *v6; // 0x100003d68
        int32_t v12 = *v10; // 0x100003d70
        int32_t v13 = v11 - v12; // 0x100003d74
        v1 = v2;
        if (v13 != 0 && v13 < 0 == ((v13 ^ v11) & (v12 ^ v11)) < 0) {
            // 0x100003d84
            *v6 = v12;
            *v10 = v11;
            v1 = 1;
        }
        // 0x100003dbc
        v5 += 4;
        v3 = (int64_t)v10 - 4;
    }
    int64_t v14 = function_100003ca0(); // 0x100003de8
    int64_t result = v2 | (int32_t)v14 | (int32_t)function_100003ca0(); // 0x100003e10
    // 0x100003e14
    return result;
}

// Address range: 0x100003e24 - 0x100003ed4
int64_t function_100003e24(void) {
    // 0x100003e24
    int64_t v1; // 0x100003e24
    int32_t v2 = v1; // 0x100003e34
    int32_t v3 = -v2; // 0x100003e4c
    int32_t v4; // 0x100003e24
    int32_t v5; // 0x100003e88
    int32_t v6; // 0x100003e4c
    if (v3 < 0 != (v3 & v2) < 0) {
        int64_t v7; // 0x100003e24
        _printf("%d ", v7);
        v5 = 1;
        v6 = v5 - v2;
        v4 = v5;
        while (v6 < 0 != ((v6 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003e5c
            _printf("%d ", v7);
            v5 = v4 + 1;
            v6 = v5 - v2;
            v4 = v5;
        }
    }
    // 0x100003e94
    _putchar(10);
    int64_t result = function_100003ca0(); // 0x100003eb4
    while ((int32_t)result != 0) {
        int64_t v8 = (0x100000000 * v1 - 0x100000000 >> 30) + v1;
        if (v3 < 0 != (v3 & v2) < 0) {
            _printf("%d ", v8);
            v5 = 1;
            v6 = v5 - v2;
            v4 = v5;
            while (v6 < 0 != ((v6 ^ v5) & (v5 ^ v2)) < 0) {
                // 0x100003e5c
                _printf("%d ", v8);
                v5 = v4 + 1;
                v6 = v5 - v2;
                v4 = v5;
            }
        }
        // 0x100003e94
        _putchar(10);
        result = function_100003ca0();
    }
    // 0x100003ec8
    return result;
}

// Address range: 0x100003ed4 - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003ed4
    int64_t v1; // bp-64, 0x100003ed4
    _memcpy(&v1, &g1, 40);
    int64_t v2 = function_100003e24(); // 0x100003f14
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f24
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f38
        ___stack_chk_fail(v2);
    }
    // 0x100003f3c
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int64_t function_100003f4c(int64_t a1) {
    // 0x100003f4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f58
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(int32_t c) {
    // 0x100003f70
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *strip(const char * str, const char *pat)
{
	/*  char replacement is typically done with lookup tables if
	 *  the replacement set can be large: it turns O(m n) into
	 *  O(m + n).
	 *  If same replacement pattern is going to be applied to many
	 *  strings, it's better to build a table beforehand and reuse it.
	 *  If charset is big like unicode, table needs to be implemented
	 *  more efficiently, say using bit field or hash table -- it
	 *  all depends on the application.
	 */
	int i = 0, tbl[128] = {0};
	while (*pat != '\0') tbl[(int)*(pat++)] = 1;

	char *ret = malloc(strlen(str) + 1);
	do {
		if (!tbl[(int)*str])
			ret[i++] = *str;
	} while (*(str++) != '\0');

	/*  assuming realloc is efficient and succeeds; if not, we could
	 *  do a two-pass, count first, alloc and strip second
	 */
	return realloc(ret, i);
}

int main()
{
	char * x = strip("She was a soul stripper. She took my heart!", "aei");
	printf(x);
	free(x);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d8c(void);
int64_t function_100003f1c(void);
void function_100003f28(int64_t * s, int32_t n);
void function_100003f34(int64_t * ptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * format, ...);
int64_t * function_100003f58(int64_t * ptr, int32_t size);
int32_t function_100003f64(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003ecc
int64_t function_100003d8c(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003da4
    int64_t v2; // bp-544, 0x100003d8c
    _bzero(&v2, 512);
    int64_t v3; // 0x100003d8c
    char v4 = *(char *)v3; // 0x100003dcc
    int64_t v5 = &v2;
    if (v4 != 0) {
        int64_t v6; // 0x100003d8c
        int64_t v7 = v6 + 1; // 0x100003de4
        *(int32_t *)(4 * (int64_t)v4 + v5) = 1;
        char v8 = *(char *)v7; // 0x100003dcc
        v6 = v7;
        while (v8 != 0) {
            // 0x100003de0
            v7 = v6 + 1;
            *(int32_t *)(4 * (int64_t)v8 + v5) = 1;
            v8 = *(char *)v7;
            v6 = v7;
        }
    }
    char * v9 = (char *)v3; // 0x100003dac
    int64_t * v10 = _malloc(_strlen(v9) + 1); // 0x100003e0c
    int32_t v11 = 0;
    char v12 = *v9; // 0x100003e1c
    char v13 = v12; // 0x100003e30
    int32_t v14 = v11; // 0x100003e30
    if (*(int32_t *)(4 * (int64_t)v12 + v5) == 0) {
        // 0x100003e38
        *(char *)((int64_t)v11 + (int64_t)v10) = v12;
        v13 = *v9;
        v14 = v11 + 1;
    }
    int32_t v15 = v14;
    char * v16 = (char *)((int64_t)v9 + 1); // 0x100003e7c
    while (v13 != 0) {
        // 0x100003e18
        v11 = v15;
        char * v17 = v16;
        v12 = *v17;
        v13 = v12;
        v14 = v11;
        if (*(int32_t *)(4 * (int64_t)v12 + v5) == 0) {
            // 0x100003e38
            *(char *)((int64_t)v11 + (int64_t)v10) = v12;
            v13 = *v17;
            v14 = v11 + 1;
        }
        // 0x100003e64
        v15 = v14;
        v16 = (char *)((int64_t)v17 + 1);
    }
    int64_t * v18 = _realloc(v10, v15); // 0x100003e8c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003eb4
        ___stack_chk_fail();
    }
    // 0x100003eb8
    return (int64_t)v18;
}

// Address range: 0x100003ecc - 0x100003f1c
int64_t entry_point(void) {
    int64_t v1 = function_100003d8c(); // 0x100003ef4
    _printf((char *)v1);
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
int64_t function_100003f1c(void) {
    // 0x100003f1c
    return ___stack_chk_fail();
}

// Address range: 0x100003f28 - 0x100003f34
void function_100003f28(int64_t * s, int32_t n) {
    // 0x100003f28
    _bzero(s, n);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int64_t * ptr, int32_t size) {
    // 0x100003f58
    return _realloc(ptr, size);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <complex.h>
#include <math.h>

/* Testing macros */
#define FMTSPEC(arg) _Generic((arg), \
    float: "%f", double: "%f", \
    long double: "%Lf", unsigned int: "%u", \
    unsigned long: "%lu", unsigned long long: "%llu", \
    int: "%d", long: "%ld", long long: "%lld", \
    default: "(invalid type (%p)")

#define CMPPARTS(x, y) ((long double complex)((long double)(x) + \
            I * (long double)(y)))

#define TEST_CMPL(i, j)\
    printf(FMTSPEC(i), i), printf(" + "), printf(FMTSPEC(j), j), \
    printf("i = %s\n", (isint(CMPPARTS(i, j)) ? "true" : "false"))

#define TEST_REAL(i)\
    printf(FMTSPEC(i), i), printf(" = %s\n", (isint(i) ? "true" : "false"))

/* Main code */
static inline int isint(long double complex n)
{
    return cimagl(n) == 0 && nearbyintl(creall(n)) == creall(n);
}

int main(void)
{
    TEST_REAL(0);
    TEST_REAL(-0);
    TEST_REAL(-2);
    TEST_REAL(-2.00000000000001);
    TEST_REAL(5);
    TEST_REAL(7.3333333333333);
    TEST_REAL(3.141592653589);
    TEST_REAL(-9.223372036854776e18);
    TEST_REAL(5e-324);
    TEST_REAL(NAN);
    TEST_CMPL(6, 0);
    TEST_CMPL(0, 1);
    TEST_CMPL(0, 0);
    TEST_CMPL(3.4, 0);

    /* Demonstrating that we can use the same function for complex values
     * constructed in the standard way */
    double complex test1 = 5 + 0*I,
                   test2 = 3.4f,
                   test3 = 3,
                   test4 = 0 + 1.2*I;

    printf("Test 1 (5+i) = %s\n", isint(test1) ? "true" : "false");
    printf("Test 2 (3.4+0i) = %s\n", isint(test2) ? "true" : "false");
    printf("Test 3 (3+0i) = %s\n", isint(test3) ? "true" : "false");
    printf("Test 4 (0+1.2i) = %s\n", isint(test4) ? "true" : "false");
}
`,`#include "test-integerness.h"



// WARNING: Removing unreachable block (ram,0x000100003ca4)
// WARNING: Removing unreachable block (ram,0x000100003c88)

undefined4 entry(void)

{
  int iVar1;
  
  iVar1 = _printf("%d");
  FUN_100003e74(0,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%d");
  FUN_100003e74(0,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%d");
  FUN_100003e74(0xc000000000000000,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%f");
  FUN_100003e74(0xc000000000000017,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%d");
  FUN_100003e74(0x4014000000000000,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%f");
  FUN_100003e74(0x401d555555555530,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%f");
  FUN_100003e74(0x400921fb5444261e,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%f");
  FUN_100003e74(0xc3e0000000000000,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%f");
  FUN_100003e74(1,0,iVar1);
  _printf(" = %s\n");
  iVar1 = _printf("%f");
  FUN_100003e74(0x7ff8000000000000,0,iVar1);
  _printf(" = %s\n");
  _printf("%d");
  _printf(" + ");
  iVar1 = _printf("%d");
  FUN_100003e74(0x4018000000000000,0,iVar1);
  _printf("i = %s\n");
  _printf("%d");
  _printf(" + ");
  iVar1 = _printf("%d");
  FUN_100003e74(0,0x3ff0000000000000,iVar1);
  _printf("i = %s\n");
  _printf("%d");
  _printf(" + ");
  iVar1 = _printf("%d");
  FUN_100003e74(0,0,iVar1);
  _printf("i = %s\n");
  _printf("%f");
  _printf(" + ");
  iVar1 = _printf("%d");
  FUN_100003e74(0x400b333333333333,0,iVar1);
  _printf("i = %s\n");
  FUN_100003e74(0x4014000000000000,0);
  iVar1 = _printf("Test 1 (5+i) = %s\n");
  FUN_100003e74(0x400b333340000000,0,iVar1);
  iVar1 = _printf("Test 2 (3.4+0i) = %s\n");
  FUN_100003e74(0x4008000000000000,0,iVar1);
  iVar1 = _printf("Test 3 (3+0i) = %s\n");
  FUN_100003e74(0,0x3ff3333333333333,iVar1);
  _printf("Test 4 (0+1.2i) = %s\n");
  return 0;
}



bool FUN_100003e74(double param_1,double param_2)

{
  bool bVar1;
  
  bVar1 = false;
  if (param_2 == 0.0) {
    bVar1 = (double)(long)param_1 == param_1;
  }
  return bVar1;
}



void ___mulsc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____mulsc3_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

int main(int argc, const char *argv[]) {
  const int max = 1000;
  int *a = malloc(max * sizeof(int));
  for (int n = 0; n < max - 1; n ++) {
    for (int m = n - 1; m >= 0; m --) {
      if (a[m] == a[n]) {
        a[n+1] = n - m;
        break;
      }
    }
  }

  printf("The first ten terms of the Van Eck sequence are:\n");
  for (int i = 0; i < 10; i ++) printf("%d ", a[i]);
  printf("\n\nTerms 991 to 1000 of the sequence are:\n");
  for (int i = 990; i < 1000; i ++) printf("%d ", a[i]);
  putchar('\n');

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t * function_100003f24(int32_t size);
int32_t function_100003f30(char * format, ...);
int32_t function_100003f3c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d6c - 0x100003f24
int64_t entry_point(void) {
    int64_t v1 = (int64_t)_malloc(4000); // 0x100003d90
    int32_t v2 = 0; // 0x100003e3c
    int32_t v3; // 0x100003d6c
    while (true) {
      lab_0x100003dc4:
        // 0x100003dc4
        v3 = v2;
        int32_t * v4 = (int32_t *)(4 * (int64_t)v3 + v1);
        int32_t v5 = v3 - 1;
        while (v5 >= 0) {
            int32_t v6 = v5; // 0x100003df8
            if (*(int32_t *)(4 * (int64_t)v5 + v1) == *v4) {
                // 0x100003e00
                *(int32_t *)((int64_t)(4 * v3 + 4) + v1) = v3 - v5;
                goto lab_0x100003e38;
            }
            v5 = v6 - 1;
        }
        goto lab_0x100003e38;
    }
  lab_0x100003e48:
    // 0x100003e48
    _printf("The first ten terms of the Van Eck sequence are:\n");
    int64_t v7; // 0x100003d6c
    _printf("%d ", v7);
    int32_t v8 = 1; // 0x100003e9c
    int32_t v9 = v8; // 0x100003e68
    while (v8 != 10) {
        // 0x100003e70
        _printf("%d ", v7);
        v8 = v9 + 1;
        v9 = v8;
    }
    // 0x100003ea8
    _printf("\n\nTerms 991 to 1000 of the sequence are:\n");
    _printf("%d ", v7);
    int32_t v10 = 991; // 0x100003f00
    int32_t v11 = v10; // 0x100003ecc
    while (v10 != 1000) {
        // 0x100003ed4
        _printf("%d ", v7);
        v10 = v11 + 1;
        v11 = v10;
    }
    // 0x100003f0c
    _putchar(10);
    return 0;
  lab_0x100003e38:
    // 0x100003e38
    v2 = v3 + 1;
    if (v3 < 998 == (997 - v3 & v2) < 0) {
        // break -> 0x100003e48
        goto lab_0x100003e48;
    }
    goto lab_0x100003dc4;
}

// Address range: 0x100003f24 - 0x100003f30
int64_t * function_100003f24(int32_t size) {
    // 0x100003f24
    return _malloc(size);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * format, ...) {
    // 0x100003f30
    return _printf(format);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(int32_t c) {
    // 0x100003f3c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int priority;
    char *data;
} node_t;

typedef struct {
    node_t *nodes;
    int len;
    int size;
} heap_t;

void push (heap_t *h, int priority, char *data) {
    if (h->len + 1 >= h->size) {
        h->size = h->size ? h->size * 2 : 4;
        h->nodes = (node_t *)realloc(h->nodes, h->size * sizeof (node_t));
    }
    int i = h->len + 1;
    int j = i / 2;
    while (i > 1 && h->nodes[j].priority > priority) {
        h->nodes[i] = h->nodes[j];
        i = j;
        j = j / 2;
    }
    h->nodes[i].priority = priority;
    h->nodes[i].data = data;
    h->len++;
}

char *pop (heap_t *h) {
    int i, j, k;
    if (!h->len) {
        return NULL;
    }
    char *data = h->nodes[1].data;

    h->nodes[1] = h->nodes[h->len];

    h->len--;

    i = 1;
    while (i!=h->len+1) {
        k = h->len+1;
        j = 2 * i;
        if (j <= h->len && h->nodes[j].priority < h->nodes[k].priority) {
            k = j;
        }
        if (j + 1 <= h->len && h->nodes[j + 1].priority < h->nodes[k].priority) {
            k = j + 1;
        }
        h->nodes[i] = h->nodes[k];
        i = k;
    }
    return data;
}

int main () {
    heap_t *h = (heap_t *)calloc(1, sizeof (heap_t));
    push(h, 3, "Clear drains");
    push(h, 4, "Feed cat");
    push(h, 5, "Make tea");
    push(h, 1, "Solve RC tasks");
    push(h, 2, "Tax return");
    int i;
    for (i = 0; i < 5; i++) {
        printf("%s\n", pop(h));
    }
    return 0;
}
`,`#include "priority-queue-1.h"



void _push(long *param_1,int param_2,undefined8 param_3)

{
  bool bVar1;
  undefined8 *puVar2;
  undefined8 *puVar3;
  void *pvVar4;
  undefined8 uVar5;
  int local_34;
  int local_30;
  int local_2c;
  
  if (*(int *)((long)param_1 + 0xc) <= *(int *)(param_1 + 1) + 1) {
    if (*(int *)((long)param_1 + 0xc) == 0) {
      local_34 = 4;
    }
    else {
      local_34 = *(int *)((long)param_1 + 0xc) << 1;
    }
    *(int *)((long)param_1 + 0xc) = local_34;
    pvVar4 = _realloc((void *)*param_1,(long)*(int *)((long)param_1 + 0xc) << 4);
    *param_1 = (long)pvVar4;
  }
  local_2c = *(int *)(param_1 + 1) + 1;
  while( true ) {
    local_30 = local_2c / 2;
    bVar1 = false;
    if (1 < local_2c) {
      bVar1 = param_2 < *(int *)(*param_1 + (long)local_30 * 0x10);
    }
    if (!bVar1) break;
    puVar2 = (undefined8 *)(*param_1 + (long)local_30 * 0x10);
    uVar5 = *puVar2;
    puVar3 = (undefined8 *)(*param_1 + (long)local_2c * 0x10);
    puVar3[1] = puVar2[1];
    *puVar3 = uVar5;
    local_2c = local_30;
  }
  *(int *)(*param_1 + (long)local_2c * 0x10) = param_2;
  *(undefined8 *)(*param_1 + (long)local_2c * 0x10 + 8) = param_3;
  *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + 1;
  return;
}



undefined8 _pop(long *param_1)

{
  int iVar1;
  undefined8 *puVar2;
  undefined8 *puVar3;
  long lVar4;
  undefined8 uVar5;
  int local_1c;
  int local_14;
  undefined8 local_8;
  
  if (*(int *)(param_1 + 1) == 0) {
    local_8 = 0;
  }
  else {
    local_8 = *(undefined8 *)(*param_1 + 0x18);
    lVar4 = *param_1;
    puVar2 = (undefined8 *)(*param_1 + (long)*(int *)(param_1 + 1) * 0x10);
    uVar5 = *puVar2;
    *(undefined8 *)(lVar4 + 0x18) = puVar2[1];
    *(undefined8 *)(lVar4 + 0x10) = uVar5;
    *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + -1;
    local_14 = 1;
    while (local_14 != *(int *)(param_1 + 1) + 1) {
      local_1c = *(int *)(param_1 + 1) + 1;
      iVar1 = local_14 * 2;
      if ((iVar1 <= *(int *)(param_1 + 1)) &&
         (*(int *)(*param_1 + (long)iVar1 * 0x10) < *(int *)(*param_1 + (long)local_1c * 0x10))) {
        local_1c = iVar1;
      }
      if ((iVar1 + 1 <= *(int *)(param_1 + 1)) &&
         (*(int *)(*param_1 + (long)(iVar1 + 1) * 0x10) < *(int *)(*param_1 + (long)local_1c * 0x10)
         )) {
        local_1c = iVar1 + 1;
      }
      puVar2 = (undefined8 *)(*param_1 + (long)local_1c * 0x10);
      uVar5 = *puVar2;
      puVar3 = (undefined8 *)(*param_1 + (long)local_14 * 0x10);
      puVar3[1] = puVar2[1];
      *puVar3 = uVar5;
      local_14 = local_1c;
    }
  }
  return local_8;
}



undefined8 entry(void)

{
  void *pvVar1;
  int local_24;
  
  pvVar1 = _calloc(1,0x10);
  _push(pvVar1,3,"Clear drains");
  _push(pvVar1,4,"Feed cat");
  _push(pvVar1,5,"Make tea");
  _push(pvVar1,1,"Solve RC tasks");
  _push(pvVar1,2,"Tax return");
  for (local_24 = 0; local_24 < 5; local_24 = local_24 + 1) {
    _pop(pvVar1);
    _printf("%s\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004010)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

#define IS_CTRL  (1 << 0)
#define IS_EXT	 (1 << 1)
#define IS_ALPHA (1 << 2)
#define IS_DIGIT (1 << 3) /* not used, just give you an idea */

unsigned int char_tbl[256] = {0};

/* could use ctypes, but then they pretty much do the same thing */
void init_table()
{
	int i;

	for (i = 0; i < 32; i++) char_tbl[i] |= IS_CTRL;
	char_tbl[127] |= IS_CTRL;

	for (i = 'A'; i <= 'Z'; i++) {
		char_tbl[i] |= IS_ALPHA;
		char_tbl[i + 0x20] |= IS_ALPHA; /* lower case */
	}

	for (i = 128; i < 256; i++) char_tbl[i] |= IS_EXT;
}

/* depends on what "stripped" means; we do it in place.
 * "what" is a combination of the IS_* macros, meaning strip if
 * a char IS_ any of them
 */
void strip(char * str, int what)
{
	unsigned char *ptr, *s = (void*)str;
	ptr = s;
	while (*s != '\0') {
		if ((char_tbl[(int)*s] & what) == 0)
			*(ptr++) = *s;
		s++;
	}
	*ptr = '\0';
}

int main()
{
	char a[256];
	int i;

	init_table();

	/* populate string with one of each char */
	for (i = 1; i < 255; i++) a[i - 1] = i; a[255] = '\0';
	strip(a, IS_CTRL);
	printf("%s\n", a);

	for (i = 1; i < 255; i++) a[i - 1] = i; a[255] = '\0';
	strip(a, IS_CTRL | IS_EXT);
	printf("%s\n", a);

	for (i = 1; i < 255; i++) a[i - 1] = i; a[255] = '\0';
	strip(a, IS_CTRL | IS_EXT | IS_ALPHA);
	printf("%s\n", a);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf8(void);
int64_t function_100003d20(void);
int64_t function_100003f7c(int64_t a1);
int32_t function_100003f88(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
char g2[9] = "TA_CONST"; // 0x1000081fc

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf8 - 0x100003d20
int64_t function_100003bf8(void) {
    for (int64_t i = 0; i < 32; i++) {
        int32_t * v1 = (int32_t *)(4 * i + (int64_t)&g1); // 0x100003c28
        *v1 = *v1 | 1;
    }
    // 0x100003c48
    *(int32_t *)&g2 = *(int32_t *)&g2 | 1;
    int32_t v2 = 65;
    int32_t * v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1); // 0x100003c90
    *v3 = *v3 | 4;
    int32_t * v4 = (int32_t *)(4 * (int64_t)(v2 + 32) + (int64_t)&g1); // 0x100003ca8
    *v4 = *v4 | 4;
    int32_t v5 = v2 + 1; // 0x100003cbc
    int32_t v6 = v2 - 89; // 0x100003c6c
    while (v6 == 0 || v6 < 0 != (88 - v2 & v5) < 0) {
        // 0x100003c7c
        v2 = v5;
        v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1);
        *v3 = *v3 | 4;
        v4 = (int32_t *)(4 * (int64_t)(v2 + 32) + (int64_t)&g1);
        *v4 = *v4 | 4;
        v5 = v2 + 1;
        v6 = v2 - 89;
    }
    int32_t v7 = 128;
    int32_t * v8 = (int32_t *)(4 * (int64_t)v7 + (int64_t)&g1); // 0x100003cf8
    *v8 = *v8 | 2;
    int32_t v9 = v7 + 1; // 0x100003d0c
    while (v7 < 255 != (254 - v7 & v9) < 0) {
        // 0x100003ce8
        v7 = v9;
        v8 = (int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *v8 = *v8 | 2;
        v9 = v7 + 1;
    }
    // 0x100003d18
    int64_t result; // 0x100003bf8
    return result;
}

// Address range: 0x100003d20 - 0x100003dbc
int64_t function_100003d20(void) {
    // 0x100003d20
    int64_t result; // 0x100003d20
    char * v1 = (char *)result;
    char v2 = *v1; // 0x100003d44
    if (v2 == 0) {
        // 0x100003dac
        *v1 = 0;
        return result;
    }
    int32_t v3 = *(int32_t *)(4 * (int64_t)v2 + (int64_t)&g1); // 0x100003d68
    char * v4 = v1; // 0x100003d78
    if ((v3 & (int32_t)result) == 0) {
        // 0x100003d80
        v4 = (char *)((int64_t)v1 + 1);
        *v1 = v2;
    }
    // 0x100003d9c
    int64_t v5; // 0x100003d20
    int64_t v6 = v5 + 1; // 0x100003da0
    char v7 = *(char *)v6; // 0x100003d44
    while (v7 != 0) {
        unsigned char v8 = v7;
        char * v9 = v4; // 0x100003d88
        v3 = *(int32_t *)(4 * (int64_t)v8 + (int64_t)&g1);
        v4 = v9;
        if ((v3 & (int32_t)result) == 0) {
            // 0x100003d80
            v4 = (char *)((int64_t)v9 + 1);
            *v9 = v8;
        }
        // 0x100003d9c
        v6++;
        v7 = *(char *)v6;
    }
    // 0x100003dac
    *v4 = 0;
    return result;
}

// Address range: 0x100003dbc - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003dbc
    function_100003bf8();
    int64_t v1; // bp-296, 0x100003dbc
    int64_t v2 = &v1;
    int32_t v3 = 1;
    *(char *)((int64_t)(v3 - 1) + v2) = (char)v3;
    int32_t v4 = v3 + 1; // 0x100003e20
    while (v3 < 254 != (253 - v3 & v4) < 0) {
        // 0x100003e04
        v3 = v4;
        *(char *)((int64_t)(v3 - 1) + v2) = (char)v3;
        v4 = v3 + 1;
    }
    // 0x100003e2c
    function_100003d20();
    _printf("%s\n", (char *)1);
    int32_t v5 = 1;
    *(char *)((int64_t)(v5 - 1) + v2) = (char)v5;
    int32_t v6 = v5 + 1; // 0x100003e98
    while (v5 < 254 != (253 - v5 & v6) < 0) {
        // 0x100003e7c
        v5 = v6;
        *(char *)((int64_t)(v5 - 1) + v2) = (char)v5;
        v6 = v5 + 1;
    }
    // 0x100003ea4
    function_100003d20();
    _printf("%s\n", (char *)3);
    int32_t v7 = 1;
    *(char *)((int64_t)(v7 - 1) + v2) = (char)v7;
    int32_t v8 = v7 + 1; // 0x100003f0c
    while (v7 < 254 != (253 - v7 & v8) < 0) {
        // 0x100003ef0
        v7 = v8;
        *(char *)((int64_t)(v7 - 1) + v2) = (char)v7;
        v8 = v7 + 1;
    }
    // 0x100003f18
    function_100003d20();
    int32_t v9 = _printf("%s\n", (char *)7); // 0x100003f40
    int64_t v10 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f50
    if (v10 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f64
        ___stack_chk_fail((int64_t)v9);
    }
    // 0x100003f68
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t function_100003f7c(int64_t a1) {
    // 0x100003f7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <err.h>

int main()
{
	pid_t pid;

	if (!(pid = fork())) {
		usleep(10000);
		printf("\tchild process: done\n");
	} else if (pid < 0) {
		err(1, "fork error");
	} else {
		printf("waiting for child %d...\n", (int)pid);
		printf("child %d finished\n", (int)wait(0));
	}

	return 0;
}
`,`#include "fork-1.h"



undefined8 entry(void)

{
  pid_t pVar1;
  
  pVar1 = _fork();
  if (pVar1 == 0) {
    _usleep(10000);
    _printf("\tchild process: done\n");
  }
  else {
    if (pVar1 < 0) {
      _err(1,"fork error");
    }
    _printf("waiting for child %d...\n");
    _wait((int *)0x0);
    _printf("child %d finished\n");
  }
  return 0;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _fork(void)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__fork_100004008)();
  return pVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _wait(int *param_1)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__wait_100004020)((int)param_1);
  return pVar1;
}


`
`#include <stdio.h> //printf()
#include <stdlib.h> //srand(), rand(), RAND_MAX, qsort()
#include <stdbool.h> //true, false
#include <time.h> //time()

#define NUMBALLS 5 //NUMBALLS>1

int compar(const void *a, const void *b){
	char c1=*(const char*)a, c2=*(const char*)b; //first cast void* to char*, then dereference
	return c1-c2;
}

_Bool issorted(char *balls){
	int i,state;
	state=0;
	for(i=0;i<NUMBALLS;i++){
		if(balls[i]<state)return false;
		if(balls[i]>state)state=balls[i];
	}
	return true;
}

void printout(char *balls){
	int i;
	char str[NUMBALLS+1];
	for(i=0;i<NUMBALLS;i++)str[i]=balls[i]==0?'r':balls[i]==1?'w':'b';
	printf("%s\n",str);
}

int main(void) {
	char balls[NUMBALLS]; //0=r, 1=w, 2=b
	int i;
	srand(time(NULL)); //not a good seed but good enough for the example
	rand(); //rand() always starts with the same values for certain seeds, making
	        //  testing pretty irritating
	// Generate balls
	for(i=0;i<NUMBALLS;i++)balls[i]=(double)rand()/RAND_MAX*3;
	while(issorted(balls)){ //enforce that we start with non-sorted balls
		printf("Accidentally still sorted: ");
		printout(balls);
		for(i=0;i<NUMBALLS;i++)balls[i]=(double)rand()/RAND_MAX*3;
	}
	printf("Non-sorted: ");
	printout(balls);
	qsort(balls,NUMBALLS,sizeof(char),compar); //sort them using quicksort (stdlib)
	if(issorted(balls)){ //unnecessary check but task enforces it
		printf("Sorted: ");
		printout(balls);
	} else {
		printf("Sort failed: ");
		printout(balls);
	}
	return 0;
}
`,`#include "dutch-national-flag-problem.h"



int _compar(char *param_1,char *param_2)

{
  return (int)*param_1 - (int)*param_2;
}



undefined _issorted(long param_1)

{
  char cVar1;
  int local_14;
  
  cVar1 = '\0';
  local_14 = 0;
  while( true ) {
    if (4 < local_14) {
      return 1;
    }
    if (*(char *)(param_1 + local_14) < cVar1) break;
    if (cVar1 < *(char *)(param_1 + local_14)) {
      cVar1 = *(char *)(param_1 + local_14);
    }
    local_14 = local_14 + 1;
  }
  return 0;
}



int _printout(long param_1)

{
  int iVar1;
  undefined local_28;
  undefined auStack_22 [6];
  int local_1c;
  long local_18;
  
  for (local_1c = 0; local_1c < 5; local_1c = local_1c + 1) {
    if (*(char *)(param_1 + local_1c) == '\0') {
      local_28 = 0x72;
    }
    else {
      local_28 = 0x77;
      if (*(char *)(param_1 + local_1c) != '\x01') {
        local_28 = 0x62;
      }
    }
    auStack_22[local_1c] = local_28;
  }
  local_18 = param_1;
  iVar1 = _printf("%s\n");
  return iVar1;
}



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  ulong uVar3;
  int local_20;
  undefined auStack_19 [5];
  undefined4 local_14;
  
  local_14 = 0;
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  _rand();
  for (local_20 = 0; local_20 < 5; local_20 = local_20 + 1) {
    iVar1 = _rand();
    auStack_19[local_20] = (char)(int)(((double)iVar1 / 2147483647.0) * 3.0);
  }
  while (uVar3 = _issorted(auStack_19), (uVar3 & 1) != 0) {
    _printf("Accidentally still sorted: ");
    _printout(auStack_19);
    for (local_20 = 0; local_20 < 5; local_20 = local_20 + 1) {
      iVar1 = _rand();
      auStack_19[local_20] = (char)(int)(((double)iVar1 / 2147483647.0) * 3.0);
    }
  }
  _printf("Non-sorted: ");
  _printout();
  _qsort(auStack_19,5,1,(int *)_compar);
  uVar3 = _issorted(auStack_19);
  if ((uVar3 & 1) == 0) {
    _printf("Sort failed: ");
    _printout(auStack_19);
  }
  else {
    _printf("Sorted: ");
    _printout(auStack_19);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004010)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004020)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define SIM_N           5  /* Run 5 simulations */
#define PRINT_DISCARDED 1  /* Whether or not to print the discard pile */

#define min(x,y) ((x<y)?(x):(y))

typedef uint8_t card_t;

/* Return a random number from an uniform distribution (0..n-1) */
unsigned int rand_n(unsigned int n) {
    unsigned int out, mask = 1;
    /* Find how many bits to mask off */
    while (mask < n) mask = mask<<1 | 1;
    /* Generate random number */
    do {
        out = rand() & mask;
    } while (out >= n);
    return out;
}

/* Return a random card (0..51) from an uniform distribution */
card_t rand_card() {
    return rand_n(52);
}

/* Print a card */
void print_card(card_t card) {
    static char *suits = "HCDS"; /* hearts, clubs, diamonds and spades */
    static char *cards[] = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"};
    printf(" %s%c", cards[card>>2], suits[card&3]);
}

/* Shuffle a pack */
void shuffle(card_t *pack) {
    int card;
    card_t temp, randpos;
    for (card=0; card<52; card++) {
        randpos = rand_card();
        temp = pack[card];
        pack[card] = pack[randpos];
        pack[randpos] = temp;
    }
}

/* Do the card trick, return whether cards match */
int trick() {
    card_t pack[52];
    card_t blacks[52/4], reds[52/4];
    card_t top, x, card;
    int blackn=0, redn=0, blacksw=0, redsw=0, result;

    /* Create and shuffle a pack */
    for (card=0; card<52; card++) pack[card] = card;
    shuffle(pack);

    /* Deal cards */
#if PRINT_DISCARDED
    printf("Discarded:"); /* Print the discard pile */
#endif
    for (card=0; card<52; card += 2) {
        top = pack[card]; /* Take card */
        if (top & 1) { /* Add next card to black or red pile */
            blacks[blackn++] = pack[card+1];
        } else {
            reds[redn++] = pack[card+1];
        }
#if PRINT_DISCARDED
        print_card(top); /* Show which card is discarded */
#endif
    }
#if PRINT_DISCARDED
    printf("\n");
#endif

    /* Swap an amount of cards */
    x = rand_n(min(blackn, redn));
    for (card=0; card<x; card++) {
        /* Pick a random card from the black and red pile to swap */
        blacksw = rand_n(blackn);
        redsw = rand_n(redn);
        /* Swap them */
        top = blacks[blacksw];
        blacks[blacksw] = reds[redsw];
        reds[redsw] = top;
    }

    /* Verify the assertion */
    result = 0;
    for (card=0; card<blackn; card++)
        result += (blacks[card] & 1) == 1;
    for (card=0; card<redn; card++)
        result -= (reds[card] & 1) == 0;
    result = !result;

    printf("The number of black cards in the 'black' pile"
           " %s the number of red cards in the 'red' pile.\n",
           result? "equals" : "does not equal");
    return result;
}

int main() {
    unsigned int seed, i, successes = 0;
    FILE *r;

    /* Seed the RNG with bytes from from /dev/urandom */
    if ((r = fopen("/dev/urandom", "r")) == NULL) {
        fprintf(stderr, "cannot open /dev/urandom\n");
        return 255;
    }
    if (fread(&seed, sizeof(unsigned int), 1, r) != 1) {
        fprintf(stderr, "failed to read from /dev/urandom\n");
        return 255;
    }
    fclose(r);
    srand(seed);

    /* Do simulations. */
    for (i=1; i<=SIM_N; i++) {
        printf("Simulation %d\n", i);
        successes += trick();
        printf("\n");
    }

    printf("Result: %d successes out of %d simulations\n",
        successes, SIM_N);

    return 0;
}
`,`#include "mind-boggling-card-trick.h"



uint _rand_n(uint param_1)

{
  uint uVar1;
  undefined4 local_1c;
  
  for (local_1c = 1; local_1c < param_1; local_1c = local_1c << 1 | 1) {
  }
  do {
    uVar1 = _rand();
  } while (param_1 <= (uVar1 & local_1c));
  return uVar1 & local_1c;
}



undefined _rand_card(void)

{
  undefined uVar1;
  
  uVar1 = _rand_n(0x34);
  return uVar1;
}



int _print_card(void)

{
  int iVar1;
  
  iVar1 = _printf(" %s%c");
  return iVar1;
}



void _shuffle(long param_1)

{
  undefined uVar1;
  byte bVar2;
  int local_1c;
  
  for (local_1c = 0; local_1c < 0x34; local_1c = local_1c + 1) {
    bVar2 = _rand_card();
    uVar1 = *(undefined *)(param_1 + local_1c);
    *(undefined *)(param_1 + local_1c) = *(undefined *)(param_1 + (ulong)bVar2);
    *(undefined *)(param_1 + (ulong)bVar2) = uVar1;
  }
  return;
}



bool _trick(void)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  long lVar5;
  int local_84;
  int local_80;
  int local_74;
  int local_70;
  byte local_69;
  byte abStack_66 [13];
  byte abStack_59 [13];
  byte abStack_4c [52];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_70 = 0;
  local_74 = 0;
  for (local_69 = 0; local_69 < 0x34; local_69 = local_69 + 1) {
    abStack_4c[local_69] = local_69;
  }
  _shuffle(abStack_4c);
  _printf("Discarded:");
  for (local_69 = 0; local_69 < 0x34; local_69 = local_69 + 2) {
    bVar2 = abStack_4c[local_69];
    if ((bVar2 & 1) == 0) {
      lVar5 = (long)local_74;
      local_74 = local_74 + 1;
      abStack_66[lVar5] = abStack_4c[(int)(local_69 + 1)];
    }
    else {
      lVar5 = (long)local_70;
      local_70 = local_70 + 1;
      abStack_59[lVar5] = abStack_4c[(int)(local_69 + 1)];
    }
    _print_card(bVar2);
  }
  _printf("\n");
  if (local_70 < local_74) {
    local_84 = local_70;
  }
  else {
    local_84 = local_74;
  }
  bVar2 = _rand_n(local_84);
  for (local_69 = 0; local_69 < bVar2; local_69 = local_69 + 1) {
    iVar3 = _rand_n(local_70);
    iVar4 = _rand_n(local_74);
    bVar1 = abStack_59[iVar3];
    abStack_59[iVar3] = abStack_66[iVar4];
    abStack_66[iVar4] = bVar1;
  }
  local_80 = 0;
  for (local_69 = 0; (int)(uint)local_69 < local_70; local_69 = local_69 + 1) {
    local_80 = local_80 + (uint)((abStack_59[local_69] & 1) == 1);
  }
  for (local_69 = 0; (int)(uint)local_69 < local_74; local_69 = local_69 + 1) {
    local_80 = local_80 - (uint)((abStack_66[local_69] & 1) == 0);
  }
  iVar3 = _printf(
                 "The number of black cards in the \'black\' pile %s the number of red cards in the \'red\' pile.\n"
                 );
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar3);
  }
  return local_80 == 0;
}



undefined4 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  size_t sVar3;
  uint local_1c;
  uint local_18;
  undefined4 local_14;
  
  local_14 = 0;
  pFVar2 = _fopen("/dev/urandom","r");
  if (pFVar2 == (FILE *)0x0) {
    _fprintf(*(FILE **)PTR____stderrp_100004010,"cannot open /dev/urandom\n");
    local_14 = 0xff;
  }
  else {
    sVar3 = _fread(&local_18,4,1,pFVar2);
    if (sVar3 == 1) {
      _fclose(pFVar2);
      _srand(local_18);
      for (local_1c = 1; local_1c < 6; local_1c = local_1c + 1) {
        iVar1 = _printf("Simulation %d\n");
        _trick(iVar1);
        _printf("\n");
      }
      _printf("Result: %d successes out of %d simulations\n");
      local_14 = 0;
    }
    else {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"failed to read from /dev/urandom\n");
      local_14 = 0xff;
    }
  }
  return local_14;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fread(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e54. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fread_100004030)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004040)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004048)(param_1);
  return;
}


`
`#include <stdio.h>

int digits[26] = { 0, 0, 100, 500, 0, 0, 0, 0, 1, 1, 0, 50, 1000, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 10, 0, 0 };

/* assuming ASCII, do upper case and get index in alphabet. could also be
        inline int VALUE(char x) { return digits [ (~0x20 & x) - 'A' ]; }
   if you think macros are evil */
#define VALUE(x) digits[(~0x20 & (x)) - 'A']

int decode(const char * roman)
{
        const char *bigger;
        int current;
        int arabic = 0;
        while (*roman != '\0') {
                current = VALUE(*roman);
                /*      if (!current) return -1;
                        note: -1 can be used as error code; Romans didn't even have zero
                */
                bigger = roman;

                /* look for a larger digit, like IV or XM */
                while (VALUE(*bigger) <= current && *++bigger != '\0');

                if (*bigger == '\0')
                        arabic += current;
                else {
                        arabic += VALUE(*bigger);
                        while (roman < bigger)
                                arabic -= VALUE(* (roman++) );
                }

                roman ++;
        }
        return arabic;
}

int main()
{
        const char * romans[] = { "MCmxC", "MMVIII", "MDClXVI", "MCXLUJ" };
        int i;

        for (i = 0; i < 4; i++)
                printf("%s\t%d\n", romans[i], decode(romans[i]));

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cfc(void);
int64_t function_100003f64(void);
int32_t function_100003f70(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = NULL; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cfc - 0x100003e8c
int64_t function_100003cfc(void) {
    // 0x100003cfc
    int64_t v1; // 0x100003cfc
    char * v2 = (char *)v1;
    char v3 = *v2; // 0x100003d10
    if (v3 == 0) {
        // 0x100003e80
        return 0;
    }
    int32_t v4 = 0;
    int32_t v5 = *(int32_t *)((4 * (int64_t)(v3 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1); // 0x100003d40
    char v6 = v3; // 0x100003d58
    char * v7 = v2;
    int32_t v8 = *(int32_t *)((4 * (int64_t)(v6 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1); // 0x100003d70
    char * v9; // 0x100003d98
    char v10; // 0x100003d9c
    while (v8 - v5 == 0 || v8 - v5 < 0 != ((v8 - v5 ^ v8) & (v8 ^ v5)) < 0) {
        // 0x100003db0
        v9 = (char *)((int64_t)v7 + 1);
        v10 = *v9;
        if (v10 == 0) {
            goto lab_0x100003dd8;
        }
        v6 = v10;
        v7 = v9;
        v8 = *(int32_t *)((4 * (int64_t)(v6 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
    }
    char v11; // 0x100003cfc
    char * v12; // 0x100003cfc
    int32_t v13; // 0x100003cfc
    int32_t v14; // 0x100003cfc
    char * v15; // 0x100003cfc
    int32_t v16; // 0x100003e58
    int32_t v17; // 0x100003e60
    int32_t v18; // 0x100003e10
    if (v6 == 0) {
        // 0x100003dd8
        v12 = v2;
        v13 = v5 + v4;
    } else {
        // 0x100003dec
        v18 = v8 + v4;
        v14 = v18;
        v12 = v2;
        v13 = v18;
        if (v2 < v7) {
            v15 = (char *)((int64_t)v2 + 1);
            v16 = *(int32_t *)((4 * (int64_t)(v3 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
            v17 = v14 - v16;
            v12 = v15;
            v13 = v17;
            while (v7 > v15) {
                // 0x100003e34
                v11 = *v15;
                v15 = (char *)((int64_t)v15 + 1);
                v16 = *(int32_t *)((4 * (int64_t)(v11 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
                v17 -= v16;
                v12 = v15;
                v13 = v17;
            }
        }
    }
    int32_t result = v13;
    char * v19 = (char *)((int64_t)v12 + 1);
    char v20 = *v19; // 0x100003d10
    while (v20 != 0) {
        // 0x100003d24
        v4 = result;
        char v21 = v20;
        char * v22 = v19; // 0x100003e1c
        v5 = *(int32_t *)((4 * (int64_t)(v21 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
        v6 = v21;
        v7 = v22;
        v8 = *(int32_t *)((4 * (int64_t)(v6 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
        while (v8 - v5 == 0 || v8 - v5 < 0 != ((v8 - v5 ^ v8) & (v8 ^ v5)) < 0) {
            // 0x100003db0
            v9 = (char *)((int64_t)v7 + 1);
            v10 = *v9;
            if (v10 == 0) {
                goto lab_0x100003dd8;
            }
            v6 = v10;
            v7 = v9;
            v8 = *(int32_t *)((4 * (int64_t)(v6 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
        }
        if (v6 == 0) {
            // 0x100003dd8
            v12 = v22;
            v13 = v5 + v4;
        } else {
            // 0x100003dec
            v18 = v8 + v4;
            v11 = v21;
            char * v23 = v22; // 0x100003e2c
            v14 = v18;
            v12 = v22;
            v13 = v18;
            if (v22 < v7) {
                v15 = (char *)((int64_t)v23 + 1);
                v16 = *(int32_t *)((4 * (int64_t)(v11 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
                v17 = v14 - v16;
                v12 = v15;
                v13 = v17;
                while (v7 > v15) {
                    // 0x100003e34
                    v11 = *v15;
                    v15 = (char *)((int64_t)v15 + 1);
                    v16 = *(int32_t *)((4 * (int64_t)(v11 & -33) + 0xfffffefc & 0xfffffffc) + (int64_t)&g1);
                    v17 -= v16;
                    v12 = v15;
                    v13 = v17;
                }
            }
        }
        // 0x100003e70
        result = v13;
        v19 = (char *)((int64_t)v12 + 1);
        v20 = *v19;
    }
    // 0x100003e80
    return result;
}

// Address range: 0x100003e8c - 0x100003f64
int64_t entry_point(void) {
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003ee0
        function_100003cfc();
        int64_t v1; // 0x100003e8c
        _printf("%s\t%d\n", (char *)v1, v1);
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f3c
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f50
        ___stack_chk_fail();
    }
    // 0x100003f54
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(void) {
    // 0x100003f64
    return ___stack_chk_fail();
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
enum { MAX_ROWS=14, MAX_NAMES=20, NAME_SZ=80 };

char *Lines[MAX_ROWS] = {
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+",
   "  |                      ID                       |",
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+",
   "  |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |",
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+",
   "  |                    QDCOUNT                    |",
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+",
   "  |                    ANCOUNT                    |",
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+",
   "  |                    NSCOUNT                    |",
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+",
   "  |                    ARCOUNT                    |",
   "  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+"
};
typedef struct {
   unsigned bit3s;
   unsigned mask;
   unsigned data;
   char A[NAME_SZ+2];
}NAME_T;
NAME_T names[MAX_NAMES];
unsigned idx_name;
enum{ID,BITS,QDCOUNT,ANCOUNT,NSCOUNT,ARCOUNT,MAX_HDR};
unsigned header[MAX_HDR]; // for test
unsigned idx_hdr;

int  bit_hdr(char *pLine);
int  bit_names(char *pLine);
void dump_names(void);
void make_test_hdr(void);

int main(void){
   char *p1;   int rv;
   printf("Extract meta-data from bit-encoded text form\n");
   make_test_hdr();
   idx_name = 0;
   for( int i=0; i<MAX_ROWS;i++ ){
      p1 = Lines[i];
      if( p1==NULL ) break;
      if( rv = bit_hdr(Lines[i]), rv>0) continue;
      if( rv = bit_names(Lines[i]),rv>0) continue;
      //printf("%s, %d\n",p1, numbits );
   }
   dump_names();
}

int  bit_hdr(char *pLine){ // count the '+--'
   char *p1 = strchr(pLine,'+');
   if( p1==NULL ) return 0;
   int numbits=0;
   for( int i=0; i<strlen(p1)-1; i+=3 ){
      if( p1[i] != '+' || p1[i+1] != '-' || p1[i+2] != '-' ) return 0;
      numbits++;
   }
   return numbits;
}

int  bit_names(char *pLine){ // count the bit-group names
   char *p1,*p2 = pLine, tmp[80];
   unsigned sz=0, maskbitcount = 15;
   while(1){
      p1 = strchr(p2,'|');  if( p1==NULL ) break;
      p1++;
      p2 = strchr(p1,'|');  if( p2==NULL ) break;
      sz = p2-p1;
      tmp[sz] = 0;  // set end of string
      int k=0;
      for(int j=0; j<sz;j++){  // strip spaces
	 if( p1[j] > ' ') tmp[k++] = p1[j];
      }
      tmp[k]= 0; sz++;
      NAME_T *pn = &names[idx_name++];
      strcpy(&pn->A[0], &tmp[0]);
      pn->bit3s = sz/3;
      if( pn->bit3s < 16 ){
	 for( int i=0; i<pn->bit3s; i++){
	    pn->mask |= 1 << maskbitcount--;
	 }
	 pn->data = header[idx_hdr] & pn->mask;
	 unsigned m2 = pn->mask;
	 while( (m2 & 1)==0 ){
	    m2>>=1;
	    pn->data >>= 1;
	 }
	 if( pn->mask == 0xf ) idx_hdr++;

      }
      else{
	 pn->data = header[idx_hdr++];
      }
   }
   return sz;
}

void dump_names(void){ // print extracted names and bits
   NAME_T *pn;
   printf("-name-bits-mask-data-\n");
   for( int i=0; i<MAX_NAMES; i++ ){
      pn = &names[i];
      if( pn->bit3s < 1 ) break;
      printf("%10s %2d X%04x = %u\n",pn->A, pn->bit3s, pn->mask, pn->data);
   }
   puts("bye..");
}

void make_test_hdr(void){
   header[ID] = 1024;
   header[QDCOUNT] = 12;
   header[ANCOUNT] = 34;
   header[NSCOUNT] = 56;
   header[ARCOUNT] = 78;
   // QR OP   AA TC RD RA Z   RCODE
   // 1  0110 1  0  1  0  000 1010
   // 1011 0101 0000 1010
   // B    5    0    A
   header[BITS] = 0xB50A;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000381c(void);
int64_t function_100003858(void);
int64_t function_100003968(void);
int64_t function_100003ca8(void);
int64_t function_100003d8c(void);
int64_t function_100003d98(int64_t a1, int64_t * a2, int64_t a3);
int32_t function_100003da4(char * format, ...);
int32_t function_100003db0(char * s);
char * function_100003dbc(char * s, int32_t c);
int32_t function_100003dc8(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003dd4; // 0x100008000
int32_t * g2 = (int32_t *)0x100000cfeedfacf; // 0x100008070
int64_t g3 = 0x100000c; // 0x100008074
int64_t g4 = 0x200000000; // 0x100008078
int64_t g5 = 0x1200000002; // 0x10000807c
int64_t g6 = 0x50800000012; // 0x100008080
int64_t g7 = 0x20008500000508; // 0x100008084
int32_t * g8 = (int32_t *)0x200085; // 0x100008088
int32_t * g9 = (int32_t *)0x1900000000; // 0x10000808c
int32_t * g10 = (int32_t *)0x4800000019; // 0x100008090

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t a1, int64_t * a2, int64_t a3);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003720 - 0x10000381c
int64_t entry_point(void) {
    // 0x100003720
    _printf("Extract meta-data from bit-encoded text form\n");
    function_10000381c();
    *(int32_t *)&g9 = 0;
    int32_t v1 = 0;
    int64_t v2 = *(int64_t *)(8 * (int64_t)v1 + (int64_t)&g1); // 0x100003774
    while (v2 != 0) {
        // 0x100003794
        if ((int32_t)function_100003858() < 1) {
            // 0x1000037c4
            function_100003968();
        }
        int32_t v3 = v1 + 1; // 0x1000037fc
        if (v1 < 13 == (12 - v1 & v3) < 0) {
            // break -> 0x100003808
            break;
        }
        v1 = v3;
        v2 = *(int64_t *)(8 * (int64_t)v1 + (int64_t)&g1);
    }
    // 0x100003808
    function_100003ca8();
    return 0;
}

// Address range: 0x10000381c - 0x100003858
int64_t function_10000381c(void) {
    // 0x10000381c
    *(int32_t *)&g2 = 1024;
    *(int32_t *)&g4 = 12;
    *(int32_t *)&g5 = 34;
    *(int32_t *)&g6 = 56;
    *(int32_t *)&g7 = 78;
    *(int32_t *)&g3 = 0xb50a;
    int64_t result; // 0x10000381c
    return result;
}

// Address range: 0x100003858 - 0x100003968
int64_t function_100003858(void) {
    // 0x100003858
    int64_t v1; // 0x100003858
    char * v2 = _strchr((char *)v1, 43); // 0x100003870
    if (v2 == NULL) {
        // 0x100003958
        return 0;
    }
    int64_t v3 = (int64_t)v2;
    int64_t v4 = 0; // 0x1000038c0
    int32_t v5 = 0; // 0x1000038c0
    if (_strlen(v2) == 1) {
        // 0x100003958
        return 0;
    }
    int32_t v6 = 0; // 0x1000038c0
    int32_t result = 0; // 0x1000038dc
    while (*(char *)(v4 + v3) == 43) {
        // 0x1000038e4
        result = 0;
        if (*(char *)((int64_t)(v5 + 1) + v3) != 45) {
            // break -> 0x100003958
            break;
        }
        // 0x100003904
        result = 0;
        if (*(char *)((int64_t)(v5 + 2) + v3) != 45) {
            // break -> 0x100003958
            break;
        }
        // 0x10000392c
        v6++;
        v5 += 3;
        v4 = v5;
        result = v6;
        if ((int64_t)_strlen(v2) - 1 <= v4) {
            // break -> 0x100003958
            break;
        }
        result = 0;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003968 - 0x100003ca8
int64_t function_100003968(void) {
    // 0x100003968
    int64_t v1; // 0x100003968
    char * v2 = _strchr((char *)v1, 124); // 0x1000039a8
    int64_t result = 0; // 0x1000039bc
    if (v2 != NULL) {
        // 0x1000039c8
        int64_t v3; // bp-104, 0x100003968
        int64_t v4 = &v3;
        int64_t v5 = (int64_t)v2 + 1; // 0x1000039cc
        char * v6 = _strchr((char *)v5, 124); // 0x1000039dc
        result = 0;
        if (v6 != NULL) {
            int32_t v7 = 15;
            int64_t v8 = (int64_t)v6 - v5; // 0x100003a04
            int32_t v9 = v8; // 0x100003a08
            *(char *)((v8 & 0xffffffff) + v4) = 0;
            int32_t v10 = 0; // 0x100003a3c
            int32_t v11 = 0; // 0x100003a3c
            int32_t v12; // 0x100003968
            int32_t v13; // 0x100003968
            char v14; // 0x100003a4c
            int32_t v15; // 0x100003a4c
            int32_t v16; // 0x100003a50
            int32_t v17; // 0x100003a98
            if (v9 != 0) {
                v12 = 0;
                v14 = *(char *)(v5 + (int64_t)v10);
                v15 = v14;
                v16 = v15 - 32;
                v13 = v12;
                if (v16 != 0 && v16 < 0 == (31 - v15 & v15) < 0) {
                    // 0x100003a60
                    *(char *)((int64_t)v12 + v4) = v14;
                    v13 = v12 + 1;
                }
                // 0x100003a94
                v17 = v10 + 1;
                v10 = v17;
                v11 = v13;
                while (v17 != v9) {
                    // 0x100003a44
                    v12 = v13;
                    v14 = *(char *)(v5 + (int64_t)v10);
                    v15 = v14;
                    v16 = v15 - 32;
                    v13 = v12;
                    if (v16 != 0 && v16 < 0 == (31 - v15 & v15) < 0) {
                        // 0x100003a60
                        *(char *)((int64_t)v12 + v4) = v14;
                        v13 = v12 + 1;
                    }
                    // 0x100003a94
                    v17 = v10 + 1;
                    v10 = v17;
                    v11 = v13;
                }
            }
            // 0x100003aa4
            *(char *)((int64_t)v11 + v4) = 0;
            uint32_t v18 = v9 + 1; // 0x100003abc
            uint32_t v19 = *(int32_t *)&g9; // 0x100003acc
            *(int32_t *)&g9 = v19 + 1;
            int64_t v20 = 96 * (int64_t)v19; // 0x100003ae0
            int32_t * v21 = (int32_t *)(v20 + (int64_t)&g10); // 0x100003af0
            ___strcpy_chk(v20 + (int64_t)&g10 + 12, &v3, -1);
            *v21 = v18 / 3;
            int32_t * v22; // 0x100003968
            int32_t v23; // 0x100003968
            int32_t v24; // 0x100003968
            int32_t v25; // 0x100003968
            int32_t v26; // 0x100003968
            int32_t v27; // 0x100003968
            int32_t v28; // 0x100003968
            int32_t v29; // 0x100003968
            int32_t v30; // 0x100003968
            int32_t v31; // 0x100003968
            int32_t v32; // 0x100003968
            uint32_t v33; // 0x100003968
            int32_t v34; // 0x100003968
            uint32_t v35; // 0x100003c3c
            int32_t v36; // 0x100003c58
            uint32_t v37; // 0x100003b94
            int32_t v38; // 0x100003ba4
            int32_t v39; // 0x100003bb0
            int32_t * v40; // 0x100003bb8
            int32_t v41; // 0x100003bc0
            int32_t v42; // 0x100003b58
            int32_t v43; // 0x100003b70
            int32_t v44; // 0x100003b80
            int32_t v45; // 0x100003bf4
            if (v18 < 48) {
                // 0x100003b38
                v22 = (int32_t *)(v20 + (int64_t)&g10 + 4);
                v23 = *v22;
                v24 = v23;
                v28 = v7;
                v25 = v23;
                v29 = v7;
                if (v18 >= 3) {
                    v42 = v28 - 1;
                    v43 = 1 << v28 | v24;
                    *v22 = v43;
                    v44 = 1;
                    v24 = v43;
                    v34 = v44;
                    v28 = v42;
                    v25 = v43;
                    v29 = v42;
                    while (v44 < *v21) {
                        // 0x100003b54
                        v42 = v28 - 1;
                        v43 = 1 << v28 | v24;
                        *v22 = v43;
                        v44 = v34 + 1;
                        v24 = v43;
                        v34 = v44;
                        v28 = v42;
                        v25 = v43;
                        v29 = v42;
                    }
                }
                // 0x100003b8c
                v30 = v29;
                v37 = *(int32_t *)&g8;
                v38 = *(int32_t *)(4 * (int64_t)v37 + (int64_t)&g2);
                v39 = v25 & v38;
                v40 = (int32_t *)(v20 + (int64_t)&g10 + 8);
                *v40 = v39;
                v41 = *v22;
                v26 = v39;
                v32 = v41;
                v27 = v41;
                if (v41 % 2 == 0) {
                    v33 = v32;
                    v45 = v26 / 2;
                    v26 = v45;
                    v32 = v33 / 2;
                    while ((v33 & 2) == 0) {
                        // 0x100003be0
                        v33 = v32;
                        v45 = v26 / 2;
                        v26 = v45;
                        v32 = v33 / 2;
                    }
                    // 0x100003bcc
                    *v40 = v45;
                    v27 = *v22;
                }
                // 0x100003c00
                v31 = v30;
                if (v27 == 15) {
                    // 0x100003c18
                    *(int32_t *)&g8 = *(int32_t *)&g8 + 1;
                    v31 = v30;
                }
            } else {
                // 0x100003c34
                v35 = *(int32_t *)&g8;
                *(int32_t *)&g8 = v35 + 1;
                v36 = *(int32_t *)(4 * (int64_t)v35 + (int64_t)&g2);
                *(int32_t *)(v20 + (int64_t)&g10 + 8) = v36;
                v31 = v7;
            }
            int64_t v46 = v18;
            char * v47 = _strchr(v6, 124); // 0x1000039a8
            result = v46;
            while (v47 != NULL) {
                int64_t v48 = (int64_t)v47 + 1; // 0x1000039cc
                char * v49 = _strchr((char *)v48, 124); // 0x1000039dc
                result = v46;
                if (v49 == NULL) {
                    // break -> 0x100003c6c
                    break;
                }
                v7 = v31;
                int64_t v50 = v48;
                v8 = (int64_t)v49 - v50;
                v9 = v8;
                *(char *)((v8 & 0xffffffff) + v4) = 0;
                v10 = 0;
                v11 = 0;
                if (v9 != 0) {
                    v12 = 0;
                    v14 = *(char *)(v50 + (int64_t)v10);
                    v15 = v14;
                    v16 = v15 - 32;
                    v13 = v12;
                    if (v16 != 0 && v16 < 0 == (31 - v15 & v15) < 0) {
                        // 0x100003a60
                        *(char *)((int64_t)v12 + v4) = v14;
                        v13 = v12 + 1;
                    }
                    // 0x100003a94
                    v17 = v10 + 1;
                    v10 = v17;
                    v11 = v13;
                    while (v17 != v9) {
                        // 0x100003a44
                        v12 = v13;
                        v14 = *(char *)(v50 + (int64_t)v10);
                        v15 = v14;
                        v16 = v15 - 32;
                        v13 = v12;
                        if (v16 != 0 && v16 < 0 == (31 - v15 & v15) < 0) {
                            // 0x100003a60
                            *(char *)((int64_t)v12 + v4) = v14;
                            v13 = v12 + 1;
                        }
                        // 0x100003a94
                        v17 = v10 + 1;
                        v10 = v17;
                        v11 = v13;
                    }
                }
                // 0x100003aa4
                *(char *)((int64_t)v11 + v4) = 0;
                v18 = v9 + 1;
                v19 = *(int32_t *)&g9;
                *(int32_t *)&g9 = v19 + 1;
                v20 = 96 * (int64_t)v19;
                v21 = (int32_t *)(v20 + (int64_t)&g10);
                ___strcpy_chk(v20 + (int64_t)&g10 + 12, &v3, -1);
                *v21 = v18 / 3;
                if (v18 < 48) {
                    // 0x100003b38
                    v22 = (int32_t *)(v20 + (int64_t)&g10 + 4);
                    v23 = *v22;
                    v24 = v23;
                    v28 = v7;
                    v25 = v23;
                    v29 = v7;
                    if (v18 >= 3) {
                        v42 = v28 - 1;
                        v43 = 1 << v28 | v24;
                        *v22 = v43;
                        v44 = 1;
                        v24 = v43;
                        v34 = v44;
                        v28 = v42;
                        v25 = v43;
                        v29 = v42;
                        while (v44 < *v21) {
                            // 0x100003b54
                            v42 = v28 - 1;
                            v43 = 1 << v28 | v24;
                            *v22 = v43;
                            v44 = v34 + 1;
                            v24 = v43;
                            v34 = v44;
                            v28 = v42;
                            v25 = v43;
                            v29 = v42;
                        }
                    }
                    // 0x100003b8c
                    v30 = v29;
                    v37 = *(int32_t *)&g8;
                    v38 = *(int32_t *)(4 * (int64_t)v37 + (int64_t)&g2);
                    v39 = v25 & v38;
                    v40 = (int32_t *)(v20 + (int64_t)&g10 + 8);
                    *v40 = v39;
                    v41 = *v22;
                    v26 = v39;
                    v32 = v41;
                    v27 = v41;
                    if (v41 % 2 == 0) {
                        v33 = v32;
                        v45 = v26 / 2;
                        v26 = v45;
                        v32 = v33 / 2;
                        while ((v33 & 2) == 0) {
                            // 0x100003be0
                            v33 = v32;
                            v45 = v26 / 2;
                            v26 = v45;
                            v32 = v33 / 2;
                        }
                        // 0x100003bcc
                        *v40 = v45;
                        v27 = *v22;
                    }
                    // 0x100003c00
                    v31 = v30;
                    if (v27 == 15) {
                        // 0x100003c18
                        *(int32_t *)&g8 = *(int32_t *)&g8 + 1;
                        v31 = v30;
                    }
                } else {
                    // 0x100003c34
                    v35 = *(int32_t *)&g8;
                    *(int32_t *)&g8 = v35 + 1;
                    v36 = *(int32_t *)(4 * (int64_t)v35 + (int64_t)&g2);
                    *(int32_t *)(v20 + (int64_t)&g10 + 8) = v36;
                    v31 = v7;
                }
                // 0x100003c68
                v46 = v18;
                v47 = _strchr(v49, 124);
                result = v46;
            }
        }
    }
    int64_t v51 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c80
    if (v51 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003c94
        ___stack_chk_fail();
    }
    // 0x100003c98
    return result;
}

// Address range: 0x100003ca8 - 0x100003d8c
int64_t function_100003ca8(void) {
    // 0x100003ca8
    _printf("-name-bits-mask-data-\n");
    int32_t v1 = 0;
    int32_t v2 = *(int32_t *)(96 * (int64_t)v1 + (int64_t)&g10); // 0x100003cfc
    while (v2 != 0) {
        // 0x100003d14
        int64_t v3; // 0x100003ca8
        _printf("%10s %2d X%04x = %u\n", (char *)v3, v3, (int32_t)v3, (int32_t)v3);
        int32_t v4 = v1 + 1; // 0x100003d68
        if (v1 < 19 == (18 - v1 & v4) < 0) {
            // break -> 0x100003d74
            break;
        }
        v1 = v4;
        v2 = *(int32_t *)(96 * (int64_t)v1 + (int64_t)&g10);
    }
    // 0x100003d74
    return _puts("bye..");
}

// Address range: 0x100003d8c - 0x100003d98
int64_t function_100003d8c(void) {
    // 0x100003d8c
    return ___stack_chk_fail();
}

// Address range: 0x100003d98 - 0x100003da4
int64_t function_100003d98(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x100003d98
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003da4 - 0x100003db0
int32_t function_100003da4(char * format, ...) {
    // 0x100003da4
    return _printf(format);
}

// Address range: 0x100003db0 - 0x100003dbc
int32_t function_100003db0(char * s) {
    // 0x100003db0
    return _puts(s);
}

// Address range: 0x100003dbc - 0x100003dc8
char * function_100003dbc(char * s, int32_t c) {
    // 0x100003dbc
    return _strchr(s, c);
}

// Address range: 0x100003dc8 - 0x100003dd4
int32_t function_100003dc8(char * s) {
    // 0x100003dc8
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h>

int dot_product(int *, int *, size_t);

int
main(void)
{
        int a[3] = {1, 3, -5};
        int b[3] = {4, -2, -1};

        printf("%d\n", dot_product(a, b, sizeof(a) / sizeof(a[0])));

        return EXIT_SUCCESS;
}

int
dot_product(int *a, int *b, size_t n)
{
        int sum = 0;
        size_t i;

        for (i = 0; i < n; i++) {
                sum += a[i] * b[i];
        }

        return sum;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ef0(void);
int64_t function_100003f6c(int64_t a1);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x1fffffffc; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e44 - 0x100003ef0
int64_t entry_point(void) {
    int64_t v1 = g1; // bp-56, 0x100003e90
    function_100003ef0();
    int32_t v2 = _printf("%d\n", (int64_t)&v1); // 0x100003eb8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ec8
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003edc
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003ee0
    return 0;
}

// Address range: 0x100003ef0 - 0x100003f6c
int64_t function_100003ef0(void) {
    int64_t v1 = 0; // 0x100003f1c
    int64_t v2; // 0x100003ef0
    if (v2 == 0) {
        // 0x100003f60
        return 0;
    }
    int32_t result = 0; // 0x100003f1c
    int64_t v3 = 4 * v1; // 0x100003f2c
    result += *(int32_t *)(v3 + v2) * *(int32_t *)(v3 + v2);
    v1++;
    while (v1 != v2) {
        // 0x100003f24
        v3 = 4 * v1;
        result += *(int32_t *)(v3 + v2) * *(int32_t *)(v3 + v2);
        v1++;
    }
    // 0x100003f60
    return result;
}

// Address range: 0x100003f6c - 0x100003f78
int64_t function_100003f6c(int64_t a1) {
    // 0x100003f6c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#define F(x,y) printf("%s",i%x?"":#y"zz")
int main(int i){for(--i;i++^100;puts(""))F(3,Fi)|F(5,Bu)||printf("%i",i);return 0;}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(char * s);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f97

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e34 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003e34
    int64_t v1; // 0x100003e34
    int32_t v2 = v1; // 0x100003e44
    if (v2 == 101) {
        // 0x100003f6c
        return 0;
    }
    char * v3 = (char *)v1; // 0x100003ecc
    int32_t v4 = v2;
    if ((_printf("%s", v3) | _printf("%s", v3)) == 0) {
        // 0x100003f38
        _printf("%i", v1);
    }
    // 0x100003f5c
    _puts((char *)&g1);
    while (v4 != 100) {
        // 0x100003e7c
        v4++;
        if ((_printf("%s", v3) | _printf("%s", v3)) == 0) {
            // 0x100003f38
            _printf("%i", v1);
        }
        // 0x100003f5c
        _puts((char *)&g1);
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * s) {
    // 0x100003f88
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>

const char *msg = "hello socket world";

int main()
{
   int i, sock, len, slen;

   struct addrinfo hints, *addrs;
   memset(&hints, 0, sizeof(struct addrinfo));
   hints.ai_family = AF_UNSPEC;
   hints.ai_socktype = SOCK_STREAM;

   if (0 == getaddrinfo("localhost", "256", &hints, &addrs))
   {
       sock = socket(addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);
       if ( sock >= 0 )
       {
           if ( connect(sock, addrs->ai_addr, addrs->ai_addrlen) >= 0 )
           {
               const char *pm = msg;
               do
               {
                  len = strlen(pm);
                  slen = send(sock, pm, len, 0);
                  pm += slen;
               } while ((0 <= slen) && (slen < len));
           }
           close(sock);
       }
       freeaddrinfo(addrs);
   }
}
`,`#include "sockets.h"



undefined4 entry(void)

{
  int iVar1;
  size_t sVar2;
  ssize_t sVar3;
  char *local_68;
  addrinfo *local_60;
  addrinfo aStack_58;
  int local_24;
  int local_20;
  int local_1c;
  undefined4 local_14;
  
  local_14 = 0;
  _memset(&aStack_58,0,0x30);
  aStack_58.ai_family = 0;
  aStack_58.ai_socktype = 1;
  iVar1 = _getaddrinfo("localhost","256",&aStack_58,&local_60);
  if (iVar1 == 0) {
    local_1c = _socket(local_60->ai_family,local_60->ai_socktype,local_60->ai_protocol);
    if (-1 < local_1c) {
      iVar1 = _connect(local_1c,local_60->ai_addr,local_60->ai_addrlen);
      if (-1 < iVar1) {
        local_68 = _msg;
        do {
          sVar2 = _strlen(local_68);
          local_20 = (int)sVar2;
          sVar3 = _send(local_1c,local_68,(long)local_20,0);
          local_24 = (int)sVar3;
          local_68 = local_68 + local_24;
        } while (-1 < local_24 && local_24 < local_20);
      }
      _close(local_1c);
    }
    _freeaddrinfo(local_60);
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004000)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _connect(int param_1,sockaddr *param_2,socklen_t param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__connect_100004008)(param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _freeaddrinfo(addrinfo *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__freeaddrinfo_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getaddrinfo(char *param_1,char *param_2,addrinfo *param_3,addrinfo **param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getaddrinfo_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004020)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _send(int param_1,void *param_2,size_t param_3,int param_4)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__send_100004028)(param_1,param_2,param_3,param_4);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _socket(int param_1,int param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__socket_100004030)(param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}


`
`#include <stdio.h>
#include <math.h>

// https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm

int p(int year) {
	return (int)((double)year + floor(year/4) - floor(year/100) + floor(year/400)) % 7;
}

int is_long_year(int year) {
	return p(year) == 4 || p(year - 1) == 3;
}

void print_long_years(int from, int to) {
	for (int year = from; year <= to; ++year) {
		if (is_long_year(year)) {
			printf("%d ", year);
		}
	}
}

int main() {

	printf("Long (53 week) years between 1800 and 2100\n\n");
	print_long_years(1800, 2100);
	printf("\n");
	return 0;
}
`,`#include "long-year.h"



int _p(int param_1)

{
  return (int)((((double)(long)param_1 + (double)(long)(double)(param_1 / 4)) -
               (double)(long)(double)(param_1 / 100)) + (double)(long)(double)(param_1 / 400)) % 7;
}



bool _is_long_year(int param_1)

{
  bool bVar1;
  int iVar2;
  
  iVar2 = _p(param_1);
  bVar1 = true;
  if (iVar2 != 4) {
    iVar2 = _p(param_1 + -1);
    bVar1 = iVar2 == 3;
  }
  return bVar1;
}



ulong _print_long_years(ulong param_1,int param_2)

{
  uint uVar1;
  int local_1c;
  
  for (local_1c = (int)param_1; local_1c <= param_2; local_1c = local_1c + 1) {
    param_1 = _is_long_year(local_1c);
    if ((int)param_1 != 0) {
      uVar1 = _printf("%d ");
      param_1 = (ulong)uVar1;
    }
  }
  return param_1;
}



undefined4 entry(void)

{
  _printf("Long (53 week) years between 1800 and 2100\n\n");
  _print_long_years(0x708,0x834);
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int *board, *flood, *known, top = 0, w, h;

static inline int idx(int y, int x) { return y * w + x; }

int neighbors(int c, int *p)
/*
@c cell
@p list of neighbours
@return amount of neighbours
*/
{
	int i, j, n = 0;
	int y = c / w, x = c % w;

	for (i = y - 1; i <= y + 1; i++) {
		if (i < 0 || i >= h) continue;
		for (j = x - 1; j <= x + 1; j++)
			if (!(j < 0 || j >= w
				|| (j == x && i == y)
				|| board[ p[n] = idx(i,j) ] == -1))
				n++;
	}

	return n;
}

void flood_fill(int c)
/*
fill all free cells around @c with 1 and write output to variable flood
@c cell
*/
{
	int i, n[8], nei;

	nei = neighbors(c, n);
	for (i = 0; i < nei; i++) { // for all neighbours
		if (board[n[i]] || flood[n[i]]) continue; // if cell is not free, choose another neighbour

		flood[n[i]] = 1;
		flood_fill(n[i]);
	}
}

/* Check all empty cells are reachable from higher known cells.
   Should really do more checks to make sure cell_x and cell_x+1
   share enough reachable empty cells; I'm lazy. Will implement
   if a good counter example is presented. */
int check_connectity(int lowerbound)
{
	int c;
	memset(flood, 0, sizeof(flood[0]) * w * h);
	for (c = lowerbound + 1; c <= top; c++)
		if (known[c]) flood_fill(known[c]); // mark all free cells around known cells

	for (c = 0; c < w * h; c++)
		if (!board[c] && !flood[c]) // if there are free cells which could not be reached from flood_fill
			return 0;

	return 1;
}

void make_board(int x, int y, const char *s)
{
	int i;

	w = x, h = y;
        top = 0;
	x = w * h;

        known = calloc(x + 1, sizeof(int));
        board = calloc(x,     sizeof(int));
        flood = calloc(x,     sizeof(int));

	while (x--) board[x] = -1;

	for (y = 0; y < h; y++)
	for (x = 0; x < w; x++) {
		i = idx(y, x);

		while (isspace(*s)) s++;

		switch (*s) {
		case '_':	board[i] = 0;
		case '.':	break;
		default:
			known[ board[i] = strtol(s, 0, 10) ] = i;
			if (board[i] > top) top = board[i];
		}

		while (*s && !isspace(*s)) s++;
	}
}

void show_board(const char *s)
{
	int i, j, c;

	printf("\n%s:\n", s);

	for (i = 0; i < h; i++, putchar('\n'))
	for (j = 0; j < w; j++) {
		c = board[ idx(i, j) ];
		printf(!c ? " __" : c == -1 ? "   " : " %2d", c);
	}
}

int fill(int c, int n)
{
	int i, nei, p[8], ko, bo;

	if ((board[c] && board[c] != n) || (known[n] && known[n] != c))
		return 0;

	if (n == top) return 1;

	ko = known[n];
	bo = board[c];
	board[c] = n;

	if (check_connectity(n)) {
		nei = neighbors(c, p);
		for (i = 0; i < nei; i++)
			if (fill(p[i], n + 1))
				return 1;
	}

	board[c] = bo;
	known[n] = ko;
	return 0;
}

int main()
{
	make_board(
#define USE_E 0
#if (USE_E == 0)
		8,8,	" __ 33 35 __ __ .. .. .."
			" __ __ 24 22 __ .. .. .."
			" __ __ __ 21 __ __ .. .."
			" __ 26 __ 13 40 11 .. .."
			" 27 __ __ __  9 __  1 .."
			" .   . __ __ 18 __ __ .."
			" .  ..  .  . __  7 __ __"
			" .  .. .. ..  .  .  5 __"
#elif (USE_E == 1)
	3, 3,	" . 4 ."
		" _ 7 _"
		" 1 _ _"
#else
	50, 3,
	" 1 _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . 74"
	" . . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ . _ ."
	" . . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ . . _ _ ."
#endif
	);

	show_board("Before");
	fill(known[1], 1);
	show_board("After"); /* "40 lbs in two weeks!" */

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003300(void);
int64_t function_1000034c4(void);
int64_t function_1000034f4(void);
int64_t function_100003610(void);
int64_t function_100003794(void);
int64_t function_100003a80(void);
int64_t function_100003bc8(void);
int64_t function_100003e68(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003e74(void);
int64_t * function_100003e80(int32_t nmemb, int32_t size);
int32_t function_100003e8c(int32_t c);
int32_t function_100003e98(char * format, ...);
int32_t function_100003ea4(int32_t c);
int32_t function_100003eb0(char * nptr, char ** endptr, int32_t base);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
int64_t g3 = 0x4b800000012; // 0x100008010
int32_t * g4 = (int32_t *)0x200085; // 0x100008018
int64_t g5 = 0x4800000019; // 0x100008020
char g6[5] = "__PA"; // 0x100008028

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003300 - 0x1000034c4
int64_t function_100003300(void) {
    // 0x100003300
    int64_t v1; // 0x100003300
    int32_t v2 = v1; // 0x10000330c
    int32_t v3 = *(int32_t *)&g6;
    int32_t v4 = v2 / v3; // 0x100003328
    int32_t v5 = v4 - 1; // 0x10000334c
    int32_t v6 = v4 + 1; // 0x100003360
    if (((v5 ^ v6) & v4 + 0x7fffffff) < 0) {
        // 0x1000034b4
        return 0;
    }
    int32_t v7 = v2 % v3;
    int32_t v8 = v7 - 1;
    int32_t v9 = v7 + 1;
    int32_t v10 = 0;
    uint32_t v11 = v5;
    int32_t v12 = v10; // 0x100003380
    int32_t v13; // 0x100003300
    int32_t v14; // 0x100003300
    int32_t v15; // 0x100003300
    uint32_t v16; // 0x100003300
    int32_t v17; // 0x100003394
    int32_t v18; // 0x100003398
    int32_t v19; // 0x100003494
    int32_t v20; // 0x1000033c8
    int32_t v21; // 0x1000033f8
    int32_t v22; // 0x1000033fc
    int64_t v23; // 0x100003454
    int32_t v24; // 0x100003468
    if (v11 >= 0) {
        // 0x100003388
        v17 = *(int32_t *)&g4;
        v18 = v11 - v17;
        v12 = v10;
        if (((v8 ^ v9) & v7 + 0x7fffffff) >= 0 && v18 < 0 != ((v18 ^ v11) & (v17 ^ v11)) < 0) {
            // 0x1000033d8
            v13 = v10;
            v16 = v8;
            v14 = v13;
            if (v16 >= 0) {
                // 0x1000033ec
                v21 = *(int32_t *)&g6;
                v22 = v16 - v21;
                v14 = v13;
                if (v11 == v4 != (v16 == v7) && v22 < 0 != ((v22 ^ v16) & (v21 ^ v16)) < 0) {
                    // 0x10000343c
                    v23 = function_1000034c4();
                    *(int32_t *)(4 * (int64_t)v13 + v1) = (int32_t)v23;
                    v24 = *(int32_t *)((4 * v23 & 0xfffffffc) + g2);
                    v14 = v13 + (int32_t)(v24 != -1);
                }
            }
            // 0x100003490
            v15 = v14;
            v19 = v16 + 1;
            v20 = v19 - v9;
            v12 = v15;
            while (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v19 ^ v9)) < 0) {
                // 0x1000033d8
                v13 = v15;
                v16 = v19;
                v14 = v13;
                if (v16 >= 0) {
                    // 0x1000033ec
                    v21 = *(int32_t *)&g6;
                    v22 = v16 - v21;
                    v14 = v13;
                    if (v11 == v4 != (v16 == v7) && v22 < 0 != ((v22 ^ v16) & (v21 ^ v16)) < 0) {
                        // 0x10000343c
                        v23 = function_1000034c4();
                        *(int32_t *)(4 * (int64_t)v13 + v1) = (int32_t)v23;
                        v24 = *(int32_t *)((4 * v23 & 0xfffffffc) + g2);
                        v14 = v13 + (int32_t)(v24 != -1);
                    }
                }
                // 0x100003490
                v15 = v14;
                v19 = v16 + 1;
                v20 = v19 - v9;
                v12 = v15;
            }
        }
    }
    int32_t result = v12;
    int32_t v25 = v11 + 1; // 0x1000034a8
    int32_t v26 = v25 - v6; // 0x100003364
    while (v26 == 0 || v26 < 0 != ((v26 ^ v25) & (v25 ^ v6)) < 0) {
        // 0x100003374
        v10 = result;
        v11 = v25;
        v12 = v10;
        if (v11 >= 0) {
            // 0x100003388
            v17 = *(int32_t *)&g4;
            v18 = v11 - v17;
            v12 = v10;
            if (((v8 ^ v9) & v7 + 0x7fffffff) >= 0 && v18 < 0 != ((v18 ^ v11) & (v17 ^ v11)) < 0) {
                // 0x1000033d8
                v13 = v10;
                v16 = v8;
                v14 = v13;
                if (v16 >= 0) {
                    // 0x1000033ec
                    v21 = *(int32_t *)&g6;
                    v22 = v16 - v21;
                    v14 = v13;
                    if (v11 == v4 != (v16 == v7) && v22 < 0 != ((v22 ^ v16) & (v21 ^ v16)) < 0) {
                        // 0x10000343c
                        v23 = function_1000034c4();
                        *(int32_t *)(4 * (int64_t)v13 + v1) = (int32_t)v23;
                        v24 = *(int32_t *)((4 * v23 & 0xfffffffc) + g2);
                        v14 = v13 + (int32_t)(v24 != -1);
                    }
                }
                // 0x100003490
                v15 = v14;
                v19 = v16 + 1;
                v20 = v19 - v9;
                v12 = v15;
                while (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v19 ^ v9)) < 0) {
                    // 0x1000033d8
                    v13 = v15;
                    v16 = v19;
                    v14 = v13;
                    if (v16 >= 0) {
                        // 0x1000033ec
                        v21 = *(int32_t *)&g6;
                        v22 = v16 - v21;
                        v14 = v13;
                        if (v11 == v4 != (v16 == v7) && v22 < 0 != ((v22 ^ v16) & (v21 ^ v16)) < 0) {
                            // 0x10000343c
                            v23 = function_1000034c4();
                            *(int32_t *)(4 * (int64_t)v13 + v1) = (int32_t)v23;
                            v24 = *(int32_t *)((4 * v23 & 0xfffffffc) + g2);
                            v14 = v13 + (int32_t)(v24 != -1);
                        }
                    }
                    // 0x100003490
                    v15 = v14;
                    v19 = v16 + 1;
                    v20 = v19 - v9;
                    v12 = v15;
                }
            }
        }
        // 0x1000034a4
        result = v12;
        v25 = v11 + 1;
        v26 = v25 - v6;
    }
    // 0x1000034b4
    return result;
}

// Address range: 0x1000034c4 - 0x1000034f4
int64_t function_1000034c4(void) {
    int32_t v1 = *(int32_t *)&g6; // 0x1000034dc
    int64_t v2; // 0x1000034c4
    return v1 * (int32_t)v2 + (int32_t)v2;
}

// Address range: 0x1000034f4 - 0x100003610
int64_t function_1000034f4(void) {
    int64_t v1 = function_100003300(); // 0x10000351c
    int32_t v2 = v1; // 0x100003520
    int32_t v3 = -v2; // 0x100003534
    int64_t v4 = v1; // 0x10000353c
    if (v3 < 0 != (v3 & v2) < 0) {
        // 0x100003544
        int64_t v5; // bp-56, 0x1000034f4
        int64_t v6 = &v5; // 0x100003554
        int32_t v7 = 0; // 0x1000035d4
        int64_t v8 = 4 * (int64_t)*(int32_t *)(4 * (int64_t)v7 + v6); // 0x10000355c
        int64_t v9 = v1; // 0x100003568
        int32_t * v10; // 0x100003588
        if (*(int32_t *)(v8 + g2) == 0) {
            // 0x100003570
            v10 = (int32_t *)(g3 + v8);
            v9 = v1;
            if (*v10 == 0) {
                // 0x1000035a0
                *v10 = 1;
                v9 = function_1000034f4();
            }
        }
        int64_t v11 = v9;
        v7++;
        int32_t v12 = v7 - v2; // 0x100003534
        v4 = v11;
        while (v12 < 0 != ((v12 ^ v7) & (v7 ^ v2)) < 0) {
            int64_t v13 = v11;
            v8 = 4 * (int64_t)*(int32_t *)(4 * (int64_t)v7 + v6);
            v9 = v13;
            if (*(int32_t *)(v8 + g2) == 0) {
                // 0x100003570
                v10 = (int32_t *)(g3 + v8);
                v9 = v13;
                if (*v10 == 0) {
                    // 0x1000035a0
                    *v10 = 1;
                    v9 = function_1000034f4();
                }
            }
            // 0x1000035d0
            v11 = v9;
            v7++;
            v12 = v7 - v2;
            v4 = v11;
        }
    }
    int64_t v14 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000035ec
    int64_t result = v4; // 0x1000035f8
    if (v14 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003600
        result = ___stack_chk_fail();
    }
    // 0x100003604
    return result;
}

// Address range: 0x100003610 - 0x100003794
int64_t function_100003610(void) {
    int32_t v1 = *(int32_t *)&g6; // 0x100003634
    int32_t v2 = *(int32_t *)&g4; // 0x100003648
    ___memset_chk(g3, 0, 4 * (int64_t)v1 * (int64_t)v2, -1);
    int64_t v3; // 0x100003610
    int32_t v4 = (int32_t)v3 + 1;
    int32_t v5 = *(int32_t *)&g1; // 0x100003674
    int32_t v6 = v4 - v5; // 0x100003678
    int32_t v7 = v4; // 0x100003680
    if (v6 == 0 || v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0) {
        int32_t v8 = v5; // 0x1000036a4
        if (*(int32_t *)(4 * (int64_t)v7 + g5) != 0) {
            // 0x1000036ac
            function_1000034f4();
            v8 = *(int32_t *)&g1;
        }
        int32_t v9 = v8; // 0x100003674
        v7++;
        while (v7 - v9 == 0 || v7 - v9 < 0 != ((v7 - v9 ^ v7) & (v9 ^ v7)) < 0) {
            // 0x100003688
            v8 = v9;
            if (*(int32_t *)(4 * (int64_t)v7 + g5) != 0) {
                // 0x1000036ac
                function_1000034f4();
                v8 = *(int32_t *)&g1;
            }
            // 0x1000036cc
            v9 = v8;
            v7++;
        }
    }
    int32_t v10 = *(int32_t *)&g4 * *(int32_t *)&g6;
    int32_t v11 = -v10; // 0x100003704
    if (v11 < 0 == (v10 & v11) < 0) {
        // 0x100003784
        return 1;
    }
    int32_t v12 = 0; // 0x10000376c
    int64_t v13 = 4 * (int64_t)v12; // 0x100003724
    if (*(int32_t *)(v13 + g2) == 0) {
        // 0x100003738
        if (*(int32_t *)(v13 + g3) == 0) {
            // break -> 0x100003784
            break;
        }
    }
    // 0x100003768
    v12++;
    int32_t v14 = v12 - v10; // 0x100003704
    int64_t result = 1; // 0x10000370c
    while (v14 < 0 != ((v14 ^ v12) & (v12 ^ v10)) < 0) {
        // 0x100003714
        v13 = 4 * (int64_t)v12;
        if (*(int32_t *)(v13 + g2) == 0) {
            // 0x100003738
            result = 0;
            if (*(int32_t *)(v13 + g3) == 0) {
                // break -> 0x100003784
                break;
            }
        }
        // 0x100003768
        v12++;
        v14 = v12 - v10;
        result = 1;
    }
    // 0x100003784
    return result;
}

// Address range: 0x100003794 - 0x100003a80
int64_t function_100003794(void) {
    // 0x100003794
    int64_t v1; // 0x100003794
    int32_t v2 = v1; // 0x1000037a0
    int32_t v3 = v1; // 0x1000037a4
    *(int32_t *)&g6 = v2;
    *(int32_t *)&g4 = v3;
    *(int32_t *)&g1 = 0;
    int32_t v4 = v2 * v3; // 0x1000037dc
    g5 = (int64_t)_calloc(v4 + 1, 4);
    g2 = (int64_t)_calloc(v4, 4);
    int64_t result = (int64_t)_calloc(v4, 4); // 0x10000382c
    g3 = result;
    int32_t v5 = v4; // 0x100003854
    if (v4 != 0) {
        v5--;
        *(int32_t *)(4 * (int64_t)v5 + g2) = -1;
        while (v5 != 0) {
            // 0x10000385c
            v5--;
            *(int32_t *)(4 * (int64_t)v5 + g2) = -1;
        }
    }
    int32_t v6 = *(int32_t *)&g4; // 0x10000388c
    int32_t v7 = -v6; // 0x100003890
    if (v7 < 0 == (v6 & v7) < 0) {
        // 0x100003a74
        return result;
    }
    int32_t v8 = v6; // 0x10000388c
    int32_t v9 = 0; // 0x100003a68
    char * v10 = (char *)v1; // 0x100003794
    int32_t v11 = *(int32_t *)&g6; // 0x1000038b4
    int32_t v12 = -v11; // 0x1000038b8
    int32_t v13 = 0; // 0x1000038c0
    char * v14 = v10; // 0x1000038c0
    char v15; // 0x100003794
    int32_t v16; // 0x100003794
    int32_t v17; // 0x100003794
    char * v18; // 0x100003794
    char * v19; // 0x100003794
    char * v20; // 0x100003794
    char * v21; // 0x100003794
    int64_t v22; // 0x1000038d0
    char * v23; // 0x100003794
    int32_t v24; // 0x10000397c
    int64_t v25; // 0x10000399c
    int32_t v26; // 0x1000039b0
    int32_t v27; // 0x1000039b8
    int32_t v28; // 0x1000039bc
    int32_t v29; // 0x1000038b4
    int64_t v30; // 0x100003794
    int64_t v31; // 0x100003794
    if (v12 < 0 != (v11 & v12) < 0) {
        while (true) {
            // 0x1000038c8
            v22 = function_1000034c4();
            v18 = v14;
            v19 = v14;
            if (_isspace((int32_t)*v14) != 0) {
                v23 = (char *)((int64_t)v18 + 1);
                v18 = v23;
                v19 = v23;
                while (_isspace((int32_t)*v23) != 0) {
                    // 0x1000038f8
                    v23 = (char *)((int64_t)v18 + 1);
                    v18 = v23;
                    v19 = v23;
                }
            }
            // 0x100003908
            v20 = v19;
            v15 = 46;
            switch (*v20) {
                case 46: {
                    goto lab_0x100003a30;
                }
                case 95: {
                    // 0x100003938
                    *(int32_t *)(g2 + (0x100000000 * v22 >> 30)) = 0;
                    goto lab_0x1000039f0;
                }
                default: {
                    // 0x100003958
                    v24 = _strtol(v20, NULL, 10);
                    v25 = 0x100000000 * v22 >> 30;
                    *(int32_t *)(g2 + v25) = v24;
                    *(int32_t *)(g5 + (int64_t)(4 * v24)) = (int32_t)v22;
                    v26 = *(int32_t *)(g2 + v25);
                    v27 = *(int32_t *)&g1;
                    v28 = v26 - v27;
                    if (v28 != 0 && v28 < 0 == ((v28 ^ v26) & (v27 ^ v26)) < 0) {
                        // 0x1000039cc
                        *(int32_t *)&g1 = v26;
                    }
                    goto lab_0x1000039f0;
                }
            }
        }
        // 0x1000038a8
        v31 = v30;
        v16 = *(int32_t *)&g4;
        v17 = v29;
        v10 = v21;
    }
    int64_t result2 = result;
    v9++;
    int32_t v32 = v9 - v8; // 0x100003890
    while (v32 < 0 != ((v32 ^ v9) & (v8 ^ v9)) < 0) {
        // 0x1000038a8
        v12 = -v11;
        v13 = 0;
        v14 = v10;
        if (v12 < 0 != (v11 & v12) < 0) {
            while (true) {
                // 0x1000038c8
                v22 = function_1000034c4();
                v18 = v14;
                v19 = v14;
                if (_isspace((int32_t)*v14) != 0) {
                    v23 = (char *)((int64_t)v18 + 1);
                    v18 = v23;
                    v19 = v23;
                    while (_isspace((int32_t)*v23) != 0) {
                        // 0x1000038f8
                        v23 = (char *)((int64_t)v18 + 1);
                        v18 = v23;
                        v19 = v23;
                    }
                }
                // 0x100003908
                v20 = v19;
                v15 = 46;
                switch (*v20) {
                    case 46: {
                        goto lab_0x100003a30;
                    }
                    case 95: {
                        // 0x100003938
                        *(int32_t *)(g2 + (0x100000000 * v22 >> 30)) = 0;
                        goto lab_0x1000039f0;
                    }
                    default: {
                        // 0x100003958
                        v24 = _strtol(v20, NULL, 10);
                        v25 = 0x100000000 * v22 >> 30;
                        *(int32_t *)(g2 + v25) = v24;
                        *(int32_t *)(g5 + (int64_t)(4 * v24)) = (int32_t)v22;
                        v26 = *(int32_t *)(g2 + v25);
                        v27 = *(int32_t *)&g1;
                        v28 = v26 - v27;
                        if (v28 != 0 && v28 < 0 == ((v28 ^ v26) & (v27 ^ v26)) < 0) {
                            // 0x1000039cc
                            *(int32_t *)&g1 = v26;
                        }
                        goto lab_0x1000039f0;
                    }
                }
            }
            // 0x1000038a8
            v31 = v30;
            v16 = *(int32_t *)&g4;
            v17 = v29;
            v10 = v21;
        }
        // 0x100003a64
        v9++;
        v32 = v9 - v8;
    }
    // 0x100003a74
    return result2;
  lab_0x100003a30:;
    char * v33 = v20;
    int32_t v34 = _isspace((int32_t)v15); // 0x100003a1c
    char * v35; // 0x100003794
    while (v34 == 0) {
        char * v36 = (char *)((int64_t)v33 + 1);
        char v37 = *v36; // 0x1000039f8
        char v38 = v37; // 0x100003a0c
        char * v39 = v36; // 0x100003a0c
        if (v37 == 0) {
            // 0x1000039f4
            v35 = v36;
            goto lab_0x100003a50;
        }
        v33 = v39;
        v34 = _isspace((int32_t)v38);
    }
    // 0x100003a30
    v35 = v33;
    goto lab_0x100003a50;
  lab_0x1000039f0:;
    char v42 = *v20;
    v15 = v42;
    v35 = v20;
    if (v42 == 0) {
        goto lab_0x100003a50;
    } else {
        goto lab_0x100003a30;
    }
  lab_0x100003a50:;
    int32_t v40 = v13 + 1; // 0x100003a54
    v29 = *(int32_t *)&g6;
    int32_t v41 = v40 - v29; // 0x1000038b8
    v13 = v40;
    v14 = v35;
    if (v41 < 0 == ((v41 ^ v40) & (v29 ^ v40)) < 0) {
        // break -> 0x1000038a8
        goto lab_0x1000038a8;
    }
    goto lab_0x1000038c8;
}

// Address range: 0x100003a80 - 0x100003bc8
int64_t function_100003a80(void) {
    // 0x100003a80
    int64_t v1; // 0x100003a80
    int32_t result = _printf("\n%s:\n", (char *)v1); // 0x100003aa4
    int32_t v2 = *(int32_t *)&g4; // 0x100003abc
    int32_t v3 = -v2; // 0x100003ac0
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003bbc
        return result;
    }
    int32_t v4 = 0; // 0x100003ac8
    int32_t v5 = *(int32_t *)&g6; // 0x100003ae4
    int32_t v6 = -v5; // 0x100003ae8
    int32_t v7; // 0x100003a80
    int64_t v8; // 0x100003b10
    int32_t v9; // 0x100003b18
    int32_t v10; // 0x100003b94
    int32_t v11; // 0x100003ae4
    int32_t v12; // 0x100003ae8
    char * v13; // 0x100003b6c
    if (v6 < 0 != (v5 & v6) < 0) {
        v8 = function_1000034c4();
        v9 = *(int32_t *)((4 * v8 & 0xfffffffc) + g2);
        v13 = " __";
        if (v9 != 0) {
            // 0x100003b44
            v13 = v9 != -1 ? " %2d" : "   ";
        }
        // 0x100003b74
        _printf(v13);
        v10 = 1;
        v11 = *(int32_t *)&g6;
        v12 = v10 - v11;
        v7 = v10;
        while (v12 < 0 != ((v12 ^ v10) & (v11 ^ v10)) < 0) {
            // 0x100003af8
            v8 = function_1000034c4();
            v9 = *(int32_t *)((4 * v8 & 0xfffffffc) + g2);
            v13 = " __";
            if (v9 != 0) {
                // 0x100003b44
                v13 = v9 != -1 ? " %2d" : "   ";
            }
            // 0x100003b74
            _printf(v13);
            v10 = v7 + 1;
            v11 = *(int32_t *)&g6;
            v12 = v10 - v11;
            v7 = v10;
        }
    }
    // 0x100003ba4
    v4++;
    int32_t result2 = _putchar(10); // 0x100003bb4
    int32_t v14 = *(int32_t *)&g4; // 0x100003abc
    int32_t v15 = v4 - v14; // 0x100003ac0
    while (v15 < 0 != ((v15 ^ v4) & (v14 ^ v4)) < 0) {
        // 0x100003ad8
        v5 = *(int32_t *)&g6;
        v6 = -v5;
        if (v6 < 0 != (v5 & v6) < 0) {
            v8 = function_1000034c4();
            v9 = *(int32_t *)((4 * v8 & 0xfffffffc) + g2);
            v13 = " __";
            if (v9 != 0) {
                // 0x100003b44
                v13 = v9 != -1 ? " %2d" : "   ";
            }
            // 0x100003b74
            _printf(v13);
            v10 = 1;
            v11 = *(int32_t *)&g6;
            v12 = v10 - v11;
            v7 = v10;
            while (v12 < 0 != ((v12 ^ v10) & (v11 ^ v10)) < 0) {
                // 0x100003af8
                v8 = function_1000034c4();
                v9 = *(int32_t *)((4 * v8 & 0xfffffffc) + g2);
                v13 = " __";
                if (v9 != 0) {
                    // 0x100003b44
                    v13 = v9 != -1 ? " %2d" : "   ";
                }
                // 0x100003b74
                _printf(v13);
                v10 = v7 + 1;
                v11 = *(int32_t *)&g6;
                v12 = v10 - v11;
                v7 = v10;
            }
        }
        // 0x100003ba4
        v4++;
        result2 = _putchar(10);
        v14 = *(int32_t *)&g4;
        v15 = v4 - v14;
    }
    // 0x100003bbc
    return result2;
}

// Address range: 0x100003bc8 - 0x100003dfc
int64_t function_100003bc8(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003bdc
    int64_t v2; // 0x100003bc8
    int32_t v3 = v2; // 0x100003be8
    int64_t v4 = 0x100000000 * v2 >> 30; // 0x100003bfc
    int32_t * v5 = (int32_t *)(g2 + v4);
    int32_t v6 = *v5; // 0x100003bfc
    int64_t result = 0; // 0x100003c08
    int64_t v7; // 0x100003c48
    int32_t v8; // 0x100003c48
    if (v6 == 0 || v6 == v3) {
        // 0x100003c38
        v7 = 0x100000000 * v2 >> 30;
        v8 = *(int32_t *)(g5 + v7);
        result = 0;
        if (v8 == 0 || v8 == (int32_t)v2) {
            // 0x100003c8c
            result = 1;
            if (*(int32_t *)&g1 == v3) {
                goto lab_0x100003dc0;
            } else {
                // 0x100003cb4
                *v5 = v3;
                if ((int32_t)function_100003610() == 0) {
                    goto lab_0x100003d88;
                } else {
                    int32_t v9 = function_100003300(); // 0x100003d18
                    int32_t v10 = -v9; // 0x100003d2c
                    int32_t v11 = 0; // 0x100003d34
                    if (v10 < 0 == (v10 & v9) < 0) {
                        goto lab_0x100003d88;
                    } else {
                        result = 1;
                        while ((int32_t)function_100003bc8() == 0) {
                            int32_t v12 = v11 + 1; // 0x100003d78
                            int32_t v13 = v12 - v9; // 0x100003d2c
                            v11 = v12;
                            if (v13 < 0 == ((v13 ^ v12) & (v12 ^ v9)) < 0) {
                                goto lab_0x100003d88;
                            }
                            result = 1;
                        }
                        goto lab_0x100003dc0;
                    }
                }
            }
        } else {
            goto lab_0x100003dc0;
        }
    } else {
        goto lab_0x100003dc0;
    }
  lab_0x100003d88:
    // 0x100003d88
    *(int32_t *)(g2 + v4) = v6;
    *(int32_t *)(g5 + v7) = v8;
    result = 0;
    goto lab_0x100003dc0;
  lab_0x100003dc0:
    // 0x100003dc0
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003de8
        ___stack_chk_fail();
    }
    // 0x100003dec
    return result;
}

// Address range: 0x100003dfc - 0x100003e68
int64_t entry_point(void) {
    // 0x100003dfc
    function_100003794();
    function_100003a80();
    function_100003bc8();
    function_100003a80();
    return 0;
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e68
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e74 - 0x100003e80
int64_t function_100003e74(void) {
    // 0x100003e74
    return ___stack_chk_fail();
}

// Address range: 0x100003e80 - 0x100003e8c
int64_t * function_100003e80(int32_t nmemb, int32_t size) {
    // 0x100003e80
    return _calloc(nmemb, size);
}

// Address range: 0x100003e8c - 0x100003e98
int32_t function_100003e8c(int32_t c) {
    // 0x100003e8c
    return _isspace(c);
}

// Address range: 0x100003e98 - 0x100003ea4
int32_t function_100003e98(char * format, ...) {
    // 0x100003e98
    return _printf(format);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(int32_t c) {
    // 0x100003ea4
    return _putchar(c);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * nptr, char ** endptr, int32_t base) {
    // 0x100003eb0
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#define LIMIT 15
int smallPrimes[LIMIT];

static void sieve() {
    int i = 2, j;
    int p = 5;

    smallPrimes[0] = 2;
    smallPrimes[1] = 3;

    while (i < LIMIT) {
        for (j = 0; j < i; j++) {
            if (smallPrimes[j] * smallPrimes[j] <= p) {
                if (p % smallPrimes[j] == 0) {
                    p += 2;
                    break;
                }
            } else {
                smallPrimes[i++] = p;
                p += 2;
                break;
            }
        }
    }
}

static bool is_prime(uint64_t n) {
    uint64_t i;

    for (i = 0; i < LIMIT; i++) {
        if (n % smallPrimes[i] == 0) {
            return n == smallPrimes[i];
        }
    }

    i = smallPrimes[LIMIT - 1] + 2;
    for (; i * i <= n; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }

    return true;
}

static uint64_t divisor_count(uint64_t n) {
    uint64_t count = 1;
    uint64_t d;

    while (n % 2 == 0) {
        n /= 2;
        count++;
    }

    for (d = 3; d * d <= n; d += 2) {
        uint64_t q = n / d;
        uint64_t r = n % d;
        uint64_t dc = 0;
        while (r == 0) {
            dc += count;
            n = q;
            q = n / d;
            r = n % d;
        }
        count += dc;
    }

    if (n != 1) {
        return count *= 2;
    }
    return count;
}

static uint64_t OEISA073916(size_t n) {
    uint64_t count = 0;
    uint64_t result = 0;
    size_t i;

    if (is_prime(n)) {
        return (uint64_t)pow(smallPrimes[n - 1], n - 1);
    }

    for (i = 1; count < n; i++) {
        if (n % 2 == 1) {
            //  The solution for an odd (non-prime) term is always a square number
            uint64_t root = (uint64_t)sqrt(i);
            if (root * root != i) {
                continue;
            }
        }
        if (divisor_count(i) == n) {
            count++;
            result = i;
        }
    }

    return result;
}

int main() {
    size_t n;

    sieve();

    for (n = 1; n <= LIMIT; n++) {
        if (n == 13) {
            printf("A073916(%lu) = One more bit needed to represent result.\n", n);
        } else {
            printf("A073916(%lu) = %llu\n", n, OEISA073916(n));
        }
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a04(void);
int64_t function_100003b50(void);
int64_t function_100003c74(void);
int64_t function_100003db8(void);
float64_t function_100003f28(float64_t a1, float64_t a2);
int32_t function_100003f34(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x100000c; // 0x100008004

// ------- Dynamically Linked Functions Without Header --------

float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000394c - 0x100003a04
int64_t entry_point(void) {
    // 0x10000394c
    function_100003b50();
    int64_t v1; // 0x10000394c
    int32_t v2 = v1;
    for (int64_t i = 1; i < 16; i++) {
        // 0x100003980
        if (i == 13) {
            // 0x100003994
            _printf("A073916(%lu) = One more bit needed to represent result.\n", v2);
        } else {
            // 0x1000039b0
            function_100003a04();
            _printf("A073916(%lu) = %llu\n", v2, v1);
        }
    }
    // 0x1000039f4
    return 0;
}

// Address range: 0x100003a04 - 0x100003b50
int64_t function_100003a04(void) {
    // 0x100003a04
    int64_t v1; // 0x100003a04
    uint64_t v2 = v1;
    if (function_100003c74() % 2 != 0) {
        // 0x100003a2c
        int128_t v3; // 0x100003a04
        _pow((float64_t)(int64_t)__asm_sshll(0.0f, 0), (float64_t)(int64_t)v3);
        // 0x100003b40
        float64_t result; // 0x100003a04
        return result;
    }
    // 0x100003a74
    if (v2 == 0) {
        // 0x100003b40
        return (float64_t)0;
    }
    int64_t v4 = 1; // 0x100003b28
    int64_t v5 = 0;
    float64_t v6 = 4.9406564584124654e-324; // 0x100003a04
    int64_t v7 = 0;
    int64_t v8; // 0x100003a04
    int64_t v9; // 0x100003a04
    int64_t v10; // 0x100003a04
    float64_t v11; // 0x100003b24
    int64_t v12; // 0x100003a04
    int64_t v13; // 0x100003a04
    while (true) {
      lab_0x100003a8c_2:
        // 0x100003a8c
        v12 = v7;
        v11 = v6;
        v10 = v5;
        v9 = v4;
        if (v2 == (2 * v2 / 2 || 1)) {
            int64_t v14 = sqrt(v11); // 0x100003abc
            v8 = v10;
            v13 = v12;
            if (v14 * v14 == (int64_t)v11) {
                goto lab_0x100003aec;
            } else {
                goto lab_0x100003b24;
            }
        } else {
            // 0x100003a8c
            goto lab_0x100003aec;
        }
    }
  lab_0x100003b34:;
    // 0x100003b40
    int64_t v15; // 0x100003a04
    return (float64_t)v15;
  lab_0x100003aec:;
    int64_t v16 = function_100003db8(); // 0x100003af0
    v8 = v16 == v2 ? v9 : v10;
    v13 = v12 + (int64_t)(v16 == v2);
    goto lab_0x100003b24;
  lab_0x100003b24:
    // 0x100003b24
    v7 = v13;
    v5 = v8;
    v4 = (int64_t)v11 + 1;
    v6 = v4;
    v15 = v5;
    if (v7 >= v2) {
        // break -> 0x100003b34
        goto lab_0x100003b34;
    }
    goto lab_0x100003a8c_2;
}

// Address range: 0x100003b50 - 0x100003c74
int64_t function_100003b50(void) {
    // 0x100003b50
    *(int32_t *)&g1 = 2;
    *(int32_t *)&g2 = 3;
    int32_t v1 = 2;
    int32_t v2 = 5; // 0x100003b50
    int32_t v3; // 0x100003b50
    while (true) {
      lab_0x100003b98:;
        int32_t v4 = v2;
        int32_t v5 = v1;
        int32_t v6 = -v5; // 0x100003ba0
        v2 = v4;
        v3 = v5;
        if (v6 < 0 != (v5 & v6) < 0) {
            int32_t v7 = 0;
            int32_t v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1); // 0x100003bbc
            int32_t v9 = v8 * v8; // 0x100003bc8
            while (v9 - v4 == 0 || v9 - v4 < 0 != ((v9 - v4 ^ v9) & (v9 ^ v4)) < 0) {
                if (v4 % v8 == 0) {
                    // 0x100003c10
                    v2 = v4 + 2;
                    v3 = v5;
                    goto lab_0x100003c68;
                }
                int32_t v10 = v7 + 1; // 0x100003c5c
                int32_t v11 = v10 - v5; // 0x100003ba0
                int32_t v12 = v10; // 0x100003ba8
                v2 = v4;
                v3 = v5;
                if (v11 < 0 == ((v11 ^ v10) & (v10 ^ v5)) < 0) {
                    goto lab_0x100003c68;
                }
                v7 = v12;
                v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
                v9 = v8 * v8;
            }
            // 0x100003c24
            *(int32_t *)(4 * (int64_t)v5 + (int64_t)&g1) = v4;
            v2 = v4 + 2;
            v3 = v5 + 1;
        }
        goto lab_0x100003c68;
    }
    // 0x100003c6c
    int64_t result; // 0x100003b50
    return result;
  lab_0x100003c68:
    // 0x100003c68
    v1 = v3;
    if (v1 < 15 == (14 - v1 & v1) < 0) {
        int64_t result2; // 0x100003b50
        return result2;
    }
    goto lab_0x100003b98;
}

// Address range: 0x100003c74 - 0x100003db8
int64_t function_100003c74(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    uint64_t v2 = v1;
    int64_t v3 = 0; // 0x100003cfc
    uint64_t v4 = (int64_t)*(int32_t *)(4 * v3 + (int64_t)&g1); // 0x100003ca8
    int64_t result; // 0x100003c74
    int64_t v5; // 0x100003c74
    while (v2 % v4 != 0) {
        // 0x100003c84
        v3++;
        if (v3 >= 15) {
            int64_t v6 = (int64_t)(*(int32_t *)((int64_t)&g1 + 56) + 2); // 0x100003d1c
            uint64_t v7 = v6 * v6; // 0x100003d30
            v5 = v6;
            result = 1;
            if (v7 >= v2 == (v7 != v2)) {
                return result;
            } else {
                goto lab_0x100003d48;
            }
        }
        v4 = (int64_t)*(int32_t *)(4 * v3 + (int64_t)&g1);
    }
    // 0x100003cc8
    result = v2 == v4;
  lab_0x100003da8:
    // 0x100003da8
    return result;
  lab_0x100003d48:
    // 0x100003d48
    result = 0;
    if (v2 % v5 == 0) {
        return result;
    } else {
        int64_t v8 = v5 + 2; // 0x100003d88
        uint64_t v9 = v8 * v8; // 0x100003d30
        v5 = v8;
        result = 1;
        if (v9 >= v2 == (v9 != v2)) {
            return result;
        } else {
            goto lab_0x100003d48;
        }
    }
}

// Address range: 0x100003db8 - 0x100003f28
int64_t function_100003db8(void) {
    int64_t v1 = 1;
    int64_t v2; // 0x100003db8
    int64_t v3 = v2;
    int64_t v4 = v3 / 2; // 0x100003dd4
    int64_t v5 = v1 + 1; // 0x100003de8
    while (v3 == 2 * v4) {
        // 0x100003dcc
        v1 = v5;
        v3 = v4;
        v4 = v3 / 2;
        v5 = v1 + 1;
    }
    // 0x100003e1c
    if (v3 <= 9 == (v3 != 9)) {
        // 0x100003ee8
        return v1 << (int64_t)(v3 != 1);
    }
    uint64_t v6 = 3;
    int64_t v7 = v3; // 0x100003e78
    int64_t v8 = 0; // 0x100003e78
    int64_t v9; // 0x100003db8
    int64_t v10; // 0x100003db8
    int64_t v11; // 0x100003db8
    int64_t v12; // 0x100003e88
    if (v3 % v6 == 0) {
        v10 = v3 / v6;
        v12 = v1;
        v11 = v12;
        v9 = v10;
        v7 = v10;
        v8 = v12;
        while (v10 % v6 == 0) {
            // 0x100003e80
            v10 = v9 / v6;
            v12 = v11 + v1;
            v11 = v12;
            v9 = v10;
            v7 = v10;
            v8 = v12;
        }
    }
    int64_t v13 = v7;
    int64_t v14 = v8 + v1; // 0x100003ecc
    int64_t v15 = v6 + 2; // 0x100003edc
    uint64_t v16 = v15 * v15; // 0x100003e24
    while (v16 >= v13 != v16 != v13) {
        int64_t v17 = v14;
        v6 = v15;
        v9 = v13;
        v7 = v13;
        v8 = 0;
        if (v13 % v6 == 0) {
            v10 = v9 / v6;
            v12 = v17;
            v11 = v12;
            v9 = v10;
            v7 = v10;
            v8 = v12;
            while (v10 % v6 == 0) {
                // 0x100003e80
                v10 = v9 / v6;
                v12 = v11 + v17;
                v11 = v12;
                v9 = v10;
                v7 = v10;
                v8 = v12;
            }
        }
        // 0x100003ec4
        v13 = v7;
        v14 = v8 + v17;
        v15 = v6 + 2;
        v16 = v15 * v15;
    }
    // 0x100003ee8
    return v14 << (int64_t)(v13 != 1);
}

// Address range: 0x100003f28 - 0x100003f34
float64_t function_100003f28(float64_t a1, float64_t a2) {
    // 0x100003f28
    return _pow(a1, a2);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <string.h>  // we include the library string.h to the use of string

void saisie(
    char *cpointeur);  // Prototypes of the three functions used in the program
int compte(char *s);
char *miroir(char *s);

int main(int argc, char *argv[])
{
    char chaine[20];
    saisie(chaine);
    printf("miroir est %s", miroir(chaine));
}
// this function is used to put a string
void saisie(char *cpointeur)
{
    printf("saisir une chaine\n");
    scanf("%s", cpointeur);
}
/* the function miroir (in french ) it means "mirror" , the major idea is to
permute the first caractere with the last using an auxilary variable (aux) the
the 2nd character with the penultimate one and so on . we made a call to the
function (compte) which counts the length of the string . As you can see clearly
, I substruct 1 from the equation k = compte(s)-1 ; to get rid of the EOF
caractere which is '\0' because it is not a caractere from the string typed */
char *miroir(char *s)
{
    int i;
    char aux;
    int k;
    k = compte(s) - 1;
    i = 0;
    while (i <= k)
    {
        aux = s[i];
        s[i] = s[k];
        s[k] = aux;
        k--;
        i++;
    }

    return s;
}

// compte plays the role of strlen so we can change it by an strlen function if
// you want that
int compte(char *s)
{
    char *p;
    int k;
    p = s;
    k = 0;
    while (*p != '\0')
    {
        p++;
        k++;
    }
    return k;
}
`,`#include "mirror.h"



undefined8 entry(void)

{
  int iVar1;
  undefined auStack_2c [20];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _saisie();
  _miroir(auStack_2c);
  iVar1 = _printf("miroir est %s");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



int _saisie(void)

{
  int iVar1;
  
  _printf("saisir une chaine\n");
  iVar1 = _scanf("%s");
  return iVar1;
}



long _miroir(long param_1)

{
  undefined uVar1;
  undefined4 local_24;
  undefined4 local_1c;
  
  local_24 = _compte(param_1);
  for (local_1c = 0; local_24 = local_24 + -1, local_1c <= local_24; local_1c = local_1c + 1) {
    uVar1 = *(undefined *)(param_1 + local_1c);
    *(undefined *)(param_1 + local_1c) = *(undefined *)(param_1 + local_24);
    *(undefined *)(param_1 + local_24) = uVar1;
  }
  return param_1;
}



int _compte(char *param_1)

{
  int local_14;
  char *local_10;
  
  local_14 = 0;
  for (local_10 = param_1; *local_10 != '\0'; local_10 = local_10 + 1) {
    local_14 = local_14 + 1;
  }
  return local_14;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>


#define MAX_POINTS 100
#define PLAYER_COUNT 4


//Possible player moves.
typedef enum {
    ROLL,
    HOLD
} Moves;

//To allow the player definition to be used in the function definition.
typedef struct Player Player;

//This function takes the player's current score, returns 1 if the player rolls and 0 if they hold.
typedef Moves (*DeciderFunction) (Player *player);

struct Player{
    unsigned int score;
    unsigned int roundScore;
    DeciderFunction dFunction;
};

/*
    Auxiliary functions
*/
static int randrange(int min, int max){
    return (rand() % (max - min + 1)) + min;
}

//Creates a player with the given decider function.
static Player *create_player(DeciderFunction dFunction) {
    Player *player = malloc(sizeof(Player));
    player->score = 0;
    player->roundScore = 0;
    player->dFunction = dFunction;

    return player;
}

/*
    Player functions
*/
//Randomly decides whether to hold or roll.
static Moves random_player(Player *player) {
    if (player->score + player->roundScore >= MAX_POINTS)
        return HOLD;

    int num = randrange(0, 9);

    //We do the second check to make sure the player rolls at least once.
    if (num < 5 || player->roundScore == 0)
        return ROLL;
    return HOLD;
}

//Always tries to score at least a quarter of the difference between their score and "MAX_POINTS".
static Moves quarter_player(Player *player) {
    if (player->score + player->roundScore >= MAX_POINTS)
        return HOLD;

    unsigned int target = (MAX_POINTS - player->score) / 4;

    if (player->roundScore < target)
        return ROLL;
    return HOLD;
}

//Always tries to score at least fifteen points.
static Moves fifteen_player(Player *player) {
    if (player->score + player->roundScore >= MAX_POINTS)
        return HOLD;

    if (player->roundScore < 15)
        return ROLL;
    return HOLD;
}

//Behaves like the fifteen player, except they get nervous when they are close to wining.
static Moves nervous_player(Player *player) {
    if (player->score + player->roundScore >= MAX_POINTS)
        return HOLD;

    float scorePercent = (float)(1 / MAX_POINTS) * (float)(player->score + player->roundScore);

    //If the player's score is more than 75% of the total score there is a chance they will hold with less points.
    if (scorePercent >= 0.75 && player->roundScore > 6) {
        int num = randrange(0, 9);

        if (num < 5)
            return ROLL;
        return HOLD;
    }

    if (player->roundScore < 15)
        return ROLL;
    return HOLD;
}

/*
    Game functions.
*/
//Given a player it plays as long as the decider function allows it.
static void play(Player *player) {
    while (1) {
        if (player->dFunction(player) == ROLL) {
            int roll = randrange(1, 6);

            if (roll > 1) {
                player->roundScore += roll;
                fprintf(stdout, "Player rolls a %d - Round score: %d\n", roll, player->roundScore);
            }
            else {
                //If the player rolls a 1 they loose all their points.
                player->score = 0;
                player->roundScore = 0;

                fprintf(stdout, "Player rolls a 1, they loose all their points\n");

                break;
            }
        }
        else {
            player->score += player->roundScore;
            player->roundScore = 0;

            fprintf(stdout, "Player holds\n");

            break;
        }
    }
    fprintf(stdout, "Current score: %d\n", player->score);
}

static void game_controller(Player *players[]) {
    int playFlag = 1;
    while (playFlag) {
        for (int i = 0; i < PLAYER_COUNT; i++) {
            fprintf(stdout, "\nPlayer %d turn\n", i + 1);
            play(players[i]);

            //Check whether the given player has won, if so end the game and display total scores.
            if (players[i]->score >= MAX_POINTS) {
                fprintf(stdout, "\n\nPlayer %d has won", i + 1);

                puts("\n\nThe overall scores were:");
                for (int j = 0; j < PLAYER_COUNT; j++)
                    fprintf(stdout, "Player %d: %d points\n", j + 1, players[j]->score);
                puts("");

                playFlag = 0;
                break;
            }
        }
    }
}


int main () {
    //Seed the random number generator with the current system time.
    srand(time(0));

    Player *players[PLAYER_COUNT];
    players[0] = create_player(random_player);
    players[1] = create_player(quarter_player);
    players[2] = create_player(fifteen_player);
    players[3] = create_player(nervous_player);

    game_controller(players);

    for (int i = 0; i < PLAYER_COUNT; i++)
        free(players[i]);

    return 0;
}
`,`#include "pig-the-dice-game-player.h"



undefined8 entry(void)

{
  time_t tVar1;
  int local_40;
  undefined8 local_38 [4];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  local_38[0] = FUN_100003854(FUN_10000389c);
  local_38[1] = FUN_100003854(FUN_10000393c);
  local_38[2] = FUN_100003854(FUN_1000039cc);
  local_38[3] = FUN_100003854(FUN_100003a3c);
  FUN_100003b48(local_38);
  for (local_40 = 0; local_40 < 4; local_40 = local_40 + 1) {
    _free((void *)local_38[local_40]);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



undefined4 * FUN_100003854(undefined8 param_1)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_malloc(0x10);
  *puVar1 = 0;
  puVar1[1] = 0;
  *(undefined8 *)(puVar1 + 2) = param_1;
  return puVar1;
}



undefined4 FUN_10000389c(int *param_1)

{
  int iVar1;
  undefined4 local_14;
  
  if ((uint)(*param_1 + param_1[1]) < 100) {
    iVar1 = FUN_100003cd4(0,9);
    if ((iVar1 < 5) || (param_1[1] == 0)) {
      local_14 = 0;
    }
    else {
      local_14 = 1;
    }
  }
  else {
    local_14 = 1;
  }
  return local_14;
}



undefined4 FUN_10000393c(int *param_1)

{
  undefined4 local_4;
  
  if ((uint)(*param_1 + param_1[1]) < 100) {
    if ((uint)param_1[1] < (100U - *param_1) / 4) {
      local_4 = 0;
    }
    else {
      local_4 = 1;
    }
  }
  else {
    local_4 = 1;
  }
  return local_4;
}



undefined4 FUN_1000039cc(int *param_1)

{
  undefined4 local_4;
  
  if ((uint)(*param_1 + param_1[1]) < 100) {
    if ((uint)param_1[1] < 0xf) {
      local_4 = 0;
    }
    else {
      local_4 = 1;
    }
  }
  else {
    local_4 = 1;
  }
  return local_4;
}



undefined4 FUN_100003a3c(int *param_1)

{
  int iVar1;
  undefined4 local_14;
  
  if ((uint)(*param_1 + param_1[1]) < 100) {
    if (((float)(uint)(*param_1 + param_1[1]) * 0.0 < 0.75) || ((uint)param_1[1] < 7)) {
      if ((uint)param_1[1] < 0xf) {
        local_14 = 0;
      }
      else {
        local_14 = 1;
      }
    }
    else {
      iVar1 = FUN_100003cd4(0,9);
      if (iVar1 < 5) {
        local_14 = 0;
      }
      else {
        local_14 = 1;
      }
    }
  }
  else {
    local_14 = 1;
  }
  return local_14;
}



ulong FUN_100003b48(ulong param_1)

{
  bool bVar1;
  uint uVar2;
  ulong uVar3;
  int local_24;
  int local_20;
  
  bVar1 = true;
  uVar3 = param_1;
LAB_100003b64:
  do {
    if (!bVar1) {
      return uVar3;
    }
    local_20 = 0;
    while( true ) {
      if (3 < local_20) goto LAB_100003b64;
      _fprintf(*(FILE **)PTR____stdoutp_100004010,"\nPlayer %d turn\n");
      uVar3 = FUN_100003d1c(*(undefined8 *)(param_1 + (long)local_20 * 8));
      if (99 < **(uint **)(param_1 + (long)local_20 * 8)) break;
      local_20 = local_20 + 1;
    }
    _fprintf(*(FILE **)PTR____stdoutp_100004010,"\n\nPlayer %d has won");
    _puts("\n\nThe overall scores were:");
    for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
      _fprintf(*(FILE **)PTR____stdoutp_100004010,"Player %d: %d points\n");
    }
    uVar2 = _puts("");
    uVar3 = (ulong)uVar2;
    bVar1 = false;
  } while( true );
}



int FUN_100003cd4(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = _rand();
  iVar1 = (param_2 - param_1) + 1;
  iVar2 = 0;
  if (iVar1 != 0) {
    iVar2 = iVar3 / iVar1;
  }
  return (iVar3 - iVar2 * iVar1) + param_1;
}



int FUN_100003d1c(int *param_1)

{
  int iVar1;
  
  do {
    iVar1 = (**(code **)(param_1 + 2))(param_1);
    if (iVar1 != 0) {
      *param_1 = *param_1 + param_1[1];
      param_1[1] = 0;
      _fprintf(*(FILE **)PTR____stdoutp_100004010,"Player holds\n");
LAB_100003e34:
      iVar1 = _fprintf(*(FILE **)PTR____stdoutp_100004010,"Current score: %d\n");
      return iVar1;
    }
    iVar1 = FUN_100003cd4(1,6);
    if (iVar1 < 2) {
      *param_1 = 0;
      param_1[1] = 0;
      _fprintf(*(FILE **)PTR____stdoutp_100004010,"Player rolls a 1, they loose all their points\n")
      ;
      goto LAB_100003e34;
    }
    param_1[1] = param_1[1] + iVar1;
    _fprintf(*(FILE **)PTR____stdoutp_100004010,"Player rolls a %d - Round score: %d\n");
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004038)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004040)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004048)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define SIDE 600
#define NUM_PARTICLES 10000

bool W[SIDE][SIDE];

int main() {
    srand((unsigned)time(NULL));
    W[SIDE / 2][SIDE / 2] = true;

    for (int i = 0; i < NUM_PARTICLES; i++) {
        unsigned int x, y;
        OVER: do {
            x = rand() % (SIDE - 2) + 1;
            y = rand() % (SIDE - 2) + 1;
        } while (W[y][x]);

        while (W[y-1][x-1] + W[y-1][x] + W[y-1][x+1] +
               W[y][x-1]               + W[y][x+1] +
               W[y+1][x-1] + W[y+1][x] + W[y+1][x+1] == 0) {
            unsigned int dxy = rand() % 8;
            if (dxy > 3) dxy++;
            x += (dxy % 3) - 1;
            y += (dxy / 3) - 1;
            if (x < 1 || x >= SIDE - 1 || y < 1 || y >= SIDE - 1)
                goto OVER;
        }

        W[y][x] = true;
    }

    printf("P1\n%d %d\n", SIDE, SIDE);
    for (int r = 0; r < SIDE; r++) {
        for (int c = 0; c < SIDE; c++)
            printf("%d ", W[r][c]);
        putchar('\n');
    }
    return 0;
}
`,`#include "brownian-tree-2.h"



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  int local_2c;
  int local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  int local_18;
  
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  DAT_10003404c = 1;
  local_18 = 0;
LAB_100003b70:
  if (9999 < local_18) {
    _printf("P1\n%d %d\n");
    for (local_28 = 0; local_28 < 600; local_28 = local_28 + 1) {
      for (local_2c = 0; local_2c < 600; local_2c = local_2c + 1) {
        _printf("%d ");
      }
      _putchar(10);
    }
    return 0;
  }
  do {
    do {
      iVar1 = _rand();
      local_1c = iVar1 % 0x256 + 1;
      iVar1 = _rand();
      local_20 = iVar1 % 0x256 + 1;
    } while (((&_W)[(ulong)local_1c + (ulong)local_20 * 600] & 1) != 0);
    do {
      if ((byte)(((&_W)[(ulong)(local_1c - 1) + (ulong)(local_20 - 1) * 600] & 1) +
                 ((&_W)[(ulong)local_1c + (ulong)(local_20 - 1) * 600] & 1) +
                 ((&_W)[(ulong)(local_1c + 1) + (ulong)(local_20 - 1) * 600] & 1) +
                 ((&_W)[(ulong)(local_1c - 1) + (ulong)local_20 * 600] & 1) +
                 ((&_W)[(ulong)(local_1c + 1) + (ulong)local_20 * 600] & 1) +
                 ((&_W)[(ulong)(local_1c - 1) + (ulong)(local_20 + 1) * 600] & 1) +
                 ((&_W)[(ulong)local_1c + (ulong)(local_20 + 1) * 600] & 1) +
                ((&_W)[(ulong)(local_1c + 1) + (ulong)(local_20 + 1) * 600] & 1)) != '\0') {
        (&_W)[(ulong)local_1c + (ulong)local_20 * 600] = 1;
        local_18 = local_18 + 1;
        goto LAB_100003b70;
      }
      iVar1 = _rand();
      local_24 = iVar1 % 8;
      if (3 < local_24) {
        local_24 = local_24 + 1;
      }
      local_1c = local_1c + (local_24 % 3 - 1);
      local_20 = local_20 + (local_24 / 3 - 1);
    } while ((((local_1c != 0) && (local_1c < 599)) && (local_20 != 0)) && (local_20 < 599));
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004010)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004020)();
  return tVar1;
}


`
`#include <stdio.h>

int i;

#define sum(i, lo_byname, hi_byname, term)      \
  ({                                            \
  int lo = lo_byname;                           \
  int hi = hi_byname;                           \
                                                \
  double temp = 0;                              \
  for (i = lo; i <= hi; ++i)                    \
    temp += term;                               \
  temp;                                         \
  })

int main () {
    printf("%f\n", sum(i, 1, 100, 1.0 / i));
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f98(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ec4 - 0x100003f98
int64_t entry_point(void) {
    // 0x100003ec4
    *(int32_t *)&g1 = 1;
    int128_t v1 = __asm_sshll(0.0f, 0); // 0x100003f30
    int32_t v2 = *(int32_t *)&g1; // 0x100003f58
    int32_t v3 = v2 + 1; // 0x100003f5c
    *(int32_t *)&g1 = v3;
    while (v2 == 99 || v2 < 99 != (98 - v2 & v3) < 0) {
        // 0x100003f20
        v1 = __asm_sshll(0.0f, 0);
        v2 = *(int32_t *)&g1;
        v3 = v2 + 1;
        *(int32_t *)&g1 = v3;
    }
    // 0x100003f68
    _printf("%f\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`// From manpage for "getline"

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	FILE *stream;
	char *line = NULL;
	size_t len = 0;
	ssize_t read;

	stream = fopen("file.txt", "r");
	if (stream == NULL)
		exit(EXIT_FAILURE);

	while ((read = getline(&line, &len, stream)) != -1) {
		printf("Retrieved line of length %u :\n", read);
		printf("%s", line);
	}

	free(line);
	fclose(stream);
	exit(EXIT_SUCCESS);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
void function_100003f30(int32_t status);
int32_t function_100003f3c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f48(char * filename, char * modes);
void function_100003f54(int64_t * ptr);
int32_t function_100003f60(char ** lineptr, int32_t * n, struct _IO_FILE * stream);
int32_t function_100003f6c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _getline(char ** a1, int32_t * a2, struct _IO_FILE * a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e70 - 0x100003f30
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-40, 0x100003e80
    int64_t v2 = 0; // bp-48, 0x100003e84
    struct _IO_FILE * v3 = _fopen("file.txt", "r"); // 0x100003e98
    if (v3 == NULL) {
        // 0x100003eb4
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003ec0
    if (_getline((char **)&v1, (int32_t *)&v2, v3) == -1) {
        // 0x100003f18
        _free((int64_t *)v1);
        _fclose(v3);
        return 0;
    }
    _printf("Retrieved line of length %u :\n", (int32_t)(int64_t)&v2);
    _printf("%s", &v2);
    // 0x100003ee4
    while (_getline((char **)&v1, (int32_t *)&v2, v3) != -1) {
        // 0x100003ee4
        _printf("Retrieved line of length %u :\n", (int32_t)(int64_t)&v2);
        _printf("%s", &v2);
    }
    // 0x100003f18
    _free((int64_t *)v1);
    _fclose(v3);
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
void function_100003f30(int32_t status) {
    // 0x100003f30
    _exit(status);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(struct _IO_FILE * stream) {
    // 0x100003f3c
    return _fclose(stream);
}

// Address range: 0x100003f48 - 0x100003f54
struct _IO_FILE * function_100003f48(char * filename, char * modes) {
    // 0x100003f48
    return _fopen(filename, modes);
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * ptr) {
    // 0x100003f54
    _free(ptr);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char ** lineptr, int32_t * n, struct _IO_FILE * stream) {
    // 0x100003f60
    return _getline(lineptr, n, stream);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#define MAX_BUF 50

int main(void)
{
  char buf[MAX_BUF];
  time_t seconds = time(NULL);
  struct tm *now = localtime(&seconds);
  const char *months[] = {"January", "February", "March", "April", "May", "June",
                          "July", "August", "September", "October", "November", "December"};

  const char *days[] = {"Sunday", "Monday", "Tuesday", "Wednesday","Thursday","Friday","Saturday"};

  (void) printf("%d-%d-%d\n", now->tm_year + 1900, now->tm_mon + 1, now->tm_mday);
  (void) printf("%s, %s %d, %d\n",days[now->tm_wday], months[now->tm_mon],
               now->tm_mday, now->tm_year + 1900);
  /* using the strftime (the result depends on the locale) */
  (void) strftime(buf, MAX_BUF, "%A, %B %e, %Y", now);
  (void) printf("%s\n", buf);
  return EXIT_SUCCESS;
}
`,`#include "date-format.h"



undefined8 entry(void)

{
  int iVar1;
  tm *ptVar2;
  time_t local_108;
  undefined4 local_fc;
  undefined auStack_f8 [56];
  undefined auStack_c0 [102];
  char acStack_5a [50];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_fc = 0;
  local_108 = _time((time_t *)0x0);
  ptVar2 = _localtime(&local_108);
  _memcpy(auStack_c0,&PTR_s_January_100004038,0x60);
  _memcpy(auStack_f8,&PTR_s_Sunday_100004098,0x38);
  _printf("%d-%d-%d\n");
  _printf("%s, %s %d, %d\n");
  _strftime(acStack_5a,0x32,"%A, %B %e, %Y",ptVar2);
  iVar1 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * _localtime(time_t *param_1)

{
  tm *ptVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  ptVar1 = (tm *)(*(code *)PTR__localtime_100004010)();
  return ptVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strftime(char *param_1,size_t param_2,char *param_3,tm *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strftime_100004028)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004030)();
  return tVar1;
}


`
`#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>

#define MAX_BRIGHTNESS 255

// C99 doesn't define M_PI (GNU-C99 does)
#define M_PI 3.14159265358979323846264338327

/*
 * Loading part taken from
 * http://www.vbforums.com/showthread.php?t=261522
 * BMP info:
 * http://en.wikipedia.org/wiki/BMP_file_format
 *
 * Note: the magic number has been removed from the bmpfile_header_t
 * structure since it causes alignment problems
 *     bmpfile_magic_t should be written/read first
 * followed by the
 *     bmpfile_header_t
 * [this avoids compiler-specific alignment pragmas etc.]
 */

typedef struct {
    uint8_t magic[2];
} bmpfile_magic_t;

typedef struct {
    uint32_t filesz;
    uint16_t creator1;
    uint16_t creator2;
    uint32_t bmp_offset;
} bmpfile_header_t;

typedef struct {
    uint32_t header_sz;
    int32_t  width;
    int32_t  height;
    uint16_t nplanes;
    uint16_t bitspp;
    uint32_t compress_type;
    uint32_t bmp_bytesz;
    int32_t  hres;
    int32_t  vres;
    uint32_t ncolors;
    uint32_t nimpcolors;
} bitmap_info_header_t;

typedef struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t nothing;
} rgb_t;

// Use short int instead unsigned char' so that we can
// store negative values.
typedef short int pixel_t;

pixel_t *load_bmp(const char *filename,
                  bitmap_info_header_t *bitmapInfoHeader)
{
    FILE *filePtr = fopen(filename, "rb");
    if (filePtr == NULL) {
        perror("fopen()");
        return NULL;
    }

    bmpfile_magic_t mag;
    if (fread(&mag, sizeof(bmpfile_magic_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return NULL;
    }

    // verify that this is a bmp file by check bitmap id
    // warning: dereferencing type-punned pointer will break
    // strict-aliasing rules [-Wstrict-aliasing]
    if (*((uint16_t*)mag.magic) != 0x4D42) {
        fprintf(stderr, "Not a BMP file: magic=%c%c\n",
                mag.magic[0], mag.magic[1]);
        fclose(filePtr);
        return NULL;
    }

    bmpfile_header_t bitmapFileHeader; // our bitmap file header
    // read the bitmap file header
    if (fread(&bitmapFileHeader, sizeof(bmpfile_header_t),
              1, filePtr) != 1) {
        fclose(filePtr);
        return NULL;
    }

    // read the bitmap info header
    if (fread(bitmapInfoHeader, sizeof(bitmap_info_header_t),
              1, filePtr) != 1) {
        fclose(filePtr);
        return NULL;
    }

    if (bitmapInfoHeader->compress_type != 0)
        fprintf(stderr, "Warning, compression is not supported.\n");

    // move file point to the beginning of bitmap data
    if (fseek(filePtr, bitmapFileHeader.bmp_offset, SEEK_SET)) {
        fclose(filePtr);
        return NULL;
    }

    // allocate enough memory for the bitmap image data
    pixel_t *bitmapImage = malloc(bitmapInfoHeader->bmp_bytesz *
                                  sizeof(pixel_t));

    // verify memory allocation
    if (bitmapImage == NULL) {
        fclose(filePtr);
        return NULL;
    }

    // read in the bitmap image data
    size_t pad, count=0;
    unsigned char c;
    pad = 4*ceil(bitmapInfoHeader->bitspp*bitmapInfoHeader->width/32.) - bitmapInfoHeader->width;
    for(size_t i=0; i<bitmapInfoHeader->height; i++){
	    for(size_t j=0; j<bitmapInfoHeader->width; j++){
		    if (fread(&c, sizeof(unsigned char), 1, filePtr) != 1) {
			    fclose(filePtr);
			    return NULL;
		    }
		    bitmapImage[count++] = (pixel_t) c;
	    }
	    fseek(filePtr, pad, SEEK_CUR);
    }

    // If we were using unsigned char as pixel_t, then:
    // fread(bitmapImage, 1, bitmapInfoHeader->bmp_bytesz, filePtr);

    // close file and return bitmap image data
    fclose(filePtr);
    return bitmapImage;
}

// Return: true on error.
bool save_bmp(const char *filename, const bitmap_info_header_t *bmp_ih,
              const pixel_t *data)
{
    FILE* filePtr = fopen(filename, "wb");
    if (filePtr == NULL)
        return true;

    bmpfile_magic_t mag = {{0x42, 0x4d}};
    if (fwrite(&mag, sizeof(bmpfile_magic_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return true;
    }

    const uint32_t offset = sizeof(bmpfile_magic_t) +
                            sizeof(bmpfile_header_t) +
                            sizeof(bitmap_info_header_t) +
                            ((1U << bmp_ih->bitspp) * 4);

    const bmpfile_header_t bmp_fh = {
        .filesz = offset + bmp_ih->bmp_bytesz,
        .creator1 = 0,
        .creator2 = 0,
        .bmp_offset = offset
    };

    if (fwrite(&bmp_fh, sizeof(bmpfile_header_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return true;
    }
    if (fwrite(bmp_ih, sizeof(bitmap_info_header_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return true;
    }

    // Palette
    for (size_t i = 0; i < (1U << bmp_ih->bitspp); i++) {
        const rgb_t color = {(uint8_t)i, (uint8_t)i, (uint8_t)i};
        if (fwrite(&color, sizeof(rgb_t), 1, filePtr) != 1) {
            fclose(filePtr);
            return true;
        }
    }

    // We use int instead of uchar, so we can't write img
    // in 1 call any more.
    // fwrite(data, 1, bmp_ih->bmp_bytesz, filePtr);

    // Padding: http://en.wikipedia.org/wiki/BMP_file_format#Pixel_storage
    size_t pad = 4*ceil(bmp_ih->bitspp*bmp_ih->width/32.) - bmp_ih->width;
    unsigned char c;
    for(size_t i=0; i < bmp_ih->height; i++) {
	    for(size_t j=0; j < bmp_ih->width; j++) {
		    c = (unsigned char) data[j + bmp_ih->width*i];
		    if (fwrite(&c, sizeof(char), 1, filePtr) != 1) {
			    fclose(filePtr);
			    return true;
		    }
	    }
	    c = 0;
	    for(size_t j=0; j<pad; j++)
		    if (fwrite(&c, sizeof(char), 1, filePtr) != 1) {
			    fclose(filePtr);
			    return true;
		    }
    }

    fclose(filePtr);
    return false;
}

// if normalize is true, map pixels to range 0..MAX_BRIGHTNESS
void convolution(const pixel_t *in, pixel_t *out, const float *kernel,
                 const int nx, const int ny, const int kn,
                 const bool normalize)
{
    assert(kn % 2 == 1);
    assert(nx > kn && ny > kn);
    const int khalf = kn / 2;
    float min = FLT_MAX, max = -FLT_MAX;

    if (normalize)
        for (int m = khalf; m < nx - khalf; m++)
            for (int n = khalf; n < ny - khalf; n++) {
                float pixel = 0.0;
                size_t c = 0;
                for (int j = -khalf; j <= khalf; j++)
                    for (int i = -khalf; i <= khalf; i++) {
                        pixel += in[(n - j) * nx + m - i] * kernel[c];
                        c++;
                    }
                if (pixel < min)
                    min = pixel;
                if (pixel > max)
                    max = pixel;
                }

    for (int m = khalf; m < nx - khalf; m++)
        for (int n = khalf; n < ny - khalf; n++) {
            float pixel = 0.0;
            size_t c = 0;
            for (int j = -khalf; j <= khalf; j++)
                for (int i = -khalf; i <= khalf; i++) {
                    pixel += in[(n - j) * nx + m - i] * kernel[c];
                    c++;
                }

            if (normalize)
                pixel = MAX_BRIGHTNESS * (pixel - min) / (max - min);
            out[n * nx + m] = (pixel_t)pixel;
        }
}

/*
 * gaussianFilter:
 * http://www.songho.ca/dsp/cannyedge/cannyedge.html
 * determine size of kernel (odd #)
 * 0.0 <= sigma < 0.5 : 3
 * 0.5 <= sigma < 1.0 : 5
 * 1.0 <= sigma < 1.5 : 7
 * 1.5 <= sigma < 2.0 : 9
 * 2.0 <= sigma < 2.5 : 11
 * 2.5 <= sigma < 3.0 : 13 ...
 * kernelSize = 2 * int(2*sigma) + 3;
 */
void gaussian_filter(const pixel_t *in, pixel_t *out,
                     const int nx, const int ny, const float sigma)
{
    const int n = 2 * (int)(2 * sigma) + 3;
    const float mean = (float)floor(n / 2.0);
    float kernel[n * n]; // variable length array

    fprintf(stderr, "gaussian_filter: kernel size %d, sigma=%g\n",
            n, sigma);
    size_t c = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            kernel[c] = exp(-0.5 * (pow((i - mean) / sigma, 2.0) +
                                    pow((j - mean) / sigma, 2.0)))
                        / (2 * M_PI * sigma * sigma);
            c++;
        }

    convolution(in, out, kernel, nx, ny, n, true);
}

/*
 * Links:
 * http://en.wikipedia.org/wiki/Canny_edge_detector
 * http://www.tomgibara.com/computer-vision/CannyEdgeDetector.java
 * http://fourier.eng.hmc.edu/e161/lectures/canny/node1.html
 * http://www.songho.ca/dsp/cannyedge/cannyedge.html
 *
 * Note: T1 and T2 are lower and upper thresholds.
 */
pixel_t *canny_edge_detection(const pixel_t *in,
                              const bitmap_info_header_t *bmp_ih,
                              const int tmin, const int tmax,
                              const float sigma)
{
    const int nx = bmp_ih->width;
    const int ny = bmp_ih->height;

    pixel_t *G = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *after_Gx = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *after_Gy = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *nms = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *out = malloc(bmp_ih->bmp_bytesz * sizeof(pixel_t));

    if (G == NULL || after_Gx == NULL || after_Gy == NULL ||
        nms == NULL || out == NULL) {
        fprintf(stderr, "canny_edge_detection:"
                " Failed memory allocation(s).\n");
        exit(1);
    }

    gaussian_filter(in, out, nx, ny, sigma);

    const float Gx[] = {-1, 0, 1,
                        -2, 0, 2,
                        -1, 0, 1};

    convolution(out, after_Gx, Gx, nx, ny, 3, false);

    const float Gy[] = { 1, 2, 1,
                         0, 0, 0,
                        -1,-2,-1};

    convolution(out, after_Gy, Gy, nx, ny, 3, false);

    for (int i = 1; i < nx - 1; i++)
        for (int j = 1; j < ny - 1; j++) {
            const int c = i + nx * j;
            // G[c] = abs(after_Gx[c]) + abs(after_Gy[c]);
            G[c] = (pixel_t)hypot(after_Gx[c], after_Gy[c]);
        }

    // Non-maximum suppression, straightforward implementation.
    for (int i = 1; i < nx - 1; i++)
        for (int j = 1; j < ny - 1; j++) {
            const int c = i + nx * j;
            const int nn = c - nx;
            const int ss = c + nx;
            const int ww = c + 1;
            const int ee = c - 1;
            const int nw = nn + 1;
            const int ne = nn - 1;
            const int sw = ss + 1;
            const int se = ss - 1;

            const float dir = (float)(fmod(atan2(after_Gy[c],
                                                 after_Gx[c]) + M_PI,
                                           M_PI) / M_PI) * 8;

            if (((dir <= 1 || dir > 7) && G[c] > G[ee] &&
                 G[c] > G[ww]) || // 0 deg
                ((dir > 1 && dir <= 3) && G[c] > G[nw] &&
                 G[c] > G[se]) || // 45 deg
                ((dir > 3 && dir <= 5) && G[c] > G[nn] &&
                 G[c] > G[ss]) || // 90 deg
                ((dir > 5 && dir <= 7) && G[c] > G[ne] &&
                 G[c] > G[sw]))   // 135 deg
                nms[c] = G[c];
            else
                nms[c] = 0;
        }

    // Reuse array
    // used as a stack. nx*ny/2 elements should be enough.
    int *edges = (int*) after_Gy;
    memset(out, 0, sizeof(pixel_t) * nx * ny);
    memset(edges, 0, sizeof(pixel_t) * nx * ny);

    // Tracing edges with hysteresis . Non-recursive implementation.
    size_t c = 1;
    for (int j = 1; j < ny - 1; j++)
        for (int i = 1; i < nx - 1; i++) {
            if (nms[c] >= tmax && out[c] == 0) { // trace edges
                out[c] = MAX_BRIGHTNESS;
                int nedges = 1;
                edges[0] = c;

                do {
                    nedges--;
                    const int t = edges[nedges];

                    int nbs[8]; // neighbours
                    nbs[0] = t - nx;     // nn
                    nbs[1] = t + nx;     // ss
                    nbs[2] = t + 1;      // ww
                    nbs[3] = t - 1;      // ee
                    nbs[4] = nbs[0] + 1; // nw
                    nbs[5] = nbs[0] - 1; // ne
                    nbs[6] = nbs[1] + 1; // sw
                    nbs[7] = nbs[1] - 1; // se

                    for (int k = 0; k < 8; k++)
                        if (nms[nbs[k]] >= tmin && out[nbs[k]] == 0) {
                            out[nbs[k]] = MAX_BRIGHTNESS;
                            edges[nedges] = nbs[k];
                            nedges++;
                        }
                } while (nedges > 0);
            }
            c++;
        }

    free(after_Gx);
    free(after_Gy);
    free(G);
    free(nms);

    return out;
}

int main(const int argc, const char ** const argv)
{
    if (argc < 2) {
        printf("Usage: %s image.bmp\n", argv[0]);
        return 1;
    }

    static bitmap_info_header_t ih;
    const pixel_t *in_bitmap_data = load_bmp(argv[1], &ih);
    if (in_bitmap_data == NULL) {
        fprintf(stderr, "main: BMP image not loaded.\n");
        return 1;
    }

    printf("Info: %d x %d x %d\n", ih.width, ih.height, ih.bitspp);

    const pixel_t *out_bitmap_data =
        canny_edge_detection(in_bitmap_data, &ih, 45, 50, 1.0f);
    if (out_bitmap_data == NULL) {
        fprintf(stderr, "main: failed canny_edge_detection.\n");
        return 1;
    }

    if (save_bmp("out.bmp", &ih, out_bitmap_data)) {
        fprintf(stderr, "main: BMP image not saved.\n");
        return 1;
    }

    free((pixel_t*)in_bitmap_data);
    free((pixel_t*)out_bitmap_data);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002310(void);
int64_t function_100002638(void);
int64_t function_100002a0c(void);
int64_t function_100002ec4(void);
int64_t function_100002f6c(void);
int64_t function_100003138(void);
int64_t function_100003d04(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003d10(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003d1c(int64_t a1);
float64_t function_100003d28(float64_t a1, float64_t a2);
int64_t * function_100003d34(int32_t nmemb, int32_t size);
void function_100003d40(int32_t status);
float64_t function_100003d4c(float64_t a1);
int32_t function_100003d58(struct _IO_FILE * stream);
float64_t function_100003d64(float64_t a1, float64_t a2);
struct _IO_FILE * function_100003d70(char * filename, char * modes);
int32_t function_100003d7c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003d88(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003d94(int64_t * ptr);
int32_t function_100003da0(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003dac(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
float64_t function_100003db8(float64_t a1, float64_t a2);
int64_t * function_100003dc4(int32_t size);
int64_t * function_100003dd0(int64_t * s, int32_t c, int32_t n);
void function_100003ddc(char * s);
float64_t function_100003de8(float64_t a1, float64_t a2);
int32_t function_100003df4(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 32.0; // 0x100003e00
float64_t g2 = 6.2831853071795862; // 0x100003e08
float64_t g3 = 3.1415926535897931; // 0x100003e10
int64_t g4 = 0; // 0x100008000
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(void);
int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
float64_t _atan2(float64_t a1, float64_t a2);
int64_t * _calloc(int32_t a1, int32_t a2);
float64_t _exp(float64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
float64_t _fmod(float64_t a1, float64_t a2);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
float64_t _hypot(float64_t a1, float64_t a2);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100002310 - 0x100002638
int64_t function_100002310(void) {
    // 0x100002310
    int64_t v1; // 0x100002310
    struct _IO_FILE * v2 = _fopen((char *)v1, "rb"); // 0x100002330
    if (v2 == NULL) {
        // 0x10000234c
        _perror("fopen()");
        // 0x100002628
        return 0;
    }
    // 0x100002360
    int64_t v3; // bp-50, 0x100002310
    if (_fread(&v3, 2, 1, v2) != 1) {
        // 0x100002384
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    // 0x100002394
    if (v3 % 0x10000 != 0x4d42) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004028; // 0x1000023b4
        _fprintf((struct _IO_FILE *)v4, "Not a BMP file: magic=%c%c\n", 1, (char)(int64_t)v2);
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    // 0x1000023f0
    int64_t v5; // bp-64, 0x100002310
    if (_fread(&v5, 12, 1, v2) != 1 || _fread((int64_t *)v1, 40, 1, v2) != 1) {
        // 0x100002414
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    // 0x100002458
    if (*(int32_t *)(v1 + 16) != 0) {
        int64_t v6 = *(int64_t *)*(int64_t *)0x100004028; // 0x100002478
        _fprintf((struct _IO_FILE *)v6, "Warning, compression is not supported.\n");
    }
    // 0x10000248c
    int32_t v7; // 0x100002310
    if (_fseek(v2, v7, 0) != 0) {
        // 0x1000024b0
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    int64_t * v8 = _malloc(2 * *(int32_t *)(v1 + 20)); // 0x1000024cc
    if (v8 == NULL) {
        // 0x1000024e8
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    int64_t v9 = (int64_t)v8; // 0x1000024cc
    int32_t * v10 = (int32_t *)(v1 + 4); // 0x100002508
    float64_t v11 = (float64_t)(*v10 * (int32_t)*(int16_t *)(v1 + 14)) / g1; // 0x10000251c
    float64_t v12 = __asm_frintp(v11); // 0x100002520
    __asm_sshll(0.0f, 0);
    int32_t * v13 = (int32_t *)(v1 + 8); // 0x100002558
    int64_t v14 = 0; // 0x100002564
    int64_t v15 = 0; // 0x100002564
    int64_t result; // 0x100002310
    if (*v13 != 0) {
        int64_t v16 = v15; // 0x100002588
        int64_t v17; // bp-89, 0x100002310
        int64_t v18; // 0x100002310
        int64_t v19; // 0x1000025d0
        int64_t v20; // 0x1000025e4
        if (*v10 != 0) {
            if (_fread(&v17, 1, 1, v2) != 1) {
                // 0x1000025b4
                _fclose(v2);
                result = 0;
                return result;
            }
            // 0x1000025c4
            v19 = v16 + 1;
            *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
            v20 = 1;
            v18 = v20;
            v16 = v19;
            v15 = v19;
            while (v20 < (int64_t)*v10) {
                // 0x100002590
                if (_fread(&v17, 1, 1, v2) != 1) {
                    // 0x1000025b4
                    _fclose(v2);
                    result = 0;
                    return result;
                }
                // 0x1000025c4
                v19 = v16 + 1;
                *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
                v20 = v18 + 1;
                v18 = v20;
                v16 = v19;
                v15 = v19;
            }
        }
        // 0x1000025f0
        _fseek(v2, (int32_t)(int64_t)-((v11 - 4.0 * v12)), 1);
        v14++;
        while (v14 < (int64_t)*v13) {
            // 0x100002574
            v16 = v15;
            if (*v10 != 0) {
                if (_fread(&v17, 1, 1, v2) != 1) {
                    // 0x1000025b4
                    _fclose(v2);
                    result = 0;
                    return result;
                }
                // 0x1000025c4
                v19 = v16 + 1;
                *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
                v20 = 1;
                v18 = v20;
                v16 = v19;
                v15 = v19;
                while (v20 < (int64_t)*v10) {
                    // 0x100002590
                    if (_fread(&v17, 1, 1, v2) != 1) {
                        // 0x1000025b4
                        _fclose(v2);
                        result = 0;
                        return result;
                    }
                    // 0x1000025c4
                    v19 = v16 + 1;
                    *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
                    v20 = v18 + 1;
                    v18 = v20;
                    v16 = v19;
                    v15 = v19;
                }
            }
            // 0x1000025f0
            _fseek(v2, (int32_t)(int64_t)-((v11 - 4.0 * v12)), 1);
            v14++;
        }
    }
    // 0x100002614
    _fclose(v2);
    result = v9;
  lab_0x100002628:
    // 0x100002628
    return result;
}

// Address range: 0x100002638 - 0x100002a0c
int64_t function_100002638(void) {
    // 0x100002638
    int64_t v1; // 0x100002638
    struct _IO_FILE * v2 = _fopen((char *)v1, "wb"); // 0x10000265c
    if (v2 == NULL) {
        // 0x1000029f8
        return 1;
    }
    int64_t v3 = 0x4d42; // bp-58, 0x10000269c
    if (_fwrite(&v3, 2, 1, v2) != 1) {
        // 0x1000026c0
        _fclose(v2);
        // 0x1000029f8
        return 1;
    }
    int16_t * v4 = (int16_t *)(v1 + 14); // 0x1000026e0
    int32_t v5 = *(int32_t *)(v1 + 20); // 0x100002704
    int64_t v6 = v5 + 54 + (4 << (int32_t)*v4); // bp-76, 0x100002710
    if (_fwrite(&v6, 12, 1, v2) != 1) {
        // 0x100002744
        _fclose(v2);
        // 0x1000029f8
        return 1;
    }
    int32_t v7 = 0; // 0x10000277c
    int64_t result; // 0x100002638
    if (_fwrite((int64_t *)v1, 40, 1, v2) != 1) {
        // 0x100002784
        _fclose(v2);
        result = 1;
      lab_0x1000029f8:
        // 0x1000029f8
        return result;
    }
    int64_t v8 = 0x100000000000000 * (int64_t)v7 >> 56; // bp-92, 0x1000027d8
    int64_t v9; // 0x100002638
    int32_t * v10; // 0x10000284c
    int32_t * v11; // 0x10000289c
    uint64_t v12; // 0x100002884
    while (_fwrite(&v8, 4, 1, v2) == 1) {
        // 0x1000027a8
        v7++;
        uint32_t v13 = (int32_t)*v4; // 0x1000027b0
        if ((int64_t)v7 >= (int64_t)(1 << v13)) {
            // 0x100002840
            v10 = (int32_t *)(v1 + 4);
            float64_t v14 = (float64_t)(*v10 * v13) / g1; // 0x100002860
            float64_t v15 = __asm_frintp(v14); // 0x100002864
            __asm_sshll(0.0f, 0);
            v11 = (int32_t *)(v1 + 8);
            if (*v11 == 0) {
                // 0x1000029dc
                _fclose(v2);
                result = 0;
                return result;
            } else {
                // 0x1000028b8
                v12 = (int64_t)-((v14 - 4.0 * v15));
                v9 = 0;
                goto lab_0x1000028b8_2;
            }
        }
        v8 = 0x100000000000000 * (int64_t)v7 >> 56;
    }
    // 0x100002810
    _fclose(v2);
    // 0x1000029f8
    return 1;
  lab_0x1000028b8_2:;
    int64_t v16 = v9;
    int32_t v17 = *v10; // 0x1000028c0
    int64_t v18; // 0x100002638
    int64_t v19; // 0x100002638
    if (v17 == 0) {
        goto lab_0x100002950;
    } else {
        // 0x1000028d4
        v18 = v17;
        v19 = 0;
        goto lab_0x1000028d4_2;
    }
  lab_0x100002950:;
    int64_t v20 = 0; // bp-105, 0x100002950
    int64_t v21 = 0; // 0x10000296c
    if (v12 == 0) {
        goto lab_0x1000029cc;
    } else {
        goto lab_0x100002974;
    }
  lab_0x1000029cc:;
    int64_t v22 = v16 + 1; // 0x1000029d0
    v9 = v22;
    if (v22 < (int64_t)*v11) {
        goto lab_0x1000028b8_2;
    } else {
        // 0x1000029dc
        _fclose(v2);
        result = 0;
        return result;
    }
  lab_0x100002974:
    // 0x100002974
    if (_fwrite(&v20, 1, 1, v2) == 1) {
        int64_t v23 = v21 + 1; // 0x1000029bc
        v21 = v23;
        if (v23 < v12) {
            goto lab_0x100002974;
        } else {
            goto lab_0x1000029cc;
        }
    } else {
        // 0x100002998
        _fclose(v2);
        result = 1;
        return result;
    }
  lab_0x1000028d4_2:;
    uint16_t v24 = *(int16_t *)(2 * (v18 * v16 + v19) + v1); // 0x1000028f4
    v20 = 0x100000000000000 * (int64_t)v24 >> 56;
    if (_fwrite(&v20, 1, 1, v2) == 1) {
        int64_t v25 = v19 + 1; // 0x100002944
        int64_t v26 = (int64_t)*v10; // 0x1000028c0
        v18 = v26;
        v19 = v25;
        if (v25 < v26) {
            goto lab_0x1000028d4_2;
        } else {
            goto lab_0x100002950;
        }
    } else {
        // 0x100002920
        _fclose(v2);
        result = 1;
        return result;
    }
}

// Address range: 0x100002a0c - 0x100002ec4
int64_t function_100002a0c(void) {
    // 0x100002a0c
    int64_t v1; // 0x100002a0c
    uint64_t v2 = v1;
    int32_t v3 = v1; // 0x100002a2c
    int32_t v4 = v3 / 2; // 0x100002a44
    int64_t v5; // 0x100002a0c
    if (-1 - 2 * v4 != -v3) {
        // 0x100002a6c
        v5 = ___assert_rtn("convolution", "canny-edge-detector.c", 223, "kn % 2 == 1");
    }
    int32_t v6 = v1; // 0x100002a24
    int32_t v7 = v1; // 0x100002a28
    int32_t v8 = v6 - v3; // 0x100002a98
    int64_t result; // 0x100002a0c
    if (v8 == 0 || v8 < 0 != ((v8 ^ v6) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100002ae4
        result = ___assert_rtn("convolution", "canny-edge-detector.c", 224, "nx > kn && ny > kn");
        goto lab_0x100002b08;
    } else {
        int32_t v9 = v7 - v3; // 0x100002ab8
        result = v5;
        if (v9 == 0 || v9 < 0 != ((v9 ^ v7) & (int32_t)(v1 ^ v1)) < 0) {
            // 0x100002ae4
            result = ___assert_rtn("convolution", "canny-edge-detector.c", 224, "nx > kn && ny > kn");
            goto lab_0x100002b08;
        } else {
            goto lab_0x100002b08;
        }
    }
  lab_0x100002b08:;
    float32_t v10 = 3.40282347e+38f; // bp-64, 0x100002b20
    float32_t v11 = -3.40282347e+38f; // 0x100002b28
    float32_t v12 = -3.40282347e+38f; // bp-68, 0x100002b2c
    int32_t v13 = v6 - v4;
    int32_t v14 = v4 - v13;
    int32_t v15 = (v14 ^ v4) & (v13 ^ v4);
    float32_t v16; // 0x100002a0c
    if (v2 % 2 != 0) {
        if (v14 < 0 != v15 < 0) {
            int32_t v17 = v7 - v4; // 0x100002b80
            int32_t v18 = v4 - v17; // 0x100002b84
            int32_t v19 = -v4;
            int32_t v20 = v19 - v4;
            float32_t v21 = -3.40282347e+38f;
            float32_t v22 = 3.40282347e+38f;
            int32_t v23 = -0x800001;
            int32_t v24 = v4; // 0x100002ce0
            float32_t v25 = v21; // 0x100002b8c
            float32_t v26 = v22; // 0x100002b8c
            int32_t v27 = v23; // 0x100002b8c
            float32_t v28; // 0x100002a0c
            float32_t v29 = v28; // 0x100002b8c
            float32_t v30 = v21; // 0x100002b8c
            float32_t v31 = v22; // 0x100002b8c
            int32_t v32 = v23; // 0x100002b8c
            float32_t v33 = v28; // 0x100002b8c
            float32_t v34; // 0x100002a0c
            float32_t v35; // 0x100002a0c
            int32_t v36; // 0x100002a0c
            float32_t v37; // 0x100002a0c
            float32_t v38; // 0x100002a0c
            float32_t v39; // 0x100002a0c
            int32_t v40; // 0x100002a0c
            float32_t v41; // 0x100002ca4
            int32_t v42; // 0x100002a0c
            float32_t v43; // 0x100002ca0
            float32_t v44; // 0x100002a0c
            float32_t v45; // 0x100002a0c
            int64_t v46; // 0x100002a0c
            int32_t v47; // 0x100002a0c
            int32_t v48; // 0x100002a0c
            float32_t v49; // 0x100002c38
            float32_t v50; // 0x100002c40
            int64_t v51; // 0x100002c4c
            int32_t v52; // 0x100002c5c
            int32_t v53; // 0x100002be8
            int32_t v54; // 0x100002c70
            int32_t v55; // 0x100002bbc
            int32_t v56; // 0x100002ccc
            int32_t v57; // 0x100002b84
            if (v18 < 0 != ((v18 ^ v4) & (v17 ^ v4)) < 0) {
                v41 = v25;
                v34 = v27;
                v44 = v29;
                v36 = v27;
                v37 = v27;
                if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                    v52 = v19;
                    v46 = 0;
                    __asm_sshll_5(0, 0);
                    v49 = *(float32_t *)(4 * v46 + v1);
                    v50 = v34 + v44 * v49;
                    v51 = v46 + 1;
                    v52++;
                    v53 = v52 - v4;
                    v35 = v50;
                    v45 = v49;
                    v46 = v51;
                    while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                        // 0x100002bf8
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v46 + v1);
                        v50 = v35 + v45 * v49;
                        v51 = v46 + 1;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                    }
                    // 0x100002c6c
                    v54 = v19 + 1;
                    v55 = v54 - v4;
                    v47 = v54;
                    while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                        // 0x100002bf8
                        v52 = v19;
                        v45 = v49;
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v51 + v1);
                        v50 += v45 * v49;
                        v51++;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                        while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                            // 0x100002bf8
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v35 + v45 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                        }
                        // 0x100002c6c
                        v54 = v47 + 1;
                        v55 = v54 - v4;
                        v47 = v54;
                    }
                    // 0x100002c7c
                    v36 = v50;
                    v37 = v50;
                }
                // 0x100002c7c
                v43 = v37;
                v42 = v36;
                v38 = v26;
                if (v43 > v26) {
                    // 0x100002c94
                    v10 = v42;
                    v38 = v42;
                }
                // 0x100002ca0
                v11 = v43;
                v39 = v41;
                v40 = v43;
                if (v43 != v41) {
                    v39 = v41;
                    v40 = v43;
                    if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                        // 0x100002cb8
                        v11 = v42;
                        v12 = v42;
                        v39 = v42;
                        v40 = v42;
                    }
                }
                // 0x100002cc8
                v56 = v4 + 1;
                v57 = v56 - v17;
                v26 = v38;
                v27 = v40;
                v48 = v56;
                v29 = v41;
                v30 = v39;
                v31 = v38;
                v32 = v40;
                v33 = v41;
                while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v17)) < 0) {
                    // 0x100002b94
                    v41 = v39;
                    v34 = v27;
                    v44 = v29;
                    v36 = v27;
                    v37 = v27;
                    if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                        v52 = v19;
                        v46 = 0;
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v46 + v1);
                        v50 = v34 + v44 * v49;
                        v51 = v46 + 1;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                        while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                            // 0x100002bf8
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v35 + v45 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                        }
                        // 0x100002c6c
                        v54 = v19 + 1;
                        v55 = v54 - v4;
                        v47 = v54;
                        while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                            // 0x100002bf8
                            v52 = v19;
                            v45 = v49;
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v51 + v1);
                            v50 += v45 * v49;
                            v51++;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                            while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                // 0x100002bf8
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v46 + v1);
                                v50 = v35 + v45 * v49;
                                v51 = v46 + 1;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                            }
                            // 0x100002c6c
                            v54 = v47 + 1;
                            v55 = v54 - v4;
                            v47 = v54;
                        }
                        // 0x100002c7c
                        v36 = v50;
                        v37 = v50;
                    }
                    // 0x100002c7c
                    v43 = v37;
                    v42 = v36;
                    v38 = v26;
                    if (v43 > v26) {
                        // 0x100002c94
                        v10 = v42;
                        v38 = v42;
                    }
                    // 0x100002ca0
                    v11 = v43;
                    v39 = v41;
                    v40 = v43;
                    if (v43 != v41) {
                        v39 = v41;
                        v40 = v43;
                        if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                            // 0x100002cb8
                            v11 = v42;
                            v12 = v42;
                            v39 = v42;
                            v40 = v42;
                        }
                    }
                    // 0x100002cc8
                    v56 = v48 + 1;
                    v57 = v56 - v17;
                    v26 = v38;
                    v27 = v40;
                    v48 = v56;
                    v29 = v41;
                    v30 = v39;
                    v31 = v38;
                    v32 = v40;
                    v33 = v41;
                }
            }
            // 0x100002cdc
            v23 = v32;
            v22 = v31;
            v21 = v30;
            v24++;
            int32_t v58 = v24 - v13; // 0x100002b58
            v28 = v33;
            v16 = v33;
            while (v58 < 0 != ((v58 ^ v24) & (v24 ^ v13)) < 0) {
                // 0x100002b74
                v25 = v21;
                v26 = v22;
                v27 = v23;
                v29 = v28;
                v30 = v21;
                v31 = v22;
                v32 = v23;
                v33 = v28;
                if (v18 < 0 != ((v18 ^ v4) & (v17 ^ v4)) < 0) {
                    v41 = v25;
                    v34 = v27;
                    v44 = v29;
                    v36 = v27;
                    v37 = v27;
                    if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                        v52 = v19;
                        v46 = 0;
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v46 + v1);
                        v50 = v34 + v44 * v49;
                        v51 = v46 + 1;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                        while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                            // 0x100002bf8
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v35 + v45 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                        }
                        // 0x100002c6c
                        v54 = v19 + 1;
                        v55 = v54 - v4;
                        v47 = v54;
                        while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                            // 0x100002bf8
                            v52 = v19;
                            v45 = v49;
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v51 + v1);
                            v50 += v45 * v49;
                            v51++;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                            while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                // 0x100002bf8
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v46 + v1);
                                v50 = v35 + v45 * v49;
                                v51 = v46 + 1;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                            }
                            // 0x100002c6c
                            v54 = v47 + 1;
                            v55 = v54 - v4;
                            v47 = v54;
                        }
                        // 0x100002c7c
                        v36 = v50;
                        v37 = v50;
                    }
                    // 0x100002c7c
                    v43 = v37;
                    v42 = v36;
                    v38 = v26;
                    if (v43 > v26) {
                        // 0x100002c94
                        v10 = v42;
                        v38 = v42;
                    }
                    // 0x100002ca0
                    v11 = v43;
                    v39 = v41;
                    v40 = v43;
                    if (v43 != v41) {
                        v39 = v41;
                        v40 = v43;
                        if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                            // 0x100002cb8
                            v11 = v42;
                            v12 = v42;
                            v39 = v42;
                            v40 = v42;
                        }
                    }
                    // 0x100002cc8
                    v56 = v4 + 1;
                    v57 = v56 - v17;
                    v26 = v38;
                    v27 = v40;
                    v48 = v56;
                    v29 = v41;
                    v30 = v39;
                    v31 = v38;
                    v32 = v40;
                    v33 = v41;
                    while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v17)) < 0) {
                        // 0x100002b94
                        v41 = v39;
                        v34 = v27;
                        v44 = v29;
                        v36 = v27;
                        v37 = v27;
                        if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                            v52 = v19;
                            v46 = 0;
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v34 + v44 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                            while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                // 0x100002bf8
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v46 + v1);
                                v50 = v35 + v45 * v49;
                                v51 = v46 + 1;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                            }
                            // 0x100002c6c
                            v54 = v19 + 1;
                            v55 = v54 - v4;
                            v47 = v54;
                            while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                                // 0x100002bf8
                                v52 = v19;
                                v45 = v49;
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v51 + v1);
                                v50 += v45 * v49;
                                v51++;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                                while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                    // 0x100002bf8
                                    __asm_sshll_5(0, 0);
                                    v49 = *(float32_t *)(4 * v46 + v1);
                                    v50 = v35 + v45 * v49;
                                    v51 = v46 + 1;
                                    v52++;
                                    v53 = v52 - v4;
                                    v35 = v50;
                                    v45 = v49;
                                    v46 = v51;
                                }
                                // 0x100002c6c
                                v54 = v47 + 1;
                                v55 = v54 - v4;
                                v47 = v54;
                            }
                            // 0x100002c7c
                            v36 = v50;
                            v37 = v50;
                        }
                        // 0x100002c7c
                        v43 = v37;
                        v42 = v36;
                        v38 = v26;
                        if (v43 > v26) {
                            // 0x100002c94
                            v10 = v42;
                            v38 = v42;
                        }
                        // 0x100002ca0
                        v11 = v43;
                        v39 = v41;
                        v40 = v43;
                        if (v43 != v41) {
                            v39 = v41;
                            v40 = v43;
                            if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                                // 0x100002cb8
                                v11 = v42;
                                v12 = v42;
                                v39 = v42;
                                v40 = v42;
                            }
                        }
                        // 0x100002cc8
                        v56 = v48 + 1;
                        v57 = v56 - v17;
                        v26 = v38;
                        v27 = v40;
                        v48 = v56;
                        v29 = v41;
                        v30 = v39;
                        v31 = v38;
                        v32 = v40;
                        v33 = v41;
                    }
                }
                // 0x100002cdc
                v23 = v32;
                v22 = v31;
                v21 = v30;
                v24++;
                v58 = v24 - v13;
                v28 = v33;
                v16 = v33;
            }
        }
    }
    if (v14 < 0 == v15 < 0) {
        // 0x100002eb8
        return result;
    }
    int32_t v59 = v7 - v4; // 0x100002d34
    int32_t v60 = v4 - v59; // 0x100002d38
    int32_t v61 = -v4;
    int32_t v62 = v61 - v4;
    float32_t v63 = v16; // 0x100002d40
    float32_t v64; // 0x100002a0c
    float32_t v65; // 0x100002a0c
    float32_t v66; // 0x100002a0c
    float32_t v67; // 0x100002a0c
    float32_t v68; // 0x100002a0c
    float32_t v69; // 0x100002a0c
    float32_t v70; // 0x100002a0c
    float32_t v71; // 0x100002a0c
    float32_t v72; // 0x100002a0c
    int64_t v73; // 0x100002a0c
    int32_t v74; // 0x100002a0c
    int32_t v75; // 0x100002a0c
    float32_t v76; // 0x100002dec
    float32_t v77; // 0x100002df4
    int64_t v78; // 0x100002e00
    int32_t v79; // 0x100002e10
    int32_t v80; // 0x100002d9c
    int32_t v81; // 0x100002e98
    int32_t v82; // 0x100002d38
    float32_t v83; // 0x100002e5c
    int32_t v84; // 0x100002e24
    int32_t v85; // 0x100002d70
    if (v60 < 0 != ((v60 ^ v4) & (v59 ^ v4)) < 0) {
        v64 = v11;
        v66 = v11;
        v71 = v16;
        if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
            v79 = v61;
            v73 = 0;
            __asm_sshll_5(0, 0);
            v76 = *(float32_t *)(4 * v73 + v1);
            v77 = v64 + v16 * v76;
            v78 = v73 + 1;
            v79++;
            v80 = v79 - v4;
            v65 = v77;
            v72 = v76;
            v73 = v78;
            while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                // 0x100002dac
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v73 + v1);
                v77 = v65 + v72 * v76;
                v78 = v73 + 1;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
            }
            // 0x100002e20
            v84 = v61 + 1;
            v85 = v84 - v4;
            v74 = v84;
            v66 = v77;
            v71 = v76;
            while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                // 0x100002dac
                v79 = v61;
                v72 = v76;
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v78 + v1);
                v77 += v72 * v76;
                v78++;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
                while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                    // 0x100002dac
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v65 + v72 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                }
                // 0x100002e20
                v84 = v74 + 1;
                v85 = v84 - v4;
                v74 = v84;
                v66 = v77;
                v71 = v76;
            }
        }
        // 0x100002e30
        v68 = v66;
        v67 = v68;
        v83 = v71;
        if (v2 % 2 != 0) {
            // 0x100002e3c
            v83 = v12 - v10;
            v67 = 255.0f * (v68 - v10) / v83;
        }
        // 0x100002e6c
        v11 = v67;
        *(int16_t *)(v1 + (int64_t)(2 * (v4 * v6 + v4))) = (int16_t)(int32_t)v67;
        v81 = v4 + 1;
        v82 = v81 - v59;
        v75 = v81;
        v69 = v83;
        v63 = v83;
        while (v82 < 0 != ((v82 ^ v81) & (v81 ^ v59)) < 0) {
            // 0x100002d48
            v64 = v11;
            v70 = v69;
            v66 = v11;
            v71 = v69;
            if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
                v79 = v61;
                v73 = 0;
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v73 + v1);
                v77 = v64 + v70 * v76;
                v78 = v73 + 1;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
                while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                    // 0x100002dac
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v65 + v72 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                }
                // 0x100002e20
                v84 = v61 + 1;
                v85 = v84 - v4;
                v74 = v84;
                v66 = v77;
                v71 = v76;
                while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                    // 0x100002dac
                    v79 = v61;
                    v72 = v76;
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v78 + v1);
                    v77 += v72 * v76;
                    v78++;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                    while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                        // 0x100002dac
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v73 + v1);
                        v77 = v65 + v72 * v76;
                        v78 = v73 + 1;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                    }
                    // 0x100002e20
                    v84 = v74 + 1;
                    v85 = v84 - v4;
                    v74 = v84;
                    v66 = v77;
                    v71 = v76;
                }
            }
            // 0x100002e30
            v68 = v66;
            v67 = v68;
            v83 = v71;
            if (v2 % 2 != 0) {
                // 0x100002e3c
                v83 = v12 - v10;
                v67 = 255.0f * (v68 - v10) / v83;
            }
            // 0x100002e6c
            v11 = v67;
            *(int16_t *)(v1 + (int64_t)(2 * (v75 * v6 + v4))) = (int16_t)(int32_t)v67;
            v81 = v75 + 1;
            v82 = v81 - v59;
            v75 = v81;
            v69 = v83;
            v63 = v83;
        }
    }
    int32_t v86 = v4 + 1; // 0x100002eac
    int32_t v87 = v86 - v13; // 0x100002d0c
    float32_t v88 = v63; // 0x100002d14
    while (v87 < 0 != ((v87 ^ v86) & (v86 ^ v13)) < 0) {
        int32_t v89 = v86;
        v69 = v88;
        v63 = v88;
        if (v60 < 0 != ((v60 ^ v4) & (v59 ^ v4)) < 0) {
            v64 = v11;
            v70 = v69;
            v66 = v11;
            v71 = v69;
            if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
                v79 = v61;
                v73 = 0;
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v73 + v1);
                v77 = v64 + v70 * v76;
                v78 = v73 + 1;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
                while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                    // 0x100002dac
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v65 + v72 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                }
                // 0x100002e20
                v84 = v61 + 1;
                v85 = v84 - v4;
                v74 = v84;
                v66 = v77;
                v71 = v76;
                while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                    // 0x100002dac
                    v79 = v61;
                    v72 = v76;
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v78 + v1);
                    v77 += v72 * v76;
                    v78++;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                    while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                        // 0x100002dac
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v73 + v1);
                        v77 = v65 + v72 * v76;
                        v78 = v73 + 1;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                    }
                    // 0x100002e20
                    v84 = v74 + 1;
                    v85 = v84 - v4;
                    v74 = v84;
                    v66 = v77;
                    v71 = v76;
                }
            }
            // 0x100002e30
            v68 = v66;
            v67 = v68;
            v83 = v71;
            if (v2 % 2 != 0) {
                // 0x100002e3c
                v83 = v12 - v10;
                v67 = 255.0f * (v68 - v10) / v83;
            }
            // 0x100002e6c
            v11 = v67;
            *(int16_t *)(v1 + (int64_t)(2 * (v4 * v6 + v89))) = (int16_t)(int32_t)v67;
            v81 = v4 + 1;
            v82 = v81 - v59;
            v75 = v81;
            v69 = v83;
            v63 = v83;
            while (v82 < 0 != ((v82 ^ v81) & (v81 ^ v59)) < 0) {
                // 0x100002d48
                v64 = v11;
                v70 = v69;
                v66 = v11;
                v71 = v69;
                if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
                    v79 = v61;
                    v73 = 0;
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v64 + v70 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                    while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                        // 0x100002dac
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v73 + v1);
                        v77 = v65 + v72 * v76;
                        v78 = v73 + 1;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                    }
                    // 0x100002e20
                    v84 = v61 + 1;
                    v85 = v84 - v4;
                    v74 = v84;
                    v66 = v77;
                    v71 = v76;
                    while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                        // 0x100002dac
                        v79 = v61;
                        v72 = v76;
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v78 + v1);
                        v77 += v72 * v76;
                        v78++;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                        while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                            // 0x100002dac
                            __asm_sshll_5(0, 0);
                            v76 = *(float32_t *)(4 * v73 + v1);
                            v77 = v65 + v72 * v76;
                            v78 = v73 + 1;
                            v79++;
                            v80 = v79 - v4;
                            v65 = v77;
                            v72 = v76;
                            v73 = v78;
                        }
                        // 0x100002e20
                        v84 = v74 + 1;
                        v85 = v84 - v4;
                        v74 = v84;
                        v66 = v77;
                        v71 = v76;
                    }
                }
                // 0x100002e30
                v68 = v66;
                v67 = v68;
                v83 = v71;
                if (v2 % 2 != 0) {
                    // 0x100002e3c
                    v83 = v12 - v10;
                    v67 = 255.0f * (v68 - v10) / v83;
                }
                // 0x100002e6c
                v11 = v67;
                *(int16_t *)(v1 + (int64_t)(2 * (v75 * v6 + v89))) = (int16_t)(int32_t)v67;
                v81 = v75 + 1;
                v82 = v81 - v59;
                v75 = v81;
                v69 = v83;
                v63 = v83;
            }
        }
        // 0x100002ea8
        v86 = v89 + 1;
        v87 = v86 - v13;
        v88 = v63;
    }
    // 0x100002eb8
    return result;
}

// Address range: 0x100002ec4 - 0x100002f6c
int64_t function_100002ec4(void) {
    // 0x100002ec4
    __asm_sshll(0.0f, 0);
    float64_t v1; // 0x100002ec4
    __asm_frintm(0.5 * v1);
    return ___chkstk_darwin();
}

// Address range: 0x100002f6c - 0x100003138
int64_t function_100002f6c(void) {
    // 0x100002f6c
    int64_t v1; // 0x100002f6c
    int64_t v2 = v1;
    int64_t v3; // 0x100002f6c
    int64_t v4 = (int64_t)&v3 - *(int64_t *)(v2 - 96); // 0x100002f74
    int64_t * v5 = (int64_t *)(v2 - 88); // 0x100002f7c
    *v5 = v4;
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004028; // 0x100002f8c
    int32_t * v7 = (int32_t *)(v2 - 40); // 0x100002f90
    float32_t * v8 = (float32_t *)(v2 - 36); // 0x100002f98
    *(int64_t *)(v4 - 16) = (int64_t)*v7;
    *(float64_t *)(v4 - 8) = (float64_t)*v8;
    int128_t v9; // 0x100002f6c
    int64_t v10 = v9; // 0x100002fb8
    _fprintf((struct _IO_FILE *)v6, "gaussian_filter: kernel size %d, sigma=%g\n", v1, (float64_t)v10);
    int64_t * v11 = (int64_t *)(v2 - 72); // 0x100002fc0
    *v11 = 0;
    int64_t v12 = v2 - 76; // 0x100002fc4
    int32_t * v13 = (int32_t *)v12; // 0x100002fc4
    *v13 = 0;
    int32_t v14 = *v7; // 0x100002fd0
    int32_t v15 = -v14; // 0x100002fd4
    if (v15 < 0 != (v14 & v15) < 0) {
        int64_t v16 = v2 - 80; // 0x100002fe4
        int32_t * v17 = (int32_t *)v16; // 0x100002fe4
        float32_t * v18 = (float32_t *)(v2 - 44);
        float64_t * v19 = (float64_t *)(v2 - 104);
        *v17 = 0;
        int32_t v20 = *v7; // 0x100002ff0
        int32_t v21 = -v20; // 0x100002ff4
        int64_t v22 = v10; // 0x100002ffc
        int64_t v23; // 0x100002f6c
        int64_t v24; // 0x100002f6c
        float64_t v25; // 0x100003028
        float32_t v26; // 0x100003034
        float32_t v27; // 0x10000303c
        float32_t v28; // 0x100003044
        float64_t v29; // 0x100003050
        float64_t v30; // 0x100003058
        float64_t v31; // 0x100003068
        int64_t v32; // 0x10000306c
        float64_t v33; // 0x100003074
        int64_t v34; // 0x100003098
        int32_t v35; // 0x1000030b4
        int32_t v36; // 0x100002ff0
        int32_t v37; // 0x100002ff4
        if (v21 < 0 != (v20 & v21) < 0) {
            *(float64_t *)(v2 - 112) = 2.0;
            v25 = _pow((float64_t)v10, (float64_t)(int64_t)v9);
            *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
            v26 = *(float32_t *)v16;
            v27 = *v18;
            v28 = *v8;
            v29 = _pow(v25, (float64_t)(int64_t)v9);
            v30 = *v19;
            v31 = _exp(v29);
            v32 = *v5;
            v33 = (float64_t)*v8;
            v34 = *v11;
            *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
            *v11 = *v11 + 1;
            v35 = *v17 + 1;
            *v17 = v35;
            v23 = (float32_t)v31;
            v36 = *v7;
            v37 = v35 - v36;
            v24 = v23;
            v22 = v23;
            while (v37 < 0 != ((v37 ^ v35) & (v36 ^ v35)) < 0) {
                // 0x100003004
                *(float64_t *)(v2 - 112) = 2.0;
                v25 = _pow((float64_t)v24, (float64_t)(int64_t)v9);
                *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
                v26 = *(float32_t *)v16;
                v27 = *v18;
                v28 = *v8;
                v29 = _pow(v25, (float64_t)(int64_t)v9);
                v30 = *v19;
                v31 = _exp(v29);
                v32 = *v5;
                v33 = (float64_t)*v8;
                v34 = *v11;
                *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
                *v11 = *v11 + 1;
                v35 = *v17 + 1;
                *v17 = v35;
                v23 = (float32_t)v31;
                v36 = *v7;
                v37 = v35 - v36;
                v24 = v23;
                v22 = v23;
            }
        }
        int64_t v38 = v22;
        int32_t v39 = *v13 + 1; // 0x1000030c8
        *v13 = v39;
        int32_t v40 = *v7; // 0x100002fd0
        while (v39 - v40 < 0 != ((v39 - v40 ^ v39) & (v40 ^ v39)) < 0) {
            // 0x100002fe4
            *v17 = 0;
            v20 = *v7;
            v21 = -v20;
            v24 = v38;
            v22 = v38;
            if (v21 < 0 != (v20 & v21) < 0) {
                *(float64_t *)(v2 - 112) = 2.0;
                v25 = _pow((float64_t)v24, (float64_t)(int64_t)v9);
                *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
                v26 = *(float32_t *)v16;
                v27 = *v18;
                v28 = *v8;
                v29 = _pow(v25, (float64_t)(int64_t)v9);
                v30 = *v19;
                v31 = _exp(v29);
                v32 = *v5;
                v33 = (float64_t)*v8;
                v34 = *v11;
                *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
                *v11 = *v11 + 1;
                v35 = *v17 + 1;
                *v17 = v35;
                v23 = (float32_t)v31;
                v36 = *v7;
                v37 = v35 - v36;
                v24 = v23;
                v22 = v23;
                while (v37 < 0 != ((v37 ^ v35) & (v36 ^ v35)) < 0) {
                    // 0x100003004
                    *(float64_t *)(v2 - 112) = 2.0;
                    v25 = _pow((float64_t)v24, (float64_t)(int64_t)v9);
                    *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
                    v26 = *(float32_t *)v16;
                    v27 = *v18;
                    v28 = *v8;
                    v29 = _pow(v25, (float64_t)(int64_t)v9);
                    v30 = *v19;
                    v31 = _exp(v29);
                    v32 = *v5;
                    v33 = (float64_t)*v8;
                    v34 = *v11;
                    *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
                    *v11 = *v11 + 1;
                    v35 = *v17 + 1;
                    *v17 = v35;
                    v23 = (float32_t)v31;
                    v36 = *v7;
                    v37 = v35 - v36;
                    v24 = v23;
                    v22 = v23;
                }
            }
            // 0x1000030c4
            v38 = v22;
            v39 = *v13 + 1;
            *v13 = v39;
            v40 = *v7;
        }
    }
    int64_t v41 = function_100002a0c(); // 0x1000030f4
    *(int64_t *)(v2 - 120) = *(int64_t *)(v2 - 56);
    int64_t result = v41; // 0x100003118
    if (*(int64_t *)*(int64_t *)0x100004020 != *(int64_t *)(v2 - 8)) {
        // 0x100003120
        result = ___stack_chk_fail(v41);
    }
    // 0x100003124
    return result;
}

// Address range: 0x100003138 - 0x100003b60
int64_t function_100003138(void) {
    // 0x100003138
    int128_t v1; // 0x100003138
    int128_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004020; // 0x100003158
    int64_t v4; // 0x100003138
    int32_t v5 = *(int32_t *)(v4 + 4); // 0x100003178
    int32_t v6 = *(int32_t *)(v4 + 8); // 0x100003184
    int32_t v7 = 2 * v5 * v6; // 0x1000031a0
    int64_t v8 = (int64_t)_calloc(v7, 1); // bp-192, 0x1000031b8
    int64_t * v9 = _calloc(v7, 1); // 0x1000031d4
    int64_t * v10 = _calloc(v7, 1); // 0x1000031f8
    int64_t * v11 = _calloc(v7, 1); // 0x10000321c
    int32_t v12 = *(int32_t *)(*(int64_t *)((int64_t)&v8 + 32) + 20); // 0x10000322c
    int64_t * v13 = _malloc(2 * v12); // 0x100003234
    if (v13 == NULL || v11 == NULL || v10 == NULL || v9 == NULL || v8 == 0) {
        int64_t v14 = *(int64_t *)*(int64_t *)0x100004028; // 0x1000032ac
        _fprintf((struct _IO_FILE *)v14, "canny_edge_detection: Failed memory allocation(s).\n");
        _exit(1);
        // UNREACHABLE
    }
    int64_t v15 = (int64_t)v10; // 0x1000031f8
    int64_t v16 = (int64_t)v11; // 0x10000321c
    function_100002ec4();
    int64_t v17; // bp-76, 0x100003138
    _memset(&v17, 0, 36);
    v17 = -0x4010000000000000;
    function_100002a0c();
    int64_t v18; // bp-112, 0x100003138
    _memset(&v18, 0, 36);
    v18 = 0x3ff0000000000000;
    function_100002a0c();
    int32_t v19 = v5 - 1; // 0x1000033d8
    int32_t v20 = 2 - v5;
    int32_t v21; // 0x100003138
    int32_t v22; // 0x100003138
    int32_t v23; // 0x100003138
    int32_t v24; // 0x100003138
    int64_t v25; // 0x100003138
    int64_t v26; // 0x100003138
    int32_t v27; // 0x100003400
    int32_t v28; // 0x1000034fc
    int64_t v29; // 0x100003574
    float64_t v30; // 0x1000035b0
    float32_t v31; // 0x1000035c4
    if (v20 < 0 == (v20 & v19) < 0) {
        int32_t v32 = v6 - 1; // 0x1000038c8
        int32_t v33 = 2 - v6; // 0x1000038cc
        v22 = v33 & v32;
        v21 = v33;
        v23 = v32;
    } else {
        // 0x1000033f8
        v27 = v6 - 1;
        int32_t v34 = 2 - v6; // 0x100003404
        int32_t v35 = v34 & v27; // 0x100003404
        int64_t v36 = v1;
        int32_t v37 = 1;
        int32_t v38 = 1; // 0x10000340c
        int64_t v39 = v36; // 0x10000340c
        int64_t v40 = v36; // 0x10000340c
        int64_t v41; // 0x100003138
        int64_t v42; // 0x100003434
        int16_t v43; // 0x100003438
        float64_t v44; // 0x10000345c
        int32_t v45; // 0x10000347c
        int32_t v46; // 0x100003404
        if (v34 < 0 != v35 < 0) {
            v42 = 2 * (int64_t)(v38 * v5 + v37);
            v43 = *(int16_t *)(v42 + (int64_t)v9);
            v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
            *(int16_t *)(v8 + v42) = v43;
            v45 = v38 + 1;
            v41 = (float32_t)v44;
            v46 = v45 - v27;
            v38 = v45;
            v39 = v41;
            v40 = v41;
            while (v46 < 0 != ((v46 ^ v45) & (v45 ^ v27)) < 0) {
                // 0x100003414
                v42 = 2 * (int64_t)(v38 * v5 + v37);
                v43 = *(int16_t *)(v42 + (int64_t)v9);
                v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
                *(int16_t *)(v8 + v42) = v43;
                v45 = v38 + 1;
                v41 = (float32_t)v44;
                v46 = v45 - v27;
                v38 = v45;
                v39 = v41;
                v40 = v41;
            }
        }
        // 0x10000348c
        v36 = v40;
        int32_t v47 = v37 + 1; // 0x100003490
        int32_t v48 = v47 - v19; // 0x1000033dc
        int32_t v49 = 1; // 0x1000033e4
        int64_t v50 = v36; // 0x1000033e4
        while (v48 < 0 != ((v48 ^ v47) & (v47 ^ v19)) < 0) {
            // 0x1000033f8
            v37 = v47;
            v38 = 1;
            v39 = v36;
            v40 = v36;
            if (v34 < 0 != v35 < 0) {
                v42 = 2 * (int64_t)(v38 * v5 + v37);
                v43 = *(int16_t *)(v42 + (int64_t)v9);
                v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
                *(int16_t *)(v8 + v42) = v43;
                v45 = v38 + 1;
                v41 = (float32_t)v44;
                v46 = v45 - v27;
                v38 = v45;
                v39 = v41;
                v40 = v41;
                while (v46 < 0 != ((v46 ^ v45) & (v45 ^ v27)) < 0) {
                    // 0x100003414
                    v42 = 2 * (int64_t)(v38 * v5 + v37);
                    v43 = *(int16_t *)(v42 + (int64_t)v9);
                    v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
                    *(int16_t *)(v8 + v42) = v43;
                    v45 = v38 + 1;
                    v41 = (float32_t)v44;
                    v46 = v45 - v27;
                    v38 = v45;
                    v39 = v41;
                    v40 = v41;
                }
            }
            // 0x10000348c
            v36 = v40;
            v47 = v37 + 1;
            v48 = v47 - v19;
            v49 = 1;
            v50 = v36;
        }
        while (true) {
            int32_t v51 = v49;
            v24 = 1;
            v25 = v50;
            v26 = v50;
            if (v34 < 0 != v35 < 0) {
                while (true) {
                  lab_0x1000034ec:
                    // 0x1000034ec
                    v28 = v24 * v5 + v51;
                    v29 = 2 * (int64_t)v28;
                    int16_t v52 = *(int16_t *)(v29 + v15); // 0x100003578
                    float64_t v53 = g3; // 0x1000035a4
                    v30 = _fmod(_atan2((float64_t)v25, (float64_t)(int64_t)v2), (float64_t)(int64_t)v2);
                    v31 = 8.0f * (float32_t)((v53 + (float64_t)v52) / v53);
                    if (v31 == 1.0f || v31 > 1.0f) {
                        goto lab_0x1000035fc;
                    } else {
                        if (v31 == 7.0f) {
                            goto lab_0x100003654;
                        } else {
                            if (v31 > 7.0f == v31 >= 7.0f == v31 <= 7.0f) {
                                goto lab_0x1000035fc;
                            } else {
                                goto lab_0x100003654;
                            }
                        }
                    }
                }
            }
          lab_0x100003840:;
            int32_t v54 = v51 + 1; // 0x100003844
            int32_t v55 = v54 - v19; // 0x1000034b4
            v49 = v54;
            v50 = v26;
            v22 = v35;
            v21 = v34;
            v23 = v27;
            if (v55 < 0 == ((v55 ^ v54) & (v54 ^ v19)) < 0) {
                // break -> 0x100003850
                break;
            }
        }
    }
    int64_t result = (int64_t)v13; // 0x100003234
    int64_t v56 = 2 * (int64_t)v5 * (int64_t)v6; // 0x100003870
    ___memset_chk(result, 0, v56, -1);
    ___memset_chk(v15, 0, v56, -1);
    if (v21 < 0 != v22 < 0) {
        int32_t v57 = v4; // 0x100003168
        int32_t v58 = v4; // 0x10000316c
        int32_t v59; // bp-144, 0x100003138
        int64_t v60 = &v59;
        int32_t v61 = 1; // 0x100003af0
        int32_t v62 = 1;
        int32_t v63 = v62; // 0x1000038fc
        int32_t v64 = v62; // 0x1000038fc
        int64_t v65; // 0x100003138
        int32_t v66; // 0x100003138
        int32_t v67; // 0x100003138
        int32_t v68; // 0x100003138
        int32_t v69; // 0x100003138
        int32_t v70; // 0x100003138
        int64_t v71; // 0x10000390c
        int32_t v72; // 0x10000390c
        int32_t v73; // 0x100003914
        int16_t * v74; // 0x10000392c
        int32_t v75; // 0x100003acc
        int32_t v76; // 0x100003adc
        int32_t v77; // 0x1000038f4
        int32_t v78; // 0x100003970
        int32_t * v79; // 0x100003a18
        int64_t v80; // 0x100003a1c
        int32_t v81; // 0x100003a1c
        int32_t v82; // 0x100003a24
        int16_t * v83; // 0x100003a44
        if (v20 < 0 != (v20 & v19) < 0) {
            v66 = v63;
            v71 = 2 * (int64_t)v66;
            v72 = (int32_t)*(int16_t *)(v71 + v16);
            v73 = v72 - v58;
            if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                // 0x100003924
                v74 = (int16_t *)(v71 + result);
                if (*v74 == 0) {
                    // 0x100003940
                    *v74 = 255;
                    *(int32_t *)v10 = v66;
                    v78 = 0;
                    v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                    v65 = 0;
                    v67 = v78;
                    v79 = (int32_t *)(4 * v65 + v60);
                    v80 = 2 * (int64_t)*v79;
                    v81 = (int32_t)*(int16_t *)(v80 + v16);
                    v82 = v81 - v57;
                    v68 = v67;
                    if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                        // 0x100003a34
                        v83 = (int16_t *)(v80 + result);
                        v68 = v67;
                        if (*v83 == 0) {
                            // 0x100003a58
                            *v83 = 255;
                            *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                            v68 = v67 + 1;
                        }
                    }
                    // 0x100003a9c
                    v69 = v68;
                    v65++;
                    while (v65 != 8) {
                        // 0x100003a0c
                        v67 = v69;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                    }
                    // 0x100003ab0
                    while (v69 >= 1) {
                        // 0x10000396c
                        v78 = v69 - 1;
                        v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                        v65 = 0;
                        v67 = v78;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                        while (v65 != 8) {
                            // 0x100003a0c
                            v67 = v69;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                        }
                    }
                }
            }
            // 0x100003ac8
            v75 = v66 + 1;
            v76 = 2;
            v77 = v76 - v19;
            v70 = v76;
            v64 = v75;
            while (v77 < 0 != ((v77 ^ v76) & (v76 ^ v19)) < 0) {
                // 0x100003904
                v66 = v75;
                v71 = 2 * (int64_t)v66;
                v72 = (int32_t)*(int16_t *)(v71 + v16);
                v73 = v72 - v58;
                if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                    // 0x100003924
                    v74 = (int16_t *)(v71 + result);
                    if (*v74 == 0) {
                        // 0x100003940
                        *v74 = 255;
                        *(int32_t *)v10 = v66;
                        v78 = 0;
                        v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                        v65 = 0;
                        v67 = v78;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                        while (v65 != 8) {
                            // 0x100003a0c
                            v67 = v69;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                        }
                        // 0x100003ab0
                        while (v69 >= 1) {
                            // 0x10000396c
                            v78 = v69 - 1;
                            v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                            v65 = 0;
                            v67 = v78;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                            while (v65 != 8) {
                                // 0x100003a0c
                                v67 = v69;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                            }
                        }
                    }
                }
                // 0x100003ac8
                v75 = v66 + 1;
                v76 = v70 + 1;
                v77 = v76 - v19;
                v70 = v76;
                v64 = v75;
            }
        }
        // 0x100003aec
        v62 = v64;
        v61++;
        while (v61 - v23 < 0 != ((v61 - v23 ^ v61) & (v61 ^ v23)) < 0) {
            // 0x1000038e8
            v63 = v62;
            v64 = v62;
            if (v20 < 0 != (v20 & v19) < 0) {
                v66 = v63;
                v71 = 2 * (int64_t)v66;
                v72 = (int32_t)*(int16_t *)(v71 + v16);
                v73 = v72 - v58;
                if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                    // 0x100003924
                    v74 = (int16_t *)(v71 + result);
                    if (*v74 == 0) {
                        // 0x100003940
                        *v74 = 255;
                        *(int32_t *)v10 = v66;
                        v78 = 0;
                        v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                        v65 = 0;
                        v67 = v78;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                        while (v65 != 8) {
                            // 0x100003a0c
                            v67 = v69;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                        }
                        // 0x100003ab0
                        while (v69 >= 1) {
                            // 0x10000396c
                            v78 = v69 - 1;
                            v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                            v65 = 0;
                            v67 = v78;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                            while (v65 != 8) {
                                // 0x100003a0c
                                v67 = v69;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                            }
                        }
                    }
                }
                // 0x100003ac8
                v75 = v66 + 1;
                v76 = 2;
                v77 = v76 - v19;
                v70 = v76;
                v64 = v75;
                while (v77 < 0 != ((v77 ^ v76) & (v76 ^ v19)) < 0) {
                    // 0x100003904
                    v66 = v75;
                    v71 = 2 * (int64_t)v66;
                    v72 = (int32_t)*(int16_t *)(v71 + v16);
                    v73 = v72 - v58;
                    if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                        // 0x100003924
                        v74 = (int16_t *)(v71 + result);
                        if (*v74 == 0) {
                            // 0x100003940
                            *v74 = 255;
                            *(int32_t *)v10 = v66;
                            v78 = 0;
                            v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                            v65 = 0;
                            v67 = v78;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                            while (v65 != 8) {
                                // 0x100003a0c
                                v67 = v69;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                            }
                            // 0x100003ab0
                            while (v69 >= 1) {
                                // 0x10000396c
                                v78 = v69 - 1;
                                v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                                v65 = 0;
                                v67 = v78;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                                while (v65 != 8) {
                                    // 0x100003a0c
                                    v67 = v69;
                                    v79 = (int32_t *)(4 * v65 + v60);
                                    v80 = 2 * (int64_t)*v79;
                                    v81 = (int32_t)*(int16_t *)(v80 + v16);
                                    v82 = v81 - v57;
                                    v68 = v67;
                                    if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                        // 0x100003a34
                                        v83 = (int16_t *)(v80 + result);
                                        v68 = v67;
                                        if (*v83 == 0) {
                                            // 0x100003a58
                                            *v83 = 255;
                                            *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                            v68 = v67 + 1;
                                        }
                                    }
                                    // 0x100003a9c
                                    v69 = v68;
                                    v65++;
                                }
                            }
                        }
                    }
                    // 0x100003ac8
                    v75 = v66 + 1;
                    v76 = v70 + 1;
                    v77 = v76 - v19;
                    v70 = v76;
                    v64 = v75;
                }
            }
            // 0x100003aec
            v62 = v64;
            v61++;
        }
    }
    // 0x100003afc
    _free(v9);
    _free(v10);
    _free((int64_t *)v8);
    _free(v11);
    if (*(int64_t *)*(int64_t *)0x100004020 != v3) {
        // 0x100003b48
        ___stack_chk_fail((int64_t)&g5);
    }
    // 0x100003b4c
    return result;
  lab_0x1000035fc:;
    int16_t v84 = *(int16_t *)(v8 + v29); // 0x100003608
    int32_t v85 = v84; // 0x100003608
    int16_t v86 = *(int16_t *)(v8 + 2 * (int64_t)(v28 - 1)); // 0x100003614
    int32_t v87 = v85 - (int32_t)v86; // 0x100003618
    int16_t v88; // 0x100003138
    if (v87 == 0 || v87 < 0 != ((v87 ^ v85) & (int32_t)(v86 ^ v84)) < 0) {
        goto lab_0x100003654;
    } else {
        int16_t v89 = *(int16_t *)(v8 + 2 * (int64_t)(v28 + 1)); // 0x100003640
        int32_t v90 = v85 - (int32_t)v89; // 0x100003644
        v88 = v84;
        if (v90 == 0 || v90 < 0 != ((v90 ^ v85) & (int32_t)(v89 ^ v84)) < 0) {
            goto lab_0x100003654;
        } else {
            // 0x1000037ec
            *(int16_t *)(v29 + v16) = v88;
            goto lab_0x10000382c;
        }
    }
  lab_0x100003654:;
    int32_t v91 = v28 - v5; // 0x10000350c
    int32_t v92 = v28 + v5; // 0x10000351c
    if (v31 == 1.0f) {
        goto lab_0x1000036dc;
    } else {
        if (v31 > 1.0f == v31 >= 1.0f == v31 <= 1.0f) {
            if (v31 <= 3.0f == (v31 != 3.0f)) {
                goto lab_0x1000036dc;
            } else {
                int16_t v93 = *(int16_t *)(v8 + v29); // 0x100003690
                int32_t v94 = v93; // 0x100003690
                int16_t v95 = *(int16_t *)(v8 + 2 * (int64_t)(v91 + 1)); // 0x10000369c
                int32_t v96 = v94 - (int32_t)v95; // 0x1000036a0
                if (v96 == 0 || v96 < 0 != ((v96 ^ v94) & (int32_t)(v95 ^ v93)) < 0) {
                    goto lab_0x1000036dc;
                } else {
                    int16_t v97 = *(int16_t *)(v8 + 2 * (int64_t)(v92 - 1)); // 0x1000036c8
                    int32_t v98 = v94 - (int32_t)v97; // 0x1000036cc
                    v88 = v93;
                    if (v98 == 0 || v98 < 0 != ((v98 ^ v94) & (int32_t)(v97 ^ v93)) < 0) {
                        goto lab_0x1000036dc;
                    } else {
                        // 0x1000037ec
                        *(int16_t *)(v29 + v16) = v88;
                        goto lab_0x10000382c;
                    }
                }
            }
        } else {
            goto lab_0x1000036dc;
        }
    }
  lab_0x1000036dc:
    if (v31 == 3.0f) {
        goto lab_0x100003764;
    } else {
        if (v31 > 3.0f == v31 >= 3.0f == v31 <= 3.0f) {
            if (v31 <= 5.0f == (v31 != 5.0f)) {
                goto lab_0x100003764;
            } else {
                int16_t v99 = *(int16_t *)(v8 + v29); // 0x100003718
                int32_t v100 = v99; // 0x100003718
                int16_t v101 = *(int16_t *)(v8 + 2 * (int64_t)v91); // 0x100003724
                int32_t v102 = v100 - (int32_t)v101; // 0x100003728
                if (v102 == 0 || v102 < 0 != ((v102 ^ v100) & (int32_t)(v101 ^ v99)) < 0) {
                    goto lab_0x100003764;
                } else {
                    int16_t v103 = *(int16_t *)(v8 + 2 * (int64_t)v92); // 0x100003750
                    int32_t v104 = v100 - (int32_t)v103; // 0x100003754
                    v88 = v99;
                    if (v104 == 0 || v104 < 0 != ((v104 ^ v100) & (int32_t)(v103 ^ v99)) < 0) {
                        goto lab_0x100003764;
                    } else {
                        // 0x1000037ec
                        *(int16_t *)(v29 + v16) = v88;
                        goto lab_0x10000382c;
                    }
                }
            }
        } else {
            goto lab_0x100003764;
        }
    }
  lab_0x100003764:
    if (v31 == 5.0f) {
        // 0x100003814
        *(int16_t *)(v29 + v16) = 0;
        goto lab_0x10000382c;
    } else {
        if (v31 > 5.0f == v31 >= 5.0f == v31 <= 5.0f) {
            if (v31 <= 7.0f == (v31 != 7.0f)) {
                // 0x100003814
                *(int16_t *)(v29 + v16) = 0;
                goto lab_0x10000382c;
            } else {
                int16_t v105 = *(int16_t *)(v8 + v29); // 0x1000037a0
                int32_t v106 = v105; // 0x1000037a0
                int16_t v107 = *(int16_t *)(v8 + 2 * (int64_t)(v91 - 1)); // 0x1000037ac
                int32_t v108 = v106 - (int32_t)v107; // 0x1000037b0
                if (v108 == 0 || v108 < 0 != ((v108 ^ v106) & (int32_t)(v107 ^ v105)) < 0) {
                    // 0x100003814
                    *(int16_t *)(v29 + v16) = 0;
                    goto lab_0x10000382c;
                } else {
                    int16_t v109 = *(int16_t *)(v8 + 2 * (int64_t)(v92 + 1)); // 0x1000037d8
                    int32_t v110 = v106 - (int32_t)v109; // 0x1000037dc
                    v88 = v105;
                    if (v110 == 0 || v110 < 0 != ((v110 ^ v106) & (int32_t)(v109 ^ v105)) < 0) {
                        // 0x100003814
                        *(int16_t *)(v29 + v16) = 0;
                        goto lab_0x10000382c;
                    } else {
                        // 0x1000037ec
                        *(int16_t *)(v29 + v16) = v88;
                        goto lab_0x10000382c;
                    }
                }
            }
        } else {
            // 0x100003814
            *(int16_t *)(v29 + v16) = 0;
            goto lab_0x10000382c;
        }
    }
  lab_0x10000382c:;
    int32_t v111 = v24 + 1; // 0x100003830
    int64_t v112 = (float32_t)v30;
    int32_t v113 = v111 - v27; // 0x1000034dc
    v24 = v111;
    v25 = v112;
    v26 = v112;
    if (v113 < 0 == ((v113 ^ v111) & (v111 ^ v27)) < 0) {
        // break -> 0x100003840
        goto lab_0x100003840;
    }
    goto lab_0x1000034ec;
}

// Address range: 0x100003b60 - 0x100003d04
int64_t entry_point(void) {
    // 0x100003b60
    int64_t v1; // 0x100003b60
    int32_t v2 = v1; // 0x100003b70
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003b8c
        _printf("Usage: %s image.bmp\n", (char *)v1);
        // 0x100003cf4
        return 1;
    }
    int64_t v3 = function_100002310(); // 0x100003bc4
    if (v3 == 0) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004028; // 0x100003be8
        _fprintf((struct _IO_FILE *)v4, "main: BMP image not loaded.\n");
        // 0x100003cf4
        return 1;
    }
    // 0x100003c04
    _printf("Info: %d x %d x %d\n", (int64_t)&g4, v1, v1);
    int64_t v5 = function_100003138(); // 0x100003c58
    if (v5 == 0) {
        int64_t v6 = *(int64_t *)*(int64_t *)0x100004028; // 0x100003c7c
        _fprintf((struct _IO_FILE *)v6, "main: failed canny_edge_detection.\n");
        // 0x100003cf4
        return 1;
    }
    // 0x100003c98
    int64_t result; // 0x100003b60
    if (function_100002638() % 2 == 0) {
        // 0x100003cdc
        _free((int64_t *)v3);
        _free((int64_t *)v5);
        result = 0;
    } else {
        int64_t v7 = *(int64_t *)*(int64_t *)0x100004028; // 0x100003cc0
        _fprintf((struct _IO_FILE *)v7, "main: BMP image not saved.\n");
        result = 1;
    }
    // 0x100003cf4
    return result;
}

// Address range: 0x100003d04 - 0x100003d10
int64_t function_100003d04(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003d04
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003d10 - 0x100003d1c
int64_t function_100003d10(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d10
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003d1c - 0x100003d28
int64_t function_100003d1c(int64_t a1) {
    // 0x100003d1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d28 - 0x100003d34
float64_t function_100003d28(float64_t a1, float64_t a2) {
    // 0x100003d28
    return _atan2(a1, a2);
}

// Address range: 0x100003d34 - 0x100003d40
int64_t * function_100003d34(int32_t nmemb, int32_t size) {
    // 0x100003d34
    return _calloc(nmemb, size);
}

// Address range: 0x100003d40 - 0x100003d4c
void function_100003d40(int32_t status) {
    // 0x100003d40
    _exit(status);
}

// Address range: 0x100003d4c - 0x100003d58
float64_t function_100003d4c(float64_t a1) {
    // 0x100003d4c
    return _exp(a1);
}

// Address range: 0x100003d58 - 0x100003d64
int32_t function_100003d58(struct _IO_FILE * stream) {
    // 0x100003d58
    return _fclose(stream);
}

// Address range: 0x100003d64 - 0x100003d70
float64_t function_100003d64(float64_t a1, float64_t a2) {
    // 0x100003d64
    return _fmod(a1, a2);
}

// Address range: 0x100003d70 - 0x100003d7c
struct _IO_FILE * function_100003d70(char * filename, char * modes) {
    // 0x100003d70
    return _fopen(filename, modes);
}

// Address range: 0x100003d7c - 0x100003d88
int32_t function_100003d7c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003d7c
    return _fprintf(stream, format);
}

// Address range: 0x100003d88 - 0x100003d94
int32_t function_100003d88(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003d88
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003d94 - 0x100003da0
void function_100003d94(int64_t * ptr) {
    // 0x100003d94
    _free(ptr);
}

// Address range: 0x100003da0 - 0x100003dac
int32_t function_100003da0(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003da0
    return _fseek(stream, off, whence);
}

// Address range: 0x100003dac - 0x100003db8
int32_t function_100003dac(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003dac
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003db8 - 0x100003dc4
float64_t function_100003db8(float64_t a1, float64_t a2) {
    // 0x100003db8
    return _hypot(a1, a2);
}

// Address range: 0x100003dc4 - 0x100003dd0
int64_t * function_100003dc4(int32_t size) {
    // 0x100003dc4
    return _malloc(size);
}

// Address range: 0x100003dd0 - 0x100003ddc
int64_t * function_100003dd0(int64_t * s, int32_t c, int32_t n) {
    // 0x100003dd0
    return _memset(s, c, n);
}

// Address range: 0x100003ddc - 0x100003de8
void function_100003ddc(char * s) {
    // 0x100003ddc
    _perror(s);
}

// Address range: 0x100003de8 - 0x100003df4
float64_t function_100003de8(float64_t a1, float64_t a2) {
    // 0x100003de8
    return _pow(a1, a2);
}

// Address range: 0x100003df4 - 0x100003e00
int32_t function_100003df4(char * format, ...) {
    // 0x100003df4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 28

`
`#include <stdio.h>

int main() {
  printf("%d\n", 'a'); /* prints "97" */
  printf("%c\n", 97); /* prints "a"; we don't have to cast because printf is type agnostic */
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f38 - 0x100003f94
int64_t entry_point(void) {
    // 0x100003f38
    int64_t v1; // 0x100003f38
    _printf("%d\n", v1);
    _printf("%c\n", (char)v1);
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

typedef struct { const char *s; int ln, bad; } rec_t;
int cmp_rec(const void *aa, const void *bb)
{
	const rec_t *a = aa, *b = bb;
	return a->s == b->s ? 0 : !a->s ? 1 : !b->s ? -1 : strncmp(a->s, b->s, 10);
}

int read_file(const char *fn)
{
	int fd = open(fn, O_RDONLY);
	if (fd == -1) return 0;

	struct stat s;
	fstat(fd, &s);

	char *txt = malloc(s.st_size);
	read(fd, txt, s.st_size);
	close(fd);

	int i, j, lines = 0, k, di, bad;
	for (i = lines = 0; i < s.st_size; i++)
		if (txt[i] == '\n') {
			txt[i] = '\0';
			lines++;
		}

	rec_t *rec = calloc(sizeof(rec_t), lines);
	const char *ptr, *end;
	rec[0].s = txt;
	rec[0].ln = 1;
	for (i = 0; i < lines; i++) {
		if (i + 1 < lines) {
			rec[i + 1].s = rec[i].s + strlen(rec[i].s) + 1;
			rec[i + 1].ln = i + 2;
		}
		if (sscanf(rec[i].s, "%4d-%2d-%2d", &di, &di, &di) != 3) {
			printf("bad line %d: %s\n", i, rec[i].s);
			rec[i].s = 0;
			continue;
		}
		ptr = rec[i].s + 10;

		for (j = k = 0; j < 25; j++) {
			if (!strtod(ptr, (char**)&end) && end == ptr) break;
			k++, ptr = end;
			if (!(di = strtol(ptr, (char**)&end, 10)) && end == ptr) break;
			k++, ptr = end;
			if (di < 1) rec[i].bad = 1;
		}

		if (k != 48) {
			printf("bad format at line %d: %s\n", i, rec[i].s);
			rec[i].s = 0;
		}
	}

	qsort(rec, lines, sizeof(rec_t), cmp_rec);
	for (i = 1, bad = rec[0].bad, j = 0; i < lines && rec[i].s; i++) {
		if (rec[i].bad) bad++;
		if (strncmp(rec[i].s, rec[j].s, 10)) {
			j = i;
		} else
			printf("dup line %d: %.10s\n", rec[i].ln, rec[i].s);
	}

	free(rec);
	free(txt);
	printf("\n%d out %d lines good\n", lines - bad, lines);
	return 0;
}

int main()
{
	read_file("readings.txt");
	return 0;
}
`,`#include "text-processing-2.h"



int _cmp_rec(long *param_1,long *param_2)

{
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  
  if (*param_1 == *param_2) {
    local_34 = 0;
  }
  else {
    if (*param_1 == 0) {
      local_38 = 1;
    }
    else {
      if (*param_2 == 0) {
        local_3c = -1;
      }
      else {
        local_3c = _strncmp((char *)*param_1,(char *)*param_2,10);
      }
      local_38 = local_3c;
    }
    local_34 = local_38;
  }
  return local_34;
}



undefined4 _read_file(char *param_1)

{
  bool bVar1;
  int iVar2;
  size_t sVar3;
  long lVar4;
  double dVar5;
  char *local_100;
  char *local_f8;
  undefined8 *local_f0;
  int local_e8;
  int local_e4;
  int local_e0;
  int local_dc;
  int local_d8;
  int local_d4;
  void *local_d0;
  stat sStack_c8;
  int local_34;
  char *local_30;
  
  local_30 = param_1;
  local_34 = _open(param_1,0);
  if (local_34 != -1) {
    _fstat(local_34,&sStack_c8);
    local_d0 = _malloc(sStack_c8.st_size);
    _read(local_34,local_d0,sStack_c8.st_size);
    _close(local_34);
    local_dc = 0;
    for (local_d4 = 0; local_d4 < sStack_c8.st_size; local_d4 = local_d4 + 1) {
      if (*(char *)((long)local_d0 + (long)local_d4) == '\n') {
        *(undefined *)((long)local_d0 + (long)local_d4) = 0;
        local_dc = local_dc + 1;
      }
    }
    local_f0 = (undefined8 *)_calloc(0x10,(long)local_dc);
    *local_f0 = local_d0;
    *(undefined4 *)(local_f0 + 1) = 1;
    for (local_d4 = 0; local_d4 < local_dc; local_d4 = local_d4 + 1) {
      if (local_d4 + 1 < local_dc) {
        lVar4 = local_f0[(long)local_d4 * 2];
        sVar3 = _strlen((char *)local_f0[(long)local_d4 * 2]);
        local_f0[(long)(local_d4 + 1) * 2] = lVar4 + sVar3 + 1;
        *(int *)(local_f0 + (long)(local_d4 + 1) * 2 + 1) = local_d4 + 2;
      }
      iVar2 = _sscanf((char *)local_f0[(long)local_d4 * 2],"%4d-%2d-%2d");
      if (iVar2 == 3) {
        local_f8 = (char *)(local_f0[(long)local_d4 * 2] + 10);
        local_e0 = 0;
        local_d8 = 0;
        while ((local_d8 < 0x19 &&
               ((dVar5 = _strtod(local_f8,&local_100), dVar5 != 0.0 || (local_100 != local_f8))))) {
          local_e0 = local_e0 + 1;
          local_f8 = local_100;
          lVar4 = _strtol(local_100,&local_100,10);
          local_e4 = (int)lVar4;
          if ((local_e4 == 0) && (local_100 == local_f8)) break;
          local_e0 = local_e0 + 1;
          local_f8 = local_100;
          if (local_e4 < 1) {
            *(undefined4 *)((long)local_f0 + (long)local_d4 * 0x10 + 0xc) = 1;
          }
          local_d8 = local_d8 + 1;
        }
        if (local_e0 != 0x30) {
          _printf("bad format at line %d: %s\n");
          local_f0[(long)local_d4 * 2] = 0;
        }
      }
      else {
        _printf("bad line %d: %s\n");
        local_f0[(long)local_d4 * 2] = 0;
      }
    }
    _qsort(local_f0,(long)local_dc,0x10,(int *)_cmp_rec);
    local_d4 = 1;
    local_e8 = *(int *)((long)local_f0 + 0xc);
    local_d8 = 0;
    while( true ) {
      bVar1 = false;
      if (local_d4 < local_dc) {
        bVar1 = local_f0[(long)local_d4 * 2] != 0;
      }
      if (!bVar1) break;
      if (*(int *)((long)local_f0 + (long)local_d4 * 0x10 + 0xc) != 0) {
        local_e8 = local_e8 + 1;
      }
      iVar2 = _strncmp((char *)local_f0[(long)local_d4 * 2],(char *)local_f0[(long)local_d8 * 2],10)
      ;
      if (iVar2 == 0) {
        _printf("dup line %d: %.10s\n");
      }
      else {
        local_d8 = local_d4;
      }
      local_d4 = local_d4 + 1;
    }
    _free(local_f0);
    _free(local_d0);
    _printf("\n%d out %d lines good\n");
  }
  return 0;
}



undefined4 entry(void)

{
  _read_file("readings.txt");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004028)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _read(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__read_100004040)(param_1);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004050)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strncmp(char *param_1,char *param_2,size_t param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strncmp_100004058)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _strtod(char *param_1,char **param_2)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__strtod_100004060)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _strtol(char *param_1,char **param_2,int param_3)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__strtol_100004068)(param_1,param_2,param_3);
  return lVar1;
}


`
`#include <stdio.h>
#include <stdint.h>

typedef uint32_t uint;
typedef uint64_t ulong;

ulong ipow(const uint x, const uint y) {
    ulong result = 1;
    for (uint i = 1; i <= y; i++)
        result *= x;
    return result;
}

uint min(const uint x, const uint y) {
    return (x < y) ? x : y;
}

void throw_die(const uint n_sides, const uint n_dice, const uint s, uint counts[]) {
    if (n_dice == 0) {
        counts[s]++;
        return;
    }

    for (uint i = 1; i < n_sides + 1; i++)
        throw_die(n_sides, n_dice - 1, s + i, counts);
}

double beating_probability(const uint n_sides1, const uint n_dice1,
                           const uint n_sides2, const uint n_dice2) {
    const uint len1 = (n_sides1 + 1) * n_dice1;
    uint C1[len1];
    for (uint i = 0; i < len1; i++)
        C1[i] = 0;
    throw_die(n_sides1, n_dice1, 0, C1);

    const uint len2 = (n_sides2 + 1) * n_dice2;
    uint C2[len2];
    for (uint j = 0; j < len2; j++)
        C2[j] = 0;
    throw_die(n_sides2, n_dice2, 0, C2);

    const double p12 = (double)(ipow(n_sides1, n_dice1) * ipow(n_sides2, n_dice2));

    double tot = 0;
    for (uint i = 0; i < len1; i++)
        for (uint j = 0; j < min(i, len2); j++)
            tot += (double)C1[i] * C2[j] / p12;
    return tot;
}

int main() {
    printf("%1.16f\n", beating_probability(4, 9, 6, 6));
    printf("%1.16f\n", beating_probability(10, 5, 7, 6));
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ad4(void);
int64_t function_100003b40(void);
int64_t function_100003b88(void);
int64_t function_100003c3c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ca4(void);
int64_t function_100003d4c(void);
int64_t function_100003f78(int64_t a1);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(int64_t a1);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ad4 - 0x100003b40
int64_t function_100003ad4(void) {
    // 0x100003ad4
    int64_t v1; // 0x100003ad4
    uint32_t v2 = (int32_t)v1; // 0x100003adc
    if (v2 <= 1 == (v2 != 1)) {
        // 0x100003b34
        return 1;
    }
    int32_t v3 = 1; // 0x100003b28
    int64_t result = 1; // 0x100003b18
    result *= (v1 & 0xffffffff);
    v3++;
    while (v3 >= v2 != v3 != v2) {
        // 0x100003b0c
        result *= (v1 & 0xffffffff);
        v3++;
    }
    // 0x100003b34
    return result;
}

// Address range: 0x100003b40 - 0x100003b88
int64_t function_100003b40(void) {
    // 0x100003b40
    int64_t v1; // 0x100003b40
    int64_t v2 = v1;
    int64_t v3 = v1;
    return ((int32_t)v3 < (int32_t)v2 ? v3 : v2) & 0xffffffff;
}

// Address range: 0x100003b88 - 0x100003c3c
int64_t function_100003b88(void) {
    // 0x100003b88
    int64_t v1; // 0x100003b88
    int64_t result; // 0x100003b88
    if ((int32_t)v1 == 0) {
        int32_t * v2 = (int32_t *)((4 * v1 & 0x3fffffffc) + v1); // 0x100003bc4
        *v2 = *v2 + 1;
        // 0x100003c30
        return result;
    }
    uint32_t v3 = (int32_t)v1 + 1; // 0x100003be8
    if (v3 <= 1) {
        // 0x100003c30
        return result;
    }
    int32_t v4 = 1; // 0x100003bf4
    v4++;
    result = function_100003b88();
    while (v4 != v3) {
        // 0x100003bfc
        v4++;
        result = function_100003b88();
    }
    // 0x100003c30
    return result;
}

// Address range: 0x100003c3c - 0x100003ca4
int64_t function_100003c3c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003c3c
    return ___chkstk_darwin(a1);
}

// Address range: 0x100003ca4 - 0x100003d4c
int64_t function_100003ca4(void) {
    // 0x100003ca4
    int64_t v1; // 0x100003ca4
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 - 104); // 0x100003cb4
    int64_t v4; // 0x100003ca4
    *v3 = (int64_t)&v4 - *(int64_t *)(v2 - 112);
    int32_t * v5 = (int32_t *)(v2 - 52); // 0x100003cbc
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v2 - 28); // 0x100003cc8
    if (*v6 != 0) {
        *(int32_t *)*v3 = 0;
        int32_t v7 = *v5 + 1; // 0x100003cf8
        *v5 = v7;
        while (v7 < *v6) {
            // 0x100003cdc
            *(int32_t *)(4 * (int64_t)v7 + *v3) = 0;
            v7 = *v5 + 1;
            *v5 = v7;
        }
    }
    int64_t v8 = function_100003b88(); // 0x100003d14
    uint32_t v9 = (*(int32_t *)(v2 - 20) + 1) * *(int32_t *)(v2 - 24); // 0x100003d24
    *(int32_t *)(v2 - 56) = v9;
    *(int64_t *)(v2 - 128) = 4 * (int64_t)v9 + 15 & 0x7fffffff0;
    return ___chkstk_darwin(v8);
}

// Address range: 0x100003d4c - 0x100003efc
int64_t function_100003d4c(void) {
    // 0x100003d4c
    int64_t v1; // 0x100003d4c
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 - 120); // 0x100003d5c
    int64_t v4; // 0x100003d4c
    *v3 = (int64_t)&v4 - *(int64_t *)(v2 - 128);
    int32_t * v5 = (int32_t *)(v2 - 68); // 0x100003d64
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v2 - 56); // 0x100003d70
    if (*v6 != 0) {
        *(int32_t *)*v3 = 0;
        int32_t v7 = *v5 + 1; // 0x100003da0
        *v5 = v7;
        while (v7 < *v6) {
            // 0x100003d84
            *(int32_t *)(4 * (int64_t)v7 + *v3) = 0;
            v7 = *v5 + 1;
            *v5 = v7;
        }
    }
    // 0x100003dac
    function_100003b88();
    int64_t v8 = function_100003ad4(); // 0x100003dc8
    int64_t * v9 = (int64_t *)(v2 - 136); // 0x100003dcc
    *v9 = v8;
    int64_t v10 = function_100003ad4(); // 0x100003dd8
    int64_t v11 = *v9; // 0x100003de0
    float64_t * v12 = (float64_t *)(v2 - 80); // 0x100003dec
    *v12 = (float64_t)(v11 * v10);
    int64_t v13 = v2 - 88; // 0x100003df4
    float64_t * v14 = (float64_t *)v13; // 0x100003df4
    *v14 = 0.0;
    int32_t * v15 = (int32_t *)(v2 - 92); // 0x100003df8
    *v15 = 0;
    int32_t * v16 = (int32_t *)(v2 - 28); // 0x100003e04
    int64_t v17 = v11; // 0x100003e10
    if (*v16 != 0) {
        int32_t * v18 = (int32_t *)(v2 - 96); // 0x100003e18
        int32_t * v19 = (int32_t *)(v2 - 140); // 0x100003e24
        float64_t v20 = 0.0;
        *v18 = 0;
        *v19 = 0;
        int64_t v21 = function_100003b40(); // 0x100003e30
        float64_t v22 = v20; // 0x100003e40
        float64_t v23; // 0x100003d4c
        float64_t v24 = v23; // 0x100003e40
        float64_t v25 = v23; // 0x100003e40
        float64_t v26 = v20; // 0x100003e40
        int64_t v27 = v21; // 0x100003e40
        float64_t v28; // 0x100003e78
        float64_t v29; // 0x100003e80
        int32_t v30; // 0x100003e90
        int64_t v31; // 0x100003e30
        if (*v19 < (int32_t)v21) {
            v28 = v22 * v24 / *v12;
            v29 = *v14 + v28;
            *v14 = v29;
            v30 = *v18 + 1;
            *v18 = v30;
            *v19 = v30;
            v31 = function_100003b40();
            v24 = v28;
            v25 = v28;
            v26 = v29;
            v27 = v31;
            while (*v19 < (int32_t)v31) {
                // 0x100003e48
                v28 = v29 * v24 / *v12;
                v29 = *v14 + v28;
                *v14 = v29;
                v30 = *v18 + 1;
                *v18 = v30;
                *v19 = v30;
                v31 = function_100003b40();
                v24 = v28;
                v25 = v28;
                v26 = v29;
                v27 = v31;
            }
        }
        // 0x100003ea0
        v20 = v26;
        uint32_t v32 = *v15 + 1; // 0x100003ea4
        *v15 = v32;
        v23 = v25;
        v17 = v27;
        while (v32 < *v16) {
            // 0x100003e18
            *v18 = 0;
            *v19 = 0;
            v21 = function_100003b40();
            v22 = v20;
            v24 = v23;
            v25 = v23;
            v26 = v20;
            v27 = v21;
            if (*v19 < (int32_t)v21) {
                v28 = v22 * v24 / *v12;
                v29 = *v14 + v28;
                *v14 = v29;
                v30 = *v18 + 1;
                *v18 = v30;
                *v19 = v30;
                v31 = function_100003b40();
                v24 = v28;
                v25 = v28;
                v26 = v29;
                v27 = v31;
                while (*v19 < (int32_t)v31) {
                    // 0x100003e48
                    v28 = v29 * v24 / *v12;
                    v29 = *v14 + v28;
                    *v14 = v29;
                    v30 = *v18 + 1;
                    *v18 = v30;
                    *v19 = v30;
                    v31 = function_100003b40();
                    v24 = v28;
                    v25 = v28;
                    v26 = v29;
                    v27 = v31;
                }
            }
            // 0x100003ea0
            v20 = v26;
            v32 = *v15 + 1;
            *v15 = v32;
            v23 = v25;
            v17 = v27;
        }
    }
    // 0x100003eb0
    *(int64_t *)(v2 - 160) = *(int64_t *)v13;
    *(int64_t *)(v2 - 152) = *(int64_t *)(v2 - 40);
    int64_t result = v17; // 0x100003ed8
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003ee0
        result = ___stack_chk_fail(v17);
    }
    // 0x100003ee4
    return result;
}

// Address range: 0x100003efc - 0x100003f78
int64_t entry_point(void) {
    // 0x100003efc
    function_100003c3c(4, 9, 6, 6);
    int128_t v1; // 0x100003efc
    _printf("%1.16f\n", (float64_t)(int64_t)v1);
    function_100003c3c(10, 5, 7, 6);
    _printf("%1.16f\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t function_100003f78(int64_t a1) {
    // 0x100003f78
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

// can be any swap function. This swap is optimized for numbers.
void swap(int *x, int *y) {
	if(x == y)
		return;
	*x ^= *y;
	*y ^= *x;
	*x ^= *y;
}
void cocktailsort(int *a, size_t n) {
	while(1) {
		// packing two similar loops into one
		char flag;
		size_t start[2] = {1, n - 1},
			   end[2] = {n, 0},
			   inc[2] = {1, -1};
		for(int it = 0; it < 2; ++it) {
			flag = 1;
			for(int i = start[it]; i != end[it]; i += inc[it])
				if(a[i - 1] > a[i]) {
					swap(a + i - 1, a + i);
					flag = 0;
				}
			if(flag)
				return;
		}
	}
}

int main(void) {
	int a[] = { 5, -1, 101, -4, 0, 1, 8, 6, 2, 3 };
	size_t n = sizeof(a)/sizeof(a[0]);

	cocktailsort(a, n);
	for (size_t i = 0; i < n; ++i)
		printf("%d ", a[i]);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c68(void);
int64_t function_100003ce4(void);
int64_t function_100003f3c(int64_t a1);
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.94065645841246544176568792868221372e-324L; // 0x100003f60
int64_t g2 = -0xfffffffb; // 0x100003f70

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c68 - 0x100003ce4
int64_t function_100003c68(void) {
    // 0x100003c68
    int64_t result; // 0x100003c68
    // 0x100003cdc
    return result;
}

// Address range: 0x100003ce4 - 0x100003e64
int64_t function_100003ce4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cf8
    int64_t v2; // bp-40, 0x100003ce4
    int64_t v3 = &v2; // 0x100003d64
    float128_t v4; // bp-80, 0x100003ce4
    int64_t v5 = &v4;
    int64_t v6; // 0x100003ce4
    while (true) {
      lab_0x100003d0c:
        // 0x100003d0c
        v2 = 1;
        v4 = g1;
        int64_t v7 = 0;
        int32_t v8 = 0; // 0x100003ce4
        int64_t v9; // 0x100003ce4
        int64_t v10 = v9; // 0x100003ce4
        while (true) {
          lab_0x100003d58:;
            int64_t v11 = v7;
            int64_t v12 = 8 * v11; // 0x100003d68
            int64_t v13 = *(int64_t *)(v12 + v3); // 0x100003d68
            int64_t v14 = 0x100000000 * v13 >> 32; // 0x100003d74
            int64_t v15; // bp-56, 0x100003ce4
            int64_t * v16 = (int64_t *)(v12 + (int64_t)&v15); // 0x100003d80
            int64_t v17 = *v16; // 0x100003d80
            v6 = v10;
            if (v17 == v14) {
                // break (via goto) -> 0x100003e1c
                goto lab_0x100003e1c_2;
            }
            int32_t v18 = v8;
            int32_t v19 = v13; // 0x100003e00
            int64_t v20; // 0x100003ce4
            int32_t v21 = *(int32_t *)(v20 + (int64_t)(4 * v19 - 4)); // 0x100003da0
            int32_t v22 = *(int32_t *)(4 * v14 + v20); // 0x100003dac
            int32_t v23 = v21 - v22; // 0x100003db0
            int64_t v24 = v17; // 0x100003db8
            int32_t v25 = 1; // 0x100003db8
            int64_t v26 = v10; // 0x100003db8
            if (v23 != 0 && v23 < 0 == ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                // 0x100003dc0
                v26 = function_100003c68();
                v24 = *v16;
                v25 = 0;
            }
            int64_t v27 = v26;
            int32_t v28 = v25;
            int64_t v29 = v24; // 0x100003d80
            v19 += (int32_t)*(int64_t *)(v12 + v5);
            int64_t v30 = v19; // 0x100003d74
            while (v29 != v30) {
                // 0x100003d94
                v21 = *(int32_t *)(v20 + (int64_t)(4 * v19 - 4));
                v22 = *(int32_t *)(4 * v30 + v20);
                v23 = v21 - v22;
                v24 = v29;
                v25 = v28;
                v26 = v27;
                if (v23 != 0 && v23 < 0 == ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                    // 0x100003dc0
                    v26 = function_100003c68();
                    v24 = *v16;
                    v25 = 0;
                }
                // 0x100003dec
                v27 = v26;
                v28 = v25;
                v29 = v24;
                v19 += (int32_t)*(int64_t *)(v12 + v5);
                v30 = v19;
            }
            // 0x100003e08
            v6 = v27;
            if (v28 % 256 != 0) {
                // break (via goto) -> 0x100003e1c
                goto lab_0x100003e1c_2;
            }
            // 0x100003d44
            v7 = v11 + 1;
            v9 = v27;
            v8 = v18 + 1;
            v10 = v27;
            if (v11 == 0 == ((int32_t)v7 & -v18) < 0) {
                goto lab_0x100003d0c;
            } else {
                goto lab_0x100003d58;
            }
        }
    }
  lab_0x100003e1c_2:;
    int64_t result = v6; // 0x100003e34
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e3c
        result = ___stack_chk_fail(v6);
    }
    // 0x100003e40
    return result;
}

// Address range: 0x100003e64 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003e64
    int64_t v1; // bp-64, 0x100003e64
    _memcpy(&v1, &g2, 40);
    function_100003ce4();
    int32_t v2; // 0x100003ef0
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003ed0
        v2 = _printf("%d ", 10);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f14
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f28
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(int64_t a1) {
    // 0x100003f3c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f48
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`   #include<stdlib.h>
   #include<ctype.h>
   #include<stdio.h>

   int** oddMagicSquare(int n) {
        if (n < 3 || n % 2 == 0)
            return NULL;

        int value = 0;
        int squareSize = n * n;
        int c = n / 2, r = 0,i;

        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        while (++value <= squareSize) {
            result[r][c] = value;
            if (r == 0) {
                if (c == n - 1) {
                    r++;
                } else {
                    r = n - 1;
                    c++;
                }
            } else if (c == n - 1) {
                r--;
                c = 0;
            } else if (result[r - 1][c + 1] == 0) {
                r--;
                c++;
            } else {
                r++;
            }
        }
        return result;
    }

    int** singlyEvenMagicSquare(int n) {
        if (n < 6 || (n - 2) % 4 != 0)
            return NULL;

        int size = n * n;
        int halfN = n / 2;
        int subGridSize = size / 4, i;

        int** subGrid = oddMagicSquare(halfN);
        int gridFactors[] = {0, 2, 3, 1};
        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                int grid = (r / halfN) * 2 + (c / halfN);
                result[r][c] = subGrid[r % halfN][c % halfN];
                result[r][c] += gridFactors[grid] * subGridSize;
            }
        }

        int nColsLeft = halfN / 2;
        int nColsRight = nColsLeft - 1;

        for (int r = 0; r < halfN; r++)
            for (int c = 0; c < n; c++) {
                if (c < nColsLeft || c >= n - nColsRight
                        || (c == nColsLeft && r == nColsLeft)) {

                    if (c == 0 && r == nColsLeft)
                        continue;

                    int tmp = result[r][c];
                    result[r][c] = result[r + halfN][c];
                    result[r + halfN][c] = tmp;
                }
            }

        return result;
    }
	
	int numDigits(int n){
		int count = 1;
		
		while(n>=10){
			n /= 10;
			count++;
		}
		
		return count;
	}
	
	void printMagicSquare(int** square,int rows){
		int i,j;
		
		for(i=0;i<rows;i++){
			for(j=0;j<rows;j++){
				printf("%*s%d",rows - numDigits(square[i][j]),"",square[i][j]);
			}
			printf("\n");
		}
		printf("\nMagic constant: %d ", (rows * rows + 1) * rows / 2);
	}
	
	int main(int argC,char* argV[])
	{
		int n;
		
		if(argC!=2||isdigit(argV[1][0])==0)
			printf("Usage : %s <integer specifying rows in magic square>",argV[0]);
		else{
			n = atoi(argV[1]);
			printMagicSquare(singlyEvenMagicSquare(n),n);
		}
		return 0;
	}
`,`#include "magic-squares-of-singly-even-order.h"



void * _oddMagicSquare(int param_1)

{
  void *pvVar1;
  int local_30;
  int local_2c;
  int local_28;
  int local_20;
  void *local_18;
  
  if ((param_1 < 3) || (param_1 % 2 == 0)) {
    local_18 = (void *)0x0;
  }
  else {
    local_20 = 0;
    local_28 = param_1 / 2;
    local_2c = 0;
    local_18 = _malloc((long)param_1 << 3);
    for (local_30 = 0; local_30 < param_1; local_30 = local_30 + 1) {
      pvVar1 = _malloc((long)param_1 << 2);
      *(void **)((long)local_18 + (long)local_30 * 8) = pvVar1;
    }
    while (local_20 = local_20 + 1, local_20 <= param_1 * param_1) {
      *(int *)(*(long *)((long)local_18 + (long)local_2c * 8) + (long)local_28 * 4) = local_20;
      if (local_2c == 0) {
        if (local_28 == param_1 + -1) {
          local_2c = 1;
        }
        else {
          local_2c = param_1 + -1;
          local_28 = local_28 + 1;
        }
      }
      else if (local_28 == param_1 + -1) {
        local_2c = local_2c + -1;
        local_28 = 0;
      }
      else if (*(int *)(*(long *)((long)local_18 + (long)(local_2c + -1) * 8) +
                       (long)(local_28 + 1) * 4) == 0) {
        local_2c = local_2c + -1;
        local_28 = local_28 + 1;
      }
      else {
        local_2c = local_2c + 1;
      }
    }
  }
  return local_18;
}



void * _singlyEvenMagicSquare(int param_1)

{
  int *piVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  long lVar8;
  void *pvVar9;
  int local_7c;
  int local_78;
  int local_68;
  int local_64;
  int local_4c;
  void *local_38;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  if ((param_1 < 6) || ((param_1 + -2) % 4 != 0)) {
    local_38 = (void *)0x0;
  }
  else {
    iVar3 = param_1 / 2;
    lVar8 = _oddMagicSquare(iVar3);
    local_30[2] = 3;
    local_30[3] = 1;
    local_30[0] = 0;
    local_30[1] = 2;
    local_38 = _malloc((long)param_1 << 3);
    for (local_4c = 0; local_4c < param_1; local_4c = local_4c + 1) {
      pvVar9 = _malloc((long)param_1 << 2);
      *(void **)((long)local_38 + (long)local_4c * 8) = pvVar9;
    }
    for (local_64 = 0; local_64 < param_1; local_64 = local_64 + 1) {
      for (local_68 = 0; local_68 < param_1; local_68 = local_68 + 1) {
        iVar4 = 0;
        if (iVar3 != 0) {
          iVar4 = local_64 / iVar3;
        }
        iVar5 = 0;
        if (iVar3 != 0) {
          iVar5 = local_68 / iVar3;
        }
        iVar6 = 0;
        if (iVar3 != 0) {
          iVar6 = local_64 / iVar3;
        }
        iVar7 = 0;
        if (iVar3 != 0) {
          iVar7 = local_68 / iVar3;
        }
        *(undefined4 *)(*(long *)((long)local_38 + (long)local_64 * 8) + (long)local_68 * 4) =
             *(undefined4 *)
              (*(long *)(lVar8 + (long)(local_64 - iVar6 * iVar3) * 8) +
              (long)(local_68 - iVar7 * iVar3) * 4);
        piVar1 = (int *)(*(long *)((long)local_38 + (long)local_64 * 8) + (long)local_68 * 4);
        *piVar1 = *piVar1 + local_30[iVar5 + iVar4 * 2] * ((param_1 * param_1) / 4);
      }
    }
    iVar4 = iVar3 / 2;
    for (local_78 = 0; local_78 < iVar3; local_78 = local_78 + 1) {
      for (local_7c = 0; local_7c < param_1; local_7c = local_7c + 1) {
        if ((((local_7c < iVar4) || (param_1 - (iVar4 + -1) <= local_7c)) ||
            ((local_7c == iVar4 && (local_78 == iVar4)))) &&
           ((local_7c != 0 || (local_78 != iVar4)))) {
          uVar2 = *(undefined4 *)
                   (*(long *)((long)local_38 + (long)local_78 * 8) + (long)local_7c * 4);
          *(undefined4 *)(*(long *)((long)local_38 + (long)local_78 * 8) + (long)local_7c * 4) =
               *(undefined4 *)
                (*(long *)((long)local_38 + (long)(local_78 + iVar3) * 8) + (long)local_7c * 4);
          *(undefined4 *)
           (*(long *)((long)local_38 + (long)(local_78 + iVar3) * 8) + (long)local_7c * 4) = uVar2;
        }
      }
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_38;
}



int _numDigits(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 1;
  for (local_4 = param_1; 9 < local_4; local_4 = local_4 / 10) {
    local_8 = local_8 + 1;
  }
  return local_8;
}



int _printMagicSquare(long param_1,int param_2)

{
  int iVar1;
  int local_24;
  int local_20;
  
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
      _numDigits(*(undefined4 *)(*(long *)(param_1 + (long)local_20 * 8) + (long)local_24 * 4));
      _printf("%*s%d");
    }
    _printf("\n");
  }
  iVar1 = _printf("\nMagic constant: %d ");
  return iVar1;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if ((param_1 == 2) && (iVar1 = _isdigit((int)**(char **)(param_2 + 8)), iVar1 != 0)) {
    iVar1 = _atoi(*(char **)(param_2 + 8));
    uVar2 = _singlyEvenMagicSquare(iVar1);
    _printMagicSquare(uVar2,iVar1);
  }
  else {
    _printf("Usage : %s <integer specifying rows in magic square>");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isdigit(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isdigit_100004018)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void quicksort(int *A, int len);

int main (void) {
  int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
  int n = sizeof a / sizeof a[0];

  int i;
  for (i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("\n");

  quicksort(a, n);

  for (i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("\n");

  return 0;
}

void quicksort(int *A, int len) {
  if (len < 2) return;

  int pivot = A[len / 2];

  int i, j;
  for (i = 0, j = len - 1; ; i++, j--) {
    while (A[i] < pivot) i++;
    while (A[j] > pivot) j--;

    if (i >= j) break;

    int temp = A[i];
    A[i]     = A[j];
    A[j]     = temp;
  }

  quicksort(A, i);
  quicksort(A + i, len - i);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003de8(void);
int64_t function_100003f54(int64_t a1);
int64_t * function_100003f60(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f6c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4100000004; // 0x100003f78

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca4 - 0x100003de8
int64_t entry_point(void) {
    // 0x100003ca4
    int64_t v1; // bp-64, 0x100003ca4
    _memcpy(&v1, &g1, 40);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003d00
        _printf("%d ", (int64_t)&g1);
    }
    // 0x100003d38
    _printf((char *)0x100003fa4);
    function_100003de8();
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003d70
        _printf("%d ", 10);
    }
    int32_t v2 = _printf("\n"); // 0x100003db0
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc0
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003dd4
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003dd8
    return 0;
}

// Address range: 0x100003de8 - 0x100003f54
int64_t function_100003de8(void) {
    // 0x100003de8
    int64_t v1; // 0x100003de8
    int32_t v2 = v1; // 0x100003df8
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003f48
        int64_t result; // 0x100003de8
        return result;
    }
    int32_t v3 = *(int32_t *)(v1 + (int64_t)(4 * v2 / 2)); // 0x100003e24
    int32_t v4 = 0; // 0x100003e3c
    int32_t v5 = v2; // 0x100003e3c
    int32_t v6; // 0x100003de8
    int32_t v7; // 0x100003de8
    int32_t * v8; // 0x100003de8
    int32_t v9; // 0x100003e4c
    while (true) {
      lab_0x100003e40:
        // 0x100003e40
        while (true) {
            // 0x100003e44
            v6 = v4;
            v8 = (int32_t *)(4 * (int64_t)v6 + v1);
            v9 = *v8;
            int32_t v10 = v9 - v3; // 0x100003e54
            v4 = v6 + 1;
            v7 = v5;
            if (v10 < 0 == ((v10 ^ v9) & (v9 ^ v3)) < 0) {
                goto lab_0x100003e78;
            }
        }
        goto lab_0x100003ea8;
    }
  lab_0x100003f1c:
    // 0x100003f1c
    function_100003de8();
    // 0x100003f48
    return function_100003de8();
  lab_0x100003e78:
    // 0x100003e78
    v5 = v7 - 1;
    int32_t * v11 = (int32_t *)(4 * (int64_t)v5 + v1);
    int32_t v12 = *v11; // 0x100003e80
    int32_t v13 = v12 - v3; // 0x100003e88
    v7 = v5;
    if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v3)) < 0) {
        goto lab_0x100003ea8;
    } else {
        goto lab_0x100003e78;
    }
  lab_0x100003ea8:;
    int32_t v14 = v6 - v5; // 0x100003eb0
    if (v14 < 0 == ((v14 ^ v6) & (v5 ^ v6)) < 0) {
        // break -> 0x100003f1c
        goto lab_0x100003f1c;
    }
    // 0x100003ec4
    *v8 = v12;
    *v11 = v9;
    goto lab_0x100003e40;
}

// Address range: 0x100003f54 - 0x100003f60
int64_t function_100003f54(int64_t a1) {
    // 0x100003f54
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t * function_100003f60(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f60
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

struct RealSet {
    bool(*contains)(struct RealSet*, struct RealSet*, double);
    struct RealSet *left;
    struct RealSet *right;
    double low, high;
};

typedef enum {
    CLOSED,
    LEFT_OPEN,
    RIGHT_OPEN,
    BOTH_OPEN,
} RangeType;

double length(struct RealSet *self) {
    const double interval = 0.00001;
    double p = self->low;
    int count = 0;

    if (isinf(self->low) || isinf(self->high)) return -1.0;
    if (self->high <= self->low) return 0.0;

    do {
        if (self->contains(self, NULL, p)) count++;
        p += interval;
    } while (p < self->high);
    return count * interval;
}

bool empty(struct RealSet *self) {
    if (self->low == self->high) {
        return !self->contains(self, NULL, self->low);
    }
    return length(self) == 0.0;
}

static bool contains_closed(struct RealSet *self, struct RealSet *_, double d) {
    return self->low <= d && d <= self->high;
}

static bool contains_left_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low < d && d <= self->high;
}

static bool contains_right_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low <= d && d < self->high;
}

static bool contains_both_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low < d && d < self->high;
}

static bool contains_intersect(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) && self->right->contains(self->right, NULL, d);
}

static bool contains_union(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) || self->right->contains(self->right, NULL, d);
}

static bool contains_subtract(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) && !self->right->contains(self->right, NULL, d);
}

struct RealSet* makeSet(double low, double high, RangeType type) {
    bool(*contains)(struct RealSet*, struct RealSet*, double);
    struct RealSet *rs;

    switch (type) {
    case CLOSED:
        contains = contains_closed;
        break;
    case LEFT_OPEN:
        contains = contains_left_open;
        break;
    case RIGHT_OPEN:
        contains = contains_right_open;
        break;
    case BOTH_OPEN:
        contains = contains_both_open;
        break;
    default:
        return NULL;
    }

    rs = malloc(sizeof(struct RealSet));
    rs->contains = contains;
    rs->left = NULL;
    rs->right = NULL;
    rs->low = low;
    rs->high = high;
    return rs;
}

struct RealSet* makeIntersect(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_intersect;
    rs->left = left;
    rs->right = right;
    rs->low = fmin(left->low, right->low);
    rs->high = fmin(left->high, right->high);
    return rs;
}

struct RealSet* makeUnion(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_union;
    rs->left = left;
    rs->right = right;
    rs->low = fmin(left->low, right->low);
    rs->high = fmin(left->high, right->high);
    return rs;
}

struct RealSet* makeSubtract(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_subtract;
    rs->left = left;
    rs->right = right;
    rs->low = left->low;
    rs->high = left->high;
    return rs;
}

int main() {
    struct RealSet *a = makeSet(0.0, 1.0, LEFT_OPEN);
    struct RealSet *b = makeSet(0.0, 2.0, RIGHT_OPEN);
    struct RealSet *c = makeSet(1.0, 2.0, LEFT_OPEN);
    struct RealSet *d = makeSet(0.0, 3.0, RIGHT_OPEN);
    struct RealSet *e = makeSet(0.0, 1.0, BOTH_OPEN);
    struct RealSet *f = makeSet(0.0, 1.0, CLOSED);
    struct RealSet *g = makeSet(0.0, 0.0, CLOSED);
    int i;

    for (i = 0; i < 3; ++i) {
        struct RealSet *t;

        t = makeUnion(a, b);
        printf("(0, 1]   union   [0, 2) contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeIntersect(b, c);
        printf("[0, 2) intersect (1, 2] contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeSubtract(d, e);
        printf("[0, 3)     -     (0, 1) contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeSubtract(d, f);
        printf("[0, 3)     -     [0, 1] contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        printf("\n");
    }

    printf("[0, 0] is empty %d\n", empty(g));

    free(a);
    free(b);
    free(c);
    free(d);
    free(e);
    free(f);
    free(g);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_1000032c4(void);
int64_t function_1000034b4(int32_t a1, float64_t a2);
int64_t function_100003524(int32_t a1);
int64_t function_100003534(void);
int64_t function_1000035cc(int64_t a1);
int64_t function_1000036d0(void);
int64_t function_100003730(void);
int64_t function_100003790(void);
int64_t function_1000037f0(void);
int64_t function_100003850(int64_t a1, int64_t a2);
int64_t function_1000038e0(void);
int64_t function_100003918(float64_t a1);
int64_t function_100003964(int64_t a1, int64_t a2);
int64_t function_1000039f4(void);
int64_t function_100003a2c(float64_t a1);
int64_t function_100003a78(int64_t a1, int64_t a2);
int64_t function_100003af0(void);
int64_t function_100003b28(float64_t a1);
void function_100003e9c(int64_t * ptr);
int64_t * function_100003ea8(int32_t size);
int32_t function_100003eb4(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0e-5; // 0x100003ec0
float64_t g2 = INFINITY; // 0x100003ec8

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000032c4 - 0x1000034b4
int64_t function_1000032c4(void) {
    // 0x1000032c4
    int64_t result; // 0x1000032c4
    float64_t v1 = *(float64_t *)(result + 24); // 0x100003344
    if (fabs(v1) == g2) {
        // 0x100003460
        return function_100003524(0);
    }
    float64_t v2 = *(float64_t *)(result + 32); // 0x1000033fc
    if (fabs(v2) == g2) {
        // 0x100003460
        return function_100003524(0);
    }
    if (v2 <= v1 == (v2 != v1)) {
        // 0x10000349c
        return result;
    }
    // 0x10000348c
    return function_100003524(0);
}

// Address range: 0x1000034b4 - 0x100003524
int64_t function_1000034b4(int32_t a1, float64_t a2) {
    // 0x1000034b4
    __asm_sshll(0.0f, 0);
    return function_100003524((int32_t)(float32_t)((g1 + a2) * g1));
}

// Address range: 0x100003524 - 0x100003534
int64_t function_100003524(int32_t a1) {
    // 0x100003524
    int64_t result; // 0x100003524
    return result;
}

// Address range: 0x100003534 - 0x1000035cc
int64_t function_100003534(void) {
    // 0x100003534
    int64_t v1; // 0x100003534
    float64_t v2 = *(float64_t *)(v1 + 24); // 0x100003548
    int64_t result; // 0x100003534
    if (v2 != *(float64_t *)(v1 + 32)) {
        // 0x100003598
        function_1000032c4();
        result = v2 == 0.0;
    }
    // 0x100003564
    return result;
}

// Address range: 0x1000035cc - 0x1000036c0
int64_t function_1000035cc(int64_t a1) {
    // 0x1000035cc
    int64_t v1; // 0x1000035cc
    uint64_t v2 = v1 & 0xffffffff; // 0x1000035ec
    return v2 >= 3 == (v2 != 3) ? 0 : v1;
}

// Address range: 0x1000036d0 - 0x100003730
int64_t function_1000036d0(void) {
    // 0x1000036d0
    float64_t v1; // 0x1000036d0
    float64_t v2 = v1;
    int64_t v3; // 0x1000036d0
    float64_t v4 = *(float64_t *)(v3 + 24); // 0x1000036e4
    int64_t result = 0; // 0x1000036fc
    if (v4 <= v2 != v4 != v2) {
        float64_t v5 = *(float64_t *)(v3 + 32); // 0x10000370c
        result = v2 == v5 | v2 > v5;
    }
    // 0x100003720
    return result;
}

// Address range: 0x100003730 - 0x100003790
int64_t function_100003730(void) {
    // 0x100003730
    float64_t v1; // 0x100003730
    float64_t v2 = v1;
    int64_t result = 0; // 0x10000374c
    int64_t v3; // 0x100003730
    if (*(float64_t *)(v3 + 24) > v2) {
        float64_t v4 = *(float64_t *)(v3 + 32); // 0x10000376c
        result = v2 == v4 | v2 > v4;
    }
    // 0x100003780
    return result;
}

// Address range: 0x100003790 - 0x1000037f0
int64_t function_100003790(void) {
    // 0x100003790
    float64_t v1; // 0x100003790
    float64_t v2 = v1;
    int64_t v3; // 0x100003790
    float64_t v4 = *(float64_t *)(v3 + 24); // 0x1000037a4
    int64_t result = 0; // 0x1000037bc
    if (v4 <= v2 != v4 != v2) {
        // 0x1000037c4
        result = v2 > *(float64_t *)(v3 + 32);
    }
    // 0x1000037e0
    return result;
}

// Address range: 0x1000037f0 - 0x100003850
int64_t function_1000037f0(void) {
    int64_t result = 0; // 0x10000380c
    int64_t v1; // 0x1000037f0
    float64_t v2; // 0x1000037f0
    if (*(float64_t *)(v1 + 24) > v2) {
        // 0x100003824
        result = v2 > *(float64_t *)(v1 + 32);
    }
    // 0x100003840
    return result;
}

// Address range: 0x100003850 - 0x1000038e0
int64_t function_100003850(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(40); // 0x100003868
    int64_t result = (int64_t)v1; // 0x100003868
    *v1 = 0x1000038e0;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    float64_t v2 = llvm_minnum_f64(*(float64_t *)(a1 + 24), *(float64_t *)(a2 + 24)); // 0x1000038a8
    *(float64_t *)(result + 24) = v2;
    float64_t v3 = llvm_minnum_f64(*(float64_t *)(a1 + 32), *(float64_t *)(a2 + 32)); // 0x1000038c4
    *(float64_t *)(result + 32) = v3;
    return result;
}

// Address range: 0x1000038e0 - 0x100003918
int64_t function_1000038e0(void) {
    // 0x1000038e0
    int64_t v1; // 0x1000038e0
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003918 - 0x100003964
int64_t function_100003918(float64_t a1) {
    // 0x100003918
    int64_t v1; // 0x100003918
    if (v1 % 2 == 0) {
        // 0x100003950
        return 0;
    }
    // 0x100003928
    return *(int64_t *)(*(int64_t *)(v1 - 8) + 16);
}

// Address range: 0x100003964 - 0x1000039f4
int64_t function_100003964(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(40); // 0x10000397c
    int64_t result = (int64_t)v1; // 0x10000397c
    *v1 = 0x1000039f4;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    float64_t v2 = llvm_minnum_f64(*(float64_t *)(a1 + 24), *(float64_t *)(a2 + 24)); // 0x1000039bc
    *(float64_t *)(result + 24) = v2;
    float64_t v3 = llvm_minnum_f64(*(float64_t *)(a1 + 32), *(float64_t *)(a2 + 32)); // 0x1000039d8
    *(float64_t *)(result + 32) = v3;
    return result;
}

// Address range: 0x1000039f4 - 0x100003a2c
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003a2c - 0x100003a78
int64_t function_100003a2c(float64_t a1) {
    // 0x100003a2c
    int64_t v1; // 0x100003a2c
    if (v1 % 2 == 0) {
        // 0x100003a3c
        return *(int64_t *)(*(int64_t *)(v1 - 8) + 16);
    }
    // 0x100003a64
    return 1;
}

// Address range: 0x100003a78 - 0x100003af0
int64_t function_100003a78(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(40); // 0x100003a90
    int64_t result = (int64_t)v1; // 0x100003a90
    *v1 = 0x100003af0;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    *(int64_t *)(result + 24) = *(int64_t *)(a1 + 24);
    *(int64_t *)(result + 32) = *(int64_t *)(a1 + 32);
    return result;
}

// Address range: 0x100003af0 - 0x100003b28
int64_t function_100003af0(void) {
    // 0x100003af0
    int64_t v1; // 0x100003af0
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003b28 - 0x100003b78
int64_t function_100003b28(float64_t a1) {
    // 0x100003b28
    int64_t v1; // 0x100003b28
    if (v1 % 2 == 0) {
        // 0x100003b64
        return 0;
    }
    // 0x100003b38
    return *(int64_t *)(*(int64_t *)(v1 - 8) + 16);
}

// Address range: 0x100003b78 - 0x100003e9c
int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = function_1000035cc(1); // 0x100003ba8
    int64_t v2 = function_1000035cc(0x4000000000000000); // 0x100003bc4
    int64_t v3 = function_1000035cc(v2); // 0x100003bdc
    int64_t v4 = function_1000035cc(function_1000035cc(v3)); // 0x100003c08
    function_1000035cc(function_1000035cc(v4));
    int64_t result = function_100003964(v1, v2); // 0x100003c64
    __asm_sshll(0.0f, 0);
    return result;
}

// Address range: 0x100003e9c - 0x100003ea8
void function_100003e9c(int64_t * ptr) {
    // 0x100003e9c
    _free(ptr);
}

// Address range: 0x100003ea8 - 0x100003eb4
int64_t * function_100003ea8(int32_t size) {
    // 0x100003ea8
    return _malloc(size);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(char * format, ...) {
    // 0x100003eb4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 22

`
`#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

typedef int bool;

void sieve(int limit, int primes[], int *count) {
    bool *c = calloc(limit + 1, sizeof(bool)); /* composite = TRUE */
    /* no need to process even numbers */
    int i, p = 3, p2, n = 0;
    p2 = p * p;
    while (p2 <= limit) {
        for (i = p2; i <= limit; i += 2 * p)
            c[i] = TRUE;
        do {
            p += 2;
        } while (c[p]);
        p2 = p * p;
    }
    for (i = 3; i <= limit; i += 2) {
        if (!c[i]) primes[n++] = i;
    }
    *count = n;
    free(c);
}

/* finds the period of the reciprocal of n */
int findPeriod(int n) {
    int i, r = 1, rr, period = 0;
    for (i = 1; i <= n + 1; ++i) {
        r = (10 * r) % n;
    }
    rr = r;
    do {
        r = (10 * r) % n;
        period++;
    } while (r != rr);
    return period;
}

int main() {
    int i, prime, count = 0, index = 0, primeCount, longCount = 0, numberCount;
    int *primes, *longPrimes, *totals;
    int numbers[] = {500, 1000, 2000, 4000, 8000, 16000, 32000, 64000};

    primes = calloc(6500, sizeof(int));
    numberCount = sizeof(numbers) / sizeof(int);
    totals = calloc(numberCount, sizeof(int));
    sieve(64000, primes, &primeCount);
    longPrimes = calloc(primeCount, sizeof(int));
    /* Surely longCount < primeCount */
    for (i = 0; i < primeCount; ++i) {
        prime = primes[i];
        if (findPeriod(prime) == prime - 1) {
            longPrimes[longCount++] = prime;
        }
    }
    for (i = 0; i < longCount; ++i, ++count) {
        if (longPrimes[i] > numbers[index]) {
            totals[index++] = count;
        }
    }
    totals[numberCount - 1] = count;
    printf("The long primes up to %d are:\n", numbers[0]);
    printf("[");
    for (i = 0; i < totals[0]; ++i) {
        printf("%d ", longPrimes[i]);
    }
    printf("\b]\n");

    printf("\nThe number of long primes up to:\n");
    for (i = 0; i < 8; ++i) {
        printf("  %5d is %d\n", numbers[i], totals[i]);
    }
    free(totals);
    free(longPrimes);
    free(primes);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003990(void);
int64_t function_100003b28(void);
int64_t function_100003ef4(int64_t a1);
int64_t * function_100003f00(int32_t nmemb, int32_t size);
void function_100003f0c(int64_t * ptr);
int32_t function_100003f18(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.12199579121230513803200548695149323e-311L; // 0x100003f24
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003990 - 0x100003b28
int64_t function_100003990(void) {
    // 0x100003990
    int64_t v1; // 0x100003990
    int32_t v2 = v1; // 0x10000399c
    int64_t * v3 = _calloc(v2 + 1, 4); // 0x1000039bc
    int64_t v4 = (int64_t)v3; // 0x1000039bc
    int32_t v5 = 9 - v2; // 0x1000039ec
    if (v5 == 0 || v5 < 0 != (v5 & v2) < 0) {
        int32_t v6 = 3;
        int32_t v7 = 9;
        int32_t v8 = v7 - v2; // 0x100003a10
        int32_t v9; // 0x100003a44
        if (v8 == 0 || v8 < 0 != ((v8 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003a20
            v9 = v7;
            *(int32_t *)(4 * (int64_t)v9 + v4) = 1;
            v9 += 2 * v6;
            while (v9 - v2 == 0 || v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
                // 0x100003a20
                *(int32_t *)(4 * (int64_t)v9 + v4) = 1;
                v9 += 2 * v6;
            }
        }
        int32_t v10 = v6 + 2; // 0x100003a58
        int32_t v11 = v10; // 0x100003a78
        while (*(int32_t *)(4 * (int64_t)v10 + v4) != 0) {
            // 0x100003a54
            v10 = v11 + 2;
            v11 = v10;
        }
        int32_t v12 = v10 * v10; // 0x100003a88
        while (v12 - v2 == 0 || v12 - v2 < 0 != ((v12 - v2 ^ v12) & (v12 ^ v2)) < 0) {
            // 0x100003a08
            v6 = v10;
            v7 = v12;
            v8 = v7 - v2;
            if (v8 == 0 || v8 < 0 != ((v8 ^ v7) & (v7 ^ v2)) < 0) {
                // 0x100003a20
                v9 = v7;
                *(int32_t *)(4 * (int64_t)v9 + v4) = 1;
                v9 += 2 * v6;
                while (v9 - v2 == 0 || v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
                    // 0x100003a20
                    *(int32_t *)(4 * (int64_t)v9 + v4) = 1;
                    v9 += 2 * v6;
                }
            }
            // 0x100003a54
            v10 = v6 + 2;
            v11 = v10;
            while (*(int32_t *)(4 * (int64_t)v10 + v4) != 0) {
                // 0x100003a54
                v10 = v11 + 2;
                v11 = v10;
            }
            // 0x100003a80
            v12 = v10 * v10;
        }
    }
    int32_t v13 = 3 - v2; // 0x100003aa8
    if (v13 != 0 && v13 < 0 == (v13 & v2) < 0) {
        // 0x100003b08
        *(int32_t *)v1 = 0;
        _free(v3);
        return &g2;
    }
    int32_t v14 = 0;
    int32_t v15 = 3;
    int32_t v16 = v14; // 0x100003acc
    if (*(int32_t *)(4 * (int64_t)v15 + v4) == 0) {
        // 0x100003ad4
        *(int32_t *)(4 * (int64_t)v14 + v1) = v15;
        v16 = v14 + 1;
    }
    int32_t v17 = v16;
    int32_t v18 = v15 + 2; // 0x100003afc
    int32_t v19 = v18 - v2; // 0x100003aa8
    while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
        // 0x100003ab8
        v14 = v17;
        v15 = v18;
        v16 = v14;
        if (*(int32_t *)(4 * (int64_t)v15 + v4) == 0) {
            // 0x100003ad4
            *(int32_t *)(4 * (int64_t)v14 + v1) = v15;
            v16 = v14 + 1;
        }
        // 0x100003af8
        v17 = v16;
        v18 = v15 + 2;
        v19 = v18 - v2;
    }
    // 0x100003b08
    *(int32_t *)v1 = v17;
    _free(v3);
    return &g2;
}

// Address range: 0x100003b28 - 0x100003bf4
int64_t function_100003b28(void) {
    // 0x100003b28
    int64_t v1; // 0x100003b28
    int32_t v2 = v1; // 0x100003b2c
    int32_t v3 = v2 + 1; // 0x100003b4c
    int32_t v4 = -v2; // 0x100003b50
    int32_t v5 = 1; // 0x100003b58
    int32_t v6 = 1; // 0x100003b58
    int32_t v7 = 1; // 0x100003b58
    if (v2 == 0 || v4 < 0 != (v3 & v4) < 0) {
        v7 = 10 * v7 % v2;
        v6++;
        int32_t v8 = v6 - v3; // 0x100003b50
        v5 = v7;
        while (v8 == 0 || v8 < 0 != ((v8 ^ v6) & (v6 ^ v3)) < 0) {
            // 0x100003b60
            v7 = 10 * v7 % v2;
            v6++;
            v8 = v6 - v3;
            v5 = v7;
        }
    }
    int32_t v9 = v5;
    int32_t result = 0; // 0x100003bc4
    v9 = 10 * v9 % v2;
    result++;
    while (v9 != v5) {
        // 0x100003ba0
        v9 = 10 * v9 % v2;
        result++;
    }
    // 0x100003be8
    return result;
}

// Address range: 0x100003bf4 - 0x100003ef4
int64_t entry_point(void) {
    float128_t v1 = g1; // bp-64, 0x100003c2c
    int64_t * v2 = _calloc(0x1964, 4); // 0x100003c44
    int64_t * v3 = _calloc(8, 4); // 0x100003c5c
    function_100003990();
    int32_t v4; // bp-88, 0x100003bf4
    int64_t * v5 = _calloc(v4, 4); // 0x100003c7c
    int64_t v6 = (int64_t)v5; // 0x100003c7c
    int32_t v7 = -v4; // 0x100003c94
    int32_t v8 = 0; // 0x100003c9c
    int32_t v9 = 0; // 0x100003c9c
    if (v7 < 0 != (v4 & v7) < 0) {
        int32_t v10 = 0;
        int32_t v11 = *(int32_t *)(4 * (int64_t)v9 + (int64_t)v2); // 0x100003cac
        int32_t v12 = v10; // 0x100003ccc
        if (v11 - 1 == (int32_t)function_100003b28()) {
            // 0x100003cd4
            *(int32_t *)(4 * (int64_t)v10 + v6) = v11;
            v12 = v10 + 1;
        }
        int32_t v13 = v12;
        v9++;
        int32_t v14 = v9 - v4; // 0x100003c94
        v8 = v13;
        while (v14 < 0 != ((v14 ^ v9) & (v4 ^ v9)) < 0) {
            // 0x100003ca4
            v10 = v13;
            v11 = *(int32_t *)(4 * (int64_t)v9 + (int64_t)v2);
            v12 = v10;
            if (v11 - 1 == (int32_t)function_100003b28()) {
                // 0x100003cd4
                *(int32_t *)(4 * (int64_t)v10 + v6) = v11;
                v12 = v10 + 1;
            }
            // 0x100003cf8
            v13 = v12;
            v9++;
            v14 = v9 - v4;
            v8 = v13;
        }
    }
    int64_t v15 = (int64_t)v3; // 0x100003c5c
    int32_t v16 = -v8; // 0x100003d18
    int32_t v17 = 0; // 0x100003d20
    if (v16 < 0 != (v8 & v16) < 0) {
        int32_t v18 = 0;
        int32_t v19 = 0;
        int32_t v20 = *(int32_t *)(4 * (int64_t)v19 + v6); // 0x100003d30
        int64_t v21 = 4 * (int64_t)v18; // 0x100003d3c
        int32_t v22 = *(int32_t *)(v21 + (int64_t)&v1); // 0x100003d3c
        int32_t v23 = v20 - v22; // 0x100003d40
        int32_t v24 = v18; // 0x100003d48
        if (v23 != 0 && v23 < 0 == ((v23 ^ v20) & (v22 ^ v20)) < 0) {
            // 0x100003d50
            *(int32_t *)(v21 + v15) = v19;
            v24 = v18 + 1;
        }
        int32_t v25 = v19 + 1; // 0x100003d78
        int32_t v26 = v25 - v8; // 0x100003d18
        v17 = v25;
        while (v26 < 0 != ((v26 ^ v25) & (v25 ^ v8)) < 0) {
            // 0x100003d28
            v18 = v24;
            v19 = v25;
            v20 = *(int32_t *)(4 * (int64_t)v19 + v6);
            v21 = 4 * (int64_t)v18;
            v22 = *(int32_t *)(v21 + (int64_t)&v1);
            v23 = v20 - v22;
            v24 = v18;
            if (v23 != 0 && v23 < 0 == ((v23 ^ v20) & (v22 ^ v20)) < 0) {
                // 0x100003d50
                *(int32_t *)(v21 + v15) = v19;
                v24 = v18 + 1;
            }
            // 0x100003d74
            v25 = v19 + 1;
            v26 = v25 - v8;
            v17 = v25;
        }
    }
    // 0x100003d90
    *(int32_t *)(v15 + 28) = v17;
    _printf("The long primes up to %d are:\n", 4);
    _printf("[");
    int32_t v27 = *(int32_t *)v3; // 0x100003ddc
    int32_t v28 = -v27; // 0x100003de0
    int32_t v29 = 0; // 0x100003de8
    if (v28 < 0 != (v27 & v28) < 0) {
        _printf("%d ", 4);
        v29++;
        int32_t v30 = *(int32_t *)v3; // 0x100003ddc
        while (v29 - v30 < 0 != ((v29 - v30 ^ v29) & (v30 ^ v29)) < 0) {
            // 0x100003df0
            _printf("%d ", 4);
            v29++;
            v30 = *(int32_t *)v3;
        }
    }
    // 0x100003e28
    _printf("\b]\n");
    _printf("\nThe number of long primes up to:\n");
    for (int32_t i = 0; i < 8; i++) {
        // 0x100003e5c
        _printf("  %5d is %d\n", 4, (int64_t)&v4);
    }
    // 0x100003ea8
    _free(v3);
    _free(v5);
    _free(v2);
    int64_t v31 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ecc
    if (v31 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ee0
        ___stack_chk_fail((int64_t)&g2);
    }
    // 0x100003ee4
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1) {
    // 0x100003ef4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t * function_100003f00(int32_t nmemb, int32_t size) {
    // 0x100003f00
    return _calloc(nmemb, size);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(int64_t * ptr) {
    // 0x100003f0c
    _free(ptr);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

const int PRIMES[] = {
    2, 3, 5, 7,
    11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
    101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,
    307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523,
    541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769,
    773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997,
    1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217,
    1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451,
    1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663,
    1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907,
    1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141,
    2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383,
    2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659,
    2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861,
    2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163
};
#define PRIME_LENGTH (sizeof(PRIMES) / sizeof(int))

bool isPrime(int n) {
    int i;

    if (n < 2) {
        return false;
    }

    for (i = 0; i < PRIME_LENGTH; ++i) {
        if (n == PRIMES[i]) {
            return true;
        }
        if (n % PRIMES[i] == 0) {
            return false;
        }
        if (n < PRIMES[i] * PRIMES[i]) {
            break;
        }
    }

    return true;
}

int main() {
    const int MAX_LENGTH = 700000;
    int i, n, c1, c2;

    int *primePtr = calloc(MAX_LENGTH, sizeof(int));
    if (primePtr == 0) {
        return EXIT_FAILURE;
    }

    for (i = 0; i < PRIME_LENGTH; i++) {
        primePtr[i] = PRIMES[i];
    }

    i--;
    for (n = PRIMES[i] + 4; n < 10000100;) {
        if (isPrime(n)) {
            primePtr[i++] = n;
        }
        n += 2;

        if (isPrime(n)) {
            primePtr[i++] = n;
        }
        n += 4;

        if (i >= MAX_LENGTH) {
            printf("Allocate more memory.");
            return EXIT_FAILURE;
        }
    }

    /////////////////////////////////////////////////////////////
    printf("First 36 strong primes:");
    c1 = 0;
    c2 = 0;
    for (n = 0, i = 1; i < MAX_LENGTH - 1; i++) {
        if (2 * primePtr[i] > primePtr[i - 1] + primePtr[i + 1]) {
            if (n < 36) {
                printf("  %d", primePtr[i]);
                n++;
            }
            if (primePtr[i] < 1000000) {
                c1++;
                c2++;
            } else if (primePtr[i] < 10000000) {
                c2++;
            } else break;
        }
    }
    printf("\nThere are %d strong primes below 1,000,000", c1);
    printf("\nThere are %d strong primes below 10,000,000\n\n", c2);

    /////////////////////////////////////////////////////////////
    printf("First 37 weak primes:");
    c1 = 0;
    c2 = 0;
    for (n = 0, i = 1; i < MAX_LENGTH - 1; i++) {
        if (2 * primePtr[i] < primePtr[i - 1] + primePtr[i + 1]) {
            if (n < 37) {
                printf("  %d", primePtr[i]);
                n++;
            }
            if (primePtr[i] < 1000000) {
                c1++;
                c2++;
            } else if (primePtr[i] < 10000000) {
                c2++;
            } else break;
        }
    }
    printf("\nThere are %d weak primes below 1,000,000", c1);
    printf("\nThere are %d weak primes below 10,000,000\n\n", c2);

    free(primePtr);
    return EXIT_SUCCESS;
}
`,`#include "strong-and-weak-primes.h"



undefined _isPrime(int param_1)

{
  int iVar1;
  int iVar2;
  uint local_c;
  undefined local_1;
  
  if (param_1 < 2) {
    local_1 = 0;
  }
  else {
    for (local_c = 0; local_c < 0x1bf; local_c = local_c + 1) {
      if (param_1 == *(int *)(&_PRIMES + (long)(int)local_c * 4)) {
        return 1;
      }
      iVar1 = *(int *)(&_PRIMES + (long)(int)local_c * 4);
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = param_1 / iVar1;
      }
      if (param_1 == iVar2 * iVar1) {
        return 0;
      }
      if (param_1 < *(int *)(&_PRIMES + (long)(int)local_c * 4) *
                    *(int *)(&_PRIMES + (long)(int)local_c * 4)) break;
    }
    local_1 = 1;
  }
  return local_1;
}



undefined4 entry(void)

{
  void *pvVar1;
  ulong uVar2;
  long lVar3;
  int local_20;
  uint local_1c;
  
  pvVar1 = _calloc(700000,4);
  if (pvVar1 == (void *)0x0) {
    return 1;
  }
  for (local_1c = 0; local_1c < 0x1bf; local_1c = local_1c + 1) {
    *(undefined4 *)((long)pvVar1 + (long)(int)local_1c * 4) =
         *(undefined4 *)(&_PRIMES + (long)(int)local_1c * 4);
  }
  local_1c = local_1c - 1;
  local_20 = *(int *)(&_PRIMES + (long)(int)local_1c * 4) + 4;
  while (local_20 < 0x9896e4) {
    uVar2 = _isPrime(local_20);
    if ((uVar2 & 1) != 0) {
      lVar3 = (long)(int)local_1c;
      local_1c = local_1c + 1;
      *(int *)((long)pvVar1 + lVar3 * 4) = local_20;
    }
    uVar2 = _isPrime(local_20 + 2);
    if ((uVar2 & 1) != 0) {
      lVar3 = (long)(int)local_1c;
      local_1c = local_1c + 1;
      *(int *)((long)pvVar1 + lVar3 * 4) = local_20 + 2;
    }
    local_20 = local_20 + 6;
    if (699999 < (int)local_1c) {
      _printf("Allocate more memory.");
      return 1;
    }
  }
  _printf("First 36 strong primes:");
  local_20 = 0;
  for (local_1c = 1; (int)local_1c < 699999; local_1c = local_1c + 1) {
    if (*(int *)((long)pvVar1 + (long)(int)(local_1c + -1) * 4) +
        *(int *)((long)pvVar1 + (long)(int)(local_1c + 1) * 4) <
        *(int *)((long)pvVar1 + (long)(int)local_1c * 4) * 2) {
      if (local_20 < 0x24) {
        _printf("  %d");
        local_20 = local_20 + 1;
      }
      if ((999999 < *(int *)((long)pvVar1 + (long)(int)local_1c * 4)) &&
         (9999999 < *(int *)((long)pvVar1 + (long)(int)local_1c * 4))) break;
    }
  }
  _printf("\nThere are %d strong primes below 1,000,000");
  _printf("\nThere are %d strong primes below 10,000,000\n\n");
  _printf("First 37 weak primes:");
  local_20 = 0;
  for (local_1c = 1; (int)local_1c < 699999; local_1c = local_1c + 1) {
    if (*(int *)((long)pvVar1 + (long)(int)local_1c * 4) * 2 <
        *(int *)((long)pvVar1 + (long)(int)(local_1c + -1) * 4) +
        *(int *)((long)pvVar1 + (long)(int)(local_1c + 1) * 4)) {
      if (local_20 < 0x25) {
        _printf("  %d");
        local_20 = local_20 + 1;
      }
      if ((999999 < *(int *)((long)pvVar1 + (long)(int)local_1c * 4)) &&
         (9999999 < *(int *)((long)pvVar1 + (long)(int)local_1c * 4))) break;
    }
  }
  _printf("\nThere are %d weak primes below 1,000,000");
  _printf("\nThere are %d weak primes below 10,000,000\n\n");
  _free(pvVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x00010000378c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003798. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0001000037a4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

int qselect(int *v, int len, int k)
{
#	define SWAP(a, b) { tmp = v[a]; v[a] = v[b]; v[b] = tmp; }
	int i, st, tmp;

	for (st = i = 0; i < len - 1; i++) {
		if (v[i] > v[len-1]) continue;
		SWAP(i, st);
		st++;
	}

	SWAP(len-1, st);

	return k == st	?v[st]
			:st > k	? qselect(v, st, k)
				: qselect(v + st, len - st, k - st);
}

int main(void)
{
#	define N (sizeof(x)/sizeof(x[0]))
	int x[] = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};
	int y[N];

	int i;
	for (i = 0; i < 10; i++) {
		memcpy(y, x, sizeof(x)); // qselect modifies array
		printf("%d: %d\n", i, qselect(y, 10, i));
	}

	return 0;
}
`,`#include "quickselect-algorithm.h"



undefined4 _qselect(long param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_28;
  undefined4 local_24;
  
  local_28 = 0;
  for (local_24 = 0; local_24 < param_2 + -1; local_24 = local_24 + 1) {
    if (*(int *)(param_1 + (long)local_24 * 4) <= *(int *)(param_1 + (long)(param_2 + -1) * 4)) {
      uVar1 = *(undefined4 *)(param_1 + (long)local_24 * 4);
      *(undefined4 *)(param_1 + (long)local_24 * 4) = *(undefined4 *)(param_1 + (long)local_28 * 4);
      *(undefined4 *)(param_1 + (long)local_28 * 4) = uVar1;
      local_28 = local_28 + 1;
    }
  }
  uVar1 = *(undefined4 *)(param_1 + (long)(param_2 + -1) * 4);
  *(undefined4 *)(param_1 + (long)(param_2 + -1) * 4) =
       *(undefined4 *)(param_1 + (long)local_28 * 4);
  *(undefined4 *)(param_1 + (long)local_28 * 4) = uVar1;
  if (param_3 == local_28) {
    local_30 = *(undefined4 *)(param_1 + (long)local_28 * 4);
  }
  else {
    if (param_3 < local_28) {
      local_34 = _qselect(param_1,local_28,param_3);
    }
    else {
      local_34 = _qselect(param_1 + (long)local_28 * 4,param_2 - local_28,param_3 - local_28);
    }
    local_30 = local_34;
  }
  return local_30;
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  int local_70;
  undefined auStack_68 [40];
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memcpy(auStack_40,&DAT_100003f78,0x28);
  for (local_70 = 0; local_70 < 10; local_70 = local_70 + 1) {
    _memcpy(auStack_68,auStack_40,0x28);
    _qselect(auStack_68,10,local_70);
    uVar1 = _printf("%d: %d\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(){
  int bounds[ 2 ] = {1, 100};
  char input[ 2 ] = "  ";
    /* second char is for the newline from hitting [return] */
  int choice = (bounds[ 0 ] + bounds[ 1 ]) / 2;
    /* using a binary search */

  printf( "Choose a number between %d and %d.\n", bounds[ 0 ], bounds[ 1 ] );

  do{
    switch( input[ 0 ] ){
      case 'H':
        bounds[ 1 ] = choice;
        break;
      case 'L':
        bounds[ 0 ] = choice;
        break;
      case 'Y':
        printf( "\nAwwwright\n" );
        return 0;
    }
    choice = (bounds[ 0 ] + bounds[ 1 ]) / 2;

    printf( "Is the number %d? (Y/H/L) ", choice );
  }while( scanf( "%1s", input ) == 1 );

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f24(int64_t a1);
int32_t function_100003f30(char * format, ...);
int32_t function_100003f3c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d90 - 0x100003f24
int64_t entry_point(void) {
    // 0x100003d90
    int64_t v1; // 0x100003d90
    _printf("Choose a number between %d and %d.\n", v1, v1);
    _printf("Is the number %d? (Y/H/L) ", v1);
    int32_t v2 = _scanf("%1s", (char **)v1); // 0x100003ecc
    while (v2 == 1) {
        // 0x100003e14
        _printf("Is the number %d? (Y/H/L) ", v1);
        v2 = _scanf("%1s", (char **)v1);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003efc
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f10
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f14
    return 0;
}

// Address range: 0x100003f24 - 0x100003f30
int64_t function_100003f24(int64_t a1) {
    // 0x100003f24
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * format, ...) {
    // 0x100003f30
    return _printf(format);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>

int cmpstr(const void *a, const void *b)
{
    return strcmp(*(const char**)a, *(const char**)b);
}

int main(void)
{
    DIR *basedir;
    char path[PATH_MAX];
    struct dirent *entry;
    char **dirnames;
    int diralloc = 128;
    int dirsize  = 0;

    if (!(dirnames = malloc(diralloc * sizeof(char*)))) {
        perror("malloc error:");
        return 1;
    }

    if (!getcwd(path, PATH_MAX)) {
        perror("getcwd error:");
        return 1;
    }

    if (!(basedir = opendir(path))) {
        perror("opendir error:");
        return 1;
    }

    while ((entry = readdir(basedir))) {
        if (dirsize >= diralloc) {
            diralloc *= 2;
            if (!(dirnames = realloc(dirnames, diralloc * sizeof(char*)))) {
                perror("realloc error:");
                return 1;
            }
        }
        dirnames[dirsize++] = strdup(entry->d_name);
    }

    qsort(dirnames, dirsize, sizeof(char*), cmpstr);

    int i;
    for (i = 0; i < dirsize; ++i) {
        if (dirnames[i][0] != '.') {
            printf("%s\n", dirnames[i]);
        }
    }

    for (i = 0; i < dirsize; ++i)
        free(dirnames[i]);
    free(dirnames);
    closedir(basedir);
    return 0;
}
`,`#include "unix-ls.h"



int _cmpstr(undefined8 *param_1,undefined8 *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)*param_1,(char *)*param_2);
  return iVar1;
}



undefined4 entry(void)

{
  char *pcVar1;
  long lVar2;
  long lVar3;
  int local_454;
  int local_450;
  int local_44c;
  void *local_448;
  undefined4 local_42c;
  char acStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_44c = 0x80;
  local_450 = 0;
  local_448 = _malloc(0x400);
  if (local_448 == (void *)0x0) {
    _perror("malloc error:");
    local_42c = 1;
  }
  else {
    pcVar1 = _getcwd(acStack_428,0x400);
    if (pcVar1 == (char *)0x0) {
      _perror("getcwd error:");
      local_42c = 1;
    }
    else {
      lVar2 = _opendir(acStack_428);
      if (lVar2 == 0) {
        _perror("opendir error:");
        local_42c = 1;
      }
      else {
        while (lVar3 = _readdir(lVar2), lVar3 != 0) {
          if (local_44c <= local_450) {
            local_44c = local_44c << 1;
            local_448 = _realloc(local_448,(long)local_44c << 3);
            if (local_448 == (void *)0x0) {
              _perror("realloc error:");
              local_42c = 1;
              goto LAB_100003e84;
            }
          }
          pcVar1 = _strdup((char *)(lVar3 + 0x15));
          lVar3 = (long)local_450;
          local_450 = local_450 + 1;
          *(char **)((long)local_448 + lVar3 * 8) = pcVar1;
        }
        _qsort(local_448,(long)local_450,8,(int *)_cmpstr);
        for (local_454 = 0; local_454 < local_450; local_454 = local_454 + 1) {
          if (**(char **)((long)local_448 + (long)local_454 * 8) != '.') {
            _printf("%s\n");
          }
        }
        for (local_454 = 0; local_454 < local_450; local_454 = local_454 + 1) {
          _free(*(void **)((long)local_448 + (long)local_454 * 8));
        }
        _free(local_448);
        _closedir(lVar2);
        local_42c = 0;
      }
    }
  }
LAB_100003e84:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return local_42c;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _closedir(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__closedir_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _getcwd(char *param_1,size_t param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__getcwd_100004020)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004028)();
  return pvVar1;
}



void _opendir(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__opendir_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004048)();
  return;
}



void _readdir(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__readdir_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004058)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004060)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004068)();
  return pcVar1;
}


`
`#include<stdio.h>

int main (void)
{
    int i;
    for (i = 1; i <= 100; i++)
    {
        if (!(i % 15))
            printf ("FizzBuzz");
        else if (!(i % 3))
            printf ("Fizz");
        else if (!(i % 5))
            printf ("Buzz");
        else
            printf ("%d", i);

        printf("\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e60 - 0x100003f84
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e60
    if (v1 % 15 == 0) {
        // 0x100003eb4
        _printf("FizzBuzz");
    } else {
        if (v1 % 3 == 0) {
            // 0x100003ee8
            _printf("Fizz");
        } else {
            if (v1 % 5 == 0) {
                // 0x100003f1c
                _printf("Buzz");
            } else {
                // 0x100003f2c
                _printf("%d", v2);
            }
        }
    }
    // 0x100003f54
    _printf((char *)0x100003fa6);
    int32_t v3 = v1 + 1; // 0x100003f68
    while (v1 == 99 || v1 < 99 != (98 - v1 & v3) < 0) {
        // 0x100003e90
        v1 = v3;
        if (v1 % 15 == 0) {
            // 0x100003eb4
            _printf("FizzBuzz");
        } else {
            if (v1 % 3 == 0) {
                // 0x100003ee8
                _printf("Fizz");
            } else {
                if (v1 % 5 == 0) {
                    // 0x100003f1c
                    _printf("Buzz");
                } else {
                    // 0x100003f2c
                    _printf("%d", v2);
                }
            }
        }
        // 0x100003f54
        _printf((char *)0x100003fa6);
        v3 = v1 + 1;
    }
    // 0x100003f74
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdbool.h>

void halve(int *x) { *x >>= 1; }
void doublit(int *x)  { *x <<= 1; }
bool iseven(const int x) { return (x & 1) ==  0; }

int ethiopian(int plier,
	      int plicand, const bool tutor)
{
  int result=0;

  if (tutor)
    printf("ethiopian multiplication of %d by %d\n", plier, plicand);

  while(plier >= 1) {
    if ( iseven(plier) ) {
      if (tutor) printf("%4d %6d struck\n", plier, plicand);
    } else {
      if (tutor) printf("%4d %6d kept\n", plier, plicand);
      result += plicand;
    }
    halve(&plier); doublit(&plicand);
  }
  return result;
}

int main()
{
  printf("%d\n", ethiopian(17, 34, true));
  return 0;
}
`,`#include "ethiopian-multiplication.h"



void _halve(int *param_1)

{
  *param_1 = *param_1 >> 1;
  return;
}



void _doublit(int *param_1)

{
  *param_1 = *param_1 << 1;
  return;
}



bool _iseven(uint param_1)

{
  return (param_1 & 1) == 0;
}



int _ethiopian(int param_1,int param_2,byte param_3)

{
  ulong uVar1;
  int local_20;
  int local_18;
  int local_14;
  
  param_3 = param_3 & 1;
  local_20 = 0;
  local_18 = param_2;
  local_14 = param_1;
  if (param_3 != 0) {
    _printf("ethiopian multiplication of %d by %d\n");
  }
  while (0 < local_14) {
    uVar1 = _iseven(local_14);
    if ((uVar1 & 1) == 0) {
      if (param_3 != 0) {
        _printf("%4d %6d kept\n");
      }
      local_20 = local_20 + local_18;
    }
    else if (param_3 != 0) {
      _printf("%4d %6d struck\n");
    }
    _halve(&local_14);
    _doublit(&local_18);
  }
  return local_20;
}



undefined4 entry(void)

{
  _ethiopian(0x11,0x22,1);
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef enum {
  TRITTRUE,  /* In this enum, equivalent to integer value 0 */
  TRITMAYBE, /* In this enum, equivalent to integer value 1 */
  TRITFALSE  /* In this enum, equivalent to integer value 2 */
} trit;

/* We can trivially find the result of the operation by passing
   the trinary values as indeces into the lookup tables' arrays. */
trit tritNot[3] = {TRITFALSE , TRITMAYBE, TRITTRUE};
trit tritAnd[3][3] = { {TRITTRUE, TRITMAYBE, TRITFALSE},
                       {TRITMAYBE, TRITMAYBE, TRITFALSE},
                       {TRITFALSE, TRITFALSE, TRITFALSE} };

trit tritOr[3][3] = { {TRITTRUE, TRITTRUE, TRITTRUE},
                      {TRITTRUE, TRITMAYBE, TRITMAYBE},
                      {TRITTRUE, TRITMAYBE, TRITFALSE} };

trit tritThen[3][3] = { { TRITTRUE, TRITMAYBE, TRITFALSE},
                        { TRITTRUE, TRITMAYBE, TRITMAYBE},
                        { TRITTRUE, TRITTRUE, TRITTRUE } };

trit tritEquiv[3][3] = { { TRITTRUE, TRITMAYBE, TRITFALSE},
                         { TRITMAYBE, TRITMAYBE, TRITMAYBE},
                         { TRITFALSE, TRITMAYBE, TRITTRUE } };

/* Everything beyond here is just demonstration */

const char* tritString[3] = {"T", "?", "F"};

void demo_binary_op(trit operator[3][3], const char* name)
{
  trit operand1 = TRITTRUE; /* Declare. Initialize for CYA */
  trit operand2 = TRITTRUE; /* Declare. Initialize for CYA */

  /* Blank line */
  printf("\n");

  /* Demo this operator */
  for( operand1 = TRITTRUE; operand1 <= TRITFALSE; ++operand1 )
  {
    for( operand2 = TRITTRUE; operand2 <= TRITFALSE; ++operand2 )
    {
      printf("%s %s %s: %s\n", tritString[operand1],
                               name,
                               tritString[operand2],
                               tritString[operator[operand1][operand2]]);
    }
  }

}

int main()
{
  trit op1 = TRITTRUE; /* Declare. Initialize for CYA */
  trit op2 = TRITTRUE; /* Declare. Initialize for CYA */

  /* Demo 'not' */
  for( op1 = TRITTRUE; op1 <= TRITFALSE; ++op1 )
  {
    printf("Not %s: %s\n", tritString[op1], tritString[tritNot[op1]]);
  }
  demo_binary_op(tritAnd, "And");
  demo_binary_op(tritOr, "Or");
  demo_binary_op(tritThen, "Then");
  demo_binary_op(tritEquiv, "Equiv");


  return 0;
}
`,`#include "ternary-logic-1.h"



int _demo_binary_op(void)

{
  int iVar1;
  uint local_28;
  uint local_24;
  
  iVar1 = _printf("\n");
  for (local_24 = 0; local_24 < 3; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < 3; local_28 = local_28 + 1) {
      iVar1 = _printf("%s %s %s: %s\n");
    }
  }
  return iVar1;
}



undefined8 entry(void)

{
  uint local_18;
  
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    _printf("Not %s: %s\n");
  }
  _demo_binary_op(&_tritAnd,"And");
  _demo_binary_op(&_tritOr,"Or");
  _demo_binary_op(&_tritThen,"Then");
  _demo_binary_op(&_tritEquiv,"Equiv");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdbool.h>

void halve(int *x) { *x >>= 1; }
void doublit(int *x)  { *x <<= 1; }
bool iseven(const int x) { return (x & 1) ==  0; }

int ethiopian(int plier,
	      int plicand, const bool tutor)
{
  int result=0;

  if (tutor)
    printf("ethiopian multiplication of %d by %d\n", plier, plicand);

  while(plier >= 1) {
    if ( iseven(plier) ) {
      if (tutor) printf("%4d %6d struck\n", plier, plicand);
    } else {
      if (tutor) printf("%4d %6d kept\n", plier, plicand);
      result += plicand;
    }
    halve(&plier); doublit(&plicand);
  }
  return result;
}

int main()
{
  printf("%d\n", ethiopian(17, 34, true));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d68(void);
int64_t function_100003d88(void);
int64_t function_100003da8(void);
int64_t function_100003dc8(void);
int32_t function_100003f4c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d68 - 0x100003d88
int64_t function_100003d68(void) {
    // 0x100003d68
    int64_t v1; // 0x100003d68
    int64_t result = v1;
    *(int32_t *)result = (int32_t)result >> 1;
    return result;
}

// Address range: 0x100003d88 - 0x100003da8
int64_t function_100003d88(void) {
    // 0x100003d88
    int64_t v1; // 0x100003d88
    int64_t result = v1;
    *(int32_t *)result = 2 * (int32_t)result;
    return result;
}

// Address range: 0x100003da8 - 0x100003dc8
int64_t function_100003da8(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    return (uint64_t)v1 % 2 == 0;
}

// Address range: 0x100003dc8 - 0x100003ef8
int64_t function_100003dc8(void) {
    // 0x100003dc8
    int64_t v1; // 0x100003dc8
    uint64_t v2 = v1;
    if (v2 % 2 != 0) {
        // 0x100003df8
        _printf("ethiopian multiplication of %d by %d\n", v1, v2);
    }
    // 0x100003e24
    if ((int32_t)v1 < 1 != ((int32_t)v1 & -(int32_t)v1) < 0) {
        // 0x100003ee8
        return 0;
    }
    // 0x100003e24
    while (true) {
        // 0x100003e3c
        if (function_100003da8() % 2 == 0) {
            if (v2 % 2 != 0) {
                // 0x100003e94
                _printf("%4d %6d kept\n", v1, v2);
            }
        } else {
            if (v2 % 2 != 0) {
                // 0x100003e58
                _printf("%4d %6d struck\n", v1, v2);
            }
        }
        // 0x100003ed4
        function_100003d68();
        function_100003d88();
    }
}

// Address range: 0x100003ef8 - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003ef8
    function_100003dc8();
    _printf("%d\n", 34);
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <string.h>

typedef struct { char v[16]; } deck;
typedef unsigned int uint;

uint n, d, best[16];

void tryswaps(deck *a, uint f, uint s) {
#	define A a->v
#	define B b.v
	if (d > best[n]) best[n] = d;
	while (1) {
		if ((A[s] == s || (A[s] == -1 && !(f & 1U << s)))
			&& (d + best[s] >= best[n] || A[s] == -1))
			break;

		if (d + best[s] <= best[n]) return;
		if (!--s) return;
	}

	d++;
	deck b = *a;
	for (uint i = 1, k = 2; i <= s; k <<= 1, i++) {
		if (A[i] != i && (A[i] != -1 || (f & k)))
			continue;

		for (uint j = B[0] = i; j--;) B[i - j] = A[j];
		tryswaps(&b, f | k, s);
	}
	d--;
}

int main(void) {
	deck x;
	memset(&x, -1, sizeof(x));
	x.v[0] = 0;

	for (n = 1; n < 13; n++) {
		tryswaps(&x, 1, n - 1);
		printf("%2d: %d\n", n, best[n]);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b34(void);
int64_t function_100003f84(void);
int32_t function_100003f90(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int32_t * g2 = (int32_t *)0x100000000; // 0x100008040
int32_t * g3; // 0x100008044

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b34 - 0x100003e78
int64_t function_100003b34(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b48
    uint32_t v2 = *(int32_t *)&g2; // 0x100003b64
    uint32_t v3 = *(int32_t *)&g3; // 0x100003b70
    int32_t * v4 = (int32_t *)(4 * (int64_t)v3 + (int64_t)&g1);
    uint32_t v5 = *v4; // 0x100003b80
    int32_t * v6 = v4; // 0x100003b8c
    int32_t v7 = v2; // 0x100003b8c
    if (v2 != v5 && v2 >= v5) {
        // 0x100003b94
        *v4 = v2;
        uint32_t v8 = *(int32_t *)&g3;
        v6 = (int32_t *)(4 * (int64_t)v8 + (int64_t)&g1);
        v7 = *(int32_t *)&g2;
    }
    // 0x100003bc0
    int64_t v9; // 0x100003b34
    int32_t v10 = v9; // 0x100003b54
    int32_t v11 = v9; // 0x100003bc0
    uint32_t v12; // 0x100003b34
    int64_t v13; // 0x100003bc8
    char v14; // 0x100003bcc
    while (true) {
      lab_0x100003bc4:
        // 0x100003bc4
        v12 = v11;
        v13 = v12;
        v14 = *(char *)(v9 + v13);
        if (v12 == (int32_t)v14) {
            goto lab_0x100003c20;
        } else {
            if (v14 == -1) {
                if ((1 << v12 & v10) == 0) {
                    goto lab_0x100003c20;
                } else {
                    goto lab_0x100003c84;
                }
            } else {
                goto lab_0x100003c84;
            }
        }
    }
  lab_0x100003cf0:
    // 0x100003cf0
    *(int32_t *)&g2 = v7 + 1;
    if (v12 == 0 != v12 != 0) {
        int32_t v15 = 2; // 0x100003b34
        while (true) {
          lab_0x100003d3c:;
            int32_t v16 = v15;
            char v17 = *(char *)v9; // 0x100003d44
            if (v17 == 0) {
                // 0x100003df8
                function_100003b34();
                // 0x100003e14
                v15 = 2 * v16;
                goto lab_0x100003d3c;
            } else {
                if ((v16 & v10) == 0 == v17 == -1) {
                    // 0x100003df8
                    function_100003b34();
                    // 0x100003e14
                    v15 = 2 * v16;
                    goto lab_0x100003d3c;
                } else {
                    // 0x100003e14
                    v15 = 2 * v16;
                    goto lab_0x100003d3c;
                }
            }
        }
    }
    // 0x100003e30
    *(int32_t *)&g2 = v7;
  lab_0x100003e48_2:;
    // 0x100003e48
    int64_t result; // 0x100003b34
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e68
        result = ___stack_chk_fail();
    }
    // 0x100003e6c
    return result;
  lab_0x100003c20:;
    int32_t v18 = *(int32_t *)(4 * v13 + (int64_t)&g1); // 0x100003c3c
    if (v14 == -1 | v18 + v7 >= *v6) {
        // break -> 0x100003cf0
        goto lab_0x100003cf0;
    }
    goto lab_0x100003c84;
  lab_0x100003c84:;
    uint32_t v19 = *(int32_t *)(4 * v13 + (int64_t)&g1) + v7; // 0x100003ca4
    uint32_t v20 = *v6; // 0x100003cb4
    if (v19 >= v20 != v19 != v20) {
        goto lab_0x100003e48_2;
    }
    // 0x100003ccc
    v11 = v12 - 1;
    if (v11 == 0) {
        goto lab_0x100003e48_2;
    }
    goto lab_0x100003bc4;
}

// Address range: 0x100003e78 - 0x100003f84
int64_t entry_point(void) {
    // 0x100003e78
    *(int32_t *)&g3 = 1;
    function_100003b34();
    _printf("%2d: %d\n", 1, (int64_t)0);
    int32_t v1 = *(int32_t *)&g3 + 1; // 0x100003f44
    *(int32_t *)&g3 = v1;
    while (v1 < 13) {
        // 0x100003ed8
        function_100003b34();
        _printf("%2d: %d\n", 1, (int64_t)(v1 - 1));
        v1 = *(int32_t *)&g3 + 1;
        *(int32_t *)&g3 = v1;
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f5c
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f70
        ___stack_chk_fail();
    }
    // 0x100003f74
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int64_t function_100003f84(void) {
    // 0x100003f84
    return ___stack_chk_fail();
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void farey(int n)
{
	typedef struct { int d, n; } frac;
	frac f1 = {0, 1}, f2 = {1, n}, t;
	int k;

	printf("%d/%d %d/%d", 0, 1, 1, n);
	while (f2.n > 1) {
		k = (n + f1.n) / f2.n;
		t = f1, f1 = f2, f2 = (frac) { f2.d * k - t.d, f2.n * k - t.n };
		printf(" %d/%d", f2.d, f2.n);
	}

	putchar('\n');
}

typedef unsigned long long ull;
ull *cache;
size_t ccap;

ull farey_len(int n)
{
	if (n >= ccap) {
		size_t old = ccap;
		if (!ccap) ccap = 16;
		while (ccap <= n) ccap *= 2;
		cache = realloc(cache, sizeof(ull) * ccap);
		memset(cache + old, 0, sizeof(ull) * (ccap - old));
	} else if (cache[n])
		return cache[n];

	ull len = (ull)n*(n + 3) / 2;
	int p, q = 0;
	for (p = 2; p <= n; p = q) {
		q = n/(n/p) + 1;
		len -= farey_len(n/p) * (q - p);
	}

	cache[n] = len;
	return len;
}

int main(void)
{
	int n;
	for (n = 1; n <= 11; n++) {
		printf("%d: ", n);
		farey(n);
	}

	for (n = 100; n <= 1000; n += 100)
		printf("%d: %llu items\n", n, farey_len(n));

	n = 10000000;
	printf("\n%d: %llu items\n", n, farey_len(n));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ad0(void);
int64_t function_100003be4(void);
int64_t function_100003f30(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003f3c(char * format, ...);
int32_t function_100003f48(int32_t c);
int64_t * function_100003f54(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003ad0 - 0x100003be4
int64_t function_100003ad0(void) {
    // 0x100003ad0
    int64_t v1; // 0x100003ad0
    int32_t v2 = v1; // 0x100003adc
    _printf("%d/%d %d/%d", v1, v1, v1, v1);
    if (v2 == 1 || v2 < 1 != (v2 & -v2) < 0) {
        // 0x100003bd0
        return _putchar(10);
    }
    while (true) {
        // 0x100003b44
        _printf(" %d/%d", v1, v1);
    }
}

// Address range: 0x100003be4 - 0x100003e18
int64_t function_100003be4(void) {
    // 0x100003be4
    int64_t v1; // 0x100003be4
    int64_t v2 = 0x100000000 * v1;
    uint64_t v3 = v2 >> 32; // 0x100003bf4
    int64_t v4 = g2; // 0x100003c00
    if (v3 < v4) {
        int64_t result = *(int64_t *)(g1 + (v2 >> 29)); // 0x100003d04
        if (result != 0) {
            // 0x100003e08
            return result;
        }
    } else {
        int64_t v5 = v4; // 0x100003c30
        if (v4 == 0) {
            // 0x100003c38
            g2 = 16;
            v5 = 16;
        }
        int64_t v6 = v5; // 0x100003c58
        int64_t v7 = v6; // 0x100003c68
        if (v6 >= v3 != v6 != v3) {
            int64_t v8 = 2 * v6; // 0x100003c7c
            int64_t v9 = v8; // 0x100003c68
            while (v8 >= v3 != v8 != v3) {
                // 0x100003c70
                v8 = 2 * v9;
                v9 = v8;
            }
            // 0x100003c50
            g2 = v8;
            v7 = v8;
        }
        int64_t v10 = (int64_t)_realloc((int64_t *)g1, 8 * (int32_t)v7); // 0x100003cb4
        g1 = v10;
        ___memset_chk(8 * v4 + v10, 0, 8 * (g2 - v4), -1);
    }
    int32_t v11 = v1; // 0x100003bf0
    int64_t v12 = (v2 + 0x300000000 >> 32) * v3 / 2; // 0x100003d54
    int32_t v13 = 2 - v11; // 0x100003d74
    int64_t v14 = v12; // 0x100003d7c
    int64_t result2 = v12; // 0x100003d7c
    if (v13 == 0 || v13 < 0 != (v13 & v11) < 0) {
        int32_t v15 = 2;
        int32_t v16 = v11 / (v11 / v15) + 1; // 0x100003d98
        v14 -= function_100003be4() * (int64_t)(v16 - v15);
        int32_t v17 = v16 - v11; // 0x100003d74
        result2 = v14;
        while (v17 == 0 || v17 < 0 != ((v17 ^ v16) & (v16 ^ v11)) < 0) {
            // 0x100003d84
            v15 = v16;
            v16 = v11 / (v11 / v15) + 1;
            v14 -= function_100003be4() * (int64_t)(v16 - v15);
            v17 = v16 - v11;
            result2 = v14;
        }
    }
    // 0x100003de4
    *(int64_t *)(g1 + (v2 >> 29)) = result2;
    // 0x100003e08
    return result2;
}

// Address range: 0x100003e18 - 0x100003f30
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e18
    _printf("%d: ", v2);
    function_100003ad0();
    int32_t v3 = v1 + 1; // 0x100003e74
    while (v1 == 10 || v1 < 10 != (9 - v1 & v3) < 0) {
        // 0x100003e48
        v1 = v3;
        _printf("%d: ", v2);
        function_100003ad0();
        v3 = v1 + 1;
    }
    // 0x100003e8c
    function_100003be4();
    int32_t v4 = 100;
    _printf("%d: %llu items\n", v2, v2);
    int32_t v5 = v4 + 100; // 0x100003ed8
    int32_t v6 = v4 - 900; // 0x100003e90
    function_100003be4();
    while (v6 == 0 || v6 < 0 != (899 - v4 & v5) < 0) {
        // 0x100003ea0
        v4 = v5;
        _printf("%d: %llu items\n", v2, v2);
        v5 = v4 + 100;
        v6 = v4 - 900;
        function_100003be4();
    }
    // 0x100003ee4
    _printf("\n%d: %llu items\n", v2, v2);
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f30
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t c) {
    // 0x100003f48
    return _putchar(c);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int64_t * ptr, int32_t size) {
    // 0x100003f54
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned long long ULONG;

ULONG get_prime(int idx)
{
        static long n_primes = 0, alloc = 0;
        static ULONG *primes = 0;
        ULONG last, p;
        int i;

        if (idx >= n_primes) {
                if (n_primes >= alloc) {
                        alloc += 16; /* be conservative */
                        primes = realloc(primes, sizeof(ULONG) * alloc);
                }
                if (!n_primes) {
                        primes[0] = 2;
                        primes[1] = 3;
                        n_primes = 2;
                }

                last = primes[n_primes-1];
                while (idx >= n_primes) {
                        last += 2;
                        for (i = 0; i < n_primes; i++) {
                                p = primes[i];
                                if (p * p > last) {
                                        primes[n_primes++] = last;
                                        break;
                                }
                                if (last % p == 0) break;
                        }
                }
        }
        return primes[idx];
}

int main()
{
        ULONG n, x, p;
        int i, first;

        for (x = 1; ; x++) {
                printf("%lld = ", n = x);

                for (i = 0, first = 1; ; i++) {
                        p = get_prime(i);
                        while (n % p == 0) {
                                n /= p;
                                if (!first) printf(" x ");
                                first = 0;
                                printf("%lld", p);
                        }
                        if (n <= p * p) break;
                }

                if (first)      printf("%lld\n", n);
                else if (n > 1) printf(" x %lld\n", n);
                else            printf("\n");
        }
        return 0;
}
`,`#include "count-in-factors.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 _get_prime(int param_1)

{
  ulong *puVar1;
  ulong uVar2;
  ulong uVar3;
  int local_2c;
  ulong local_20;
  
  if (_DAT_100008000 <= param_1) {
    if (_DAT_100008008 <= _DAT_100008000) {
      _DAT_100008008 = _DAT_100008008 + 0x10;
      _DAT_100008010 = (undefined8 *)_realloc(_DAT_100008010,_DAT_100008008 * 8);
    }
    if (_DAT_100008000 == 0) {
      *_DAT_100008010 = 2;
      _DAT_100008010[1] = 3;
      _DAT_100008000 = 2;
    }
    local_20 = _DAT_100008010[_DAT_100008000 + -1];
LAB_100003cd8:
    if (_DAT_100008000 <= param_1) {
      local_20 = local_20 + 2;
      for (local_2c = 0; local_2c < _DAT_100008000; local_2c = local_2c + 1) {
        uVar3 = _DAT_100008010[local_2c];
        if (local_20 <= uVar3 * uVar3 && uVar3 * uVar3 - local_20 != 0) {
          puVar1 = _DAT_100008010 + _DAT_100008000;
          _DAT_100008000 = _DAT_100008000 + 1;
          *puVar1 = local_20;
          break;
        }
        uVar2 = 0;
        if (uVar3 != 0) {
          uVar2 = local_20 / uVar3;
        }
        if (local_20 == uVar2 * uVar3) break;
      }
      goto LAB_100003cd8;
    }
  }
  return _DAT_100008010[param_1];
}



void entry(void)

{
  ulong uVar1;
  bool bVar2;
  ulong uVar3;
  int local_34;
  ulong local_28;
  ulong local_20;
  
  local_28 = 1;
  do {
    local_20 = local_28;
    _printf("%lld = ");
    local_34 = 0;
    bVar2 = true;
    while( true ) {
      uVar3 = _get_prime(local_34);
      while( true ) {
        uVar1 = 0;
        if (uVar3 != 0) {
          uVar1 = local_20 / uVar3;
        }
        if (local_20 != uVar1 * uVar3) break;
        uVar1 = 0;
        if (uVar3 != 0) {
          uVar1 = local_20 / uVar3;
        }
        if (!bVar2) {
          _printf(" x ");
        }
        bVar2 = false;
        _printf("%lld");
        local_20 = uVar1;
      }
      if (local_20 <= uVar3 * uVar3) break;
      local_34 = local_34 + 1;
    }
    if (bVar2) {
      _printf("%lld\n");
    }
    else if (local_20 < 2) {
      _printf("\n");
    }
    else {
      _printf(" x %lld\n");
    }
    local_28 = local_28 + 1;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004008)();
  return pvVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef __GNUC__
#include <setjmp.h>
struct LOOP_T; typedef struct LOOP_T LOOP;
struct LOOP_T {
    jmp_buf b; LOOP * p;
} LOOP_base, * LOOP_V = &LOOP_base;
#define FOR(I, C, A, ACT) (LOOP_V = &(LOOP){ .p = LOOP_V }, \
                           (I), setjmp(LOOP_V->b), \
                           ((C) ? ((ACT),(A), longjmp(LOOP_V->b, 1), 0) : 0), \
                           LOOP_V = LOOP_V->p, 0)
#else
#define FOR(I, C, A, ACT) (({for(I;C;A){ACT;}}), 0)    // GNU version
#endif

typedef struct List { struct List * nx; char val[]; } List;
typedef struct { int _1, _2, _3; } Triple;

#define SEQ(OUT, SETS, PRED) (SEQ_var=&(ITERATOR){.l=NULL,.p=SEQ_var}, \
                              M_FFOLD(((PRED)?APPEND(OUT):0),M_ID SETS), \
                              SEQ_var->p->old=SEQ_var->l,SEQ_var=SEQ_var->p,SEQ_var->old)
typedef struct ITERATOR { List * l, * old; struct ITERATOR * p; } ITERATOR;
ITERATOR * FE_var, SEQ_base, * SEQ_var = &SEQ_base;
#define FOR_EACH(V, T, L, ACT) (FE_var=&(ITERATOR){.l=(L),.p=FE_var}, \
                                FOR((V) = *(T*)&FE_var->l->val, FE_var->l?((V)=*(T*)&FE_var->l->val,1):0, \
                                FE_var->l=FE_var->l->nx, ACT), FE_var=FE_var->p)

#define M_FFOLD(ID, ...) M_ID(M_CONC(M_FFOLD_, M_NARGS(__VA_ARGS__)) (ID, __VA_ARGS__))
#define FORSET(V, T, L) V, T, L
#define APPEND(T, val) (SEQ_var->l?listAppend(SEQ_var->l,sizeof(T),&val):(SEQ_var->l=listNew(sizeof(T),&val)))

#define M_FFOLD_1(ID, E) FOR_EACH M_IDP(FORSET E, ID)
#define M_FFOLD_2(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_1(ID, __VA_ARGS__))
#define M_FFOLD_3(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_2(ID, __VA_ARGS__))  //...

#define M_NARGS(...) M_NARGS_(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#define M_NARGS_(_10, _9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) N
#define M_CONC(A, B) M_CONC_(A, B)
#define M_CONC_(A, B) A##B
#define M_ID(...) __VA_ARGS__
#define M_IDP(...) (__VA_ARGS__)

#define R(f, t) int,intRangeList(f, t)
#define T(a, b, c) Triple,((Triple){(a),(b),(c)})

List * listNew(int sz, void * val) {
 List * l = malloc(sizeof(List) + sz); l->nx = NULL; memcpy(l->val, val, sz); return l;
}
List * listAppend(List * l, int sz, void * val) {
 while (l->nx) { l = l->nx; } l->nx = listNew(sz, val); return l;
}
List * intRangeList(int f, int t) {
 List * l = listNew(sizeof f, &f), * e = l;
 for (int i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); } // C11 compliant
//int i;
//for (i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); }    // use this for C99
 return l;
}

int main(void) {
    volatile int x, y, z; const int n = 20;

    List * pTriples = SEQ(
                          T(x, y, z),
                          (
                           (x, R(1, n)),
                           (y, R(x, n)),
                           (z, R(y, n))
                          ),
                          (x*x + y*y == z*z)
                         );

    volatile Triple t;
    FOR_EACH(t, Triple, pTriples,  printf("%d, %d, %d\n", t._1, t._2, t._3)  );

    return 0;
}
`,`#include "list-comprehensions.h"



undefined8 * _listNew(int param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc((long)param_1 + 8);
  *puVar1 = 0;
  ___memcpy_chk(puVar1 + 1,param_2,(long)param_1,0xffffffffffffffff);
  return puVar1;
}



long * _listAppend(long *param_1,undefined4 param_2,undefined8 param_3)

{
  long lVar1;
  undefined8 local_18;
  
  for (local_18 = param_1; *local_18 != 0; local_18 = (long *)*local_18) {
  }
  lVar1 = _listNew(param_2,param_3);
  *local_18 = lVar1;
  return local_18;
}



undefined8 * _intRangeList(int param_1,int param_2)

{
  undefined8 *puVar1;
  int local_2c;
  undefined8 *local_28;
  undefined8 *local_20;
  int local_18;
  int local_14;
  
  local_18 = param_2;
  local_14 = param_1;
  local_20 = (undefined8 *)_listNew(4,&local_14);
  local_28 = local_20;
  local_2c = local_14;
  while (local_2c = local_2c + 1, local_2c <= local_18) {
    puVar1 = (undefined8 *)_listNew(4,&local_2c);
    *local_28 = puVar1;
    local_28 = puVar1;
  }
  return local_20;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

undefined8 entry(void)

{
  undefined8 uVar1;
  long local_e0 [2];
  long *local_d0;
  undefined local_c4 [12];
  int local_b8;
  int local_b4;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  long local_a0 [2];
  long *local_90;
  long local_88 [2];
  long *local_78;
  long local_70 [2];
  long *local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined *local_48;
  long local_40;
  undefined4 local_34;
  int local_30;
  int local_2c;
  int local_28;
  undefined4 local_24;
  
  local_24 = 0;
  local_34 = 0x14;
  local_58 = 0;
  local_50 = 0;
  local_48 = _SEQ_var;
  _SEQ_var = (undefined *)&local_58;
  local_70[0] = _intRangeList(1);
  local_70[1] = 0;
  local_60 = _FE_var;
  local_28 = *(int *)(local_70[0] + 8);
  _FE_var = local_70;
  while (*_FE_var != 0) {
    local_28 = *(int *)(*_FE_var + 8);
    local_88[0] = _intRangeList(local_28,0x14);
    local_88[1] = 0;
    local_78 = _FE_var;
    local_2c = *(int *)(local_88[0] + 8);
    _FE_var = local_88;
    while (*_FE_var != 0) {
      local_2c = *(int *)(*_FE_var + 8);
      local_a0[0] = _intRangeList(local_2c,0x14);
      local_a0[1] = 0;
      local_90 = _FE_var;
      local_30 = *(int *)(local_a0[0] + 8);
      _FE_var = local_a0;
      while (*_FE_var != 0) {
        local_30 = *(int *)(*_FE_var + 8);
        if (local_28 * local_28 + local_2c * local_2c == local_30 * local_30) {
          if (*(long *)_SEQ_var == 0) {
            local_b8 = local_28;
            local_b4 = local_2c;
            local_b0 = local_30;
            uVar1 = _listNew(0xc,&local_b8);
            *(undefined8 *)_SEQ_var = uVar1;
          }
          else {
            local_ac = local_28;
            local_a8 = local_2c;
            local_a4 = local_30;
            _listAppend(*(undefined8 *)_SEQ_var,0xc,&local_ac);
          }
        }
        *_FE_var = *(long *)*_FE_var;
      }
      _FE_var = (long *)_FE_var[2];
      *_FE_var = *(long *)*_FE_var;
    }
    _FE_var = (long *)_FE_var[2];
    *_FE_var = *(long *)*_FE_var;
  }
  _FE_var = (long *)_FE_var[2];
  *(undefined8 *)(*(long *)(_SEQ_var + 0x10) + 8) = *(undefined8 *)_SEQ_var;
  _SEQ_var = *(undefined **)(_SEQ_var + 0x10);
  local_e0[0] = *(long *)(_SEQ_var + 8);
  local_e0[1] = 0;
  local_d0 = _FE_var;
  _FE_var = local_e0;
  local_40 = local_e0[0];
  _memcpy(local_c4,(void *)(local_e0[0] + 8),0xc);
  while (*_FE_var != 0) {
    _memcpy(local_c4,(void *)(*_FE_var + 8),0xc);
    _printf("%d, %d, %d\n");
    *_FE_var = *(long *)*_FE_var;
  }
  _FE_var = (long *)_FE_var[2];
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef char pin_t;
#define IN const pin_t *
#define OUT pin_t *
#define PIN(X) pin_t _##X; pin_t *X = & _##X;
#define V(X) (*(X))

/* a NOT that does not soil the rest of the host of the single bit */
#define NOT(X) (~(X)&1)

/* a shortcut to "implement" a XOR using only NOT, AND and OR gates, as
   task requirements constrain */
#define XOR(X,Y) ((NOT(X)&(Y)) | ((X)&NOT(Y)))

void halfadder(IN a, IN b, OUT s, OUT c)
{
  V(s) = XOR(V(a), V(b));
  V(c) = V(a) & V(b);
}

void fulladder(IN a, IN b, IN ic, OUT s, OUT oc)
{
  PIN(ps); PIN(pc); PIN(tc);

  halfadder(/*INPUT*/a, b, /*OUTPUT*/ps, pc);
  halfadder(/*INPUT*/ps, ic, /*OUTPUT*/s, tc);
  V(oc) = V(tc) | V(pc);
}

void fourbitsadder(IN a0, IN a1, IN a2, IN a3,
		   IN b0, IN b1, IN b2, IN b3,
		   OUT o0, OUT o1, OUT o2, OUT o3,
		   OUT overflow)
{
  PIN(zero); V(zero) = 0;
  PIN(tc0); PIN(tc1); PIN(tc2);

  fulladder(/*INPUT*/a0, b0, zero, /*OUTPUT*/o0, tc0);
  fulladder(/*INPUT*/a1, b1, tc0,  /*OUTPUT*/o1, tc1);
  fulladder(/*INPUT*/a2, b2, tc1,  /*OUTPUT*/o2, tc2);
  fulladder(/*INPUT*/a3, b3, tc2,  /*OUTPUT*/o3, overflow);
}


int main()
{
  PIN(a0); PIN(a1); PIN(a2); PIN(a3);
  PIN(b0); PIN(b1); PIN(b2); PIN(b3);
  PIN(s0); PIN(s1); PIN(s2); PIN(s3);
  PIN(overflow);

  V(a3) = 0; V(b3) = 1;
  V(a2) = 0; V(b2) = 1;
  V(a1) = 1; V(b1) = 1;
  V(a0) = 0; V(b0) = 0;

  fourbitsadder(a0, a1, a2, a3, /* INPUT */
		b0, b1, b2, b3,
		s0, s1, s2, s3, /* OUTPUT */
		overflow);

  printf("%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\n",
	 V(a3), V(a2), V(a1), V(a0),
	 V(b3), V(b2), V(b1), V(b0),
	 V(s3), V(s2), V(s1), V(s0),
	 V(overflow));

  return 0;
}
`,`#include "four-bit-adder.h"



void _halfadder(byte *param_1,byte *param_2,byte *param_3,byte *param_4)

{
  *param_3 = (*param_1 ^ 0xff) & 1 & *param_2 | *param_1 & (*param_2 ^ 0xff) & 1;
  *param_4 = *param_1 & *param_2;
  return;
}



void _fulladder(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
               byte *param_5)

{
  byte local_59;
  byte *local_58;
  byte local_49;
  undefined *local_48;
  undefined uStack_39;
  byte *local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_18;
  
  local_48 = &uStack_39;
  local_58 = &local_49;
  local_38 = param_5;
  local_30 = param_4;
  local_28 = param_3;
  local_20 = param_2;
  local_18 = param_1;
  _halfadder(param_1,param_2,local_48,local_58);
  _halfadder(local_48,local_28,local_30,&local_59);
  *local_38 = local_59 | *local_58;
  return;
}



void _fourbitsadder(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                   undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined8 param_8,
                   undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,
                   undefined8 param_13)

{
  undefined uStack_a9;
  undefined *local_a8;
  undefined uStack_99;
  undefined *local_98;
  undefined uStack_89;
  undefined *local_88;
  undefined local_79;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_18;
  
  local_58 = param_9;
  local_60 = param_10;
  local_68 = param_11;
  local_70 = param_12;
  local_78 = param_13;
  local_88 = &local_79;
  local_79 = 0;
  local_98 = &uStack_89;
  local_a8 = &uStack_99;
  local_50 = param_8;
  local_48 = param_7;
  local_40 = param_6;
  local_38 = param_5;
  local_30 = param_4;
  local_28 = param_3;
  local_20 = param_2;
  local_18 = param_1;
  _fulladder(param_1,param_5,local_88,param_9,local_98);
  _fulladder(local_20,local_40,local_98,local_60,local_a8);
  _fulladder(local_28,local_48,local_a8,local_68,&uStack_a9);
  _fulladder(local_30,local_50,&uStack_a9,local_70,local_78);
  return;
}



undefined4 entry(void)

{
  undefined local_e1;
  undefined *local_e0;
  undefined local_d1;
  undefined *local_d0;
  undefined local_c1;
  undefined *local_c0;
  undefined local_b1;
  undefined *local_b0;
  undefined local_a1;
  undefined *local_a0;
  undefined local_91;
  undefined *local_90;
  undefined local_81;
  undefined *local_80;
  undefined local_71;
  undefined *local_70;
  undefined local_61;
  undefined *local_60;
  undefined local_51;
  undefined *local_50;
  undefined local_41;
  undefined *local_40;
  undefined local_31;
  undefined *local_30;
  undefined local_25;
  undefined4 local_24;
  
  local_24 = 0;
  local_30 = &local_25;
  local_40 = &local_31;
  local_50 = &local_41;
  local_60 = &local_51;
  local_70 = &local_61;
  local_80 = &local_71;
  local_90 = &local_81;
  local_a0 = &local_91;
  local_b0 = &local_a1;
  local_c0 = &local_b1;
  local_d0 = &local_c1;
  local_e0 = &local_d1;
  local_51 = 0;
  local_91 = 1;
  local_41 = 0;
  local_81 = 1;
  local_31 = 1;
  local_71 = 1;
  local_25 = 0;
  local_61 = 0;
  _fourbitsadder(local_30,local_40,local_50,local_60,local_70,local_80,local_90,local_a0,local_b0,
                 local_c0,local_d0,local_e0,&local_e1);
  _printf("%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  char is_open[100] = { 0 };
  int pass, door;

  /* do the 100 passes */
  for (pass = 0; pass < 100; ++pass)
    for (door = pass; door < 100; door += pass+1)
      is_open[door] = !is_open[door];

  /* output the result */
  for (door = 0; door < 100; ++door)
    printf("door #%d is %s.\n", door+1, (is_open[door]? "open" : "closed"));

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f64(void);
int64_t * function_100003f70(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003de8 - 0x100003f64
int64_t entry_point(void) {
    // 0x100003de8
    int64_t v1; // bp-124, 0x100003de8
    _memset(&v1, 0, 100);
    int32_t v2 = 0;
    int32_t v3 = v2 + 1;
    int32_t v4 = v2; // 0x100003e8c
    char * v5 = (char *)((int64_t)v4 + (int64_t)&v1); // 0x100003e64
    *v5 = (char)(*v5 == 0);
    v4 += v3;
    while (v4 < 100 != (99 - v4 & v4) < 0) {
        // 0x100003e54
        v5 = (char *)((int64_t)v4 + (int64_t)&v1);
        *v5 = (char)(*v5 == 0);
        v4 += v3;
    }
    int32_t v6 = 0; // 0x100003e2c
    while (v3 != 100) {
        // 0x100003e54
        v2 = v3;
        v3 = v2 + 1;
        v4 = v2;
        v5 = (char *)((int64_t)v4 + (int64_t)&v1);
        *v5 = (char)(*v5 == 0);
        v4 += v3;
        while (v4 < 100 != (99 - v4 & v4) < 0) {
            // 0x100003e54
            v5 = (char *)((int64_t)v4 + (int64_t)&v1);
            *v5 = (char)(*v5 == 0);
            v4 += v3;
        }
        // 0x100003e9c
        v6 = 0;
    }
    _printf("door #%d is %s.\n", 0, (char *)100);
    int32_t v7 = v6 + 1; // 0x100003f24
    v6 = v7;
    while (v7 != 100) {
        // 0x100003ec8
        _printf("door #%d is %s.\n", 0, (char *)100);
        v7 = v6 + 1;
        v6 = v7;
    }
    int64_t v8 = *(int64_t *)0x100004008; // 0x100003f38
    if (*(int64_t *)v8 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f50
        ___stack_chk_fail();
    }
    // 0x100003f54
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(void) {
    // 0x100003f64
    return ___stack_chk_fail();
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t * function_100003f70(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f70
    return _memset(s, c, n);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#define F(x,y) printf("%s",i%x?"":#y"zz")
int main(int i){for(--i;i++^100;puts(""))F(3,Fi)|F(5,Bu)||printf("%i",i);return 0;}
`,`#include "fizzbuzz-8.h"



undefined8 entry(int param_1)

{
  int iVar1;
  int iVar2;
  int local_18;
  
  local_18 = param_1 + -1;
  while (local_18 != 100) {
    iVar1 = _printf("%s");
    iVar2 = _printf("%s");
    if (iVar1 == 0 && iVar2 == 0) {
      _printf("%i");
    }
    _puts("");
    local_18 = local_18 + 1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef enum { t_F = -1, t_M, t_T } trit;

trit t_not  (trit a) { return -a; }
trit t_and  (trit a, trit b) { return a < b ? a : b; }
trit t_or   (trit a, trit b) { return a > b ? a : b; }
trit t_eq   (trit a, trit b) { return a * b; }
trit t_imply(trit a, trit b) { return -a > b ? -a : b; }
char t_s(trit a) { return "F?T"[a + 1]; }

#define forall(a) for(a = t_F; a <= t_T; a++)
void show_op(trit (*f)(trit, trit), const char *name) {
	trit a, b;
	printf("\n[%s]\n    F ? T\n  -------", name);
	forall(a) {
		printf("\n%c |", t_s(a));
		forall(b) printf(" %c", t_s(f(a, b)));
	}
	puts("");
}

int main(void)
{
	trit a;

	puts("[Not]");
	forall(a) printf("%c | %c\n", t_s(a), t_s(t_not(a)));

	show_op(t_and,   "And");
	show_op(t_or,    "Or");
	show_op(t_eq,    "Equiv");
	show_op(t_imply, "Imply");

	return 0;
}
`,`#include "ternary-logic-2.h"



int _t_not(int param_1)

{
  return -param_1;
}



int _t_and(int param_1,int param_2)

{
  int local_c;
  
  local_c = param_2;
  if (param_1 < param_2) {
    local_c = param_1;
  }
  return local_c;
}



int _t_or(int param_1,int param_2)

{
  int local_c;
  
  local_c = param_2;
  if (param_2 < param_1) {
    local_c = param_1;
  }
  return local_c;
}



int _t_eq(int param_1,int param_2)

{
  return param_1 * param_2;
}



int _t_imply(int param_1,int param_2)

{
  int local_c;
  
  local_c = param_2;
  if (param_2 < -param_1) {
    local_c = -param_1;
  }
  return local_c;
}



long _t_s(int param_1)

{
  return (long)"F?T"[param_1 + 1];
}



int _show_op(code *param_1)

{
  int iVar1;
  int local_28;
  int local_24;
  
  _printf("\n[%s]\n    F ? T\n  -------");
  for (local_24 = -1; local_24 < 2; local_24 = local_24 + 1) {
    _t_s(local_24);
    _printf("\n%c |");
    for (local_28 = -1; local_28 < 2; local_28 = local_28 + 1) {
      (*param_1)(local_24,local_28);
      _t_s();
      _printf(" %c");
    }
  }
  iVar1 = _puts("");
  return iVar1;
}



undefined8 entry(void)

{
  int local_18;
  
  _puts("[Not]");
  for (local_18 = -1; local_18 < 2; local_18 = local_18 + 1) {
    _t_s(local_18);
    _t_not(local_18);
    _t_s();
    _printf("%c | %c\n");
  }
  _show_op(_t_and,"And");
  _show_op(_t_or,"Or");
  _show_op(_t_eq,"Equiv");
  _show_op(_t_imply,"Imply");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <alloca.h> /* stdlib.h might not have obliged. */
#include <string.h>

static void reverse(char *s, int len)
{
    int i, j;
    char tmp;

    for (i = 0, j = len - 1; i < len / 2; ++i, --j)
        tmp = s[i], s[i] = s[j], s[j] = tmp;
}

/* Wrap strcmp() for qsort(). */
static int strsort(const void *s1, const void *s2)
{
    return strcmp(*(char *const *) s1, *(char *const *) s2);
}

int main(void)
{
    int i, c, ct = 0, len, sem = 0;
    char **words, **drows, tmp[24];
    FILE *dict = fopen("unixdict.txt", "r");

    /* Determine word count. */
    while ((c = fgetc(dict)) != EOF)
        ct += c == '\n';
    rewind(dict);

    /* Using alloca() is generally discouraged, but we're not doing
     * anything too fancy and the memory gains are significant. */
    words = alloca(ct * sizeof words);
    drows = alloca(ct * sizeof drows);

    for (i = 0; fscanf(dict, "%s%n", tmp, &len) != EOF; ++i) {
        /* Use just enough memory to store the next word. */
        strcpy(words[i] = alloca(len), tmp);

        /* Store it again, then reverse it. */
        strcpy(drows[i] = alloca(len), tmp);
        reverse(drows[i], len - 1);
    }

    fclose(dict);
    qsort(drows, ct, sizeof drows, strsort);

    /* Walk both sorted lists, checking only the words which could
     * possibly be a semordnilap pair for the current reversed word. */
    for (c = i = 0; i < ct; ++i) {
        while (strcmp(drows[i], words[c]) > 0 && c < ct - 1)
            c++;
        /* We found a semordnilap. */
        if (!strcmp(drows[i], words[c])) {
            strcpy(tmp, drows[i]);
            reverse(tmp, strlen(tmp));
            /* Unless it was a palindrome. */
            if (strcmp(drows[i], tmp) > 0 && sem++ < 5)
                printf("%s\t%s\n", drows[i], tmp);
        }
    }

    printf("Semordnilap pairs: %d\n", sem);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ab0(void);
int64_t function_100003ae8(void);
int64_t function_100003e04(void);
int64_t function_100003eb4(void);
int64_t function_100003ee8(int64_t a1);
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003f00(struct _IO_FILE * stream);
int32_t function_100003f0c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f18(char * filename, char * modes);
int32_t function_100003f24(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f30(char * format, ...);
void function_100003f3c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
void function_100003f48(struct _IO_FILE * stream);
int32_t function_100003f54(char * s1, char * s2);
int32_t function_100003f60(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(int64_t a1, int64_t a2, int64_t a3);
int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
void _rewind(struct _IO_FILE * a1);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a04 - 0x100003ab0
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("unixdict.txt", "r"); // 0x100003a3c
    while (_fgetc(v1) != -1) {
        // continue -> 0x100003a48
    }
    // 0x100003a84
    _rewind(v1);
    int64_t v2; // 0x100003a04
    return ___chkstk_darwin((int64_t)&g1, (int64_t)"r", v2);
}

// Address range: 0x100003ab0 - 0x100003ae8
int64_t function_100003ab0(void) {
    // 0x100003ab0
    int64_t v1; // 0x100003ab0
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)(v2 - 96); // 0x100003ab0
    int64_t v4; // 0x100003ab0
    *(int64_t *)(v2 - 64) = (int64_t)&v4 - v3;
    *(int64_t *)(v2 - 88) = 8 * (int64_t)*(int32_t *)(v2 - 48) + 15 & -16;
    return ___chkstk_darwin(v1, v1, v1);
}

// Address range: 0x100003ae8 - 0x100003e04
int64_t function_100003ae8(void) {
    // 0x100003ae8
    int64_t v1; // 0x100003ae8
    int64_t v2; // 0x100003ae8
    int64_t v3 = (int64_t)&v1 - *(int64_t *)(v2 - 88); // 0x100003af0
    int64_t * v4 = (int64_t *)(v2 - 72); // 0x100003af8
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 - 40); // 0x100003afc
    *v5 = 0;
    int64_t * v6 = (int64_t *)(v2 - 80); // 0x100003b04
    int64_t v7 = v2 - 32; // 0x100003b10
    int64_t * v8 = (int64_t *)(v3 - 16); // 0x100003b14
    *v8 = v7;
    int64_t v9 = v2 - 52; // 0x100003b18
    int64_t * v10 = (int64_t *)(v3 - 8); // 0x100003b1c
    *v10 = v9;
    int32_t v11 = _fscanf((struct _IO_FILE *)*v6, "%s%n", (char **)v2, (int32_t **)v2); // 0x100003b28
    if (v11 != -1) {
        // 0x100003b40
        *(int64_t *)(v2 - 128) = (int64_t)*(int32_t *)v9 + 15 & -16;
        return ___chkstk_darwin((int64_t)v11, (int64_t)"%s%n", v2);
    }
    // 0x100003c0c
    _fclose((struct _IO_FILE *)*v6);
    int32_t * v12 = (int32_t *)(v2 - 48); // 0x100003c18
    int32_t v13 = *v12; // 0x100003c18
    _qsort((int64_t *)*v4, v13, 8, (int32_t (*)(int64_t *, int64_t *))0x100003eb4);
    *v5 = 0;
    int32_t * v14 = (int32_t *)(v2 - 44); // 0x100003c30
    *v14 = 0;
    int32_t v15 = *v5; // 0x100003c38
    int32_t v16 = *v12; // 0x100003c3c
    int32_t v17 = v15 - v16; // 0x100003c40
    int32_t * v18; // 0x100003ae8
    int64_t v19; // 0x100003ae8
    if (v17 < 0 == ((v17 ^ v15) & (v16 ^ v15)) < 0) {
        // 0x100003c0c
        v18 = (int32_t *)(v2 - 56);
        v19 = v13;
    } else {
        int64_t * v20 = (int64_t *)(v2 - 64);
        int32_t * v21 = (int32_t *)(v2 - 132);
        int64_t * v22 = (int64_t *)(v2 - 144);
        int32_t * v23 = (int32_t *)(v2 - 56);
        int64_t v24 = *(int64_t *)(8 * (int64_t)v15 + *v4); // 0x100003c5c
        int64_t v25 = *(int64_t *)*v20; // 0x100003c68
        uint32_t v26 = _strcmp((char *)v24, (char *)v25); // 0x100003c6c
        *v21 = 0;
        int32_t v27; // 0x100003c88
        int32_t v28; // 0x100003c90
        int32_t v29; // 0x100003c94
        int32_t v30; // 0x100003cb4
        int64_t v31; // 0x100003c5c
        int64_t v32; // 0x100003c68
        int32_t v33; // 0x100003c6c
        if (v26 >= 1) {
            v27 = *v14;
            v28 = *v12 - 1;
            v29 = v27 - v28;
            *v21 = (int32_t)(v29 < 0 != ((v29 ^ v27) & (v28 ^ v27)) < 0);
            while (v29 < 0 != ((v29 ^ v27) & (v28 ^ v27)) < 0) {
                // 0x100003cb0
                v30 = *v14 + 1;
                *v14 = v30;
                v31 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
                v32 = *(int64_t *)(*v20 + 8 * (int64_t)v30);
                v33 = _strcmp((char *)v31, (char *)v32);
                *v21 = 0;
                if (v33 < 1) {
                    // break -> 0x100003cc0
                    break;
                }
                v27 = *v14;
                v28 = *v12 - 1;
                v29 = v27 - v28;
                *v21 = (int32_t)(v29 < 0 != ((v29 ^ v27) & (v28 ^ v27)) < 0);
            }
        }
        int64_t v34 = *(int64_t *)(8 * (int64_t)*v5 + *v4); // 0x100003cc8
        int64_t v35 = *(int64_t *)(8 * (int64_t)*v14 + *v20); // 0x100003cd4
        int32_t v36 = _strcmp((char *)v34, (char *)v35); // 0x100003cd8
        int64_t v37 = v35; // 0x100003ce4
        int64_t v38; // 0x100003d20
        int64_t v39; // 0x100003d2c
        char * v40; // 0x100003d30
        int32_t v41; // 0x100003d44
        if (v36 == 0) {
            // 0x100003cec
            *v22 = v7;
            ___strcpy_chk(v7, *(int64_t *)(8 * (int64_t)*v5 + *v4), 24);
            _strlen((char *)*v22);
            function_100003e04();
            v38 = *v22;
            v39 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
            v40 = (char *)v38;
            v37 = v38;
            if (_strcmp((char *)v39, v40) >= 1) {
                // 0x100003d44
                v41 = *v23;
                *v23 = v41 + 1;
                v37 = v38;
                if (v41 < 5 != (4 - v41 & v41) < 0) {
                    // 0x100003d60
                    *v8 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
                    *v10 = v7;
                    _printf("%s\t%s\n", v40, (char *)24);
                    v37 = v38;
                }
            }
        }
        int32_t v42 = *v5 + 1; // 0x100003da0
        *v5 = v42;
        int32_t v43 = *v12; // 0x100003c3c
        int32_t v44 = v42 - v43; // 0x100003c40
        v18 = v23;
        v19 = v37;
        while (v44 < 0 != ((v44 ^ v42) & (v43 ^ v42)) < 0) {
            // 0x100003d9c
            v24 = *(int64_t *)(8 * (int64_t)v42 + *v4);
            v25 = *(int64_t *)(*v20 + 8 * (int64_t)*v14);
            v26 = _strcmp((char *)v24, (char *)v25);
            *v21 = 0;
            if (v26 >= 1) {
                v27 = *v14;
                v28 = *v12 - 1;
                v29 = v27 - v28;
                *v21 = (int32_t)(v29 < 0 != ((v29 ^ v27) & (v28 ^ v27)) < 0);
                while (v29 < 0 != ((v29 ^ v27) & (v28 ^ v27)) < 0) {
                    // 0x100003cb0
                    v30 = *v14 + 1;
                    *v14 = v30;
                    v31 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
                    v32 = *(int64_t *)(*v20 + 8 * (int64_t)v30);
                    v33 = _strcmp((char *)v31, (char *)v32);
                    *v21 = 0;
                    if (v33 < 1) {
                        // break -> 0x100003cc0
                        break;
                    }
                    v27 = *v14;
                    v28 = *v12 - 1;
                    v29 = v27 - v28;
                    *v21 = (int32_t)(v29 < 0 != ((v29 ^ v27) & (v28 ^ v27)) < 0);
                }
            }
            // 0x100003cc0
            v34 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
            v35 = *(int64_t *)(8 * (int64_t)*v14 + *v20);
            v36 = _strcmp((char *)v34, (char *)v35);
            v37 = v35;
            if (v36 == 0) {
                // 0x100003cec
                *v22 = v7;
                ___strcpy_chk(v7, *(int64_t *)(8 * (int64_t)*v5 + *v4), 24);
                _strlen((char *)*v22);
                function_100003e04();
                v38 = *v22;
                v39 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
                v40 = (char *)v38;
                v37 = v38;
                if (_strcmp((char *)v39, v40) >= 1) {
                    // 0x100003d44
                    v41 = *v23;
                    *v23 = v41 + 1;
                    v37 = v38;
                    if (v41 < 5 != (4 - v41 & v41) < 0) {
                        // 0x100003d60
                        *v8 = *(int64_t *)(8 * (int64_t)*v5 + *v4);
                        *v10 = v7;
                        _printf("%s\t%s\n", v40, (char *)24);
                        v37 = v38;
                    }
                }
            }
            // 0x100003d9c
            v42 = *v5 + 1;
            *v5 = v42;
            v43 = *v12;
            v44 = v42 - v43;
            v18 = v23;
            v19 = v37;
        }
    }
    // 0x100003dac
    *v8 = (int64_t)*v18;
    int32_t v45 = _printf("Semordnilap pairs: %d\n", v19); // 0x100003dc8
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003df0
        ___stack_chk_fail((int64_t)v45);
    }
    // 0x100003df4
    return 0;
}

// Address range: 0x100003e04 - 0x100003eb4
int64_t function_100003e04(void) {
    // 0x100003e04
    int64_t result; // 0x100003e04
    int32_t v1 = result; // 0x100003e0c
    int32_t v2 = v1 / 2; // 0x100003e30
    int32_t v3 = v1; // 0x100003e3c
    if (v1 > 1 == (v2 & -v2) < 0) {
        // 0x100003eac
        return result;
    }
    int32_t v4 = 0; // 0x100003e3c
    v3--;
    char * v5 = (char *)(result + (int64_t)v4); // 0x100003e50
    char * v6 = (char *)(result + (int64_t)v3); // 0x100003e64
    *v5 = *v6;
    *v6 = *v5;
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003e44
        v3--;
        v5 = (char *)(result + (int64_t)v4);
        v6 = (char *)(result + (int64_t)v3);
        *v5 = *v6;
        *v6 = *v5;
        v4++;
    }
    // 0x100003eac
    return result;
}

// Address range: 0x100003eb4 - 0x100003ee8
int64_t function_100003eb4(void) {
    // 0x100003eb4
    int64_t v1; // 0x100003eb4
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(int64_t a1) {
    // 0x100003ee8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ef4
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(struct _IO_FILE * stream) {
    // 0x100003f00
    return _fclose(stream);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(struct _IO_FILE * stream) {
    // 0x100003f0c
    return _fgetc(stream);
}

// Address range: 0x100003f18 - 0x100003f24
struct _IO_FILE * function_100003f18(char * filename, char * modes) {
    // 0x100003f18
    return _fopen(filename, modes);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f24
    return _fscanf(stream, format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * format, ...) {
    // 0x100003f30
    return _printf(format);
}

// Address range: 0x100003f3c - 0x100003f48
void function_100003f3c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f3c
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f48 - 0x100003f54
void function_100003f48(struct _IO_FILE * stream) {
    // 0x100003f48
    _rewind(stream);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * s1, char * s2) {
    // 0x100003f54
    return _strcmp(s1, s2);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * s) {
    // 0x100003f60
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <string.h>

/* The functions used are destructive, so after each call the string needs
 * to be copied over again. One could easily allocate new strings as
 * required, but this way allows the caller to manage memory themselves */

char* reverse_section(char *s, size_t length)
{
    if (length == 0) return s;

    size_t i; char temp;
    for (i = 0; i < length / 2 + 1; ++i)
        temp = s[i], s[i] = s[length - i], s[length - i] = temp;
    return s;
}

char* reverse_words_in_order(char *s, char delim)
{
    if (!strlen(s)) return s;

    size_t i, j;
    for (i = 0; i < strlen(s) - 1; ++i) {
        for (j = 0; s[i + j] != 0 && s[i + j] != delim; ++j)
            ;
        reverse_section(s + i, j - 1);
        s += j;
    }
    return s;
}

char* reverse_string(char *s)
{
    return strlen(s) ? reverse_section(s, strlen(s) - 1) : s;
}

char* reverse_order_of_words(char *s, char delim)
{
    reverse_string(s);
    reverse_words_in_order(s, delim);
    return s;
}

int main(void)
{
    char str[]    = "rosetta code phrase reversal";
    size_t lenstr = sizeof(str) / sizeof(str[0]);
    char scopy[lenstr];
    char delim = ' ';

    /* Original String */
    printf("Original:       \"%s\"\n", str);

    /* Reversed string */
    strncpy(scopy, str, lenstr);
    reverse_string(scopy);
    printf("Reversed:       \"%s\"\n", scopy);

    /* Reversed words in string */
    strncpy(scopy, str, lenstr);
    reverse_words_in_order(scopy, delim);
    printf("Reversed words: \"%s\"\n", scopy);

    /* Reversed order of words in string */
    strncpy(scopy, str, lenstr);
    reverse_order_of_words(scopy, delim);
    printf("Reversed order: \"%s\"\n", scopy);

    return 0;
}
`,`#include "phrase-reversals.h"



long _reverse_section(long param_1,ulong param_2)

{
  undefined uVar1;
  undefined8 local_20;
  
  if (param_2 != 0) {
    for (local_20 = 0; local_20 < param_2 / 2 + 1; local_20 = local_20 + 1) {
      uVar1 = *(undefined *)(param_1 + local_20);
      *(undefined *)(param_1 + local_20) = *(undefined *)(param_1 + (param_2 - local_20));
      *(undefined *)(param_1 + (param_2 - local_20)) = uVar1;
    }
  }
  return param_1;
}



char * _reverse_words_in_order(char *param_1,byte param_2)

{
  bool bVar1;
  size_t sVar2;
  long local_38;
  ulong local_30;
  char *local_20;
  char *local_18;
  
  sVar2 = _strlen(param_1);
  local_18 = param_1;
  if (sVar2 != 0) {
    local_20 = param_1;
    for (local_30 = 0; sVar2 = _strlen(local_20), local_30 < sVar2 - 1; local_30 = local_30 + 1) {
      local_38 = 0;
      while( true ) {
        bVar1 = false;
        if (local_20[local_30 + local_38] != '\0') {
          bVar1 = (int)local_20[local_30 + local_38] != (uint)param_2;
        }
        if (!bVar1) break;
        local_38 = local_38 + 1;
      }
      _reverse_section(local_20 + local_30,local_38 + -1);
      local_20 = local_20 + local_38;
    }
    local_18 = local_20;
  }
  return local_18;
}



char * _reverse_string(char *param_1)

{
  size_t sVar1;
  char *local_20;
  
  sVar1 = _strlen(param_1);
  local_20 = param_1;
  if (sVar1 != 0) {
    sVar1 = _strlen(param_1);
    local_20 = (char *)_reverse_section(param_1,sVar1 - 1);
  }
  return local_20;
}



undefined8 _reverse_order_of_words(undefined8 param_1,char param_2)

{
  _reverse_string(param_1);
  _reverse_words_in_order(param_1,(long)param_2);
  return param_1;
}



undefined4 entry(void)

{
  long lVar1;
  int iVar2;
  undefined8 extraout_x8;
  long alStack_a0 [2];
  long local_90;
  undefined8 local_88;
  char *local_80;
  undefined8 local_78;
  long local_70;
  undefined4 local_68;
  undefined local_61;
  undefined8 local_60;
  undefined *local_58;
  undefined8 local_50;
  undefined4 local_44;
  char local_40 [40];
  long local_18;
  
  local_58 = (undefined *)&local_90;
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_44 = 0;
  local_80 = local_40;
  builtin_strncpy(local_40,"rosetta code phrase reversal",0x1d);
  local_50 = 0x1d;
  local_88 = 0x1d;
  local_90 = 0x20;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar1 = -local_90;
  local_70 = (long)&local_90 + lVar1;
  local_60 = local_88;
  local_61 = 0x20;
  *(undefined8 *)((long)alStack_a0 + lVar1) = extraout_x8;
  _printf("Original:       \"%s\"\n");
  local_78 = 0xffffffffffffffff;
  ___strncpy_chk(local_70,local_80,local_50);
  _reverse_string(local_70);
  *(long *)((long)alStack_a0 + lVar1) = local_70;
  _printf("Reversed:       \"%s\"\n");
  ___strncpy_chk(local_70,local_80,local_50,local_78);
  _reverse_words_in_order(local_70,local_61);
  *(long *)((long)alStack_a0 + lVar1) = local_70;
  _printf("Reversed words: \"%s\"\n");
  ___strncpy_chk(local_70,local_80,local_50,local_78);
  _reverse_order_of_words(local_70,local_61);
  *(long *)((long)alStack_a0 + lVar1) = local_70;
  iVar2 = _printf("Reversed order: \"%s\"\n");
  local_44 = 0;
  local_68 = 0;
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strncpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strncpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004028)();
  return sVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef __GNUC__
#include <setjmp.h>
struct LOOP_T; typedef struct LOOP_T LOOP;
struct LOOP_T {
    jmp_buf b; LOOP * p;
} LOOP_base, * LOOP_V = &LOOP_base;
#define FOR(I, C, A, ACT) (LOOP_V = &(LOOP){ .p = LOOP_V }, \
                           (I), setjmp(LOOP_V->b), \
                           ((C) ? ((ACT),(A), longjmp(LOOP_V->b, 1), 0) : 0), \
                           LOOP_V = LOOP_V->p, 0)
#else
#define FOR(I, C, A, ACT) (({for(I;C;A){ACT;}}), 0)    // GNU version
#endif

typedef struct List { struct List * nx; char val[]; } List;
typedef struct { int _1, _2, _3; } Triple;

#define SEQ(OUT, SETS, PRED) (SEQ_var=&(ITERATOR){.l=NULL,.p=SEQ_var}, \
                              M_FFOLD(((PRED)?APPEND(OUT):0),M_ID SETS), \
                              SEQ_var->p->old=SEQ_var->l,SEQ_var=SEQ_var->p,SEQ_var->old)
typedef struct ITERATOR { List * l, * old; struct ITERATOR * p; } ITERATOR;
ITERATOR * FE_var, SEQ_base, * SEQ_var = &SEQ_base;
#define FOR_EACH(V, T, L, ACT) (FE_var=&(ITERATOR){.l=(L),.p=FE_var}, \
                                FOR((V) = *(T*)&FE_var->l->val, FE_var->l?((V)=*(T*)&FE_var->l->val,1):0, \
                                FE_var->l=FE_var->l->nx, ACT), FE_var=FE_var->p)

#define M_FFOLD(ID, ...) M_ID(M_CONC(M_FFOLD_, M_NARGS(__VA_ARGS__)) (ID, __VA_ARGS__))
#define FORSET(V, T, L) V, T, L
#define APPEND(T, val) (SEQ_var->l?listAppend(SEQ_var->l,sizeof(T),&val):(SEQ_var->l=listNew(sizeof(T),&val)))

#define M_FFOLD_1(ID, E) FOR_EACH M_IDP(FORSET E, ID)
#define M_FFOLD_2(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_1(ID, __VA_ARGS__))
#define M_FFOLD_3(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_2(ID, __VA_ARGS__))  //...

#define M_NARGS(...) M_NARGS_(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#define M_NARGS_(_10, _9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) N
#define M_CONC(A, B) M_CONC_(A, B)
#define M_CONC_(A, B) A##B
#define M_ID(...) __VA_ARGS__
#define M_IDP(...) (__VA_ARGS__)

#define R(f, t) int,intRangeList(f, t)
#define T(a, b, c) Triple,((Triple){(a),(b),(c)})

List * listNew(int sz, void * val) {
 List * l = malloc(sizeof(List) + sz); l->nx = NULL; memcpy(l->val, val, sz); return l;
}
List * listAppend(List * l, int sz, void * val) {
 while (l->nx) { l = l->nx; } l->nx = listNew(sz, val); return l;
}
List * intRangeList(int f, int t) {
 List * l = listNew(sizeof f, &f), * e = l;
 for (int i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); } // C11 compliant
//int i;
//for (i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); }    // use this for C99
 return l;
}

int main(void) {
    volatile int x, y, z; const int n = 20;

    List * pTriples = SEQ(
                          T(x, y, z),
                          (
                           (x, R(1, n)),
                           (y, R(x, n)),
                           (z, R(y, n))
                          ),
                          (x*x + y*y == z*z)
                         );

    volatile Triple t;
    FOR_EACH(t, Triple, pTriples,  printf("%d, %d, %d\n", t._1, t._2, t._3)  );

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003928(void);
int64_t function_10000397c(void);
int64_t function_1000039e4(void);
int64_t function_100003f64(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t * function_100003f70(int32_t size);
int64_t * function_100003f7c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f88(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x8010; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003928 - 0x10000397c
int64_t function_100003928(void) {
    // 0x100003928
    int64_t v1; // 0x100003928
    int32_t v2 = v1; // 0x100003934
    int64_t * v3 = _malloc(v2 + 8); // 0x100003944
    int64_t result = (int64_t)v3; // 0x100003944
    *v3 = 0;
    ___memcpy_chk(result + 8, v1, v2, -1);
    return result;
}

// Address range: 0x10000397c - 0x1000039e4
int64_t function_10000397c(void) {
    int64_t v1; // 0x10000397c
    int64_t result = v1;
    int64_t * v2 = (int64_t *)result;
    int64_t v3 = *v2; // 0x10000399c
    while (v3 != 0) {
        // 0x100003998
        result = v3;
        v2 = (int64_t *)result;
        v3 = *v2;
    }
    // 0x1000039c0
    *v2 = function_100003928();
    return result;
}

// Address range: 0x1000039e4 - 0x100003a7c
int64_t function_1000039e4(void) {
    // 0x1000039e4
    int64_t v1; // 0x1000039e4
    int32_t v2 = v1; // 0x1000039fc
    int64_t result = function_100003928(); // 0x100003a04
    int32_t v3 = (int32_t)v1 + 1;
    int32_t v4 = v3 - v2; // 0x100003a2c
    int32_t v5 = v3; // 0x100003a34
    if (v4 != 0 && v4 < 0 == ((v4 ^ v3) & (v3 ^ v2)) < 0) {
        // 0x100003a6c
        return result;
    }
    int64_t v6 = function_100003928(); // 0x100003a44
    *(int64_t *)result = v6;
    v5++;
    while (v5 - v2 == 0 || v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        int64_t v7 = v6;
        v6 = function_100003928();
        *(int64_t *)v7 = v6;
        v5++;
    }
    // 0x100003a6c
    return result;
}

// Address range: 0x100003a7c - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-88, 0x100003a9c
    g1 = &v1;
    int64_t v2 = function_1000039e4(); // 0x100003ab8
    int64_t v3 = v2; // bp-112, 0x100003ac0
    int64_t v4 = &v3; // 0x100003ad8
    g2 = v4;
    int64_t v5 = v4; // 0x100003b08
    if (v2 != 0) {
        // 0x100003b10
        int64_t v6; // bp-136, 0x100003a7c
        int64_t v7 = &v6;
        int64_t v8; // bp-160, 0x100003a7c
        int64_t v9 = &v8;
        int32_t v10 = *(int32_t *)(v2 + 8); // 0x100003b24
        int64_t v11 = function_1000039e4(); // 0x100003b5c
        v6 = v11;
        g2 = v7;
        int64_t v12 = v7; // 0x100003bac
        int64_t v13; // 0x100003a7c
        int32_t v14; // 0x100003a7c
        int32_t v15; // 0x100003bc8
        int64_t v16; // 0x100003c00
        int64_t v17; // 0x100003d90
        int64_t * v18; // 0x100003da8
        int64_t v19; // 0x100003ba0
        int32_t v20; // 0x100003c6c
        int64_t * v21; // 0x100003d70
        int64_t v22; // 0x100003c44
        int64_t v23; // 0x100003d44
        if (v11 != 0) {
            // 0x100003bb4
            v14 = v10 * v10;
            v15 = *(int32_t *)(v11 + 8);
            v16 = function_1000039e4();
            v8 = v16;
            g2 = v9;
            v13 = v9;
            if (v16 != 0) {
                // 0x100003c58
                v20 = *(int32_t *)(v16 + 8);
                if (v15 * v15 + v14 == v20 * v20) {
                    // 0x100003cd4
                    if (*(int64_t *)g1 == 0) {
                        // 0x100003d24
                        v23 = function_100003928();
                        *(int64_t *)g1 = v23;
                    } else {
                        // 0x100003cf0
                        function_10000397c();
                    }
                }
                // 0x100003d64
                v21 = (int64_t *)g2;
                *v21 = *(int64_t *)*v21;
                v22 = *(int64_t *)g2;
                v13 = g2;
                while (v22 != 0) {
                    // 0x100003c58
                    v20 = *(int32_t *)(v22 + 8);
                    if (v15 * v15 + v14 == v20 * v20) {
                        // 0x100003cd4
                        if (*(int64_t *)g1 == 0) {
                            // 0x100003d24
                            v23 = function_100003928();
                            *(int64_t *)g1 = v23;
                        } else {
                            // 0x100003cf0
                            function_10000397c();
                        }
                    }
                    // 0x100003d64
                    v21 = (int64_t *)g2;
                    *v21 = *(int64_t *)*v21;
                    v22 = *(int64_t *)g2;
                    v13 = g2;
                }
            }
            // 0x100003d84
            v17 = *(int64_t *)(v13 + 16);
            g2 = v17;
            v18 = (int64_t *)v17;
            *v18 = *(int64_t *)*v18;
            v19 = *(int64_t *)g2;
            v12 = g2;
            while (v19 != 0) {
                // 0x100003bb4
                v15 = *(int32_t *)(v19 + 8);
                v16 = function_1000039e4();
                v8 = v16;
                g2 = v9;
                v13 = v9;
                if (v16 != 0) {
                    // 0x100003c58
                    v20 = *(int32_t *)(v16 + 8);
                    if (v15 * v15 + v14 == v20 * v20) {
                        // 0x100003cd4
                        if (*(int64_t *)g1 == 0) {
                            // 0x100003d24
                            v23 = function_100003928();
                            *(int64_t *)g1 = v23;
                        } else {
                            // 0x100003cf0
                            function_10000397c();
                        }
                    }
                    // 0x100003d64
                    v21 = (int64_t *)g2;
                    *v21 = *(int64_t *)*v21;
                    v22 = *(int64_t *)g2;
                    v13 = g2;
                    while (v22 != 0) {
                        // 0x100003c58
                        v20 = *(int32_t *)(v22 + 8);
                        if (v15 * v15 + v14 == v20 * v20) {
                            // 0x100003cd4
                            if (*(int64_t *)g1 == 0) {
                                // 0x100003d24
                                v23 = function_100003928();
                                *(int64_t *)g1 = v23;
                            } else {
                                // 0x100003cf0
                                function_10000397c();
                            }
                        }
                        // 0x100003d64
                        v21 = (int64_t *)g2;
                        *v21 = *(int64_t *)*v21;
                        v22 = *(int64_t *)g2;
                        v13 = g2;
                    }
                }
                // 0x100003d84
                v17 = *(int64_t *)(v13 + 16);
                g2 = v17;
                v18 = (int64_t *)v17;
                *v18 = *(int64_t *)*v18;
                v19 = *(int64_t *)g2;
                v12 = g2;
            }
        }
        int64_t v24 = *(int64_t *)(v12 + 16); // 0x100003dc8
        g2 = v24;
        int64_t * v25 = (int64_t *)v24; // 0x100003de0
        *v25 = *(int64_t *)*v25;
        int64_t v26 = *(int64_t *)g2; // 0x100003afc
        v5 = g2;
        while (v26 != 0) {
            // 0x100003b10
            v10 = *(int32_t *)(v26 + 8);
            v11 = function_1000039e4();
            v6 = v11;
            g2 = v7;
            v12 = v7;
            if (v11 != 0) {
                // 0x100003bb4
                v14 = v10 * v10;
                v15 = *(int32_t *)(v11 + 8);
                v16 = function_1000039e4();
                v8 = v16;
                g2 = v9;
                v13 = v9;
                if (v16 != 0) {
                    // 0x100003c58
                    v20 = *(int32_t *)(v16 + 8);
                    if (v15 * v15 + v14 == v20 * v20) {
                        // 0x100003cd4
                        if (*(int64_t *)g1 == 0) {
                            // 0x100003d24
                            v23 = function_100003928();
                            *(int64_t *)g1 = v23;
                        } else {
                            // 0x100003cf0
                            function_10000397c();
                        }
                    }
                    // 0x100003d64
                    v21 = (int64_t *)g2;
                    *v21 = *(int64_t *)*v21;
                    v22 = *(int64_t *)g2;
                    v13 = g2;
                    while (v22 != 0) {
                        // 0x100003c58
                        v20 = *(int32_t *)(v22 + 8);
                        if (v15 * v15 + v14 == v20 * v20) {
                            // 0x100003cd4
                            if (*(int64_t *)g1 == 0) {
                                // 0x100003d24
                                v23 = function_100003928();
                                *(int64_t *)g1 = v23;
                            } else {
                                // 0x100003cf0
                                function_10000397c();
                            }
                        }
                        // 0x100003d64
                        v21 = (int64_t *)g2;
                        *v21 = *(int64_t *)*v21;
                        v22 = *(int64_t *)g2;
                        v13 = g2;
                    }
                }
                // 0x100003d84
                v17 = *(int64_t *)(v13 + 16);
                g2 = v17;
                v18 = (int64_t *)v17;
                *v18 = *(int64_t *)*v18;
                v19 = *(int64_t *)g2;
                v12 = g2;
                while (v19 != 0) {
                    // 0x100003bb4
                    v15 = *(int32_t *)(v19 + 8);
                    v16 = function_1000039e4();
                    v8 = v16;
                    g2 = v9;
                    v13 = v9;
                    if (v16 != 0) {
                        // 0x100003c58
                        v20 = *(int32_t *)(v16 + 8);
                        if (v15 * v15 + v14 == v20 * v20) {
                            // 0x100003cd4
                            if (*(int64_t *)g1 == 0) {
                                // 0x100003d24
                                v23 = function_100003928();
                                *(int64_t *)g1 = v23;
                            } else {
                                // 0x100003cf0
                                function_10000397c();
                            }
                        }
                        // 0x100003d64
                        v21 = (int64_t *)g2;
                        *v21 = *(int64_t *)*v21;
                        v22 = *(int64_t *)g2;
                        v13 = g2;
                        while (v22 != 0) {
                            // 0x100003c58
                            v20 = *(int32_t *)(v22 + 8);
                            if (v15 * v15 + v14 == v20 * v20) {
                                // 0x100003cd4
                                if (*(int64_t *)g1 == 0) {
                                    // 0x100003d24
                                    v23 = function_100003928();
                                    *(int64_t *)g1 = v23;
                                } else {
                                    // 0x100003cf0
                                    function_10000397c();
                                }
                            }
                            // 0x100003d64
                            v21 = (int64_t *)g2;
                            *v21 = *(int64_t *)*v21;
                            v22 = *(int64_t *)g2;
                            v13 = g2;
                        }
                    }
                    // 0x100003d84
                    v17 = *(int64_t *)(v13 + 16);
                    g2 = v17;
                    v18 = (int64_t *)v17;
                    *v18 = *(int64_t *)*v18;
                    v19 = *(int64_t *)g2;
                    v12 = g2;
                }
            }
            // 0x100003dbc
            v24 = *(int64_t *)(v12 + 16);
            g2 = v24;
            v25 = (int64_t *)v24;
            *v25 = *(int64_t *)*v25;
            v26 = *(int64_t *)g2;
            v5 = g2;
        }
    }
    // 0x100003df4
    g2 = *(int64_t *)(v5 + 16);
    int64_t v27 = g1;
    *(int64_t *)(*(int64_t *)(v27 + 16) + 8) = *(int64_t *)v27;
    int64_t v28 = *(int64_t *)(g1 + 16); // 0x100003e24
    g1 = v28;
    int64_t v29 = *(int64_t *)(v28 + 8); // 0x100003e30
    int64_t v30 = v29; // bp-224, 0x100003e40
    g2 = &v30;
    int64_t v31; // bp-196, 0x100003a7c
    _memcpy(&v31, (int64_t *)(v29 + 8), 12);
    int64_t v32 = g2; // 0x100003e78
    int64_t v33 = *(int64_t *)v32; // 0x100003e7c
    if (v33 == 0) {
        // 0x100003f3c
        g2 = *(int64_t *)(v32 + 16);
        return 0;
    }
    int64_t v34 = v33 + 8; // 0x100003ea8
    _memcpy(&v31, (int64_t *)v34, 12);
    int64_t v35; // 0x100003a7c
    _printf("%d, %d, %d\n", v34, 12, v35);
    int64_t * v36 = (int64_t *)g2; // 0x100003f28
    *v36 = *(int64_t *)*v36;
    int64_t v37 = *(int64_t *)g2; // 0x100003e7c
    while (v37 != 0) {
        // 0x100003e90
        v34 = v37 + 8;
        _memcpy(&v31, (int64_t *)v34, 12);
        _printf("%d, %d, %d\n", v34, 12, v35);
        v36 = (int64_t *)g2;
        *v36 = *(int64_t *)*v36;
        v37 = *(int64_t *)g2;
    }
    // 0x100003f3c
    g2 += 16;
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003f64
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t * function_100003f70(int32_t size) {
    // 0x100003f70
    return _malloc(size);
}

// Address range: 0x100003f7c - 0x100003f88
int64_t * function_100003f7c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f7c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
int main() {
  printf("\a");
  return 0;
}
`,`#include "terminal-control-ringing-the-terminal-bell.h"



undefined4 entry(void)

{
  _printf("\a");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<locale.h>
#include<wchar.h>
#include<stdio.h>
#include<time.h>

char rank[9];

int pos[8];

void swap(int i,int j){
	int temp = pos[i];
	pos[i] = pos[j];
	pos[j] = temp;
}

void generateFirstRank(){
	 int kPos,qPos,bPos1,bPos2,rPos1,rPos2,nPos1,nPos2,i;
	
	 for(i=0;i<8;i++){
		 rank[i] = 'e';
		 pos[i] = i;
	 }
		
	 do{
		 kPos = rand()%8;
		 rPos1 = rand()%8;
		 rPos2 = rand()%8;
	 }while((rPos1-kPos<=0 && rPos2-kPos<=0)||(rPos1-kPos>=0 && rPos2-kPos>=0)||(rPos1==rPos2 || kPos==rPos1 || kPos==rPos2));

	 rank[pos[rPos1]] = 'R';
	 rank[pos[kPos]] = 'K';
	 rank[pos[rPos2]] = 'R';
	
	 swap(rPos1,7);
	 swap(rPos2,6);
	 swap(kPos,5);
	
	 do{
		 bPos1 = rand()%5;
		 bPos2 = rand()%5;
	 }while(((pos[bPos1]-pos[bPos2])%2==0)||(bPos1==bPos2));

	 rank[pos[bPos1]] = 'B';
	 rank[pos[bPos2]] = 'B';
	
	 swap(bPos1,4);
	 swap(bPos2,3);
	
	 do{
		 qPos = rand()%3;
		 nPos1 = rand()%3;
	 }while(qPos==nPos1);
	
	 rank[pos[qPos]] = 'Q';
	 rank[pos[nPos1]] = 'N';
	
	 for(i=0;i<8;i++)
		 if(rank[i]=='e'){
			 rank[i] = 'N';
			 break;
		 }		
}

void printRank(){
	int i;
	
	#ifdef _WIN32
		printf("%s\n",rank);
	#else
	{
		setlocale(LC_ALL,"");
		printf("\n");
		for(i=0;i<8;i++){
			if(rank[i]=='K')
				printf("%lc",(wint_t)9812);
			else if(rank[i]=='Q')
				printf("%lc",(wint_t)9813);
			else if(rank[i]=='R')
				printf("%lc",(wint_t)9814);
			else if(rank[i]=='B')
				printf("%lc",(wint_t)9815);
			if(rank[i]=='N')
				printf("%lc",(wint_t)9816);
		}
	}
	#endif
}

int main()
{
	int i;
	
	srand((unsigned)time(NULL));
	
	for(i=0;i<9;i++){
		generateFirstRank();
		printRank();
	}
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038fc(void);
int64_t function_100003940(void);
int64_t function_100003d5c(void);
int32_t function_100003f5c(char * format, ...);
int32_t function_100003f68(void);
char * function_100003f74(int32_t category, char * locale);
void function_100003f80(int32_t seed);
int32_t function_100003f8c(int32_t * timer);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
char * g2 = "\x19"; // 0x100008020

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _rand(void);
char * _setlocale(int32_t a1, char * a2);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038fc - 0x100003940
int64_t function_1000038fc(void) {
    // 0x1000038fc
    int64_t result; // 0x1000038fc
    int32_t * v1 = (int32_t *)((0x100000000 * result >> 30) + (int64_t)&g1); // 0x100003914
    int32_t * v2 = (int32_t *)((0x100000000 * result >> 30) + (int64_t)&g1); // 0x100003920
    *v1 = *v2;
    *v2 = *v1;
    return result;
}

// Address range: 0x100003940 - 0x100003d5c
int64_t function_100003940(void) {
    int64_t v1 = 0;
    *(char *)(v1 + (int64_t)&g2) = 101;
    *(int32_t *)(4 * v1 + (int64_t)&g1) = (int32_t)v1;
    int64_t v2 = v1 + 1;
    while (v2 != 8) {
        // 0x100003968
        v1 = v2;
        *(char *)(v1 + (int64_t)&g2) = 101;
        *(int32_t *)(4 * v1 + (int64_t)&g1) = (int32_t)v1;
        v2 = v1 + 1;
    }
    int32_t v3 = _rand(); // 0x1000039ac
    int32_t v4 = v3 - 8 * v3 / 8; // 0x1000039c0
    int32_t v5 = _rand(); // 0x1000039c8
    int32_t v6 = v5 - 8 * v5 / 8; // 0x1000039d8
    int32_t v7 = _rand(); // 0x1000039e0
    int32_t v8 = v7 - 8 * v7 / 8; // 0x1000039f0
    int32_t v9 = v6 - v4; // 0x100003a04
    int32_t v10 = v8 - v4; // 0x100003a20
    int32_t v11 = 1; // 0x100003a10
    if (v9 < 1 != v10 < 1) {
        // 0x100003a3c
        v11 = 1;
        if (v9 < 0 || v10 < 0) {
            // 0x100003a7c
            v11 = v8 == v4 | v6 == v4 | v6 == v8;
        }
    }
    while (v11 != 0) {
        // 0x1000039ac
        v3 = _rand();
        v4 = v3 - 8 * v3 / 8;
        v5 = _rand();
        v6 = v5 - 8 * v5 / 8;
        v7 = _rand();
        v8 = v7 - 8 * v7 / 8;
        v9 = v6 - v4;
        v10 = v8 - v4;
        v11 = 1;
        if (v9 < 1 != v10 < 1) {
            // 0x100003a3c
            v11 = 1;
            if (v9 < 0 || v10 < 0) {
                // 0x100003a7c
                v11 = v8 == v4 | v6 == v4 | v6 == v8;
            }
        }
    }
    int32_t v12 = *(int32_t *)(4 * (int64_t)v6 + (int64_t)&g1); // 0x100003af8
    *(char *)((int64_t)v12 + (int64_t)&g2) = 82;
    int32_t v13 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g1); // 0x100003b18
    *(char *)((int64_t)v13 + (int64_t)&g2) = 75;
    int32_t v14 = *(int32_t *)(4 * (int64_t)v8 + (int64_t)&g1); // 0x100003b30
    *(char *)((int64_t)v14 + (int64_t)&g2) = 82;
    function_1000038fc();
    function_1000038fc();
    function_1000038fc();
    int32_t v15 = _rand() % 5;
    int32_t v16 = _rand() % 5;
    int32_t v17 = *(int32_t *)(4 * (int64_t)v15 + (int64_t)&g1); // 0x100003ba8
    int32_t * v18 = (int32_t *)(4 * (int64_t)v16 + (int64_t)&g1);
    int32_t v19 = v17 - *v18; // 0x100003bb4
    while (v15 == v16 || v19 == 2 * v19 / 2) {
        // 0x100003b64
        v15 = _rand() % 5;
        v16 = _rand() % 5;
        v17 = *(int32_t *)(4 * (int64_t)v15 + (int64_t)&g1);
        v18 = (int32_t *)(4 * (int64_t)v16 + (int64_t)&g1);
        v19 = v17 - *v18;
    }
    // 0x100003c04
    *(char *)((int64_t)v17 + (int64_t)&g2) = 66;
    *(char *)((int64_t)*v18 + (int64_t)&g2) = 66;
    function_1000038fc();
    function_1000038fc();
    int32_t v20 = _rand() % 3;
    int32_t v21 = _rand(); // 0x100003c74
    int32_t v22 = v21 % 3;
    while (v20 == v22) {
        // 0x100003c58
        v20 = _rand() % 3;
        v21 = _rand();
        v22 = v21 % 3;
    }
    int64_t result = v21; // 0x100003c74
    int32_t v23 = *(int32_t *)(4 * (int64_t)v20 + (int64_t)&g1); // 0x100003cb4
    *(char *)((int64_t)v23 + (int64_t)&g2) = 81;
    int32_t v24 = *(int32_t *)(4 * (int64_t)v22 + (int64_t)&g1); // 0x100003cd4
    *(char *)((int64_t)v24 + (int64_t)&g2) = 78;
    int32_t v25 = 0;
    char * v26 = (char *)((int64_t)v25 + (int64_t)&g2);
    while (*v26 != 101) {
        int32_t v27 = v25 + 1; // 0x100003d44
        if (v25 < 7 == (6 - v25 & v27) < 0) {
            // 0x100003d50
            return result;
        }
        v25 = v27;
        v26 = (char *)((int64_t)v25 + (int64_t)&g2);
    }
    // 0x100003d20
    *v26 = 78;
    // 0x100003d50
    return result;
}

// Address range: 0x100003d5c - 0x100003ef8
int64_t function_100003d5c(void) {
    // 0x100003d5c
    _setlocale(0, (char *)0x100003f98);
    int64_t v1 = 0; // 0x100003d5c
    int64_t v2 = _printf((char *)0x100003f99); // 0x100003d5c
    char v3; // 0x100003d5c
    char * v4; // 0x100003dac
    int32_t v5; // 0x100003d5c
    int64_t v6; // 0x100003d5c
    while (true) {
      lab_0x100003da0:
        // 0x100003da0
        v4 = (char *)(v1 + (int64_t)&g2);
        char v7 = *v4;
        v3 = v7;
        v6 = v2;
        switch (v7) {
            case 75: {
                // 0x100003dc0
                v5 = _printf("%lc", -104);
                goto lab_0x100003e9c_2;
            }
            case 81: {
                // 0x100003dfc
                v5 = _printf("%lc", -104);
                goto lab_0x100003e9c_2;
            }
            case 82: {
                // 0x100003e38
                v5 = _printf("%lc", -104);
                goto lab_0x100003e9c_2;
            }
            case 66: {
                // 0x100003e74
                v5 = _printf("%lc", -104);
                goto lab_0x100003e9c_2;
            }
            default: {
                goto lab_0x100003e9c;
            }
        }
    }
    // 0x100003eec
    int64_t result; // 0x100003d5c
    return result;
  lab_0x100003e9c:
    // 0x100003e9c
    if (v3 == 78) {
        int64_t v8 = _printf("%lc", -104); // 0x100003ed4
    }
    // 0x100003edc
    result = v6;
    int64_t v9 = v1 + 1;
    v1 = v9;
    v2 = result;
    if (v9 == 8) {
        return result;
    }
    goto lab_0x100003da0;
  lab_0x100003e9c_2:
    // 0x100003e9c
    v3 = *v4;
    v6 = v5;
    goto lab_0x100003e9c;
}

// Address range: 0x100003ef8 - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003ef8
    _srand(_time(NULL));
    for (int32_t i = 0; i < 9; i++) {
        // 0x100003f30
        function_100003940();
        function_100003d5c();
    }
    // 0x100003f4c
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(void) {
    // 0x100003f68
    return _rand();
}

// Address range: 0x100003f74 - 0x100003f80
char * function_100003f74(int32_t category, char * locale) {
    // 0x100003f74
    return _setlocale(category, locale);
}

// Address range: 0x100003f80 - 0x100003f8c
void function_100003f80(int32_t seed) {
    // 0x100003f80
    _srand(seed);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t * timer) {
    // 0x100003f8c
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

static char sym[] = "\n\t\\\"";

int main(void) {
	const char *code = "#include <stdio.h>%c%cstatic char sym[] = %c%cn%ct%c%c%c%c%c;%c%cint main(void) {%c%cconst char *code = %c%s%c;%c%cprintf(code, sym[0], sym[0], sym[3], sym[2], sym[2], sym[2], sym[2], sym[2], sym[3], sym[3], sym[0], sym[0], sym[0], sym[1], sym[3], code, sym[3], sym[0], sym[1], sym[0], sym[0], sym[1], sym[0], sym[0]);%c%c%creturn 0;%c}%c";
	printf(code, sym[0], sym[0], sym[3], sym[2], sym[2], sym[2], sym[2], sym[2], sym[3], sym[3], sym[0], sym[0], sym[0], sym[1], sym[3], code, sym[3], sym[0], sym[1], sym[0], sym[0], sym[1], sym[0], sym[0]);

	return 0;
}
`,`#include "quine-1.h"



undefined4 entry(void)

{
  _printf(
         "#include <stdio.h>%c%cstatic char sym[] = %c%cn%ct%c%c%c%c%c;%c%cint main(void) {%c%cconst char *code = %c%s%c;%c%cprintf(code, sym[0], sym[0], sym[3], sym[2], sym[2], sym[2], sym[2], sym[2], sym[3], sym[3], sym[0], sym[0], sym[0], sym[1], sym[3], code, sym[3], sym[0], sym[1], sym[0], sym[0], sym[1], sym[0], sym[0]);%c%c%creturn 0;%c}%c"
         );
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`/* Include statements and constant definitions */
#include <stdio.h>
#define HIGHEST_DEGREE 5
#define LARGEST_NUMBER 10

/* Recursive implementation of multifactorial function */
int multifact(int n, int deg){
   return n <= deg ? n : n * multifact(n - deg, deg);
}

/* Iterative implementation of multifactorial function */
int multifact_i(int n, int deg){
   int result = n;
   while (n >= deg + 1){
      result *= (n - deg);
      n -= deg;
   }
   return result;
}

/* Test function to print out multifactorials */
int main(void){
   int i, j;
   for (i = 1; i <= HIGHEST_DEGREE; i++){
      printf("\nDegree %d: ", i);
      for (j = 1; j <= LARGEST_NUMBER; j++){
         printf("%d ", multifact(j, i));
      }
   }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dd8(void);
int64_t function_100003e4c(void);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dd8 - 0x100003e4c
int64_t function_100003dd8(void) {
    // 0x100003dd8
    int64_t v1; // 0x100003dd8
    int32_t v2 = v1; // 0x100003de4
    int32_t v3 = v2 - (int32_t)v1; // 0x100003df4
    int64_t v4; // 0x100003dd8
    if (v3 != 0 && v3 < 0 == ((v3 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003e10
        v4 = function_100003dd8() * v1;
    }
    // 0x100003e3c
    return v4 & 0xffffffff;
}

// Address range: 0x100003e4c - 0x100003eb8
int64_t function_100003e4c(void) {
    // 0x100003e4c
    int64_t v1; // 0x100003e4c
    int32_t result = v1; // 0x100003e50
    int32_t v2 = v1; // 0x100003e54
    int32_t v3 = v2 + 1; // 0x100003e6c
    int32_t v4 = result - v3; // 0x100003e70
    int32_t v5 = result; // 0x100003e78
    if (v4 < 0 != ((v4 ^ result) & (v3 ^ result)) < 0) {
        // 0x100003eac
        return result;
    }
    int32_t result2 = result; // 0x100003e78
    v5 -= v2;
    result2 *= v5;
    int32_t v6 = v5 - v3; // 0x100003e70
    while (v6 < 0 == ((v6 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x100003e80
        v5 -= v2;
        result2 *= v5;
        v6 = v5 - v3;
    }
    // 0x100003eac
    return result2;
}

// Address range: 0x100003eb8 - 0x100003f80
int64_t entry_point(void) {
    uint32_t v1 = 1;
    int64_t v2; // 0x100003eb8
    _printf("\nDegree %d: ", v2);
    int64_t v3 = v1; // 0x100003f28
    int32_t v4 = 1;
    function_100003dd8();
    _printf("%d ", v3);
    int32_t v5 = v4 + 1; // 0x100003f50
    while (v4 == 9 || v4 < 9 != (8 - v4 & v5) < 0) {
        // 0x100003f24
        v4 = v5;
        function_100003dd8();
        _printf("%d ", v3);
        v5 = v4 + 1;
    }
    int32_t v6 = v1 + 1; // 0x100003f64
    int32_t v7 = v1 - 4; // 0x100003ed8
    while (v7 == 0 || v7 < 0 != (3 - v1 & v6) < 0) {
        // 0x100003ee8
        v1 = v6;
        _printf("\nDegree %d: ", v3);
        v3 = v1;
        v4 = 1;
        function_100003dd8();
        _printf("%d ", v3);
        v5 = v4 + 1;
        while (v4 == 9 || v4 < 9 != (8 - v4 & v5) < 0) {
            // 0x100003f24
            v4 = v5;
            function_100003dd8();
            _printf("%d ", v3);
            v5 = v4 + 1;
        }
        // 0x100003f60
        v6 = v1 + 1;
        v7 = v1 - 4;
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

int isprime(int n)
{
	int p;
	for (p = 2; p*p <= n; p++)
		if (n%p == 0) return 0;
	return n > 2;
}

int spiral(int w, int h, int x, int y)
{
	return y ? w + spiral(h - 1, w, y - 1, w - x - 1) : x;
}

int main(int c, char **v)
{
	int i, j, w = 50, h = 50, s = 1;
	if (c > 1 && (w = atoi(v[1])) <= 0) w = 50;
	if (c > 2 && (h = atoi(v[2])) <= 0) h = w;
	if (c > 3 && (s = atoi(v[3])) <= 0) s = 1;

	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++)
			putchar(isprime(w*h + s - 1 - spiral(w, h, j, i))[" #"]);
		putchar('\n');
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca8(void);
int64_t function_100003d40(void);
int32_t function_100003f84(char * nptr);
int32_t function_100003f90(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca8 - 0x100003d40
int64_t function_100003ca8(void) {
    // 0x100003ca8
    int64_t v1; // 0x100003ca8
    int32_t v2 = v1; // 0x100003cac
    int32_t v3 = 4 - v2; // 0x100003ccc
    int32_t v4 = 2; // 0x100003cd4
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
      lab_0x100003d1c:;
        int32_t v5 = v2 - 2; // 0x100003d20
        // 0x100003d34
        return !((v5 == 0 | v5 < 0 != (1 - v2 & v2) < 0));
    }
    while (v2 % v4 != 0) {
        // 0x100003cbc
        v4++;
        int32_t v6 = v4 * v4; // 0x100003cc4
        int32_t v7 = v6 - v2; // 0x100003ccc
        if (v7 != 0 && v7 < 0 == ((v7 ^ v6) & (v6 ^ v2)) < 0) {
            goto lab_0x100003d1c;
        }
    }
    // 0x100003d34
    return 0;
}

// Address range: 0x100003d40 - 0x100003dcc
int64_t function_100003d40(void) {
    // 0x100003d40
    int64_t v1; // 0x100003d40
    int64_t v2; // 0x100003d40
    if ((int32_t)v2 != 0) {
        // 0x100003d70
        v1 = function_100003d40() + v2;
    }
    // 0x100003dbc
    return v1 & 0xffffffff;
}

// Address range: 0x100003dcc - 0x100003f84
int64_t entry_point(void) {
    // 0x100003dcc
    int64_t v1; // 0x100003dcc
    int32_t v2 = v1; // 0x100003ddc
    int32_t v3 = v2 - 1; // 0x100003dfc
    int32_t v4 = 50; // 0x100003e04
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        int32_t v5 = _atoi((char *)*(int64_t *)(v1 + 8)); // 0x100003e14
        v4 = v5 < 1 ? 50 : v5;
    }
    int32_t v6 = v2 - 2; // 0x100003e3c
    int32_t v7 = 50; // 0x100003e44
    if (v6 != 0 && v6 < 0 == (1 - v2 & v2) < 0) {
        int32_t v8 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003e54
        v7 = v8 < 1 ? v4 : v8;
    }
    int32_t v9 = v2 - 3; // 0x100003e7c
    if (v9 != 0 && v9 < 0 == (2 - v2 & v2) < 0) {
        // 0x100003e8c
        _atoi((char *)*(int64_t *)(v1 + 24));
    }
    int32_t v10 = -v7; // 0x100003ec8
    if (v10 < 0 == (v7 & v10) < 0) {
        // 0x100003f74
        return 0;
    }
    int32_t v11 = -v4; // 0x100003ee8
    int32_t v12 = 0; // 0x100003f68
    int32_t v13; // 0x100003dcc
    char v14; // 0x100003f3c
    int32_t v15; // 0x100003f4c
    int32_t v16; // 0x100003ee8
    if (v11 < 0 != (v4 & v11) < 0) {
        function_100003d40();
        v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
        _putchar((int32_t)v14);
        v15 = 1;
        v16 = v15 - v4;
        v13 = v15;
        while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v4)) < 0) {
            // 0x100003ef8
            function_100003d40();
            v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
            _putchar((int32_t)v14);
            v15 = v13 + 1;
            v16 = v15 - v4;
            v13 = v15;
        }
    }
    // 0x100003f58
    _putchar(10);
    v12++;
    while (v12 - v7 < 0 != ((v12 - v7 ^ v12) & (v12 ^ v7)) < 0) {
        // 0x100003ee0
        if (v11 < 0 != (v4 & v11) < 0) {
            function_100003d40();
            v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
            _putchar((int32_t)v14);
            v15 = 1;
            v16 = v15 - v4;
            v13 = v15;
            while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v4)) < 0) {
                // 0x100003ef8
                function_100003d40();
                v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
                _putchar((int32_t)v14);
                v15 = v13 + 1;
                v16 = v15 - v4;
                v13 = v15;
            }
        }
        // 0x100003f58
        _putchar(10);
        v12++;
    }
    // 0x100003f74
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * nptr) {
    // 0x100003f84
    return _atoi(nptr);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(int32_t c) {
    // 0x100003f90
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`/* ===> INCLUDES <============================================================*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* ===> CONSTANTS <===========================================================*/
#define N_DECKS 7
const int kDecks[N_DECKS] = { 8, 24, 52, 100, 1020, 1024, 10000 };

/* ===> FUNCTION PROTOTYPES <=================================================*/
int CreateDeck( int **deck, int nCards );
void InitDeck( int *deck, int nCards );
int DuplicateDeck( int **dest, const int *orig, int nCards );
int InitedDeck( int *deck, int nCards );
int ShuffleDeck( int *deck, int nCards );
void FreeDeck( int **deck );

/* ===> FUNCTION DEFINITIONS <================================================*/

int main() {
    int i, nCards, nShuffles;
    int *deck = NULL;

    for( i=0; i<N_DECKS; ++i ) {
        nCards = kDecks[i];

        if( !CreateDeck(&deck,nCards) ) {
            fprintf( stderr, "Error: malloc() failed!\n" );
            return 1;
        }

        InitDeck( deck, nCards );
        nShuffles = 0;

        do {
            ShuffleDeck( deck, nCards );
            ++nShuffles;
        } while( !InitedDeck(deck,nCards) );

        printf( "Cards count: %d, shuffles required: %d.\n", nCards, nShuffles );

        FreeDeck( &deck );
    }

    return 0;
}

int CreateDeck( int **deck, int nCards ) {
    int *tmp = NULL;

    if( deck != NULL )
        tmp = malloc( nCards*sizeof(*tmp) );

    return tmp!=NULL ? (*deck=tmp)!=NULL : 0; /* (?success) (:failure) */
}

void InitDeck( int *deck, int nCards ) {
    if( deck != NULL ) {
        int i;

        for( i=0; i<nCards; ++i )
            deck[i] = i;
    }
}

int DuplicateDeck( int **dest, const int *orig, int nCards ) {
    if( orig != NULL && CreateDeck(dest,nCards) ) {
        memcpy( *dest, orig, nCards*sizeof(*orig) );
        return 1; /* success */
    }
    else {
        return 0; /* failure */
    }
}

int InitedDeck( int *deck, int nCards ) {
    int i;

    for( i=0; i<nCards; ++i )
        if( deck[i] != i )
            return 0; /* not inited */

    return 1; /* inited */
}

int ShuffleDeck( int *deck, int nCards ) {
    int *copy = NULL;

    if( DuplicateDeck(&copy,deck,nCards) ) {
        int i, j;

        for( i=j=0; i<nCards/2; ++i, j+=2 ) {
            deck[j] = copy[i];
            deck[j+1] = copy[i+nCards/2];
        }

        FreeDeck( &copy );
        return 1; /* success */
    }
    else {
        return 0; /* failure */
    }
}

void FreeDeck( int **deck ) {
    if( *deck != NULL ) {
        free( *deck );
        *deck = NULL;
    }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ba8(void);
int64_t function_100003c3c(void);
int64_t function_100003cac(void);
int64_t function_100003da0(void);
int64_t function_100003e20(void);
int64_t function_100003e6c(void);
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003f00(struct _IO_FILE * stream, char * format, ...);
void function_100003f0c(int64_t * ptr);
int64_t * function_100003f18(int32_t size);
int32_t function_100003f24(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x1800000008; // 0x100003f30
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a7c - 0x100003ba8
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003a7c
    uint64_t v2 = 0;
    uint32_t v3 = *(int32_t *)(4 * v2 + (int64_t)&g1); // 0x100003ab8
    while ((int32_t)function_100003ba8() != 0) {
        int32_t v4 = v1;
        function_100003c3c();
        function_100003cac();
        while ((int32_t)function_100003da0() == 0) {
            // 0x100003b14
            function_100003cac();
        }
        // 0x100003b4c
        int64_t v5; // 0x100003a7c
        _printf("Cards count: %d, shuffles required: %d.\n", (int64_t)v3, v5);
        function_100003e20();
        int64_t v6 = v2 + 1;
        v1 = v4 + 1;
        if (v2 < 6 == (5 - v4 & (int32_t)v6) < 0) {
            // 0x100003b98
            return 0;
        }
        v2 = v6;
        v3 = *(int32_t *)(4 * v2 + (int64_t)&g1);
    }
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ae4
    _fprintf((struct _IO_FILE *)v7, "Error: malloc() failed!\n");
    // 0x100003b98
    return 1;
}

// Address range: 0x100003ba8 - 0x100003c3c
int64_t function_100003ba8(void) {
    // 0x100003ba8
    int64_t v1; // 0x100003ba8
    if (v1 == 0) {
        // 0x100003c2c
        return 0;
    }
    int64_t * v2 = _malloc(4 * (int32_t)v1); // 0x100003bdc
    int64_t result = 0; // 0x100003bf4
    if (v2 != NULL) {
        // 0x100003bfc
        *(int64_t *)v1 = (int64_t)v2;
        result = 1;
    }
    // 0x100003c2c
    return result;
}

// Address range: 0x100003c3c - 0x100003cac
int64_t function_100003c3c(void) {
    // 0x100003c3c
    int64_t result; // 0x100003c3c
    if (result == 0) {
        // 0x100003ca4
        return result;
    }
    int32_t v1 = result; // 0x100003c44
    int32_t v2 = -v1; // 0x100003c6c
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003ca4
        return result;
    }
    int32_t v3 = 0;
    *(int32_t *)(4 * (int64_t)v3 + result) = v3;
    int32_t v4 = v3 + 1; // 0x100003c94
    while (v4 - v1 < 0 != ((v4 - v1 ^ v4) & (v4 ^ v1)) < 0) {
        // 0x100003c7c
        v3 = v4;
        *(int32_t *)(4 * (int64_t)v3 + result) = v3;
        v4 = v3 + 1;
    }
    // 0x100003ca4
    return result;
}

// Address range: 0x100003cac - 0x100003da0
int64_t function_100003cac(void) {
    // 0x100003cac
    if ((int32_t)function_100003e6c() == 0) {
        // 0x100003d90
        return 0;
    }
    // 0x100003cf0
    int64_t v1; // 0x100003cac
    int32_t v2 = v1; // 0x100003cbc
    int32_t v3 = v2 / 2; // 0x100003cfc
    int32_t v4 = 0; // 0x100003d08
    int32_t v5 = 0; // 0x100003d08
    if (v2 > 1 == (v3 & -v3) < 0) {
        // 0x100003d74
        function_100003e20();
        // 0x100003d90
        return 1;
    }
    int32_t v6 = *(int32_t *)(4 * (int64_t)v4); // 0x100003d18
    *(int32_t *)(4 * (int64_t)v5 + v1) = v6;
    int32_t v7 = *(int32_t *)(int64_t)(4 * (v4 + v3)); // 0x100003d40
    *(int32_t *)(v1 + (int64_t)(4 * v5 | 4)) = v7;
    v4++;
    int32_t v8 = v4 - v3; // 0x100003d00
    v5 += 2;
    while (v8 < 0 != ((v8 ^ v4) & (v4 ^ v3)) < 0) {
        // 0x100003d10
        v6 = *(int32_t *)(4 * (int64_t)v4);
        *(int32_t *)(4 * (int64_t)v5 + v1) = v6;
        v7 = *(int32_t *)(int64_t)(4 * (v4 + v3));
        *(int32_t *)(v1 + (int64_t)(4 * v5 | 4)) = v7;
        v4++;
        v8 = v4 - v3;
        v5 += 2;
    }
    // 0x100003d74
    function_100003e20();
    // 0x100003d90
    return 1;
}

// Address range: 0x100003da0 - 0x100003e20
int64_t function_100003da0(void) {
    // 0x100003da0
    int64_t v1; // 0x100003da0
    int32_t v2 = v1; // 0x100003da8
    int32_t v3 = -v2; // 0x100003dbc
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e14
        return 1;
    }
    int32_t v4 = 0; // 0x100003dfc
    int64_t result = 0; // 0x100003de4
    while (*(int32_t *)(4 * (int64_t)v4 + v1) == v4) {
        // 0x100003db4
        v4++;
        int32_t v5 = v4 - v2; // 0x100003dbc
        result = 1;
        if (v5 < 0 == ((v5 ^ v4) & (v4 ^ v2)) < 0) {
            // break -> 0x100003e14
            break;
        }
        result = 0;
    }
    // 0x100003e14
    return result;
}

// Address range: 0x100003e20 - 0x100003e6c
int64_t function_100003e20(void) {
    int64_t result = 0; // 0x100003e40
    int64_t v1; // 0x100003e20
    if (v1 != 0) {
        int64_t * v2 = (int64_t *)v1; // 0x100003e50
        _free(v2);
        *v2 = 0;
        result = &g2;
    }
    // 0x100003e60
    return result;
}

// Address range: 0x100003e6c - 0x100003ef4
int64_t function_100003e6c(void) {
    // 0x100003e6c
    int64_t v1; // 0x100003e6c
    if (v1 == 0) {
        // 0x100003ee4
        return 0;
    }
    int64_t v2 = function_100003ba8(); // 0x100003ea0
    int64_t result = 0; // 0x100003eac
    if ((int32_t)v2 != 0) {
        // 0x100003eb4
        ___memcpy_chk(v2, v1, 0x100000000 * v1 >> 30, -1);
        result = 1;
    }
    // 0x100003ee4
    return result;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ef4
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f00
    return _fprintf(stream, format);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(int64_t * ptr) {
    // 0x100003f0c
    _free(ptr);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h> // atoi()
#include <math.h> // pow()

int main(int argc, char* argv[])
{
  int i, count=0;
  double f, sum=0.0, prod=1.0, resum=0.0;

  for (i=1; i<argc; ++i) {
    f = atof(argv[i]);
    count++;
    sum += f;
    prod *= f;
    resum += (1.0/f);
  }
  //printf(" c:%d\n s:%f\n p:%f\n r:%f\n",count,sum,prod,resum);
  printf("Arithmetic mean = %f\n",sum/count);
  printf("Geometric mean = %f\n",pow(prod,(1.0/count)));
  printf("Harmonic mean = %f\n",count/resum);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f44(char * nptr);
float64_t function_100003f50(float64_t a1, float64_t a2);
int32_t function_100003f5c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

float64_t _atof(char * a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003de8 - 0x100003f44
int64_t entry_point(void) {
    // 0x100003de8
    int64_t v1; // 0x100003de8
    int32_t v2 = v1; // 0x100003df8
    int32_t v3 = 1 - v2; // 0x100003e2c
    int32_t v4 = 1; // 0x100003e34
    int128_t v5; // 0x100003de8
    int64_t v6 = v5; // 0x100003e34
    if (v3 < 0 != (v3 & v2) < 0) {
        float64_t v7 = _atof((char *)*(int64_t *)(8 * (int64_t)v4 + v1)); // 0x100003e48
        v4++;
        while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
            // 0x100003e3c
            v7 = _atof((char *)*(int64_t *)(8 * (int64_t)v4 + v1));
            v4++;
        }
        // 0x100003e24
        v6 = (float32_t)v7;
    }
    // 0x100003ea8
    __asm_sshll(0.0f, 0);
    _printf("Arithmetic mean = %f\n", (float64_t)v6);
    int128_t v8 = __asm_sshll(0.0f, 0); // 0x100003ee0
    _printf("Geometric mean = %f\n", _pow((float64_t)v6, (float64_t)(int64_t)v8));
    _printf("Harmonic mean = %f\n", (float64_t)(int64_t)__asm_sshll(0.0f, 0));
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
float64_t function_100003f44(char * nptr) {
    // 0x100003f44
    return _atof(nptr);
}

// Address range: 0x100003f50 - 0x100003f5c
float64_t function_100003f50(float64_t a1, float64_t a2) {
    // 0x100003f50
    return _pow(a1, a2);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

/* Returns true' if element e' is in array a'. Otherwise, returns false'.
 * Checks only the first n' elements. Pure, O(n).
 */
bool elem(int *a, size_t n, int e)
{
    for (size_t i = 0; i < n; ++i)
        if (a[i] == e)
            return true;

    return false;
}

/* Removes the duplicates in array a' of given length n'. Returns the number
 * of unique elements. In-place, order preserving, O(n ^ 2).
 */
size_t nub(int *a, size_t n)
{
    size_t m = 0;

    for (size_t i = 0; i < n; ++i)
        if (!elem(a, m, a[i]))
            a[m++] = a[i];

    return m;
}

/* Out-place version of nub'. Pure, order preserving, alloc < n * sizeof(int)
 * bytes, O(n ^ 2).
 */
size_t nub_new(int **b, int *a, size_t n)
{
    int *c = malloc(n * sizeof(int));
    memcpy(c, a, n * sizeof(int));
    int m = nub(c, n);
    *b = malloc(m * sizeof(int));
    memcpy(*b, c, m * sizeof(int));
    free(c);
    return m;
}

int main(void)
{
    int a[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};
    int *b;

    size_t n = nub_new(&b, a, sizeof(a) / sizeof(a[0]));

    for (size_t i = 0; i < n; ++i)
        printf("%d ", b[i]);
    puts("");

    free(b);
    return 0;
}
`,`#include "remove-duplicate-elements-2.h"



undefined _elem(long param_1,ulong param_2,int param_3)

{
  ulong local_28;
  
  local_28 = 0;
  while( true ) {
    if (param_2 <= local_28) {
      return 0;
    }
    if (*(int *)(param_1 + local_28 * 4) == param_3) break;
    local_28 = local_28 + 1;
  }
  return 1;
}



long _nub(long param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 local_30;
  undefined8 local_28;
  
  local_28 = 0;
  for (local_30 = 0; local_30 < param_2; local_30 = local_30 + 1) {
    uVar1 = _elem(param_1,local_28,*(undefined4 *)(param_1 + local_30 * 4));
    if ((uVar1 & 1) == 0) {
      *(undefined4 *)(param_1 + local_28 * 4) = *(undefined4 *)(param_1 + local_30 * 4);
      local_28 = local_28 + 1;
    }
  }
  return local_28;
}



long _nub_new(undefined8 *param_1,undefined8 param_2,long param_3)

{
  int iVar1;
  void *pvVar2;
  void *pvVar3;
  
  pvVar2 = _malloc(param_3 << 2);
  ___memcpy_chk(pvVar2,param_2,param_3 << 2);
  iVar1 = _nub(pvVar2,param_3);
  pvVar3 = _malloc((long)iVar1 << 2);
  *param_1 = pvVar3;
  ___memcpy_chk(*param_1,pvVar2,(long)iVar1 << 2,0xffffffffffffffff);
  _free(pvVar2);
  return (long)iVar1;
}



undefined8 entry(void)

{
  ulong uVar1;
  ulong local_60;
  void *local_50;
  undefined4 local_44;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_44 = 0;
  _memcpy(auStack_40,&DAT_100003f70,0x28);
  uVar1 = _nub_new(&local_50,auStack_40,10);
  for (local_60 = 0; local_60 < uVar1; local_60 = local_60 + 1) {
    _printf("%d ");
  }
  _puts("");
  _free(local_50);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef unsigned uint;
int is_prime(uint n)
{
        if (!(n%2) || !(n%3)) return 0;
        uint p = 1;
        while(p*p < n)
                if (n%(p += 4) == 0 || n%(p += 2) == 0)
                        return 0;
        return 1;
}

uint reverse(uint n)
{
        uint r;
        for (r = 0; n; n /= 10)
                r = r*10 + (n%10);
        return r;
}

int is_emirp(uint n)
{
        uint r = reverse(n);
        return r != n && is_prime(n) && is_prime(r);
}

int main(int argc, char **argv)
{
        uint x, c = 0;
        switch(argc) { // advanced args parsing
        case 1: for (x = 11; c < 20; x += 2)
                        if (is_emirp(x))
                                printf(" %u", x), ++c;
                break;

        case 2: for (x = 7701; x < 8000; x += 2)
                        if (is_emirp(x))
                                printf(" %u", x);
                break;

        default:
                for (x = 11; ; x += 2)
                        if (is_emirp(x) && ++c == 10000) {
                                printf("%u", x);
                                break;
                        }
        }

        putchar('\n');
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bc0(void);
int64_t function_100003cc0(void);
int64_t function_100003d2c(void);
int32_t function_100003f80(char * format, ...);
int32_t function_100003f8c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bc0 - 0x100003cc0
int64_t function_100003bc0(void) {
    // 0x100003bc0
    int64_t v1; // 0x100003bc0
    uint32_t v2 = (int32_t)v1; // 0x100003bc4
    if (v2 % 3 == 0 || 2 * v2 / 2 == v2) {
        // 0x100003cb4
        return 0;
    }
    int32_t v3 = 1; // 0x100003c78
    int64_t result = 1; // 0x100003c3c
    while (v3 * v3 < v2) {
        // 0x100003c44
        result = 0;
        if (v2 % (v3 + 4) == 0) {
            // break -> 0x100003cb4
            break;
        }
        // 0x100003c70
        v3 += 6;
        result = 0;
        if (v2 % v3 == 0) {
            // break -> 0x100003cb4
            break;
        }
        result = 1;
    }
    // 0x100003cb4
    return result;
}

// Address range: 0x100003cc0 - 0x100003d2c
int64_t function_100003cc0(void) {
    // 0x100003cc0
    int64_t v1; // 0x100003cc0
    int32_t v2 = v1; // 0x100003cc4
    uint32_t v3 = v2; // 0x100003cdc
    if (v2 == 0) {
        // 0x100003d20
        return 0;
    }
    int32_t result = 0; // 0x100003cdc
    result = 10 * result + v3 % 10;
    while (v3 >= 10) {
        // 0x100003ce4
        v3 /= 10;
        result = 10 * result + v3 % 10;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d2c - 0x100003db4
int64_t function_100003d2c(void) {
    // 0x100003d2c
    int64_t v1; // 0x100003d2c
    if ((int32_t)function_100003cc0() == (int32_t)v1) {
        // 0x100003da0
        return 0;
    }
    int64_t result = 0; // 0x100003d80
    if ((int32_t)function_100003bc0() != 0) {
        // 0x100003d88
        result = (int32_t)function_100003bc0() != 0;
    }
    // 0x100003da0
    return result;
}

// Address range: 0x100003db4 - 0x100003f80
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003db4
    int64_t v2; // 0x100003db4
    int64_t v3; // 0x100003db4
    switch ((int32_t)v3) {
        case 1: {
            int32_t v4 = 0;
            int32_t v5 = v4; // 0x100003e2c
            if ((int32_t)function_100003d2c() != 0) {
                // 0x100003e34
                _printf(" %u", (int32_t)v2);
                v5 = v4 + 1;
            }
            int32_t v6 = v5;
            while (v6 < 20) {
                // 0x100003e1c
                v4 = v6;
                v5 = v4;
                if ((int32_t)function_100003d2c() != 0) {
                    // 0x100003e34
                    _printf(" %u", (int32_t)v2);
                    v5 = v4 + 1;
                }
                // 0x100003e64
                v6 = v5;
            }
            // break -> 0x100003f68
            break;
        }
        case 2: {
            for (int32_t i = 0x1e15; i < 0x1f3f; i += 2) {
                // 0x100003e9c
                if ((int32_t)function_100003d2c() != 0) {
                    // 0x100003eb4
                    _printf(" %u", (int32_t)v2);
                }
            }
            // break -> 0x100003f68
            break;
        }
        default: {
            while (true) {
                int32_t v7 = v1;
                v1 = v7;
                if ((int32_t)function_100003d2c() != 0) {
                    // 0x100003f10
                    v1 = v7 + 1;
                    if (v7 == 0x270f) {
                        // break -> 0x100003f30
                        break;
                    }
                }
            }
            // 0x100003f30
            _printf("%u", (int32_t)v2);
            // 0x100003f68
            _putchar(10);
            return 0;
        }
    }
    // 0x100003f68
    _putchar(10);
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t c) {
    // 0x100003f8c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`/**
 * @file
 * @brief Program to print the nth term of the Fibonacci series.
 * @details 
 * Fibonacci series generally starts from 0 and 1. Every next term in
 * the series is equal to the sum of the two preceding terms.
 * For further info: https://en.wikipedia.org/wiki/Fibonacci_sequence
 *
 * @author [Luiz Carlos Aguiar C](https://github.com/IKuuhakuI)
 * @author [Niranjan](https://github.com/niranjank2022)
 */

#include <assert.h>  /// for assert()
#include <errno.h>  /// for errno - to determine whether there is an error while using strtol()
#include <stdio.h>   /// for input, output
#include <stdlib.h>  /// for exit() - to exit the program
#include <time.h>   /// to calculate time taken by fib()
/**
 * @brief Determines the nth Fibonacci term
 * @param number - n in "nth term" and it can't be negative as well as zero
 * @return nth term in unsigned type
 * @warning
 * Only till 47th and 48th fibonacci element can be stored in int and
 * unsigned int respectively (takes more than 20 seconds to print)
 */
unsigned int fib(int number)
{
    // Check for negative integers
    if (number <= 0)
    {
        fprintf(stderr, "Illegal Argument Is Passed!\n");
        exit(EXIT_FAILURE);
    }

    // Base conditions
    if (number == 1)
        return 0;

    if (number == 2)
        return 1;

    // Recursive call to the function
    return fib(number - 1) + fib(number - 2);
}

/**
 * @brief Get the input from the user
 * @return valid argument to the fibonacci function
 */
int getInput(void)
{
    int num, excess_len;
    char buffer[3], *endPtr;

    while (1)
    {  // Repeat until a valid number is entered
        printf("Please enter a valid number:");
        fgets(buffer, 3, stdin);  // Inputs the value from user

        excess_len = 0;
        if (!(buffer[0] == '\n' ||
            buffer[1] == '\n' ||
            buffer[2] == '\n')) {
            while (getchar() != '\n') excess_len++;
        }

        num = strtol(buffer, &endPtr,
                     10);  // Attempts to convert the string to integer

        // Checking the input
        if (  // The number is too large
            (excess_len > 0 || num > 48) ||
            // Characters other than digits are included in the input
            (*endPtr != '\0' && *endPtr != '\n') ||
            // No characters are entered
            endPtr == buffer)
        {
            continue;
        }

        break;
    }

    printf("\nEntered digit: %d (it might take sometime)\n", num);
    return num;
}

/**
 * @brief self-test implementation
 * @return void
 */
static void test()
{
    assert(fib(5) == 3);
    assert(fib(2) == 1);
    assert(fib(9) == 21);
}

/**
 * @brief Main function
 * @return 0 on exit
 */
int main()
{
    // Performing the test
    test();
    printf("Tests passed...\n");

    // Getting n
    printf(
        "Enter n to find nth fibonacci element...\n"
        "Note: You would be asked to enter input until valid number ( less "
        "than or equal to 48 ) is entered.\n");

    int number = getInput();
    clock_t start, end;

    start = clock();
    printf("Fibonacci element %d is %u ", number, fib(number));
    end = clock();

    printf("in %.3f seconds.\n", ((double)(end - start)) / CLOCKS_PER_SEC );
    return 0;
}
`,`#include "fibonacci.h"



int _fib(int param_1)

{
  int iVar1;
  int local_14;
  
  if (param_1 < 1) {
    _fprintf(*(FILE **)PTR____stderrp_100004008,"Illegal Argument Is Passed!\n");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  if (param_1 == 1) {
    local_14 = 0;
  }
  else if (param_1 == 2) {
    local_14 = 1;
  }
  else {
    local_14 = _fib(param_1 + -1);
    iVar1 = _fib(param_1 + -2);
    local_14 = local_14 + iVar1;
  }
  return local_14;
}



int _getInput(void)

{
  int iVar1;
  long lVar2;
  char *local_28;
  char local_1b;
  char local_1a;
  char local_19;
  int local_18;
  int local_14;
  
  do {
    _printf("Please enter a valid number:");
    _fgets(&local_1b,3,*(FILE **)PTR____stdinp_100004010);
    local_18 = 0;
    if (((local_1b != '\n') && (local_1a != '\n')) && (local_19 != '\n')) {
      while (iVar1 = _getchar(), iVar1 != 10) {
        local_18 = local_18 + 1;
      }
    }
    lVar2 = _strtol(&local_1b,&local_28,10);
    local_14 = (int)lVar2;
  } while ((((0 < local_18) || (0x30 < local_14)) || ((*local_28 != '\0' && (*local_28 != '\n'))))
          || (local_28 == &local_1b));
  _printf("\nEntered digit: %d (it might take sometime)\n");
  return local_14;
}



undefined4 entry(void)

{
  int iVar1;
  undefined4 uVar2;
  
  FUN_100003ce8();
  _printf("Tests passed...\n");
  iVar1 = _printf(
                 "Enter n to find nth fibonacci element...\nNote: You would be asked to enter input until valid number ( less than or equal to 48 ) is entered.\n"
                 );
  uVar2 = _getInput(iVar1);
  _clock();
  _fib(uVar2);
  _printf("Fibonacci element %d is %u ");
  _clock();
  _printf("in %.3f seconds.\n");
  return 0;
}



void FUN_100003ce8(void)

{
  int iVar1;
  
  iVar1 = _fib(5);
  if (iVar1 != 3) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("test","fibonacci.c",0x5e,"fib(5) == 3");
  }
  iVar1 = _fib(2);
  if (iVar1 != 1) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("test","fibonacci.c",0x5f,"fib(2) == 1");
  }
  iVar1 = _fib(9);
  if (iVar1 != 0x15) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("test","fibonacci.c",0x60,"fib(9) == 21");
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003dd8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003de4. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004018)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003df0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dfc. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004028)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004038)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _strtol(char *param_1,char **param_2,int param_3)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e2c. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__strtol_100004048)(param_1,param_2,param_3);
  return lVar1;
}


`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>


#define MAXLEN 100
typedef char TWord[MAXLEN];


typedef struct WordsArray {
    TWord *words;
    size_t len;
} WordsArray;


int is_ordered_word(const TWord word) {
    assert(word != NULL);
    int i;

    for (i = 0; word[i] != '\0'; i++)
        if (word[i] > word[i + 1] && word[i + 1] != '\0')
            return 0;

    return 1;
}


void array_append(WordsArray *words_array, const TWord new_word) {
    assert(words_array != NULL);
    assert(new_word != NULL);
    assert((words_array->len == 0) == (words_array->words == NULL));

    words_array->len++;
    words_array->words = realloc(words_array->words,
                                 words_array->len * sizeof(words_array->words[0]));
    if (words_array->words == NULL)
        exit(EXIT_FAILURE);
    strcpy(words_array->words[words_array->len-1], new_word);
}


void array_free(WordsArray *words_array) {
    assert(words_array != NULL);
    free(words_array->words);
    words_array->words = NULL;
    words_array->len = 0;
}


void list_print(WordsArray *words_array) {
    assert(words_array != NULL);
    size_t i;
    for (i = 0; i < words_array->len; i++)
        printf("\n%s", words_array->words[i]);
}


int main() {
    FILE *fp = fopen("unixdict.txt", "r");
    if (fp == NULL)
        return EXIT_FAILURE;

    WordsArray words;
    words.len = 0;
    words.words = NULL;

    TWord line;
    line[0] = '\0';
    unsigned int max_len = 0;

    while (fscanf(fp, "%99s\n", line) != EOF) { // 99 = MAXLEN - 1
        if (strlen(line) > max_len && is_ordered_word(line)) {
            max_len = strlen(line);
            array_free(&words);
            array_append(&words, line);
        } else if (strlen(line) == max_len && is_ordered_word(line)) {
            array_append(&words, line);
        }
    }

    fclose(fp);
    list_print(&words);
    array_free(&words);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038e8(void);
int64_t function_1000039e4(void);
int64_t function_100003b74(void);
int64_t function_100003bf0(void);
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003e68(void);
int64_t function_100003e74(int64_t a1, int64_t a2, int64_t a3);
void function_100003e80(int32_t status);
int32_t function_100003e8c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e98(char * filename, char * modes);
void function_100003ea4(int64_t * ptr);
int32_t function_100003eb0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003ebc(char * format, ...);
int64_t * function_100003ec8(int64_t * ptr, int32_t size);
int32_t function_100003ed4(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038e8 - 0x1000039e4
int64_t function_1000038e8(void) {
    // 0x1000038e8
    int64_t v1; // 0x1000038e8
    if (v1 == 0) {
        // 0x100003918
        ___assert_rtn("is_ordered_word", "ordered-words-2.c", 18, "word != NULL");
    }
    int32_t v2 = 0; // 0x100003940
    char v3 = *(char *)(v1 + (int64_t)v2); // 0x10000394c
    int64_t result = 1; // 0x100003958
    while (v3 != 0) {
        int32_t v4 = v3; // 0x100003968
        v2++;
        char v5 = *(char *)(v1 + (int64_t)v2); // 0x100003978
        int32_t v6 = v4 - (int32_t)v5; // 0x10000397c
        result = 0;
        if (v5 != 0 && v6 != 0 && v6 < 0 == ((v6 ^ v4) & (int32_t)(v5 ^ v3)) < 0) {
            // break -> 0x1000039d4
            break;
        }
        v3 = *(char *)(v1 + (int64_t)v2);
        result = 1;
    }
    // 0x1000039d4
    return result;
}

// Address range: 0x1000039e4 - 0x100003b74
int64_t function_1000039e4(void) {
    // 0x1000039e4
    int64_t v1; // 0x1000039e4
    int64_t v2; // 0x1000039e4
    if (v1 == 0) {
        // 0x100003a18
        v2 = ___assert_rtn("array_append", "ordered-words-2.c", 30, "words_array != NULL");
    }
    int64_t v3 = v2; // 0x100003a54
    if (v1 == 0) {
        // 0x100003a5c
        v3 = ___assert_rtn("array_append", "ordered-words-2.c", 31, "new_word != NULL");
    }
    int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003a84
    int64_t v5 = *v4; // 0x100003a84
    int64_t v6 = v5; // 0x100003abc
    int64_t v7 = v3; // 0x100003abc
    if (v5 == 0 != (v3 == 0)) {
        // 0x100003ac4
        v7 = ___assert_rtn("array_append", "ordered-words-2.c", 32, "(words_array->len == 0) == (words_array->words == NULL)");
        v6 = *v4;
    }
    int64_t v8 = v6 + 1; // 0x100003af0
    *v4 = v8;
    int64_t * v9 = _realloc((int64_t *)v7, 100 * (int32_t)v8); // 0x100003b10
    int64_t v10 = (int64_t)v9; // 0x100003b10
    *(int64_t *)v1 = v10;
    if (v9 != NULL) {
        // 0x100003b3c
        return ___strcpy_chk(v10 - 100 + 100 * *v4, v1, -1);
    }
    // 0x100003b34
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003b74 - 0x100003bf0
int64_t function_100003b74(void) {
    // 0x100003b74
    int64_t v1; // 0x100003b74
    int64_t v2; // 0x100003b74
    if (v1 == 0) {
        // 0x100003ba4
        v2 = ___assert_rtn("array_free", "ordered-words-2.c", 44, "words_array != NULL");
    }
    // 0x100003bc8
    _free((int64_t *)v2);
    *(int64_t *)v1 = 0;
    *(int64_t *)(v1 + 8) = 0;
    return &g1;
}

// Address range: 0x100003bf0 - 0x100003cb4
int64_t function_100003bf0(void) {
    // 0x100003bf0
    int64_t v1; // 0x100003bf0
    int64_t v2; // 0x100003bf0
    if (v1 == 0) {
        // 0x100003c20
        ___assert_rtn("list_print", "ordered-words-2.c", 52, "words_array != NULL");
        v2 = (int64_t)"ordered-words-2.c";
    }
    // 0x100003c44
    int32_t result; // 0x100003c90
    for (int64_t i = 0; i < *(int64_t *)(v1 + 8); i++) {
        // 0x100003c68
        result = _printf("\n%s", (char *)v2);
    }
    // 0x100003ca8
    return result;
}

// Address range: 0x100003cb4 - 0x100003e5c
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("unixdict.txt", "r"); // 0x100003ce4
    int64_t result = 1; // 0x100003cf8
    char v2; // bp-124, 0x100003cb4
    int32_t v3; // 0x100003cb4
    int32_t v4; // 0x100003cb4
    int32_t v5; // 0x100003cb4
    uint64_t v6; // 0x100003d54
    char ** v7; // 0x100003d38
    if (v1 != NULL) {
        // 0x100003d0c
        v2 = 0;
        int64_t v8; // 0x100003cb4
        v7 = (char **)v8;
        v3 = 0;
        if (_fscanf(v1, "%99s\n", v7) != -1) {
            while (true) {
              lab_0x100003d4c:
                // 0x100003d4c
                v4 = v3;
                uint64_t v9 = (int64_t)_strlen(&v2); // 0x100003d50
                v6 = (int64_t)v4;
                if (v9 == v6 || v9 < v6) {
                    goto lab_0x100003db0;
                } else {
                    // 0x100003d68
                    if ((int32_t)function_1000038e8() == 0) {
                        goto lab_0x100003db0;
                    } else {
                        int32_t v10 = _strlen(&v2); // 0x100003d88
                        function_100003b74();
                        function_1000039e4();
                        v5 = v10;
                        goto lab_0x100003df8;
                    }
                }
            }
        }
      lab_0x100003dfc:
        // 0x100003dfc
        _fclose(v1);
        function_100003bf0();
        function_100003b74();
        result = 0;
    }
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e34
    if (v11 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003e48
        ___stack_chk_fail();
    }
    // 0x100003e4c
    return result;
  lab_0x100003db0:;
    int32_t v12 = _strlen(&v2); // 0x100003db4
    v5 = v4;
    if ((int64_t)v12 == v6) {
        // 0x100003dcc
        v5 = v4;
        if ((int32_t)function_1000038e8() != 0) {
            // 0x100003de4
            function_1000039e4();
            v5 = v4;
        }
    }
    goto lab_0x100003df8;
  lab_0x100003df8:
    // 0x100003df8
    v3 = v5;
    if (_fscanf(v1, "%99s\n", v7) == -1) {
        // break -> 0x100003dfc
        goto lab_0x100003dfc;
    }
    goto lab_0x100003d4c;
}

// Address range: 0x100003e5c - 0x100003e68
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e5c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(void) {
    // 0x100003e68
    return ___stack_chk_fail();
}

// Address range: 0x100003e74 - 0x100003e80
int64_t function_100003e74(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003e74
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e80 - 0x100003e8c
void function_100003e80(int32_t status) {
    // 0x100003e80
    _exit(status);
}

// Address range: 0x100003e8c - 0x100003e98
int32_t function_100003e8c(struct _IO_FILE * stream) {
    // 0x100003e8c
    return _fclose(stream);
}

// Address range: 0x100003e98 - 0x100003ea4
struct _IO_FILE * function_100003e98(char * filename, char * modes) {
    // 0x100003e98
    return _fopen(filename, modes);
}

// Address range: 0x100003ea4 - 0x100003eb0
void function_100003ea4(int64_t * ptr) {
    // 0x100003ea4
    _free(ptr);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003eb0
    return _fscanf(stream, format);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * format, ...) {
    // 0x100003ebc
    return _printf(format);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int64_t * ptr, int32_t size) {
    // 0x100003ec8
    return _realloc(ptr, size);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(char * s) {
    // 0x100003ed4
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <string.h>

/* The functions used are destructive, so after each call the string needs
 * to be copied over again. One could easily allocate new strings as
 * required, but this way allows the caller to manage memory themselves */

char* reverse_section(char *s, size_t length)
{
    if (length == 0) return s;

    size_t i; char temp;
    for (i = 0; i < length / 2 + 1; ++i)
        temp = s[i], s[i] = s[length - i], s[length - i] = temp;
    return s;
}

char* reverse_words_in_order(char *s, char delim)
{
    if (!strlen(s)) return s;

    size_t i, j;
    for (i = 0; i < strlen(s) - 1; ++i) {
        for (j = 0; s[i + j] != 0 && s[i + j] != delim; ++j)
            ;
        reverse_section(s + i, j - 1);
        s += j;
    }
    return s;
}

char* reverse_string(char *s)
{
    return strlen(s) ? reverse_section(s, strlen(s) - 1) : s;
}

char* reverse_order_of_words(char *s, char delim)
{
    reverse_string(s);
    reverse_words_in_order(s, delim);
    return s;
}

int main(void)
{
    char str[]    = "rosetta code phrase reversal";
    size_t lenstr = sizeof(str) / sizeof(str[0]);
    char scopy[lenstr];
    char delim = ' ';

    /* Original String */
    printf("Original:       \"%s\"\n", str);

    /* Reversed string */
    strncpy(scopy, str, lenstr);
    reverse_string(scopy);
    printf("Reversed:       \"%s\"\n", scopy);

    /* Reversed words in string */
    strncpy(scopy, str, lenstr);
    reverse_words_in_order(scopy, delim);
    printf("Reversed words: \"%s\"\n", scopy);

    /* Reversed order of words in string */
    strncpy(scopy, str, lenstr);
    reverse_order_of_words(scopy, delim);
    printf("Reversed order: \"%s\"\n", scopy);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a80(void);
int64_t function_100003b5c(void);
int64_t function_100003c98(void);
int64_t function_100003d04(void);
int64_t function_100003db0(void);
int64_t function_100003ef8(int64_t a1);
int64_t function_100003f04(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strncpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a80 - 0x100003b5c
int64_t function_100003a80(void) {
    // 0x100003a80
    int64_t result; // 0x100003a80
    uint64_t v1 = result;
    if (v1 == 0) {
        // 0x100003b50
        return result;
    }
    int64_t v2 = 0;
    char * v3 = (char *)(v2 + result); // 0x100003ae4
    char * v4 = (char *)(result + v1 - v2); // 0x100003b00
    *v3 = *v4;
    *v4 = *v3;
    while (v2 != v1 / 2) {
        // 0x100003ad8
        v2++;
        v3 = (char *)(v2 + result);
        v4 = (char *)(result + v1 - v2);
        *v3 = *v4;
        *v4 = *v3;
    }
    // 0x100003b50
    return result;
}

// Address range: 0x100003b5c - 0x100003c98
int64_t function_100003b5c(void) {
    // 0x100003b5c
    int64_t v1; // 0x100003b5c
    char * v2 = (char *)v1; // 0x100003b68
    if (_strlen(v2) == 0 || _strlen(v2) == 1) {
        // 0x100003c88
        return (int64_t)v2;
    }
    int64_t v3 = 0; // 0x100003c70
    int64_t v4 = (int64_t)v2; // 0x100003bcc
    int64_t v5 = v3 + v4;
    char v6 = *(char *)v5; // 0x100003bdc
    char v7 = v6; // 0x100003bf0
    int64_t v8 = 0; // 0x100003bf0
    int64_t v9; // 0x100003b5c
    int64_t v10; // 0x100003b5c
    int64_t v11; // 0x100003c34
    char v12; // 0x100003bdc
    if (v6 != 0) {
        v10 = 0;
        v8 = v10;
        while (0x1000000 * (int32_t)v1 >> 24 != (int32_t)v7) {
            // 0x100003c30
            v11 = v10 + 1;
            v12 = *(char *)(v5 + v11);
            v7 = v12;
            v9 = v11;
            v8 = v11;
            if (v12 == 0) {
                // break -> 0x100003c40
                break;
            }
            v10 = v9;
            v8 = v10;
        }
    }
    // 0x100003c40
    function_100003a80();
    char * v13 = (char *)(v8 + v4);
    v3++;
    int32_t v14 = _strlen(v13); // 0x100003ba8
    while (v3 < (int64_t)v14 - 1) {
        // 0x100003bcc
        v4 = (int64_t)v13;
        v5 = v3 + v4;
        v6 = *(char *)v5;
        v7 = v6;
        v8 = 0;
        if (v6 != 0) {
            v10 = 0;
            v8 = v10;
            while (0x1000000 * (int32_t)v1 >> 24 != (int32_t)v7) {
                // 0x100003c30
                v11 = v10 + 1;
                v12 = *(char *)(v5 + v11);
                v7 = v12;
                v9 = v11;
                v8 = v11;
                if (v12 == 0) {
                    // break -> 0x100003c40
                    break;
                }
                v10 = v9;
                v8 = v10;
            }
        }
        // 0x100003c40
        function_100003a80();
        v13 = (char *)(v8 + v4);
        v3++;
        v14 = _strlen(v13);
    }
    // 0x100003c88
    return (int64_t)v13;
}

// Address range: 0x100003c98 - 0x100003d04
int64_t function_100003c98(void) {
    // 0x100003c98
    int64_t v1; // 0x100003c98
    char * v2 = (char *)v1; // 0x100003ca4
    int64_t result; // 0x100003c98
    if (_strlen(v2) != 0) {
        // 0x100003cc0
        _strlen(v2);
        result = function_100003a80();
    }
    // 0x100003cf4
    return result;
}

// Address range: 0x100003d04 - 0x100003d3c
int64_t function_100003d04(void) {
    // 0x100003d04
    function_100003c98();
    function_100003b5c();
    int64_t result; // 0x100003d04
    return result;
}

// Address range: 0x100003d3c - 0x100003db0
int64_t entry_point(void) {
    // 0x100003d3c
    return ___chkstk_darwin();
}

// Address range: 0x100003db0 - 0x100003ef8
int64_t function_100003db0(void) {
    // 0x100003db0
    int64_t v1; // 0x100003db0
    int64_t v2 = v1;
    int64_t v3; // 0x100003db0
    int64_t v4 = (int64_t)&v3 - *(int64_t *)(v2 - 128); // 0x100003dbc
    int64_t * v5 = (int64_t *)(v2 - 96); // 0x100003dc0
    *v5 = v4;
    *(int64_t *)(v2 - 80) = *(int64_t *)(v2 - 120);
    char * v6 = (char *)(v2 - 81); // 0x100003dd0
    *v6 = 32;
    int64_t * v7 = (int64_t *)(v4 - 16); // 0x100003ddc
    _printf("Original:       \"%s\"\n", (char *)v1);
    int64_t * v8 = (int64_t *)(v2 - 112); // 0x100003dec
    int64_t v9 = *v8; // 0x100003dec
    int64_t * v10 = (int64_t *)(v2 - 64); // 0x100003df8
    int64_t * v11 = (int64_t *)(v2 - 104); // 0x100003e00
    *v11 = -1;
    ___strncpy_chk(*v5, v9, *v10, -1);
    function_100003c98();
    *v7 = *v5;
    _printf("Reversed:       \"%s\"\n", (char *)v9);
    ___strncpy_chk(*v5, *v8, *v10, *v11);
    function_100003b5c();
    *v7 = *v5;
    _printf("Reversed words: \"%s\"\n", (char *)((int64_t)*v6 & 0xffffffff));
    ___strncpy_chk(*v5, *v8, *v10, *v11);
    function_100003d04();
    *v7 = *v5;
    int32_t v12 = _printf("Reversed order: \"%s\"\n", (char *)((int64_t)*v6 & 0xffffffff)); // 0x100003ea8
    *(int32_t *)(v2 - 52) = 0;
    int32_t * v13 = (int32_t *)(v2 - 88); // 0x100003ec0
    *v13 = 0;
    int64_t result = 0; // 0x100003edc
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003ee4
        ___stack_chk_fail((int64_t)v12);
        result = (int64_t)*v13;
    }
    // 0x100003ee8
    return result;
}

// Address range: 0x100003ef8 - 0x100003f04
int64_t function_100003ef8(int64_t a1) {
    // 0x100003ef8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f04 - 0x100003f10
int64_t function_100003f04(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f04
    return ___strncpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * s) {
    // 0x100003f1c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct IntArray_t {
    int *ptr;
    size_t length;
} IntArray;

IntArray make(size_t size) {
    IntArray temp;
    temp.ptr = calloc(size, sizeof(int));
    temp.length = size;
    return temp;
}

void destroy(IntArray *ia) {
    if (ia->ptr != NULL) {
        free(ia->ptr);

        ia->ptr = NULL;
        ia->length = 0;
    }
}

void zeroFill(IntArray dst) {
    memset(dst.ptr, 0, dst.length * sizeof(int));
}

int indexOf(const int n, const IntArray ia) {
    size_t i;
    for (i = 0; i < ia.length; i++) {
        if (ia.ptr[i] == n) {
            return i;
        }
    }
    return -1;
}

bool getDigits(int n, int le, IntArray digits) {
    while (n > 0) {
        int r = n % 10;
        if (r == 0 || indexOf(r, digits) >= 0) {
            return false;
        }
        le--;
        digits.ptr[le] = r;
        n /= 10;
    }
    return true;
}

int removeDigit(IntArray digits, size_t le, size_t idx) {
    static const int POWS[] = { 1, 10, 100, 1000, 10000 };
    int sum = 0;
    int pow = POWS[le - 2];
    size_t i;
    for (i = 0; i < le; i++) {
        if (i == idx) continue;
        sum += digits.ptr[i] * pow;
        pow /= 10;
    }
    return sum;
}

int main() {
    int lims[4][2] = { { 12, 97 }, { 123, 986 }, { 1234, 9875 }, { 12345, 98764 } };
    int count[5] = { 0 };
    int omitted[5][10] = { {0} };
    size_t upperBound = sizeof(lims) / sizeof(lims[0]);
    size_t i;

    for (i = 0; i < upperBound; i++) {
        IntArray nDigits = make(i + 2);
        IntArray dDigits = make(i + 2);
        int n;

        for (n = lims[i][0]; n <= lims[i][1]; n++) {
            int d;
            bool nOk;

            zeroFill(nDigits);
            nOk = getDigits(n, i + 2, nDigits);
            if (!nOk) {
                continue;
            }
            for (d = n + 1; d <= lims[i][1] + 1; d++) {
                size_t nix;
                bool dOk;

                zeroFill(dDigits);
                dOk = getDigits(d, i + 2, dDigits);
                if (!dOk) {
                    continue;
                }
                for (nix = 0; nix < nDigits.length; nix++) {
                    int digit = nDigits.ptr[nix];
                    int dix = indexOf(digit, dDigits);
                    if (dix >= 0) {
                        int rn = removeDigit(nDigits, i + 2, nix);
                        int rd = removeDigit(dDigits, i + 2, dix);
                        if ((double)n / d == (double)rn / rd) {
                            count[i]++;
                            omitted[i][digit]++;
                            if (count[i] <= 12) {
                                printf("%d/%d = %d/%d by omitting %d's\n", n, d, rn, rd, digit);
                            }
                        }
                    }
                }
            }
        }

        printf("\n");

        destroy(&nDigits);
        destroy(&dDigits);
    }

    for (i = 2; i <= 5; i++) {
        int j;

        printf("There are %d %d-digit fractions of which:\n", count[i - 2], i);

        for (j = 1; j <= 9; j++) {
            if (omitted[i - 2][j] == 0) {
                continue;
            }
            printf("%6d have %d's omitted\n", omitted[i - 2][j], j);
        }

        printf("\n");
    }

    return 0;
}
`,`#include "fraction-reduction.h"



undefined  [16] _make(size_t param_1)

{
  undefined auVar1 [16];
  void *pvVar2;
  
  pvVar2 = _calloc(param_1,4);
  auVar1._8_8_ = param_1;
  auVar1._0_8_ = pvVar2;
  return auVar1;
}



void _destroy(long *param_1)

{
  if (*param_1 != 0) {
    _free((void *)*param_1);
    *param_1 = 0;
    param_1[1] = 0;
  }
  return;
}



void _zeroFill(undefined8 param_1,long param_2)

{
  ___memset_chk(param_1,0,param_2 << 2,0xffffffffffffffff);
  return;
}



undefined4 _indexOf(int param_1,long param_2,ulong param_3)

{
  ulong local_28;
  
  local_28 = 0;
  while( true ) {
    if (param_3 <= local_28) {
      return 0xffffffff;
    }
    if (*(int *)(param_2 + local_28 * 4) == param_1) break;
    local_28 = local_28 + 1;
  }
  return (int)local_28;
}



undefined _getDigits(int param_1,int param_2,long param_3,undefined8 param_4)

{
  int iVar1;
  int iVar2;
  int local_30;
  int local_2c;
  
  local_30 = param_2;
  local_2c = param_1;
  while( true ) {
    if (local_2c < 1) {
      return 1;
    }
    iVar1 = local_2c % 10;
    if ((iVar1 == 0) || (iVar2 = _indexOf(iVar1,param_3,param_4), -1 < iVar2)) break;
    local_30 = local_30 + -1;
    *(int *)(param_3 + (long)local_30 * 4) = iVar1;
    local_2c = local_2c / 10;
  }
  return 0;
}



int _removeDigit(long param_1,undefined8 param_2,ulong param_3,ulong param_4)

{
  ulong local_30;
  int local_28;
  int local_24;
  
  local_24 = 0;
  local_28 = *(int *)(&DAT_100003ef8 + (param_3 - 2) * 4);
  for (local_30 = 0; local_30 < param_3; local_30 = local_30 + 1) {
    if (local_30 != param_4) {
      local_24 = local_24 + *(int *)(param_1 + local_30 * 4) * local_28;
      local_28 = local_28 / 10;
    }
  }
  return local_24;
}



undefined8 entry(void)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  void *pvVar6;
  undefined auVar7 [16];
  int local_198;
  ulong local_180;
  int local_170;
  int local_16c;
  undefined local_168 [16];
  undefined local_158 [16];
  ulong local_148;
  ulong local_140;
  undefined4 local_134;
  int aiStack_130 [50];
  int local_68 [6];
  int local_50 [10];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_134 = 0;
  local_50[2] = 0x7b;
  local_50[3] = 0x3da;
  local_50[0] = 0xc;
  local_50[1] = 0x61;
  local_50[6] = 0x3039;
  local_50[7] = 0x181cc;
  local_50[4] = 0x4d2;
  local_50[5] = 0x2693;
  local_68[0] = 0;
  local_68[1] = 0;
  local_68[2] = 0;
  local_68[3] = 0;
  local_68[4] = 0;
  pvVar6 = _memset(aiStack_130,0,200);
  local_140 = 4;
  for (local_148 = 0; local_148 < local_140; local_148 = local_148 + 1) {
    auVar7 = _make(local_148 + 2);
    local_158 = auVar7;
    auVar7 = _make(local_148 + 2);
    local_16c = local_50[local_148 * 2];
    while( true ) {
      local_168 = auVar7;
      if (local_50[local_148 * 2 + 1] < local_16c) break;
      _zeroFill(local_158._0_8_,local_158._8_8_);
      bVar2 = _getDigits(local_16c,local_148 + 2,local_158._0_8_,local_158._8_8_);
      local_170 = local_16c;
      auVar7 = local_168;
      if ((bVar2 & 1) != 0) {
        while( true ) {
          local_170 = local_170 + 1;
          auVar7 = local_168;
          if (local_50[local_148 * 2 + 1] + 1 < local_170) break;
          _zeroFill(local_168._0_8_,local_168._8_8_);
          bVar2 = _getDigits(local_170,local_148 + 2,local_168._0_8_,local_168._8_8_);
          if ((bVar2 & 1) != 0) {
            local_180 = 0;
            while( true ) {
              if ((ulong)local_158._8_8_ <= local_180) break;
              iVar1 = *(int *)(local_158._0_8_ + local_180 * 4);
              iVar3 = _indexOf(iVar1,local_168._0_8_,local_168._8_8_);
              if (-1 < iVar3) {
                iVar4 = _removeDigit(local_158._0_8_,local_158._8_8_,local_148 + 2,local_180);
                iVar3 = _removeDigit(local_168._0_8_,local_168._8_8_,local_148 + 2,(long)iVar3);
                if ((double)(long)local_16c / (double)(long)local_170 ==
                    (double)(long)iVar4 / (double)(long)iVar3) {
                  local_68[local_148] = local_68[local_148] + 1;
                  aiStack_130[local_148 * 10 + (long)iVar1] =
                       aiStack_130[local_148 * 10 + (long)iVar1] + 1;
                  if (local_68[local_148] < 0xd) {
                    _printf("%d/%d = %d/%d by omitting %d\'s\n");
                  }
                }
              }
              local_180 = local_180 + 1;
            }
          }
        }
      }
      local_16c = local_16c + 1;
    }
    _printf("\n");
    _destroy(local_158);
    pvVar6 = (void *)_destroy(local_168);
  }
  for (local_148 = 2; local_148 < 6; local_148 = local_148 + 1) {
    _printf("There are %d %d-digit fractions of which:\n");
    for (local_198 = 1; local_198 < 10; local_198 = local_198 + 1) {
      if (aiStack_130[(local_148 - 2) * 10 + (long)local_198] != 0) {
        _printf("%6d have %d\'s omitted\n");
      }
    }
    uVar5 = _printf("\n");
    pvVar6 = (void *)(ulong)uVar5;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(pvVar6);
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004028)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

/* we just return a yes/no status; caller can check errno */
int copy_file(const char *in, const char *out)
{
	int ret = 0;
	int fin, fout;
	ssize_t len;
	char *buf[4096]; /* buffer size, some multiple of block size preferred */
	struct stat st;

	if ((fin  = open(in,  O_RDONLY)) == -1) return 0;
	if (fstat(fin, &st)) goto bail;

	/* open output with same permission */
	fout = open(out, O_WRONLY|O_CREAT|O_TRUNC, st.st_mode & 0777);
	if (fout == -1) goto bail;

	while ((len = read(fin, buf, 4096)) > 0)
		write(fout, buf, len);

	ret = len ? 0 : 1; /* last read should be 0 */

bail:	if (fin != -1)  close(fin);
	if (fout != -1) close(fout);
	return ret;
}

int main()
{
	copy_file("infile", "outfile");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d5c(char * a1, char * a2);
int64_t function_100003d78(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f48(void);
int32_t function_100003f54(int32_t fd);
int32_t function_100003f60(int32_t fd, struct stat * buf);
int32_t function_100003f6c(char * file, int32_t oflag, ...);
int32_t function_100003f78(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_100003f84(int32_t fd, int64_t * buf, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _close(int32_t a1);
int32_t _fstat(int32_t a1, struct stat * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003d5c - 0x100003d78
int64_t function_100003d5c(char * a1, char * a2) {
    // 0x100003d5c
    return ___chkstk_darwin();
}

// Address range: 0x100003d78 - 0x100003f0c
int64_t function_100003d78(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d78
    int64_t v1; // 0x100003d78
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003d8c
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int32_t v3 = _open((char *)v1, 0); // 0x100003da4
    int64_t v4 = 0; // 0x100003db4
    int64_t v5; // 0x100003d78
    int32_t v6; // 0x100003d78
    if (v3 == -1) {
        goto lab_0x100003ec8;
    } else {
        // 0x100003dc4
        int64_t v7; // bp-32968, 0x100003d78
        int32_t v8 = _fstat(v3, (struct stat *)&v7); // 0x100003dcc
        v5 = 0;
        if (v8 == 0) {
            int32_t v9 = _open((char *)v1, 1537); // 0x100003e00
            if (v9 == -1) {
                // 0x100003e9c
                _close(v3);
                v4 = 0;
                goto lab_0x100003ec8;
            } else {
                // 0x100003e24
                int64_t v10; // bp-32776, 0x100003d78
                int32_t v11 = _read(v3, &v10, 0x1000); // 0x100003e30
                int32_t v12 = v11; // 0x100003e40
                if (v11 >= 1) {
                    _write(v9, &v10, v11);
                    int32_t v13 = _read(v3, &v10, 0x1000); // 0x100003e30
                    int32_t v14 = v13; // 0x100003e40
                    v12 = v13;
                    while (v13 >= 1) {
                        // 0x100003e48
                        _write(v9, &v10, v14);
                        v13 = _read(v3, &v10, 0x1000);
                        v14 = v13;
                        v12 = v13;
                    }
                }
                // 0x100003e5c
                v6 = v9;
                v5 = v12 == 0;
                goto lab_0x100003e9c;
            }
        } else {
            goto lab_0x100003e9c;
        }
    }
  lab_0x100003ec8:
    // 0x100003ec8
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003ef0
        ___stack_chk_fail();
    }
    // 0x100003ef4
    return v4 & 0xffffffff;
  lab_0x100003e9c:
    // 0x100003e9c
    _close(v3);
    v4 = v5;
    if (v6 != -1) {
        // 0x100003eb0
        _close(v6);
        v4 = v5;
    }
    goto lab_0x100003ec8;
}

// Address range: 0x100003f0c - 0x100003f48
int64_t entry_point(void) {
    // 0x100003f0c
    function_100003d5c("infile", "outfile");
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(void) {
    // 0x100003f48
    return ___stack_chk_fail();
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t fd) {
    // 0x100003f54
    return _close(fd);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t fd, struct stat * buf) {
    // 0x100003f60
    return _fstat(fd, buf);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * file, int32_t oflag, ...) {
    // 0x100003f6c
    return _open(file, oflag);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003f78
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(int32_t fd, int64_t * buf, int32_t n) {
    // 0x100003f84
    return _write(fd, buf, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>

unsigned long long sum35(unsigned long long limit)
{
    unsigned long long sum = 0;
    for (unsigned long long i = 0; i < limit; i++)
        if (!(i % 3) || !(i % 5))
            sum += i;
    return sum;
}

int main(int argc, char **argv)
{
    unsigned long long limit;

    if (argc == 2)
        limit = strtoull(argv[1], NULL, 10);
    else
        limit = 1000;

    printf("%lld\n", sum35(limit));
    return 0;
}
`,`#include "sum-multiples-of-3-and-5-1.h"



long _sum35(ulong param_1)

{
  ulong local_18;
  long local_10;
  
  local_10 = 0;
  for (local_18 = 0; local_18 < param_1; local_18 = local_18 + 1) {
    if ((local_18 % 3 == 0) || (local_18 % 5 == 0)) {
      local_10 = local_10 + local_18;
    }
  }
  return local_10;
}



undefined8 entry(int param_1,long param_2)

{
  ulonglong local_28;
  
  if (param_1 == 2) {
    local_28 = _strtoull(*(char **)(param_2 + 8),(char **)0x0,10);
  }
  else {
    local_28 = 1000;
  }
  _sum35(local_28);
  _printf("%lld\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulonglong _strtoull(char *param_1,char **param_2,int param_3)

{
  ulonglong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoull_100004008)(param_1,param_2,param_3);
  return uVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>

int main(void)
{
    int n;
    int g;
    char c;

    srand(time(NULL));
    n = 1 + (rand() % 10);

    puts("I'm thinking of a number between 1 and 10.");
    puts("Try to guess it:");

    while (1) {
        if (scanf("%d", &g) != 1) {
		/* ignore one char, in case user gave a non-number */
		scanf("%c", &c);
		continue;
	}

        if (g == n) {
	    puts("Correct!");
	    return 0;
	}
        puts("That's not my number. Try another guess:");
    }
}
`,`#include "guess-the-number.h"



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  time_t tVar3;
  int local_1c;
  
  tVar3 = _time((time_t *)0x0);
  _srand((uint)tVar3);
  iVar1 = _rand();
  _puts("I\'m thinking of a number between 1 and 10.");
  _puts("Try to guess it:");
  while( true ) {
    while (iVar2 = _scanf("%d"), iVar2 != 1) {
      _scanf("%c");
    }
    if (local_1c == iVar1 % 10 + 1) break;
    _puts("That\'s not my number. Try another guess:");
  }
  _puts("Correct!");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004008)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004020)();
  return tVar1;
}


`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

int main(int argc, char** argv)
{
	int i,j,sandPileEdge, centerPileHeight, processAgain = 1,top,down,left,right;	
	int** sandPile;
	char* fileName;
	static unsigned char colour[3];

	if(argc!=3){
		printf("Usage: %s <Sand pile side> <Center pile height>",argv[0]);
		return 0;
	}

	sandPileEdge = atoi(argv[1]);
	centerPileHeight = atoi(argv[2]);

	if(sandPileEdge<=0 || centerPileHeight<=0){
		printf("Sand pile and center pile dimensions must be positive integers.");
		return 0;
	}

	sandPile = (int**)malloc(sandPileEdge * sizeof(int*));

	for(i=0;i<sandPileEdge;i++){
		sandPile[i] = (int*)calloc(sandPileEdge,sizeof(int));
	}

	sandPile[sandPileEdge/2][sandPileEdge/2] = centerPileHeight;

	printf("Initial sand pile :\n\n");

	for(i=0;i<sandPileEdge;i++){
		for(j=0;j<sandPileEdge;j++){
			printf("%3d",sandPile[i][j]);
		}
		printf("\n");
	}

	while(processAgain == 1){

		processAgain = 0;
		top = 0;
		down = 0;
		left = 0;
		right = 0;

		for(i=0;i<sandPileEdge;i++){
			for(j=0;j<sandPileEdge;j++){
				if(sandPile[i][j]>=4){				
					if(i-1>=0){
						top = 1;
						sandPile[i-1][j]+=1;
						if(sandPile[i-1][j]>=4)
							processAgain = 1;
					}
					if(i+1<sandPileEdge){
						down = 1;
						sandPile[i+1][j]+=1;
						if(sandPile[i+1][j]>=4)
							processAgain = 1;
					}
					if(j-1>=0){
						left = 1;
						sandPile[i][j-1]+=1;
						if(sandPile[i][j-1]>=4)
							processAgain = 1;
					}
					if(j+1<sandPileEdge){
						right = 1;
						sandPile[i][j+1]+=1;
						if(sandPile[i][j+1]>=4)
							processAgain = 1;
					}
				sandPile[i][j] -= (top + down + left + right);
				if(sandPile[i][j]>=4)
					processAgain = 1;
				}
			}
		}
	}

	printf("Final sand pile : \n\n");

	for(i=0;i<sandPileEdge;i++){
		for(j=0;j<sandPileEdge;j++){
			printf("%3d",sandPile[i][j]);
		}
		printf("\n");
	}

	fileName = (char*)malloc((strlen(argv[1]) + strlen(argv[2]) + 23)*sizeof(char));

	strcpy(fileName,"Final_Sand_Pile_");
	strcat(fileName,argv[1]);
	strcat(fileName,"_");
	strcat(fileName,argv[2]);
	strcat(fileName,".ppm");
	
	FILE *fp = fopen(fileName,"wb");

	fprintf(fp,"P6\n%d %d\n255\n",sandPileEdge,sandPileEdge);

	for(i=0;i<sandPileEdge;i++){
		for(j=0;j<sandPileEdge;j++){
			colour[0] = (sandPile[i][j] + i)%256;
			colour[1] = (sandPile[i][j] + j)%256;
			colour[2] = (sandPile[i][j] + i*j)%256;
			fwrite(colour,1,3,fp);
		}
	}
	
	fclose(fp);

	printf("\nImage file written to %s\n",fileName);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e3c(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003e48(int64_t a1, char * a2);
int32_t function_100003e54(char * nptr);
int64_t * function_100003e60(int32_t nmemb, int32_t size);
int32_t function_100003e6c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e78(char * filename, char * modes);
int32_t function_100003e84(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003e90(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003e9c(int32_t size);
int32_t function_100003ea8(char * format, ...);
int32_t function_100003eb4(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x77006d70702e005f; // 0x100003f72
int64_t g2; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strcat_chk(int64_t a1, int64_t a2, int64_t a3);
int64_t ___strcpy_chk(int64_t a1, char * a2);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003660 - 0x100003e3c
int64_t entry_point(void) {
    // 0x100003660
    int64_t v1; // 0x100003660
    if ((int32_t)v1 != 3) {
        // 0x100003694
        _printf("Usage: %s <Sand pile side> <Center pile height>", (char *)v1);
        // 0x100003e2c
        return 0;
    }
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x1000036bc
    int32_t v3 = _atoi((char *)*v2); // 0x1000036c0
    int64_t * v4 = (int64_t *)(v1 + 16); // 0x1000036cc
    int32_t v5 = _atoi((char *)*v4); // 0x1000036d0
    if (v3 < 1 || v5 < 1) {
        // 0x100003700
        _printf("Sand pile and center pile dimensions must be positive integers.");
        // 0x100003e2c
        return 0;
    }
    int64_t v6 = (int64_t)_malloc(8 * v3); // 0x10000371c
    int32_t v7 = -v3;
    int32_t v8 = 0; // 0x10000373c
    int64_t v9; // 0x100003660
    if (v7 < 0 != (v3 & v7) < 0) {
        *(int64_t *)(8 * (int64_t)v8 + v6) = (int64_t)_calloc(v3, 4);
        v8++;
        int32_t v10 = v8 - v3; // 0x100003734
        v9 = 4;
        while (v10 < 0 != ((v10 ^ v8) & (v8 ^ v3)) < 0) {
            // 0x100003744
            *(int64_t *)(8 * (int64_t)v8 + v6) = (int64_t)_calloc(v3, 4);
            v8++;
            v10 = v8 - v3;
            v9 = 4;
        }
    }
    int32_t v11 = v3 / 2; // 0x100003780
    int64_t v12 = *(int64_t *)(v6 + (int64_t)(8 * v11)); // 0x100003784
    *(int32_t *)(v12 + (int64_t)(4 * v11)) = v5;
    _printf("Initial sand pile :\n\n");
    int32_t v13 = 0; // 0x1000037b8
    if (v7 < 0 != (v3 & v7) < 0) {
        int32_t v14 = 0; // 0x100003814
        _printf("%3d", v9);
        v14++;
        while (v14 - v3 < 0 != ((v14 - v3 ^ v14) & (v14 ^ v3)) < 0) {
            // 0x1000037e0
            _printf("%3d", v9);
            v14++;
        }
        // 0x100003820
        _printf("\n");
        v13++;
        while (v13 - v3 < 0 != ((v13 - v3 ^ v13) & (v13 ^ v3)) < 0) {
            // 0x1000037e0
            v14 = 0;
            _printf("%3d", v9);
            v14++;
            while (v14 - v3 < 0 != ((v14 - v3 ^ v14) & (v14 ^ v3)) < 0) {
                // 0x1000037e0
                _printf("%3d", v9);
                v14++;
            }
            // 0x100003820
            _printf("\n");
            v13++;
        }
    }
    int32_t v15; // 0x100003660
    int32_t v16; // 0x100003660
    while (v7 < 0 != (v3 & v7) < 0) {
        int32_t v17 = 0;
        int64_t * v18 = (int64_t *)(8 * (int64_t)v17 + v6); // 0x1000038b4
        int32_t v19 = 8 * v17;
        int64_t * v20 = (int64_t *)((int64_t)(v19 - 8) + v6);
        int32_t v21 = v17 + 1;
        int32_t v22 = v21 - v3;
        int64_t * v23 = (int64_t *)((int64_t)(v19 + 8) + v6);
        int32_t v24 = 0;
        int32_t v25 = 0;
        int32_t v26 = 0;
        int32_t v27 = 0;
        int32_t v28 = 0;
        int32_t v29 = 0;
        int64_t v30 = *v18; // 0x1000038b4
        int64_t v31 = 4 * (int64_t)v29; // 0x1000038bc
        int32_t v32 = *(int32_t *)(v31 + v30); // 0x1000038bc
        int64_t v33; // 0x100003660
        int64_t v34; // 0x100003660
        int32_t v35; // 0x100003b40
        int32_t v36; // 0x10000389c
        int32_t v37; // 0x100003660
        int32_t v38; // 0x100003660
        int32_t v39; // 0x100003660
        int64_t v40; // 0x100003660
        int32_t v41; // 0x100003660
        int32_t v42; // 0x100003660
        int32_t v43; // 0x100003660
        int32_t v44; // 0x100003660
        int32_t v45; // 0x100003660
        int32_t v46; // 0x100003660
        int32_t v47; // 0x100003660
        int32_t v48; // 0x100003660
        int32_t v49; // 0x100003660
        int32_t v50; // 0x100003660
        int32_t v51; // 0x100003660
        int32_t v52; // 0x100003660
        int32_t v53; // 0x100003660
        int32_t v54; // 0x100003660
        int32_t v55; // 0x100003660
        int32_t v56; // 0x100003660
        int32_t * v57; // 0x100003908
        int32_t v58; // 0x100003928
        int32_t v59; // 0x1000039d0
        int32_t * v60; // 0x100003988
        int32_t v61; // 0x1000039a8
        int32_t v62; // 0x100003660
        int32_t v63; // 0x100003660
        int32_t v64; // 0x100003660
        int32_t * v65; // 0x100003a04
        int64_t v66; // 0x100003a18
        int32_t v67; // 0x100003a24
        int32_t * v68; // 0x100003af8
        int32_t v69; // 0x100003af8
        int64_t v70; // 0x100003b0c
        int32_t v71; // 0x100003b14
        int32_t * v72; // 0x100003a84
        int64_t v73; // 0x100003a98
        int32_t v74; // 0x100003aa4
        if (v32 < 4 == (3 - v32 & v32) < 0) {
            // 0x1000038d0
            v41 = v24;
            v49 = v25;
            if (v17 >= 1) {
                // 0x1000038e8
                v57 = (int32_t *)(*v20 + v31);
                *v57 = *v57 + 1;
                v58 = *(int32_t *)(*v20 + v31);
                v41 = v58 < 4 == (3 - v58 & v58) < 0 ? 1 : v24;
                v49 = 1;
            }
            // 0x10000394c
            v42 = v41;
            v43 = v42;
            v51 = v26;
            if (v22 < 0 != ((v22 ^ v21) & (v21 ^ v3)) < 0) {
                // 0x100003968
                v60 = (int32_t *)(*v23 + v31);
                *v60 = *v60 + 1;
                v61 = *(int32_t *)(*v23 + v31);
                v43 = v61 < 4 == (3 - v61 & v61) < 0 ? 1 : v42;
                v51 = 1;
            }
            // 0x1000039cc
            v44 = v43;
            v59 = v29 - 1;
            v33 = *v18;
            v66 = v33;
            v45 = v44;
            v53 = v27;
            if (v59 >= 0) {
                // 0x1000039e4
                v65 = (int32_t *)(v33 + 4 * (int64_t)v59);
                *v65 = *v65 + 1;
                v66 = *v18;
                v67 = *(int32_t *)(v66 + (int64_t)(4 * v29 - 4));
                v45 = v67 < 4 == (3 - v67 & v67) < 0 ? 1 : v44;
                v53 = 1;
            }
            // 0x100003a48
            v46 = v45;
            v34 = v66;
            v62 = v29 + 1;
            v63 = v62 - v3;
            v64 = (v63 ^ v62) & (v62 ^ v3);
            v73 = v34;
            v47 = v46;
            v55 = v28;
            if (v63 < 0 != v64 < 0) {
                // 0x100003a64
                v72 = (int32_t *)(v34 + 4 * (int64_t)v62);
                *v72 = *v72 + 1;
                v73 = *v18;
                v74 = *(int32_t *)(v73 + (int64_t)(4 * v29 + 4));
                v47 = v74 < 4 == (3 - v74 & v74) < 0 ? 1 : v46;
                v55 = 1;
            }
            // 0x100003ac8
            v68 = (int32_t *)(v73 + v31);
            v69 = *v68;
            *v68 = v69 - (v51 + v49 + v53 + v55);
            v70 = *v18;
            v71 = *(int32_t *)(v70 + v31);
            v39 = v64;
            v38 = v63;
            v37 = v62;
            v40 = v70;
            v48 = v71 < 4 == (3 - v71 & v71) < 0 ? 1 : v47;
            v50 = v49;
            v52 = v51;
            v54 = v53;
            v56 = v55;
        } else {
            // 0x1000038ac
            v35 = v29 + 1;
            v36 = v35 - v3;
            v39 = (v36 ^ v35) & (v35 ^ v3);
            v38 = v36;
            v37 = v35;
            v40 = v30;
            v48 = v24;
            v50 = v25;
            v52 = v26;
            v54 = v27;
            v56 = v28;
        }
        int32_t v75 = v56;
        int32_t v76 = v54;
        int32_t v77 = v52;
        int32_t v78 = v50;
        int32_t v79 = v48;
        while (v38 < 0 != v39 < 0) {
            // 0x1000038ac
            v24 = v79;
            v25 = v78;
            v26 = v77;
            v27 = v76;
            v28 = v75;
            v29 = v37;
            v30 = v40;
            v31 = 4 * (int64_t)v29;
            v32 = *(int32_t *)(v31 + v30);
            if (v32 < 4 == (3 - v32 & v32) < 0) {
                // 0x1000038d0
                v41 = v24;
                v49 = v25;
                if (v17 >= 1) {
                    // 0x1000038e8
                    v57 = (int32_t *)(*v20 + v31);
                    *v57 = *v57 + 1;
                    v58 = *(int32_t *)(*v20 + v31);
                    v41 = v58 < 4 == (3 - v58 & v58) < 0 ? 1 : v24;
                    v49 = 1;
                }
                // 0x10000394c
                v42 = v41;
                v43 = v42;
                v51 = v26;
                if (v22 < 0 != ((v22 ^ v21) & (v21 ^ v3)) < 0) {
                    // 0x100003968
                    v60 = (int32_t *)(*v23 + v31);
                    *v60 = *v60 + 1;
                    v61 = *(int32_t *)(*v23 + v31);
                    v43 = v61 < 4 == (3 - v61 & v61) < 0 ? 1 : v42;
                    v51 = 1;
                }
                // 0x1000039cc
                v44 = v43;
                v59 = v29 - 1;
                v33 = *v18;
                v66 = v33;
                v45 = v44;
                v53 = v27;
                if (v59 >= 0) {
                    // 0x1000039e4
                    v65 = (int32_t *)(v33 + 4 * (int64_t)v59);
                    *v65 = *v65 + 1;
                    v66 = *v18;
                    v67 = *(int32_t *)(v66 + (int64_t)(4 * v29 - 4));
                    v45 = v67 < 4 == (3 - v67 & v67) < 0 ? 1 : v44;
                    v53 = 1;
                }
                // 0x100003a48
                v46 = v45;
                v34 = v66;
                v62 = v29 + 1;
                v63 = v62 - v3;
                v64 = (v63 ^ v62) & (v62 ^ v3);
                v73 = v34;
                v47 = v46;
                v55 = v28;
                if (v63 < 0 != v64 < 0) {
                    // 0x100003a64
                    v72 = (int32_t *)(v34 + 4 * (int64_t)v62);
                    *v72 = *v72 + 1;
                    v73 = *v18;
                    v74 = *(int32_t *)(v73 + (int64_t)(4 * v29 + 4));
                    v47 = v74 < 4 == (3 - v74 & v74) < 0 ? 1 : v46;
                    v55 = 1;
                }
                // 0x100003ac8
                v68 = (int32_t *)(v73 + v31);
                v69 = *v68;
                *v68 = v69 - (v51 + v49 + v53 + v55);
                v70 = *v18;
                v71 = *(int32_t *)(v70 + v31);
                v39 = v64;
                v38 = v63;
                v37 = v62;
                v40 = v70;
                v48 = v71 < 4 == (3 - v71 & v71) < 0 ? 1 : v47;
                v50 = v49;
                v52 = v51;
                v54 = v53;
                v56 = v55;
            } else {
                // 0x1000038ac
                v35 = v29 + 1;
                v36 = v35 - v3;
                v39 = (v36 ^ v35) & (v35 ^ v3);
                v38 = v36;
                v37 = v35;
                v40 = v30;
                v48 = v24;
                v50 = v25;
                v52 = v26;
                v54 = v27;
                v56 = v28;
            }
            // 0x100003b3c
            v75 = v56;
            v76 = v54;
            v77 = v52;
            v78 = v50;
            v79 = v48;
        }
        // 0x100003b50
        while (v22 < 0 != ((v22 ^ v21) & (v21 ^ v3)) < 0) {
            // 0x1000038ac
            v17 = v21;
            v18 = (int64_t *)(8 * (int64_t)v17 + v6);
            v19 = 8 * v17;
            v20 = (int64_t *)((int64_t)(v19 - 8) + v6);
            v21 = v17 + 1;
            v22 = v21 - v3;
            v23 = (int64_t *)((int64_t)(v19 + 8) + v6);
            v24 = v79;
            v25 = v78;
            v26 = v77;
            v27 = v76;
            v28 = v75;
            v29 = 0;
            v30 = *v18;
            v31 = 4 * (int64_t)v29;
            v32 = *(int32_t *)(v31 + v30);
            if (v32 < 4 == (3 - v32 & v32) < 0) {
                // 0x1000038d0
                v41 = v24;
                v49 = v25;
                if (v17 >= 1) {
                    // 0x1000038e8
                    v57 = (int32_t *)(*v20 + v31);
                    *v57 = *v57 + 1;
                    v58 = *(int32_t *)(*v20 + v31);
                    v41 = v58 < 4 == (3 - v58 & v58) < 0 ? 1 : v24;
                    v49 = 1;
                }
                // 0x10000394c
                v42 = v41;
                v43 = v42;
                v51 = v26;
                if (v22 < 0 != ((v22 ^ v21) & (v21 ^ v3)) < 0) {
                    // 0x100003968
                    v60 = (int32_t *)(*v23 + v31);
                    *v60 = *v60 + 1;
                    v61 = *(int32_t *)(*v23 + v31);
                    v43 = v61 < 4 == (3 - v61 & v61) < 0 ? 1 : v42;
                    v51 = 1;
                }
                // 0x1000039cc
                v44 = v43;
                v59 = v29 - 1;
                v33 = *v18;
                v66 = v33;
                v45 = v44;
                v53 = v27;
                if (v59 >= 0) {
                    // 0x1000039e4
                    v65 = (int32_t *)(v33 + 4 * (int64_t)v59);
                    *v65 = *v65 + 1;
                    v66 = *v18;
                    v67 = *(int32_t *)(v66 + (int64_t)(4 * v29 - 4));
                    v45 = v67 < 4 == (3 - v67 & v67) < 0 ? 1 : v44;
                    v53 = 1;
                }
                // 0x100003a48
                v46 = v45;
                v34 = v66;
                v62 = v29 + 1;
                v63 = v62 - v3;
                v64 = (v63 ^ v62) & (v62 ^ v3);
                v73 = v34;
                v47 = v46;
                v55 = v28;
                if (v63 < 0 != v64 < 0) {
                    // 0x100003a64
                    v72 = (int32_t *)(v34 + 4 * (int64_t)v62);
                    *v72 = *v72 + 1;
                    v73 = *v18;
                    v74 = *(int32_t *)(v73 + (int64_t)(4 * v29 + 4));
                    v47 = v74 < 4 == (3 - v74 & v74) < 0 ? 1 : v46;
                    v55 = 1;
                }
                // 0x100003ac8
                v68 = (int32_t *)(v73 + v31);
                v69 = *v68;
                *v68 = v69 - (v51 + v49 + v53 + v55);
                v70 = *v18;
                v71 = *(int32_t *)(v70 + v31);
                v39 = v64;
                v38 = v63;
                v37 = v62;
                v40 = v70;
                v48 = v71 < 4 == (3 - v71 & v71) < 0 ? 1 : v47;
                v50 = v49;
                v52 = v51;
                v54 = v53;
                v56 = v55;
            } else {
                // 0x1000038ac
                v35 = v29 + 1;
                v36 = v35 - v3;
                v39 = (v36 ^ v35) & (v35 ^ v3);
                v38 = v36;
                v37 = v35;
                v40 = v30;
                v48 = v24;
                v50 = v25;
                v52 = v26;
                v54 = v27;
                v56 = v28;
            }
            // 0x100003b3c
            v75 = v56;
            v76 = v54;
            v77 = v52;
            v78 = v50;
            v79 = v48;
            while (v38 < 0 != v39 < 0) {
                // 0x1000038ac
                v24 = v79;
                v25 = v78;
                v26 = v77;
                v27 = v76;
                v28 = v75;
                v29 = v37;
                v30 = v40;
                v31 = 4 * (int64_t)v29;
                v32 = *(int32_t *)(v31 + v30);
                if (v32 < 4 == (3 - v32 & v32) < 0) {
                    // 0x1000038d0
                    v41 = v24;
                    v49 = v25;
                    if (v17 >= 1) {
                        // 0x1000038e8
                        v57 = (int32_t *)(*v20 + v31);
                        *v57 = *v57 + 1;
                        v58 = *(int32_t *)(*v20 + v31);
                        v41 = v58 < 4 == (3 - v58 & v58) < 0 ? 1 : v24;
                        v49 = 1;
                    }
                    // 0x10000394c
                    v42 = v41;
                    v43 = v42;
                    v51 = v26;
                    if (v22 < 0 != ((v22 ^ v21) & (v21 ^ v3)) < 0) {
                        // 0x100003968
                        v60 = (int32_t *)(*v23 + v31);
                        *v60 = *v60 + 1;
                        v61 = *(int32_t *)(*v23 + v31);
                        v43 = v61 < 4 == (3 - v61 & v61) < 0 ? 1 : v42;
                        v51 = 1;
                    }
                    // 0x1000039cc
                    v44 = v43;
                    v59 = v29 - 1;
                    v33 = *v18;
                    v66 = v33;
                    v45 = v44;
                    v53 = v27;
                    if (v59 >= 0) {
                        // 0x1000039e4
                        v65 = (int32_t *)(v33 + 4 * (int64_t)v59);
                        *v65 = *v65 + 1;
                        v66 = *v18;
                        v67 = *(int32_t *)(v66 + (int64_t)(4 * v29 - 4));
                        v45 = v67 < 4 == (3 - v67 & v67) < 0 ? 1 : v44;
                        v53 = 1;
                    }
                    // 0x100003a48
                    v46 = v45;
                    v34 = v66;
                    v62 = v29 + 1;
                    v63 = v62 - v3;
                    v64 = (v63 ^ v62) & (v62 ^ v3);
                    v73 = v34;
                    v47 = v46;
                    v55 = v28;
                    if (v63 < 0 != v64 < 0) {
                        // 0x100003a64
                        v72 = (int32_t *)(v34 + 4 * (int64_t)v62);
                        *v72 = *v72 + 1;
                        v73 = *v18;
                        v74 = *(int32_t *)(v73 + (int64_t)(4 * v29 + 4));
                        v47 = v74 < 4 == (3 - v74 & v74) < 0 ? 1 : v46;
                        v55 = 1;
                    }
                    // 0x100003ac8
                    v68 = (int32_t *)(v73 + v31);
                    v69 = *v68;
                    *v68 = v69 - (v51 + v49 + v53 + v55);
                    v70 = *v18;
                    v71 = *(int32_t *)(v70 + v31);
                    v39 = v64;
                    v38 = v63;
                    v37 = v62;
                    v40 = v70;
                    v48 = v71 < 4 == (3 - v71 & v71) < 0 ? 1 : v47;
                    v50 = v49;
                    v52 = v51;
                    v54 = v53;
                    v56 = v55;
                } else {
                    // 0x1000038ac
                    v35 = v29 + 1;
                    v36 = v35 - v3;
                    v39 = (v36 ^ v35) & (v35 ^ v3);
                    v38 = v36;
                    v37 = v35;
                    v40 = v30;
                    v48 = v24;
                    v50 = v25;
                    v52 = v26;
                    v54 = v27;
                    v56 = v28;
                }
                // 0x100003b3c
                v75 = v56;
                v76 = v54;
                v77 = v52;
                v78 = v50;
                v79 = v48;
            }
        }
        if (v79 != 1) {
            // 0x100003bb0
            _printf("Final sand pile : \n\n");
            // 0x100003bb0
            v16 = 0;
            v15 = 0;
            goto lab_0x100003bb0_3;
        }
    }
    // 0x100003b64
    _printf("Final sand pile : \n\n");
    goto lab_0x100003c10;
  lab_0x100003c10:;
    int64_t * v80 = _malloc(_strlen((char *)*v2) + 23 + _strlen((char *)*v4)); // 0x100003c40
    int64_t v81 = (int64_t)v80; // 0x100003c40
    ___strcpy_chk(v81, "Final_Sand_Pile_");
    ___strcat_chk(v81, *v2, -1);
    ___strcat_chk(v81, (int64_t)&g1, -1);
    ___strcat_chk(v81, *v4, -1);
    ___strcat_chk(v81, (int64_t)".ppm", -1);
    struct _IO_FILE * v82 = _fopen((char *)v80, "wb"); // 0x100003cbc
    _fprintf(v82, "P6\n%d %d\n255\n", -1, v1);
    int32_t v83 = 0; // 0x100003d08
    int64_t v84 = (int64_t)"P6\n%d %d\n255\n"; // 0x100003d08
    if (v7 < 0 != (v3 & v7) < 0) {
        int64_t * v85 = (int64_t *)(8 * (int64_t)v83 + v6); // 0x100003d38
        int32_t v86 = 0; // 0x100003de4
        int64_t v87 = 4 * (int64_t)v86; // 0x100003d40
        int32_t v88 = *(int32_t *)(v87 + *v85); // 0x100003d40
        *(char *)&g2 = (char)(v88 + v83);
        int32_t v89 = *(int32_t *)(*v85 + v87); // 0x100003d7c
        *(char *)((int64_t)&g2 + 1) = (char)(v89 + v86);
        int32_t v90 = *(int32_t *)(*v85 + v87); // 0x100003dac
        *(char *)((int64_t)&g2 + 2) = (char)(v90 + v86 * v83);
        _fwrite(&g2, 1, 3, v82);
        v86++;
        while (v86 - v3 < 0 != ((v86 - v3 ^ v86) & (v86 ^ v3)) < 0) {
            // 0x100003d30
            v87 = 4 * (int64_t)v86;
            v88 = *(int32_t *)(v87 + *v85);
            *(char *)&g2 = (char)(v88 + v83);
            v89 = *(int32_t *)(*v85 + v87);
            *(char *)((int64_t)&g2 + 1) = (char)(v89 + v86);
            v90 = *(int32_t *)(*v85 + v87);
            *(char *)((int64_t)&g2 + 2) = (char)(v90 + v86 * v83);
            _fwrite(&g2, 1, 3, v82);
            v86++;
        }
        int32_t v91 = v83 + 1; // 0x100003df8
        int32_t v92 = v91 - v3; // 0x100003d00
        v83 = v91;
        v84 = 1;
        while (v92 < 0 != ((v92 ^ v91) & (v91 ^ v3)) < 0) {
            // 0x100003d30
            v85 = (int64_t *)(8 * (int64_t)v83 + v6);
            v86 = 0;
            v87 = 4 * (int64_t)v86;
            v88 = *(int32_t *)(v87 + *v85);
            *(char *)&g2 = (char)(v88 + v83);
            v89 = *(int32_t *)(*v85 + v87);
            *(char *)((int64_t)&g2 + 1) = (char)(v89 + v86);
            v90 = *(int32_t *)(*v85 + v87);
            *(char *)((int64_t)&g2 + 2) = (char)(v90 + v86 * v83);
            _fwrite(&g2, 1, 3, v82);
            v86++;
            while (v86 - v3 < 0 != ((v86 - v3 ^ v86) & (v86 ^ v3)) < 0) {
                // 0x100003d30
                v87 = 4 * (int64_t)v86;
                v88 = *(int32_t *)(v87 + *v85);
                *(char *)&g2 = (char)(v88 + v83);
                v89 = *(int32_t *)(*v85 + v87);
                *(char *)((int64_t)&g2 + 1) = (char)(v89 + v86);
                v90 = *(int32_t *)(*v85 + v87);
                *(char *)((int64_t)&g2 + 2) = (char)(v90 + v86 * v83);
                _fwrite(&g2, 1, 3, v82);
                v86++;
            }
            // 0x100003df4
            v91 = v83 + 1;
            v92 = v91 - v3;
            v83 = v91;
            v84 = 1;
        }
    }
    // 0x100003e04
    _fclose(v82);
    _printf("\nImage file written to %s\n", (char *)v84);
    // 0x100003e2c
    return 0;
  lab_0x100003bb0_3:
    // 0x100003bb0
    _printf("%3d", v9);
    int32_t v93 = v15 + 1; // 0x100003be4
    int32_t v94 = v93 - v3; // 0x100003ba0
    v15 = v93;
    if (v94 < 0 == ((v94 ^ v93) & (v93 ^ v3)) < 0) {
        // 0x100003bf0
        _printf("\n");
        int32_t v95 = v16 + 1; // 0x100003c04
        int32_t v96 = v95 - v3; // 0x100003b80
        if (v96 < 0 == ((v96 ^ v95) & (v95 ^ v3)) < 0) {
            goto lab_0x100003c10;
        } else {
            // 0x100003bb0
            v16 = v95;
            v15 = 0;
            goto lab_0x100003bb0_3;
        }
    } else {
        goto lab_0x100003bb0_3;
    }
}

// Address range: 0x100003e3c - 0x100003e48
int64_t function_100003e3c(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003e3c
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003e48 - 0x100003e54
int64_t function_100003e48(int64_t a1, char * a2) {
    // 0x100003e48
    return ___strcpy_chk(a1, a2);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(char * nptr) {
    // 0x100003e54
    return _atoi(nptr);
}

// Address range: 0x100003e60 - 0x100003e6c
int64_t * function_100003e60(int32_t nmemb, int32_t size) {
    // 0x100003e60
    return _calloc(nmemb, size);
}

// Address range: 0x100003e6c - 0x100003e78
int32_t function_100003e6c(struct _IO_FILE * stream) {
    // 0x100003e6c
    return _fclose(stream);
}

// Address range: 0x100003e78 - 0x100003e84
struct _IO_FILE * function_100003e78(char * filename, char * modes) {
    // 0x100003e78
    return _fopen(filename, modes);
}

// Address range: 0x100003e84 - 0x100003e90
int32_t function_100003e84(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e84
    return _fprintf(stream, format);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003e90
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003e9c - 0x100003ea8
int64_t * function_100003e9c(int32_t size) {
    // 0x100003e9c
    return _malloc(size);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(char * format, ...) {
    // 0x100003ea8
    return _printf(format);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(char * s) {
    // 0x100003eb4
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

/* we just return a yes/no status; caller can check errno */
int copy_file(const char *in, const char *out)
{
	int ret = 0;
	int fin, fout;
	ssize_t len;
	char *buf[4096]; /* buffer size, some multiple of block size preferred */
	struct stat st;

	if ((fin  = open(in,  O_RDONLY)) == -1) return 0;
	if (fstat(fin, &st)) goto bail;

	/* open output with same permission */
	fout = open(out, O_WRONLY|O_CREAT|O_TRUNC, st.st_mode & 0777);
	if (fout == -1) goto bail;

	while ((len = read(fin, buf, 4096)) > 0)
		write(fout, buf, len);

	ret = len ? 0 : 1; /* last read should be 0 */

bail:	if (fin != -1)  close(fin);
	if (fout != -1) close(fout);
	return ret;
}

int main()
{
	copy_file("infile", "outfile");
	return 0;
}
`,`#include "file-input-output-2.h"



uint _copy_file(void)

{
  uint uVar1;
  ulong uVar2;
  undefined auVar3 [16];
  stat sStack_80e8;
  size_t local_8058;
  uint local_804c;
  uint local_8048;
  uint local_8044;
  char *local_8040;
  char *local_8038;
  uint local_802c;
  undefined auStack_8028 [32768];
  long local_28;
  
  auVar3 = (*(code *)PTR____chkstk_darwin_100004000)();
  local_8040 = auVar3._8_8_;
  local_8038 = auVar3._0_8_;
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_8044 = 0;
  local_8048 = _open(local_8038,0);
  uVar2 = (ulong)local_8048;
  if (local_8048 == 0xffffffff) {
    local_802c = 0;
  }
  else {
    uVar1 = _fstat(local_8048,&sStack_80e8);
    uVar2 = (ulong)uVar1;
    if (uVar1 == 0) {
      local_804c = _open(local_8040,0x601);
      uVar2 = (ulong)local_804c;
      if (local_804c != 0xffffffff) {
        while (uVar2 = _read(local_8048,auStack_8028,0x1000), local_8058 = uVar2, 0 < (long)uVar2) {
          _write(local_804c,auStack_8028,uVar2);
        }
        local_8044 = (uint)(uVar2 == 0);
      }
    }
    if (local_8048 != 0xffffffff) {
      uVar1 = _close(local_8048);
      uVar2 = (ulong)uVar1;
    }
    if (local_804c != 0xffffffff) {
      uVar1 = _close(local_804c);
      uVar2 = (ulong)uVar1;
    }
    local_802c = local_8044;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return local_802c;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar2);
}



undefined4 entry(void)

{
  _copy_file("infile","outfile");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004020)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004028)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _read(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__read_100004030)(param_1);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _write(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__write_100004038)(param_1);
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint;
uint count = 0;

#define ulen sizeof(uint) * 8

/* could have defined as int solve(...), but void may have less
   chance to confuse poor optimizer */
void solve(int n)
{
	int cnt = 0;
	const uint full = -(int)(1 << (ulen - n));
	register uint bits, pos, *m, d, e;

	uint b0, b1, l[32], r[32], c[32], mm[33] = {0};
	n -= 3;
	/* require second queen to be left of the first queen, so
	   we ever only test half of the possible solutions. This
	   is why we can't handle n=1 here */
	for (b0 = 1U << (ulen - n - 3); b0; b0 <<= 1) {
		for (b1 = b0 << 2; b1; b1 <<= 1) {
			d = n;
			/* c: columns occupied by previous queens.
			   l: columns attacked by left diagonals
			   r: by right diagnoals */
			c[n] = b0 | b1;
			l[n] = (b0 << 2) | (b1 << 1);
			r[n] = (b0 >> 2) | (b1 >> 1);

			/* availabe columns on current row. m is stack */
			bits = *(m = mm + 1) = full & ~(l[n] | r[n] | c[n]);

			while (bits) {
				/* d: depth, aka row. counting backwards
				   because !d is often faster than d != n */
				while (d) {
					/* pos is right most nonzero bit */
					pos = -(int)bits & bits;

					/* mark bit used. only put current bits
					   on stack if not zero, so backtracking
					   will skip exhausted rows (because reading
					   stack variable is sloooow compared to
					   registers) */
					if ((bits &= ~pos))
						*m++ = bits | d;

					/* faster than l[d+1] = l[d]... */
					e = d--;
					l[d] = (l[e] | pos) << 1;
					r[d] = (r[e] | pos) >> 1;
					c[d] =  c[e] | pos;

					bits = full & ~(l[d] | r[d] | c[d]);

					if (!bits) break;
					if (!d) { cnt++; break; }
				}
				/* Bottom of stack m is a zero'd field acting
				   as sentinel.  When saving to stack, left
				   27 bits are the available columns, while
				   right 5 bits is the depth. Hence solution
				   is limited to size 27 board -- not that it
				   matters in foreseeable future. */
				d = (bits = *--m) & 31U;
				bits &= ~31U;
			}
		}
	}
	count = cnt * 2;
}

int main(int c, char **v)
{
	int nn;
	if (c <= 1 || (nn = atoi(v[1])) <= 0) nn = 8;

	if (nn > 27) {
		fprintf(stderr, "Value too large, abort\n");
		exit(1);
	}

	/* Can't solve size 1 board; might as well skip 2 and 3 */
	if (nn < 4) count = nn == 1;
	else	    solve(nn);

	printf("\nSolutions: %d\n", count);
	return 0;
}
`,`#include "n-queens-problem-4.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _solve(int param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint local_258;
  uint local_254;
  uint local_24c;
  uint *local_248;
  uint local_23c;
  int local_234;
  undefined auStack_22c [4];
  uint local_228 [32];
  uint auStack_1a8 [32];
  uint auStack_128 [32];
  uint auStack_a8 [32];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_234 = 0;
  uVar4 = -(1 << (ulong)(0x20U - param_1 & 0x1f));
  _memset(auStack_22c,0,0x84);
  uVar2 = param_1 - 3;
  local_254 = 1 << (ulong)(0x1d - uVar2 & 0x1f);
  do {
    if (local_254 == 0) {
      __count = local_234 << 1;
      if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
        return;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    for (local_258 = local_254 << 2; local_258 != 0; local_258 = local_258 << 1) {
      auStack_1a8[(int)uVar2] = local_254 | local_258;
      auStack_a8[(int)uVar2] = local_258 << 1 | local_254 << 2;
      auStack_128[(int)uVar2] = local_258 >> 1 | local_254 >> 2;
      local_23c = uVar4 & ((auStack_a8[(int)uVar2] | auStack_128[(int)uVar2] |
                           auStack_1a8[(int)uVar2]) ^ 0xffffffff);
      local_228[0] = local_23c;
      local_24c = uVar2;
      local_248 = local_228;
      while (local_23c != 0) {
        do {
          if (local_24c == 0) goto LAB_100003da0;
          uVar1 = -local_23c & local_23c;
          if ((local_23c & ~uVar1) != 0) {
            *local_248 = local_23c & (uVar1 ^ 0xffffffff) | local_24c;
            local_248 = local_248 + 1;
          }
          uVar3 = local_24c - 1;
          auStack_a8[uVar3] = (auStack_a8[local_24c] | uVar1) << 1;
          auStack_128[uVar3] = (auStack_128[local_24c] | uVar1) >> 1;
          auStack_1a8[uVar3] = auStack_1a8[local_24c] | uVar1;
          local_23c = uVar4 & ((auStack_a8[uVar3] | auStack_128[uVar3] | auStack_1a8[uVar3]) ^
                              0xffffffff);
          if (local_23c == 0) goto LAB_100003da0;
          local_24c = uVar3;
        } while (uVar3 != 0);
        local_234 = local_234 + 1;
LAB_100003da0:
        local_24c = local_248[-1] & 0x1f;
        local_23c = local_248[-1] & 0xffffffe0;
        local_248 = local_248 + -1;
      }
    }
    local_254 = local_254 << 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(int param_1,long param_2)

{
  int local_24;
  
  if ((param_1 < 2) || (local_24 = _atoi(*(char **)(param_2 + 8)), local_24 < 1)) {
    local_24 = 8;
  }
  if (local_24 < 0x1c) {
    if (local_24 < 4) {
      __count = (uint)(local_24 == 1);
    }
    else {
      _solve(local_24);
    }
    _printf("\nSolutions: %d\n");
    return 0;
  }
  _fprintf(*(FILE **)PTR____stderrp_100004010,"Value too large, abort\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004030)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
    const char *fruit[2] = { "apples", "oranges" };

    // Acquire the length of the array by dividing the size of all elements (found
    // with sizeof(fruit)) by the size of the first element.

    // Note that since the array elements are pointers to null-terminated character
    // arrays, the size of the first element is actually the size of the pointer
    // type - not the length of the string.

    // This size, regardless of the type being pointed to, is 8 bytes, 4 bytes, or
    // 2 bytes on 64-bit, 32-bit, or 16-bit platforms respectively.
    int length = sizeof(fruit) / sizeof(fruit[0]);

    printf("%d\n", length);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f7c(int64_t a1);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ef4 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003ef4
    int64_t v1; // 0x100003ef4
    int32_t v2 = _printf("%d\n", v1); // 0x100003f44
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f54
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f68
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t function_100003f7c(int64_t a1) {
    // 0x100003f7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0
#define da_rewind(name)     _qy_ ## name ## _p = 0
#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)
#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)
#define da_len(name)        _qy_ ## name ## _p
#define da_add(name)        do {da_redim(name); _qy_ ## name ## _p++;} while (0)

typedef enum {
    nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While,
    nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,
    nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or
} NodeType;

typedef struct Tree Tree;
struct Tree {
    NodeType node_type;
    Tree *left;
    Tree *right;
    int value;
};

// dependency: Ordered by NodeType, must remain in same order as NodeType enum

struct {
    char       *enum_text;
    NodeType   node_type;
} atr[] = {
    {"Identifier"  , nd_Ident,  },  {"String"      , nd_String,  },
    {"Integer"     , nd_Integer,},  {"Sequence"    , nd_Sequence,},
    {"If"          , nd_If,     },  {"Prtc"        , nd_Prtc,    },
    {"Prts"        , nd_Prts,   },  {"Prti"        , nd_Prti,    },
    {"While"       , nd_While,  },  {"Assign"      , nd_Assign,  },
    {"Negate"      , nd_Negate, },  {"Not"         , nd_Not,     },
    {"Multiply"    , nd_Mul,    },  {"Divide"      , nd_Div,     },
    {"Mod"         , nd_Mod,    },  {"Add"         , nd_Add,     },
    {"Subtract"    , nd_Sub,    },  {"Less"        , nd_Lss,     },
    {"LessEqual"   , nd_Leq,    },  {"Greater"     , nd_Gtr,     },
    {"GreaterEqual", nd_Geq,    },  {"Equal"       , nd_Eql,     },
    {"NotEqual"    , nd_Neq,    },  {"And"         , nd_And,     },
    {"Or"          , nd_Or,     },
};

FILE *source_fp;
da_dim(string_pool, const char *);
da_dim(global_names, const char *);
da_dim(global_values, int);

void error(const char *fmt, ... ) {
    va_list ap;
    char buf[1000];

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    printf("error: %s\n", buf);
    exit(1);
}

Tree *make_node(NodeType node_type, Tree *left, Tree *right) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->left = left;
    t->right = right;
    return t;
}

Tree *make_leaf(NodeType node_type, int value) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->value = value;
    return t;
}

int interp(Tree *x) {           /* interpret the parse tree */
    if (!x) return 0;
    switch(x->node_type) {
        case nd_Integer:  return x->value;
        case nd_Ident:    return global_values[x->value];
        case nd_String:   return x->value;

        case nd_Assign:   return global_values[x->left->value] = interp(x->right);
        case nd_Add:      return interp(x->left) +  interp(x->right);
        case nd_Sub:      return interp(x->left) -  interp(x->right);
        case nd_Mul:      return interp(x->left) *  interp(x->right);
        case nd_Div:      return interp(x->left) /  interp(x->right);
        case nd_Mod:      return interp(x->left) %  interp(x->right);
        case nd_Lss:      return interp(x->left) <  interp(x->right);
        case nd_Gtr:      return interp(x->left) >  interp(x->right);
        case nd_Leq:      return interp(x->left) <= interp(x->right);
        case nd_Eql:      return interp(x->left) == interp(x->right);
        case nd_Neq:      return interp(x->left) != interp(x->right);
        case nd_And:      return interp(x->left) && interp(x->right);
        case nd_Or:       return interp(x->left) || interp(x->right);
        case nd_Negate:   return -interp(x->left);
        case nd_Not:      return !interp(x->left);

        case nd_If:       if (interp(x->left))
                            interp(x->right->left);
                          else
                            interp(x->right->right);
                          return 0;

        case nd_While:    while (interp(x->left))
                            interp(x->right);
                          return 0;

        case nd_Prtc:     printf("%c", interp(x->left));
                          return 0;
        case nd_Prti:     printf("%d", interp(x->left));
                          return 0;
        case nd_Prts:     printf("%s", string_pool[interp(x->left)]);
                          return 0;

        case nd_Sequence: interp(x->left);
                          interp(x->right);
                          return 0;

        default:          error("interp: unknown tree type %d\n", x->node_type);
    }
    return 0;
}

void init_in(const char fn[]) {
    if (fn[0] == '\0')
        source_fp = stdin;
    else {
        source_fp = fopen(fn, "r");
        if (source_fp == NULL)
            error("Can't open %s\n", fn);
    }
}

NodeType get_enum_value(const char name[]) {
    for (size_t i = 0; i < sizeof(atr) / sizeof(atr[0]); i++) {
        if (strcmp(atr[i].enum_text, name) == 0) {
            return atr[i].node_type;
        }
    }
    error("Unknown token %s\n", name);
    return -1;
}

char *read_line(int *len) {
    static char *text = NULL;
    static int textmax = 0;

    for (*len = 0; ; (*len)++) {
        int ch = fgetc(source_fp);
        if (ch == EOF || ch == '\n') {
            if (*len == 0)
                return NULL;
            break;
        }
        if (*len + 1 >= textmax) {
            textmax = (textmax == 0 ? 128 : textmax * 2);
            text = realloc(text, textmax);
        }
        text[*len] = ch;
    }
    text[*len] = '\0';
    return text;
}

char *rtrim(char *text, int *len) {         // remove trailing spaces
    for (; *len > 0 && isspace(text[*len - 1]); --(*len))
        ;

    text[*len] = '\0';
    return text;
}

int fetch_string_offset(char *st) {
    int len = strlen(st);
    st[len - 1] = '\0';
    ++st;
    char *p, *q;
    p = q = st;

    while ((*p++ = *q++) != '\0') {
        if (q[-1] == '\\') {
            if (q[0] == 'n') {
                p[-1] = '\n';
                ++q;
            } else if (q[0] == '\\') {
                ++q;
            }
        }
    }

    for (int i = 0; i < da_len(string_pool); ++i) {
        if (strcmp(st, string_pool[i]) == 0) {
            return i;
        }
    }
    da_add(string_pool);
    int n = da_len(string_pool) - 1;
    string_pool[n] = strdup(st);
    return da_len(string_pool) - 1;
}

int fetch_var_offset(const char *name) {
    for (int i = 0; i < da_len(global_names); ++i) {
        if (strcmp(name, global_names[i]) == 0)
            return i;
    }
    da_add(global_names);
    int n = da_len(global_names) - 1;
    global_names[n] = strdup(name);
    da_append(global_values, 0);
    return n;
}

Tree *load_ast() {
    int len;
    char *yytext = read_line(&len);
    yytext = rtrim(yytext, &len);

    // get first token
    char *tok = strtok(yytext, " ");

    if (tok[0] == ';') {
        return NULL;
    }
    NodeType node_type = get_enum_value(tok);

    // if there is extra data, get it
    char *p = tok + strlen(tok);
    if (p != &yytext[len]) {
        int n;
        for (++p; isspace(*p); ++p)
            ;
        switch (node_type) {
            case nd_Ident:      n = fetch_var_offset(p);    break;
            case nd_Integer:    n = strtol(p, NULL, 0);     break;
            case nd_String:     n = fetch_string_offset(p); break;
            default:            error("Unknown node type: %s\n", p);
        }
        return make_leaf(node_type, n);
    }

    Tree *left  = load_ast();
    Tree *right = load_ast();
    return make_node(node_type, left, right);
}

int main(int argc, char *argv[]) {
    init_in(argc > 1 ? argv[1] : "");

    Tree *x = load_ast();
    interp(x);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002d94(void);
int64_t function_100002e00(void);
int64_t function_100002e5c(int32_t a1, int32_t a2);
int64_t function_100002ea8(int64_t a1, int64_t a2);
int64_t function_10000343c(void);
int64_t function_1000034dc(void);
int64_t function_100003598(void);
int64_t function_100003700(void);
int64_t function_1000037a8(void);
int64_t function_1000039e0(void);
int64_t function_100003ba4(void);
int64_t function_100003de4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t * function_100003df0(int32_t nmemb, int32_t size);
void function_100003dfc(int32_t status);
int32_t function_100003e08(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e14(char * filename, char * modes);
int32_t function_100003e20(int32_t c);
int32_t function_100003e2c(char * format, ...);
int64_t * function_100003e38(int64_t * ptr, int32_t size);
int32_t function_100003e44(char * s1, char * s2);
char * function_100003e50(char * s);
int32_t function_100003e5c(char * s);
char * function_100003e68(char * s, char * delim);
int32_t function_100003e74(char * nptr, char ** endptr, int32_t base);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x20000000003e80; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008190
int32_t g3 = 0; // 0x100008198
int32_t g4 = 2; // 0x10000819c
int64_t g5 = 0x55800000012; // 0x1000081a0
int32_t g6 = 0x200085; // 0x1000081a8
int32_t g7 = 0; // 0x1000081ac
int64_t g8 = 0x4800000019; // 0x1000081b0
char g9[11] = "__PAGEZERO"; // 0x1000081b8
char g10[7] = "GEZERO"; // 0x1000081bc
char g11[3] = "RO"; // 0x1000081c0
int64_t g12 = 0; // 0x1000081c8
int32_t g13 = 0; // 0x1000081d0
int32_t g14;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100002d94 - 0x100002e00
int64_t function_100002d94(void) {
    // 0x100002d94
    int64_t v1; // 0x100002d94
    int64_t v2; // bp-1032, 0x100002d94
    int64_t v3; // 0x100002d94
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("error: %s\n", NULL);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100002e00 - 0x100002e5c
int64_t function_100002e00(void) {
    int64_t * v1 = _calloc(32, 1); // 0x100002e20
    int64_t v2; // 0x100002e00
    *(int32_t *)v1 = (int32_t)v2;
    return (int64_t)v1;
}

// Address range: 0x100002e5c - 0x100002ea8
int64_t function_100002e5c(int32_t a1, int32_t a2) {
    int64_t * v1 = _calloc(32, 1); // 0x100002e78
    *(int32_t *)v1 = a1;
    int64_t result = (int64_t)v1; // 0x100002e90
    *(int32_t *)(result + 24) = a2;
    return result;
}

// Address range: 0x100002ea8 - 0x1000033d8
int64_t function_100002ea8(int64_t a1, int64_t a2) {
    // 0x100002ea8
    int64_t result; // 0x100002ea8
    if (result == 0) {
        // 0x100002ecc
        return result;
    }
    uint32_t v1 = (int32_t)result;
    if (v1 >= 24 != v1 != 24) {
        // 0x100002ecc
        return result;
    }
    // 0x10000339c
    function_100002d94();
    // UNREACHABLE
}

// Address range: 0x10000343c - 0x1000034dc
int64_t function_10000343c(void) {
    // 0x10000343c
    int64_t v1; // 0x10000343c
    if ((char)v1 == 0) {
        // 0x100003464
        *(int64_t *)&g11 = *(int64_t *)*(int64_t *)0x100004008;
        // 0x1000034d0
        int64_t result; // 0x10000343c
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x10000348c
    int64_t result2 = (int64_t)v2; // 0x10000348c
    *(int64_t *)&g11 = result2;
    if (v2 != NULL) {
        // 0x1000034d0
        return result2;
    }
    // 0x1000034b0
    function_100002d94();
    // UNREACHABLE
}

// Address range: 0x1000034dc - 0x100003598
int64_t function_1000034dc(void) {
    int64_t v1 = 0; // 0x100003558
    int64_t v2 = 16 * v1; // 0x10000350c
    int64_t v3 = *(int64_t *)(v2 + (int64_t)&g1); // 0x100003518
    int64_t v4; // 0x1000034dc
    while (_strcmp((char *)v3, (char *)v4) != 0) {
        // 0x1000034f4
        v1++;
        if (v1 >= 25) {
            // 0x100003564
            function_100002d94();
            // UNREACHABLE
        }
        v2 = 16 * v1;
        v3 = *(int64_t *)(v2 + (int64_t)&g1);
    }
    // 0x100003534
    return (int64_t)*(int32_t *)(v2 + (int64_t)&g1 + 8);
}

// Address range: 0x100003598 - 0x100003700
int64_t function_100003598(void) {
    int32_t v1 = 0; // 0x1000035b0
    int64_t result; // 0x1000036e4
    int32_t v2; // 0x100003598
    while (true) {
        // 0x1000035b4
        int64_t v3; // 0x100003598
        *(int32_t *)v3 = v1;
        int32_t v4 = _fgetc((struct _IO_FILE *)*(int64_t *)&g11); // 0x1000035c0
        int64_t v5; // 0x100003598
        v2 = *(int32_t *)&v5;
        switch (v4) {
            case -1: {
            }
            case 10: {
                // 0x1000035f0
                result = 0;
                if (v2 != 0) {
                    // 0x1000036cc
                    *(char *)(g12 + (int64_t)v2) = 0;
                    result = g12;
                }
                // 0x1000036f0
                return result;
            }
        }
        int32_t v6 = v2 + 1; // 0x10000361c
        int32_t v7 = *(int32_t *)((int64_t)&g1 + 464); // 0x100003624
        int32_t v8 = v6 - v7; // 0x100003628
        int64_t v9; // 0x100003598
        if (v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            int32_t v10 = g13; // 0x10000363c
            int32_t v11 = v10 == 0 ? 128 : 2 * v10;
            g13 = v11;
            int64_t v12 = (int64_t)_realloc((int64_t *)g12, v11); // 0x10000368c
            g12 = v12;
            v9 = v12;
        } else {
            // 0x100003614
            v9 = g12;
        }
        // 0x10000369c
        *(char *)(v9 + (int64_t)v2) = (char)v4;
        v1 = *(int32_t *)&v5 + 1;
    }
    // 0x1000035f0
    result = 0;
    if (v2 != 0) {
        // 0x1000036cc
        *(char *)(g12 + (int64_t)v2) = 0;
        result = g12;
    }
    // 0x1000036f0
    return result;
}

// Address range: 0x100003700 - 0x1000037a8
int64_t function_100003700(void) {
    // 0x100003700
    int64_t result; // 0x100003700
    int32_t v1 = result;
    if (v1 < 1) {
        // 0x100003784
        *(char *)(result + (int64_t)v1) = 0;
        return result;
    }
    uint32_t v2 = v1 - 1; // 0x100003744
    char v3 = *(char *)(result + (int64_t)v2); // 0x100003748
    int32_t v4 = v1; // 0x100003764
    while (_isspace((int32_t)v3) != 0) {
        // 0x100003770
        *(int32_t *)result = v2;
        int64_t v5; // 0x100003700
        int32_t v6 = *(int32_t *)&v5; // 0x10000371c
        v4 = v6;
        if (v6 < 1) {
            // break -> 0x100003784
            break;
        }
        v2 = v6 - 1;
        v3 = *(char *)(result + (int64_t)v2);
        v4 = v6;
    }
    // 0x100003784
    *(char *)(result + (int64_t)v4) = 0;
    return result;
}

// Address range: 0x1000037a8 - 0x1000039e0
int64_t function_1000037a8(void) {
    // 0x1000037a8
    int64_t v1; // 0x1000037a8
    int64_t v2 = v1;
    *(char *)(v2 + (int64_t)(_strlen((char *)v2) - 1)) = 0;
    int64_t v3 = v2 + 1; // 0x1000037e0
    char * v4 = (char *)v3; // 0x1000037e4
    char v5 = *v4; // 0x100003804
    int64_t v6; // 0x1000037a8
    int64_t v7; // 0x1000037a8
    char v8; // 0x1000037a8
    int64_t v9; // 0x1000037a8
    char v10; // 0x1000037a8
    char * v11; // 0x1000037a8
    char * v12; // 0x1000037a8
    char * v13; // 0x1000037a8
    if (v5 != 0) {
        int64_t v14 = v2 + 2;
        v8 = v5;
        v7 = v14;
        v6 = v14;
        v9 = v3;
        v11 = v4;
        while (true) {
          lab_0x100003828:;
            char * v15 = (char *)v6;
            v12 = v15;
            if (v8 == 92) {
                int64_t v16 = v9;
                char v17 = *v15;
                v10 = v17;
                v13 = v15;
                switch (v17) {
                    case 110: {
                        // 0x100003858
                        *v11 = 10;
                        v12 = (char *)(v16 + 2);
                        goto lab_0x1000038a8;
                    }
                    case 92: {
                        // 0x100003890
                        v12 = (char *)(v16 + 2);
                        goto lab_0x1000038a8;
                    }
                    default: {
                        goto lab_0x1000038a8_2;
                    }
                }
            } else {
                goto lab_0x1000038a8;
            }
        }
    }
  lab_0x1000038b4:;
    int32_t v18 = -g3; // 0x1000038c0
    int32_t v19 = 0; // 0x1000038c8
    if (v18 < 0 != (g3 & v18) < 0) {
        int64_t v20 = *(int64_t *)(8 * (int64_t)v19 + g2); // 0x1000038e0
        int32_t result = v19; // 0x1000038f0
        while (_strcmp(v4, (char *)v20) != 0) {
            int32_t v21 = v19 + 1; // 0x10000390c
            int32_t v22 = v21 - g3; // 0x1000038c0
            v19 = v21;
            if (v22 < 0 == ((v22 ^ v21) & (g3 ^ v21)) < 0) {
                goto lab_0x100003920;
            }
            v20 = *(int64_t *)(8 * (int64_t)v19 + g2);
            result = v19;
        }
        // 0x1000039d0
        return result;
    }
  lab_0x100003920:;
    int32_t v23 = g3;
    int32_t v24 = v23 - g4; // 0x100003930
    int32_t v25 = v23; // 0x100003938
    if (v24 < 0 == ((v24 ^ v23) & (g4 ^ v23)) < 0) {
        int32_t v26 = g4 + 32; // 0x100003954
        g4 = v26;
        g2 = (int64_t)_realloc((int64_t *)g2, 8 * v26);
        v25 = g3;
    }
    // 0x10000397c
    g3 = v25 + 1;
    char * v27 = _strdup(v4); // 0x1000039a8
    *(int64_t *)(g2 + 8 * (int64_t)v25) = (int64_t)v27;
    // 0x1000039d0
    return g3 - 1;
  lab_0x1000038a8:
    // 0x1000038a8
    v10 = *v12;
    v13 = v12;
    goto lab_0x1000038a8_2;
  lab_0x1000038a8_2:;
    char * v28 = (char *)v7;
    *v28 = v10;
    if (v10 == 0) {
        // break -> 0x1000038b4
        goto lab_0x1000038b4;
    }
    int64_t v29 = (int64_t)v13; // 0x1000037f8
    v8 = *v13;
    v7++;
    v6 = v29 + 1;
    v9 = v29;
    v11 = v28;
    goto lab_0x100003828;
}

// Address range: 0x1000039e0 - 0x100003ba4
int64_t function_1000039e0(void) {
    // 0x1000039e0
    int64_t v1; // 0x1000039e0
    char * v2 = (char *)v1; // 0x1000039ec
    int32_t v3 = -g6; // 0x100003a04
    int32_t v4 = 0; // 0x100003a0c
    if (v3 < 0 != (g6 & v3) < 0) {
        int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + g5); // 0x100003a24
        int32_t result = v4; // 0x100003a34
        while (_strcmp(v2, (char *)v5) != 0) {
            // 0x100003a4c
            v4++;
            int32_t v6 = v4 - g6; // 0x100003a04
            if (v6 < 0 == ((v6 ^ v4) & (g6 ^ v4)) < 0) {
                goto lab_0x100003a64;
            }
            v5 = *(int64_t *)(8 * (int64_t)v4 + g5);
            result = v4;
        }
        // 0x100003b94
        return result;
    }
  lab_0x100003a64:;
    int32_t v7 = g6;
    int32_t v8 = v7 - g7; // 0x100003a74
    int32_t result2 = v7; // 0x100003a7c
    if (v8 < 0 == ((v8 ^ v7) & (g7 ^ v7)) < 0) {
        int32_t v9 = g7 + 32; // 0x100003a98
        g7 = v9;
        g5 = (int64_t)_realloc((int64_t *)g5, 8 * v9);
        result2 = g6;
    }
    // 0x100003ac0
    g6 = result2 + 1;
    char * v10 = _strdup(v2); // 0x100003ae8
    *(int64_t *)(g5 + 8 * (int64_t)result2) = (int64_t)v10;
    int32_t v11 = *(int32_t *)&g9; // 0x100003b08
    int32_t v12 = *(int32_t *)&g10; // 0x100003b10
    int32_t v13 = v11 - v12; // 0x100003b14
    int32_t v14 = v11; // 0x100003b1c
    int64_t v15 = g8; // 0x100003b1c
    if (v13 < 0 == ((v13 ^ v11) & (v12 ^ v11)) < 0) {
        int32_t v16 = v12 + 32; // 0x100003b38
        *(int32_t *)&g10 = v16;
        int64_t v17 = (int64_t)_realloc((int64_t *)g8, 4 * v16); // 0x100003b4c
        g8 = v17;
        v14 = *(int32_t *)&g9;
        v15 = v17;
    }
    // 0x100003b60
    *(int32_t *)&g9 = v14 + 1;
    *(int32_t *)(4 * (int64_t)v14 + v15) = 0;
    // 0x100003b94
    return result2;
}

// Address range: 0x100003ba4 - 0x100003d70
int64_t function_100003ba4(void) {
    // 0x100003ba4
    function_100003598();
    int64_t v1 = function_100003700(); // 0x100003bc8
    char * v2 = _strtok((char *)v1, " "); // 0x100003bdc
    if (*v2 == 59) {
        // 0x100003d60
        return 0;
    }
    int64_t v3 = function_1000034dc(); // 0x100003c08
    int64_t v4 = (int64_t)_strlen(v2) + (int64_t)v2; // 0x100003c24
    int32_t v5; // 0x100003ba4
    if (v4 == v1 + (int64_t)v5) {
        // 0x100003d38
        function_100003ba4();
        function_100003ba4();
        // 0x100003d60
        return 0x100000000 * v3 >> 32;
    }
    int32_t v6 = v3; // 0x100003c0c
    char * v7 = (char *)v4; // 0x100003c58
    v7 = (char *)((int64_t)v7 + 1);
    while (_isspace((int32_t)*v7) != 0) {
        // 0x100003c5c
        v7 = (char *)((int64_t)v7 + 1);
    }
    int32_t v8; // 0x100003ba4
    switch (v6) {
        case 0: {
            // 0x100003ccc
            v8 = function_1000039e0();
            // break -> 0x100003d24
            break;
        }
        case 1: {
            // 0x100003cf8
            v8 = function_1000037a8();
            // break -> 0x100003d24
            break;
        }
        case 2: {
            // 0x100003cdc
            v8 = _strtol(v7, NULL, 0);
            // break -> 0x100003d24
            break;
        }
        default: {
            // 0x100003d08
            function_100002d94();
            // UNREACHABLE
        }
    }
    // 0x100003d60
    return 0x100000000 * function_100002e5c(v6, v8) >> 32;
}

// Address range: 0x100003d70 - 0x100003de4
int64_t entry_point(void) {
    // 0x100003d70
    function_10000343c();
    function_100003ba4();
    function_100002ea8((int64_t)&g14, (int64_t)&g14);
    return 0;
}

// Address range: 0x100003de4 - 0x100003df0
int64_t function_100003de4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003de4
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003df0 - 0x100003dfc
int64_t * function_100003df0(int32_t nmemb, int32_t size) {
    // 0x100003df0
    return _calloc(nmemb, size);
}

// Address range: 0x100003dfc - 0x100003e08
void function_100003dfc(int32_t status) {
    // 0x100003dfc
    _exit(status);
}

// Address range: 0x100003e08 - 0x100003e14
int32_t function_100003e08(struct _IO_FILE * stream) {
    // 0x100003e08
    return _fgetc(stream);
}

// Address range: 0x100003e14 - 0x100003e20
struct _IO_FILE * function_100003e14(char * filename, char * modes) {
    // 0x100003e14
    return _fopen(filename, modes);
}

// Address range: 0x100003e20 - 0x100003e2c
int32_t function_100003e20(int32_t c) {
    // 0x100003e20
    return _isspace(c);
}

// Address range: 0x100003e2c - 0x100003e38
int32_t function_100003e2c(char * format, ...) {
    // 0x100003e2c
    return _printf(format);
}

// Address range: 0x100003e38 - 0x100003e44
int64_t * function_100003e38(int64_t * ptr, int32_t size) {
    // 0x100003e38
    return _realloc(ptr, size);
}

// Address range: 0x100003e44 - 0x100003e50
int32_t function_100003e44(char * s1, char * s2) {
    // 0x100003e44
    return _strcmp(s1, s2);
}

// Address range: 0x100003e50 - 0x100003e5c
char * function_100003e50(char * s) {
    // 0x100003e50
    return _strdup(s);
}

// Address range: 0x100003e5c - 0x100003e68
int32_t function_100003e5c(char * s) {
    // 0x100003e5c
    return _strlen(s);
}

// Address range: 0x100003e68 - 0x100003e74
char * function_100003e68(char * s, char * delim) {
    // 0x100003e68
    return _strtok(s, delim);
}

// Address range: 0x100003e74 - 0x100003e80
int32_t function_100003e74(char * nptr, char ** endptr, int32_t base) {
    // 0x100003e74
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 25

`
`#include <stdio.h>

int main()
{
  rename("input.txt", "output.txt");
  rename("docs", "mydocs");
  rename("/input.txt", "/output.txt");
  rename("/docs", "/mydocs");
  return 0;
}
`,`#include "rename-a-file.h"



undefined4 entry(void)

{
  _rename("input.txt","output.txt");
  _rename("docs","mydocs");
  _rename("/input.txt","/output.txt");
  _rename("/docs","/mydocs");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rename(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rename_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

long getFileSize(const char *filename)
{
  long result;
  FILE *fh = fopen(filename, "rb");
  fseek(fh, 0, SEEK_END);
  result = ftell(fh);
  fclose(fh);
  return result;
}

int main(void)
{
  printf("%ld\n", getFileSize("input.txt"));
  printf("%ld\n", getFileSize("/input.txt"));
  return 0;
}
`,`#include "file-size-1.h"



long _getFileSize(char *param_1)

{
  FILE *pFVar1;
  long lVar2;
  
  pFVar1 = _fopen(param_1,"rb");
  _fseek(pFVar1,0,2);
  lVar2 = _ftell(pFVar1);
  _fclose(pFVar1);
  return lVar2;
}



undefined4 entry(void)

{
  _getFileSize("input.txt");
  _printf("%ld\n");
  _getFileSize("/input.txt");
  _printf("%ld\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004008)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fseek(FILE *param_1,long param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fseek_100004010)((int)param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _ftell(FILE *param_1)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__ftell_100004018)();
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<stdio.h>

#define UNITS_LENGTH 13

int main(int argC,char* argV[])
{
	int i,reference;
	char *units[UNITS_LENGTH] = {"kilometer","meter","centimeter","tochka","liniya","diuym","vershok","piad","fut","arshin","sazhen","versta","milia"};
    double factor, values[UNITS_LENGTH] = {1000.0,1.0,0.01,0.000254,0.00254,0.0254,0.04445,0.1778,0.3048,0.7112,2.1336,1066.8,7467.6};
	
	if(argC!=3)
		printf("Usage : %s followed by length as <value> <unit>");
	else{
		for(i=0;argV[2][i]!=00;i++)
			argV[2][i] = tolower(argV[2][i]);
		
		for(i=0;i<UNITS_LENGTH;i++){
			if(strstr(argV[2],units[i])!=NULL){
				reference = i;
				factor = atof(argV[1])*values[i];
				break;
			}
		}
		
		printf("%s %s is equal in length to : \n",argV[1],argV[2]);
		
		for(i=0;i<UNITS_LENGTH;i++){
			if(i!=reference)
				printf("\n%lf %s",factor/values[i],units[i]);
		}
	}
	
	return 0;
}
`,`#include "old-russian-measure-of-length.h"



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  char *pcVar2;
  int local_110;
  int local_10c;
  undefined auStack_f8 [104];
  undefined8 auStack_90 [13];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_90,&PTR_s_kilometer_100004038,0x68);
  _memcpy(auStack_f8,&DAT_100003f40,0x68);
  if (param_1 == 3) {
    for (local_10c = 0; *(char *)(*(long *)(param_2 + 0x10) + (long)local_10c) != '\0';
        local_10c = local_10c + 1) {
      iVar1 = _tolower((int)*(char *)(*(long *)(param_2 + 0x10) + (long)local_10c));
      *(char *)(*(long *)(param_2 + 0x10) + (long)local_10c) = (char)iVar1;
    }
    for (local_10c = 0; local_10c < 0xd; local_10c = local_10c + 1) {
      pcVar2 = _strstr(*(char **)(param_2 + 0x10),(char *)auStack_90[local_10c]);
      if (pcVar2 != (char *)0x0) {
        local_110 = local_10c;
        _atof(*(char **)(param_2 + 8));
        break;
      }
    }
    iVar1 = _printf("%s %s is equal in length to : \n");
    for (local_10c = 0; local_10c < 0xd; local_10c = local_10c + 1) {
      if (local_10c != local_110) {
        iVar1 = _printf("\n%lf %s");
      }
    }
  }
  else {
    iVar1 = _printf("Usage : %s followed by length as <value> <unit>");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _atof(char *param_1)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__atof_100004010)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strstr(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strstr_100004028)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tolower(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tolower_100004030)(_c);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// low <= num < high
int randInt(int low, int high) {
    return (rand() % (high - low)) + low;
}

// shuffle an array of n elements
void shuffle(int *const array, const int n) {
    if (n > 1) {
        int i;
        for (i = 0; i < n - 1; i++) {
            int j = randInt(i, n);

            int t = array[i];
            array[i] = array[j];
            array[j] = t;
        }
    }
}

// print an n * n array
void printSquare(const int *const latin, const int n) {
    int i, j;
    for (i = 0; i < n; i++) {
        printf("[");
        for (j = 0; j < n; j++) {
            if (j > 0) {
                printf(", ");
            }
            printf("%d", latin[i * n + j]);
        }
        printf("]\n");
    }
    printf("\n");
}

void latinSquare(const int n) {
    int *latin, *used;
    int i, j, k;

    if (n <= 0) {
        printf("[]\n");
        return;
    }

    // allocate
    latin = (int *)malloc(n * n * sizeof(int));
    if (!latin) {
        printf("Failed to allocate memory.");
        return;
    }

    // initialize
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            latin[i * n + j] = j;
        }
    }

    // first row
    shuffle(latin, n);

    // middle row(s)
    for (i = 1; i < n - 1; i++) {
        bool shuffled = false;

        while (!shuffled) {
            shuffle(&latin[i * n], n);

            for (k = 0; k < i; k++) {
                for (j = 0; j < n; j++) {
                    if (latin[k * n + j] == latin[i * n + j]) {
                        goto shuffling;
                    }
                }
            }
            shuffled = true;

        shuffling: {}
        }
    }

    //last row
    used = (int *)malloc(n * sizeof(int));
    for (j = 0; j < n; j++) {
        memset(used, 0, n * sizeof(int));
        for (i = 0; i < n - 1; i++) {
            used[latin[i * n + j]] = 1;
        }
        for (k = 0; k < n; k++) {
            if (used[k] == 0) {
                latin[(n - 1) * n + j] = k;
                break;
            }
        }
    }
    free(used);

    // print the result
    printSquare(latin, n);
    free(latin);
}

int main() {
    // initialze the random number generator
    srand((unsigned int)time((time_t)0));

    latinSquare(5);
    latinSquare(5);
    latinSquare(10);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000393c(int32_t a1, int32_t a2);
int64_t function_100003980(void);
int64_t function_100003a38(void);
int64_t function_100003b3c(void);
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f34(int64_t * ptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * format, ...);
int32_t function_100003f58(void);
void function_100003f64(int32_t seed);
int32_t function_100003f70(int32_t * timer);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000393c - 0x100003980
int64_t function_10000393c(int32_t a1, int32_t a2) {
    // 0x10000393c
    return _rand() % (a2 - a1) + a1;
}

// Address range: 0x100003980 - 0x100003a38
int64_t function_100003980(void) {
    // 0x100003980
    int64_t v1; // 0x100003980
    int32_t v2 = v1; // 0x100003990
    int32_t v3 = v2 - 1; // 0x100003998
    int64_t result; // 0x100003980
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0) {
        // 0x100003a2c
        return result;
    }
    int32_t v4 = 1 - v2; // 0x1000039bc
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a2c
        return result;
    }
    int32_t v5 = 0; // 0x1000039c4
    int64_t result2 = function_10000393c(v5, v2); // 0x1000039d4
    int32_t * v6 = (int32_t *)(4 * (int64_t)v5 + v1); // 0x1000039e4
    int32_t * v7 = (int32_t *)((0x100000000 * result2 >> 30) + v1); // 0x1000039f4
    *v6 = *v7;
    *v7 = *v6;
    v5++;
    int32_t v8 = v5 - v3; // 0x1000039bc
    while (v8 < 0 != ((v8 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x1000039cc
        result2 = function_10000393c(v5, v2);
        v6 = (int32_t *)(4 * (int64_t)v5 + v1);
        v7 = (int32_t *)((0x100000000 * result2 >> 30) + v1);
        *v6 = *v7;
        *v7 = *v6;
        v5++;
        v8 = v5 - v3;
    }
    // 0x100003a2c
    return result2;
}

// Address range: 0x100003a38 - 0x100003b3c
int64_t function_100003a38(void) {
    // 0x100003a38
    int64_t v1; // 0x100003a38
    int32_t v2 = v1; // 0x100003a48
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003b24
        return _printf("\n");
    }
    int32_t v4 = 0; // 0x100003a64
    _printf("[");
    int32_t v5 = 0; // 0x100003af8
    if (v5 >= 1) {
        // 0x100003aac
        _printf(", ");
    }
    // 0x100003abc
    _printf("%d", v1);
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003a98
        if (v5 >= 1) {
            // 0x100003aac
            _printf(", ");
        }
        // 0x100003abc
        _printf("%d", v1);
        v5++;
    }
    // 0x100003b04
    _printf("]\n");
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003a98
        _printf("[");
        v5 = 0;
        if (v5 >= 1) {
            // 0x100003aac
            _printf(", ");
        }
        // 0x100003abc
        _printf("%d", v1);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003a98
            if (v5 >= 1) {
                // 0x100003aac
                _printf(", ");
            }
            // 0x100003abc
            _printf("%d", v1);
            v5++;
        }
        // 0x100003b04
        _printf("]\n");
        v4++;
    }
    // 0x100003b24
    return _printf("\n");
}

// Address range: 0x100003b3c - 0x100003ed8
int64_t function_100003b3c(void) {
    // 0x100003b3c
    int64_t v1; // 0x100003b3c
    int32_t v2 = v1; // 0x100003b48
    if (v2 < 1) {
        // 0x100003ecc
        return _printf("[]\n");
    }
    int32_t v3 = 4 * v2;
    int64_t * v4 = _malloc(v3 * v2); // 0x100003b88
    if (v4 == NULL) {
        // 0x100003ecc
        return _printf("Failed to allocate memory.");
    }
    int64_t v5 = (int64_t)v4; // 0x100003b88
    int32_t v6 = -v2;
    int32_t v7 = 0; // 0x100003bcc
    if (v6 < 0 != (v6 & v2) < 0) {
        int32_t v8 = v7 * v2; // 0x100003c04
        int32_t v9 = 0;
        *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
        int32_t v10 = v9 + 1; // 0x100003c1c
        while (v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
            // 0x100003bf4
            v9 = v10;
            *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
            v10 = v9 + 1;
        }
        // 0x100003c2c
        v7++;
        while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003bf4
            v8 = v7 * v2;
            v9 = 0;
            *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
            v10 = v9 + 1;
            while (v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
                // 0x100003bf4
                v9 = v10;
                *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
                v10 = v9 + 1;
            }
            // 0x100003c2c
            v7++;
        }
    }
    // 0x100003c3c
    function_100003980();
    int32_t v11 = v2 - 1; // 0x100003c5c
    int32_t v12 = 2 - v2; // 0x100003c60
    int32_t v13 = 1; // 0x100003c68
    if (v12 < 0 != (v12 & v11) < 0) {
        while (true) {
            int32_t v14 = v13;
            int32_t v15 = -v14;
            int32_t v16 = v14 * v2;
            function_100003980();
            if (v15 < 0 != (v14 & v15) < 0) {
                while (true) {
                    int32_t v17 = 0; // 0x100003d48
                    while (true) {
                        int32_t v18 = v17;
                        if (v6 < 0 != (v6 & v2) < 0) {
                            int32_t v19 = v18 * v2; // 0x100003cec
                            int32_t v20 = 0;
                            int32_t v21 = *(int32_t *)((int64_t)(4 * (v20 + v16)) + v5); // 0x100003d14
                            if (*(int32_t *)((int64_t)(4 * (v20 + v19)) + v5) == v21) {
                                // break (via goto) -> 0x100003c84
                                goto lab_0x100003c84;
                            }
                            int32_t v22 = v20 + 1; // 0x100003d34
                            while (v22 - v2 < 0 != ((v22 - v2 ^ v22) & (v22 ^ v2)) < 0) {
                                // 0x100003ce0
                                v20 = v22;
                                v21 = *(int32_t *)((int64_t)(4 * (v20 + v16)) + v5);
                                if (*(int32_t *)((int64_t)(4 * (v20 + v19)) + v5) == v21) {
                                    // break (via goto) -> 0x100003c84
                                    goto lab_0x100003c84;
                                }
                                // 0x100003cc8
                                v22 = v20 + 1;
                            }
                        }
                        // 0x100003d44
                        v17 = v18 + 1;
                        int32_t v23 = v17 - v14; // 0x100003cb0
                        if (v23 < 0 == ((v23 ^ v17) & (v17 ^ v14)) < 0) {
                            // break (via goto) -> 0x100003d68
                            goto lab_0x100003d68;
                        }
                    }
                  lab_0x100003c84:
                    // 0x100003c84
                    function_100003980();
                }
            }
          lab_0x100003d68:
            // 0x100003d68
            v13 = v14 + 1;
            int32_t v24 = v13 - v11; // 0x100003c60
            if (v24 < 0 == ((v24 ^ v13) & (v13 ^ v11)) < 0) {
                // break -> 0x100003d78
                break;
            }
        }
    }
    int64_t * v25 = _malloc(v3); // 0x100003d80
    if (v6 < 0 != (v6 & v2) < 0) {
        int64_t v26 = (int64_t)v25; // 0x100003d80
        int32_t v27 = 1 - v2;
        int32_t v28 = v11 * v2;
        int32_t v29 = 0; // 0x100003ea0
        while (true) {
            int32_t v30 = v29;
            ___memset_chk(v26, 0, 0x100000000 * v1 >> 30, -1);
            int32_t v31 = 0; // 0x100003ddc
            if (v27 < 0 != (v27 & v11) < 0) {
                int32_t v32 = *(int32_t *)((int64_t)(4 * (v31 * v2 + v30)) + v5); // 0x100003e00
                *(int32_t *)(4 * (int64_t)v32 + v26) = 1;
                int32_t v33 = v31 + 1; // 0x100003e14
                int32_t v34 = v33 - v11; // 0x100003dd4
                v31 = v33;
                while (v34 < 0 != ((v34 ^ v33) & (v33 ^ v11)) < 0) {
                    // 0x100003de4
                    v32 = *(int32_t *)((int64_t)(4 * (v31 * v2 + v30)) + v5);
                    *(int32_t *)(4 * (int64_t)v32 + v26) = 1;
                    v33 = v31 + 1;
                    v34 = v33 - v11;
                    v31 = v33;
                }
            }
            int32_t v35 = 0;
            while (*(int32_t *)(4 * (int64_t)v35 + v26) != 0) {
                int32_t v36 = v35 + 1; // 0x100003e8c
                int32_t v37 = v36 - v2; // 0x100003e30
                if (v37 < 0 == ((v37 ^ v36) & (v36 ^ v2)) < 0) {
                    goto lab_0x100003e9c;
                }
                v35 = v36;
            }
            // 0x100003e5c
            *(int32_t *)((int64_t)(4 * (v30 + v28)) + v5) = v35;
          lab_0x100003e9c:
            // 0x100003e9c
            v29 = v30 + 1;
            int32_t v38 = v29 - v2; // 0x100003d98
            if (v38 < 0 == ((v38 ^ v29) & (v29 ^ v2)) < 0) {
                // break -> 0x100003eac
                break;
            }
        }
    }
    // 0x100003eac
    _free(v25);
    function_100003a38();
    _free(v4);
    // 0x100003ecc
    return &g1;
}

// Address range: 0x100003ed8 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003ed8
    _srand(_time(NULL));
    function_100003b3c();
    function_100003b3c();
    function_100003b3c();
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f28
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(void) {
    // 0x100003f58
    return _rand();
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(int32_t seed) {
    // 0x100003f64
    _srand(seed);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(int32_t * timer) {
    // 0x100003f70
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

/* The language task, implemented with pthreads for POSIX systems. */

/* Each rendezvous_t will be accepted by a single thread, and entered
 * by one or more threads.  accept_func() only returns an integer and
 * is always run within the entering thread's context to simplify
 * handling the arguments and return value.  This somewhat unlike an
 * Ada rendezvous and is a subset of the Ada rendezvous functionality.
 * Ada's in and out parameters can be simulated via the void pointer
 * passed to accept_func() to update variables owned by both the
 * entering and accepting threads, if a suitable struct with pointers
 * to those variables is used. */
typedef struct rendezvous {
    pthread_mutex_t lock;        /* A mutex/lock to use with the CVs.        */
    pthread_cond_t cv_entering;  /* Signaled when a thread enters.           */
    pthread_cond_t cv_accepting; /* Signaled when accepting thread is ready. */
    pthread_cond_t cv_done;      /* Signaled when accept_func() finishes.    */
    int (*accept_func)(void*);   /* The function to run when accepted.       */
    int entering;                /* Number of threads trying to enter.       */
    int accepting;               /* True if the accepting thread is ready.   */
    int done;                    /* True if accept_func() is done.           */
} rendezvous_t;

/* Static initialization for rendezvous_t. */
#define RENDEZVOUS_INITILIZER(accept_function) {   \
        .lock         = PTHREAD_MUTEX_INITIALIZER, \
        .cv_entering  = PTHREAD_COND_INITIALIZER,  \
        .cv_accepting = PTHREAD_COND_INITIALIZER,  \
        .cv_done      = PTHREAD_COND_INITIALIZER,  \
        .accept_func  = accept_function,           \
        .entering     = 0,                         \
        .accepting    = 0,                         \
        .done         = 0,                         \
    }

int enter_rendezvous(rendezvous_t *rv, void* data)
{
    /* Arguments are passed in and out of the rendezvous via
     * (void*)data, and the accept_func() return value is copied and
     * returned to the caller (entering thread).  A data struct with
     * pointers to variables in both the entering and accepting
     * threads can be used to simulate Ada's in and out parameters, if
     * needed. */
    pthread_mutex_lock(&rv->lock);

    rv->entering++;
    pthread_cond_signal(&rv->cv_entering);

    while (!rv->accepting) {
        /* Nothing is accepting yet, keep waiting.  pthreads will
         * queue all waiting entries.  The loop is needed to handle
         * both race conditions and spurious wakeups. */
        pthread_cond_wait(&rv->cv_accepting, &rv->lock);
    }

    /* Call accept_func() and copy the return value before leaving
     * the mutex. */
    int ret = rv->accept_func(data);

    /* This signal is needed so that the accepting thread will wait
     * for the rendezvous to finish before trying to accept again. */
    rv->done = 1;
    pthread_cond_signal(&rv->cv_done);

    rv->entering--;
    rv->accepting = 0;
    pthread_mutex_unlock(&rv->lock);

    return ret;
}

void accept_rendezvous(rendezvous_t *rv)
{
    /* This accept function does not take in or return parameters.
     * That is handled on the entry side.  This is only for
     * synchronization. */
    pthread_mutex_lock(&rv->lock);
    rv->accepting = 1;

    while (!rv->entering) {
        /* Nothing to accept yet, keep waiting. */
        pthread_cond_wait(&rv->cv_entering, &rv->lock);
    }

    pthread_cond_signal(&rv->cv_accepting);

    while (!rv->done) {
        /* Wait for accept_func() to finish. */
        pthread_cond_wait(&rv->cv_done, &rv->lock);
    }
    rv->done = 0;

    rv->accepting = 0;
    pthread_mutex_unlock(&rv->lock);
}

/* The printer use case task implemented using the above rendezvous
 * implementation.  Since C doesn't have exceptions, return values are
 * used to signal out of ink errors. */

typedef struct printer {
    rendezvous_t rv;
    struct printer *backup;
    int id;
    int remaining_lines;
} printer_t;

typedef struct print_args {
    struct printer *printer;
    const char* line;
} print_args_t;

int print_line(printer_t *printer, const char* line) {
    print_args_t args;
    args.printer = printer;
    args.line = line;
    return enter_rendezvous(&printer->rv, &args);
}

int accept_print(void* data) {
    /* This is called within the rendezvous, so everything is locked
     * and okay to modify. */
    print_args_t *args = (print_args_t*)data;
    printer_t *printer = args->printer;
    const char* line = args->line;

    if (printer->remaining_lines) {
        /* Print the line, character by character. */
        printf("%d: ", printer->id);
        while (*line != '\0') {
            putchar(*line++);
        }
        putchar('\n');
        printer->remaining_lines--;
        return 1;
    }
    else if (printer->backup) {
        /* "Requeue" this rendezvous with the backup printer. */
        return print_line(printer->backup, line);
    }
    else {
        /* Out of ink, and no backup available. */
        return -1;
    }
}

printer_t backup_printer = {
    .rv = RENDEZVOUS_INITILIZER(accept_print),
    .backup = NULL,
    .id = 2,
    .remaining_lines = 5,
};

printer_t main_printer = {
    .rv = RENDEZVOUS_INITILIZER(accept_print),
    .backup = &backup_printer,
    .id = 1,
    .remaining_lines = 5,
};

void* printer_thread(void* thread_data) {
    printer_t *printer = (printer_t*) thread_data;
    while (1) {
        accept_rendezvous(&printer->rv);
    }
}

typedef struct poem {
    char* name;
    char* lines[];
} poem_t;

poem_t humpty_dumpty = {
    .name = "Humpty Dumpty",
    .lines = {
        "Humpty Dumpty sat on a wall.",
        "Humpty Dumpty had a great fall.",
        "All the king's horses and all the king's men",
        "Couldn't put Humpty together again.",
        ""
    },
};

poem_t mother_goose = {
    .name = "Mother Goose",
    .lines = {
        "Old Mother Goose",
        "When she wanted to wander,",
        "Would ride through the air",
        "On a very fine gander.",
        "Jack's mother came in,",
        "And caught the goose soon,",
        "And mounting its back,",
        "Flew up to the moon.",
        ""
    },
};

void* poem_thread(void* thread_data) {
    poem_t *poem = (poem_t*)thread_data;

    for (unsigned i = 0; poem->lines[i] != ""; i++) {
        int ret = print_line(&main_printer, poem->lines[i]);
        if (ret < 0) {
            printf("      %s out of ink!\n", poem->name);
            exit(1);
        }
    }
    return NULL;
}

int main(void)
{
    pthread_t threads[4];

    pthread_create(&threads[0], NULL, poem_thread,    &humpty_dumpty);
    pthread_create(&threads[1], NULL, poem_thread,    &mother_goose);
    pthread_create(&threads[2], NULL, printer_thread, &main_printer);
    pthread_create(&threads[3], NULL, printer_thread, &backup_printer);

    pthread_join(threads[0], NULL);
    pthread_join(threads[1], NULL);
    pthread_cancel(threads[2]);
    pthread_cancel(threads[3]);

    return 0;
}
`,`#include "rendezvous-1.h"



undefined4 _enter_rendezvous(pthread_mutex_t *param_1,undefined8 param_2)

{
  undefined4 uVar1;
  
  _pthread_mutex_lock(param_1);
  *(int *)(param_1[3].__opaque + 0x10) = *(int *)(param_1[3].__opaque + 0x10) + 1;
  _pthread_cond_signal((pthread_cond_t *)(param_1 + 1));
  while (*(int *)(param_1[3].__opaque + 0x14) == 0) {
    _pthread_cond_wait((pthread_cond_t *)(param_1[1].__opaque + 0x28),param_1);
  }
  uVar1 = (**(code **)(param_1[3].__opaque + 8))(param_2);
  param_1[3].__opaque[0x18] = '\x01';
  param_1[3].__opaque[0x19] = '\0';
  param_1[3].__opaque[0x1a] = '\0';
  param_1[3].__opaque[0x1b] = '\0';
  _pthread_cond_signal((pthread_cond_t *)(param_1[2].__opaque + 0x18));
  *(int *)(param_1[3].__opaque + 0x10) = *(int *)(param_1[3].__opaque + 0x10) + -1;
  param_1[3].__opaque[0x14] = '\0';
  param_1[3].__opaque[0x15] = '\0';
  param_1[3].__opaque[0x16] = '\0';
  param_1[3].__opaque[0x17] = '\0';
  _pthread_mutex_unlock(param_1);
  return uVar1;
}



int _accept_rendezvous(pthread_mutex_t *param_1)

{
  int iVar1;
  
  _pthread_mutex_lock(param_1);
  param_1[3].__opaque[0x14] = '\x01';
  param_1[3].__opaque[0x15] = '\0';
  param_1[3].__opaque[0x16] = '\0';
  param_1[3].__opaque[0x17] = '\0';
  while (*(int *)(param_1[3].__opaque + 0x10) == 0) {
    _pthread_cond_wait((pthread_cond_t *)(param_1 + 1),param_1);
  }
  _pthread_cond_signal((pthread_cond_t *)(param_1[1].__opaque + 0x28));
  while (*(int *)(param_1[3].__opaque + 0x18) == 0) {
    _pthread_cond_wait((pthread_cond_t *)(param_1[2].__opaque + 0x18),param_1);
  }
  param_1[3].__opaque[0x18] = '\0';
  param_1[3].__opaque[0x19] = '\0';
  param_1[3].__opaque[0x1a] = '\0';
  param_1[3].__opaque[0x1b] = '\0';
  param_1[3].__opaque[0x14] = '\0';
  param_1[3].__opaque[0x15] = '\0';
  param_1[3].__opaque[0x16] = '\0';
  param_1[3].__opaque[0x17] = '\0';
  iVar1 = _pthread_mutex_unlock(param_1);
  return iVar1;
}



void _print_line(undefined8 param_1,undefined8 param_2)

{
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_18;
  
  local_30 = param_1;
  local_28 = param_2;
  local_20 = param_2;
  local_18 = param_1;
  _enter_rendezvous(param_1,&local_30);
  return;
}



undefined4 _accept_print(long *param_1)

{
  long lVar1;
  char *local_38;
  undefined4 local_14;
  
  lVar1 = *param_1;
  local_38 = (char *)param_1[1];
  if (*(int *)(lVar1 + 0xf4) == 0) {
    if (*(long *)(lVar1 + 0xe8) == 0) {
      local_14 = 0xffffffff;
    }
    else {
      local_14 = _print_line(*(undefined8 *)(lVar1 + 0xe8),local_38);
    }
  }
  else {
    _printf("%d: ");
    while (*local_38 != '\0') {
      _putchar((int)*local_38);
      local_38 = local_38 + 1;
    }
    _putchar(10);
    *(int *)(lVar1 + 0xf4) = *(int *)(lVar1 + 0xf4) + -1;
    local_14 = 1;
  }
  return local_14;
}



void _printer_thread(undefined8 param_1)

{
  do {
    _accept_rendezvous(param_1);
  } while( true );
}



undefined8 _poem_thread(long param_1)

{
  int iVar1;
  uint local_24;
  
  local_24 = 0;
  while( true ) {
    if (*(char **)(param_1 + 8 + (ulong)local_24 * 8) == "") {
      return 0;
    }
    iVar1 = _print_line(&_main_printer,*(undefined8 *)(param_1 + 8 + (ulong)local_24 * 8));
    if (iVar1 < 0) break;
    local_24 = local_24 + 1;
  }
  _printf("      %s out of ink!\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



undefined8 entry(void)

{
  int iVar1;
  pthread_t local_38;
  pthread_t local_30;
  pthread_t local_28;
  pthread_t local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _pthread_create(&local_38,(pthread_attr_t *)0x0,(void **)_poem_thread,&_humpty_dumpty);
  _pthread_create(&local_30,(pthread_attr_t *)0x0,(void **)_poem_thread,&_mother_goose);
  _pthread_create(&local_28,(pthread_attr_t *)0x0,(void **)_printer_thread,&_main_printer);
  _pthread_create(&local_20,(pthread_attr_t *)0x0,(void **)_printer_thread,&_backup_printer);
  _pthread_join(local_38,(void **)0x0);
  _pthread_join(local_30,(void **)0x0);
  _pthread_cancel(local_28);
  iVar1 = _pthread_cancel(local_20);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003da8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003db4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cancel(pthread_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dcc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cancel_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cond_signal(pthread_cond_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dd8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cond_signal_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cond_wait(pthread_cond_t *param_1,pthread_mutex_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003de4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cond_wait_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_create(pthread_t *param_1,pthread_attr_t *param_2,void **param_3,void *param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003df0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_create_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_join(pthread_t param_1,void **param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dfc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_join_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_lock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_lock_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_unlock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_unlock_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004058)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main()
{
  int junk, *junkp;

  /* Print an unitialized variable! */
  printf("junk: %d\n", junk);

  /* Follow a pointer to unitialized memory! */
  junkp = malloc(sizeof *junkp);
  if (junkp)
    printf("*junkp: %d\n", *junkp);
  return 0;
}
`,`#include "undefined-values.h"



undefined8 entry(void)

{
  void *pvVar1;
  
  _printf("junk: %d\n");
  pvVar1 = _malloc(4);
  if (pvVar1 != (void *)0x0) {
    _printf("*junkp: %d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define forall(i, n) for (int i = 0; i < n; i++)
typedef struct edge { char s, e, *str; struct edge *lnk; } edge;
typedef struct { edge* e[26]; int nin, nout, in[26], out[26];} node;
typedef struct { edge *e, *tail; int len, has[26]; } chain;

node nodes[26];
edge *names, **tmp;
int n_names;

/* add edge to graph */
void store_edge(edge *g)
{
	if (!g) return;
	int i = g->e, j = g->s;
	node *n = nodes + j;

	g->lnk = n->e[i];

	n->e[i] = g, n->out[i]++, n->nout++;
	n = nodes + i, n->in[j]++, n->nin++;
}

/* unlink an edge between nodes i and j, and return the edge */
edge* remove_edge(int i, int j)
{
	node *n = nodes + i;
	edge *g = n->e[j];
	if (g) {
		n->e[j] = g->lnk;
		g->lnk = 0;
		n->out[j]--, n->nout--;

		n = nodes + j;
		n->in[i]--;
		n->nin--;
	}
	return g;
}

void read_names()
{
	FILE *fp = fopen("poke646", "rt");
	int i, len;
	char *buf;
	edge *p;

	if (!fp) abort();

	fseek(fp, 0, SEEK_END);
	len = ftell(fp);
	buf = malloc(len + 1);
	fseek(fp, 0, SEEK_SET);
	fread(buf, 1, len, fp);
	fclose(fp);

	buf[len] = 0;
	for (n_names = i = 0; i < len; i++)
		if (isspace(buf[i]))
			buf[i] = 0, n_names++;

	if (buf[len-1]) n_names++;

	memset(nodes, 0, sizeof(node) * 26);
	tmp = calloc(n_names, sizeof(edge*));

	p = names = malloc(sizeof(edge) * n_names);
	for (i = 0; i < n_names; i++, p++) {
		if (i)	p->str = names[i-1].str + len + 1;
		else	p->str = buf;

		len = strlen(p->str);
		p->s = p->str[0] - 'a';
		p->e = p->str[len-1] - 'a';
		if (p->s < 0 || p->s >= 26 || p->e < 0 || p->e >= 26) {
			printf("bad name %s: first/last char must be letter\n",
				p->str);
			abort();
		}
	}
	printf("read %d names\n", n_names);
}

void show_chain(chain *c)
{
	printf("%d:", c->len);
	for (edge * e = c->e; e || !putchar('\n'); e = e->lnk)
		printf(" %s", e->str);
}

/* Which next node has most enter or exit edges. */
int widest(int n, int out)
{
	if (nodes[n].out[n]) return n;

	int mm = -1, mi = -1;
	forall(i, 26) {
		if (out) {
			if (nodes[n].out[i] && nodes[i].nout > mm)
				mi = i, mm = nodes[i].nout;
		} else {
			if (nodes[i].out[n] && nodes[i].nin > mm)
				mi = i, mm = nodes[i].nin;
		}
	}

	return mi;
}

void insert(chain *c, edge *e)
{
	e->lnk = c->e;
	if (!c->tail) c->tail = e;
	c->e = e;
	c->len++;
}

void append(chain *c, edge *e)
{
	if (c->tail) c->tail->lnk = e;
	else c->e = e;
	c->tail = e;
	c->len++;
}

edge * shift(chain *c)
{
	edge *e = c->e;
	if (e) {
		c->e = e->lnk;
		if (!--c->len) c->tail = 0;
	}
	return e;
}

chain* make_chain(int s)
{
	chain *c = calloc(1, sizeof(chain));
	
	/* extend backwards */
	for (int i, j = s; (i = widest(j, 0)) >= 0; j = i)
		insert(c, remove_edge(i, j));

	/* extend forwards */
	for (int i, j = s; (i = widest(j, 1)) >= 0; j = i)
		append(c, remove_edge(j, i));

	for (int step = 0;; step++) {
		edge *e = c->e;

		for (int i = 0; i < step; i++)
			if (!(e = e->lnk)) break;
		if (!e) return c;

		int n = 0;
		for (int i, j = e->s; (i = widest(j, 0)) >= 0; j = i) {
			if (!(e = remove_edge(i, j))) break;
			tmp[n++] = e;
		}

		if (n > step) {
			forall(i, step) store_edge(shift(c));
			forall(i, n) insert(c, tmp[i]);
			step = -1;
		} else while (--n >= 0)
			store_edge(tmp[n]);
	}
	return c;
}

int main(void)
{
	int best = 0;
	read_names();

	forall(i, 26) {
		/* rebuild the graph */
		memset(nodes, 0, sizeof(nodes));
		forall(j, n_names) store_edge(names + j);

		/* make a chain from node i */
		chain *c = make_chain(i);
		if (c->len > best) {
			show_chain(c);
			best = c->len;
		}
		free(c);
	}

	printf("longest found: %d\n", best);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000312c(void);
int64_t function_10000321c(void);
int64_t function_100003308(void);
int64_t function_10000367c(void);
int64_t function_100003738(void);
int64_t function_100003914(void);
int64_t function_10000397c(void);
int64_t function_1000039e8(void);
int64_t function_100003a5c(void);
void function_100003e84(void);
void function_100003e90(int64_t * s, int32_t n);
int64_t * function_100003e9c(int32_t nmemb, int32_t size);
int32_t function_100003ea8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003eb4(char * filename, char * modes);
int32_t function_100003ec0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003ecc(int64_t * ptr);
int32_t function_100003ed8(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003ee4(struct _IO_FILE * stream);
int32_t function_100003ef0(int32_t c);
int64_t * function_100003efc(int32_t size);
int32_t function_100003f08(char * format, ...);
int32_t function_100003f14(int32_t c);
int32_t function_100003f20(char * s);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1120531; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
int64_t g3 = 0x4b800000012; // 0x100008010
int64_t g4 = 0; // 0x10000ab20

// ------- Dynamically Linked Functions Without Header --------

void _abort(void);
void _bzero(int64_t * a1, int32_t a2);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _ftell(struct _IO_FILE * a1);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000312c - 0x10000321c
int64_t function_10000312c(void) {
    // 0x10000312c
    int64_t result; // 0x10000312c
    if (result != 0) {
        int64_t v1 = 0x100000000000000 * result;
        int64_t v2 = 424 * (v1 >> 56); // 0x10000316c
        int64_t v3 = (int64_t)*(char *)(result + 1); // 0x100003188
        int64_t v4 = *(int64_t *)(v2 + (int64_t)&g3 + 8 * v3); // 0x10000318c
        *(int64_t *)(result + 16) = v4;
        int32_t * v5 = (int32_t *)(v2 + (int64_t)&g3 + 320 + 4 * v3); // 0x1000031b8
        *v5 = *v5 + 1;
        int32_t * v6 = (int32_t *)(v2 + (int64_t)&g3 + 212); // 0x1000031c8
        *v6 = *v6 + 1;
        int64_t v7 = 424 * v3; // 0x1000031d8
        int32_t * v8 = (int32_t *)((v1 >> 54) + (int64_t)&g3 + 216 + v7); // 0x1000031f4
        *v8 = *v8 + 1;
        int32_t * v9 = (int32_t *)(v7 + (int64_t)&g3 + 208); // 0x100003204
        *v9 = *v9 + 1;
    }
    // 0x100003214
    return result;
}

// Address range: 0x10000321c - 0x100003308
int64_t function_10000321c(void) {
    // 0x10000321c
    int64_t v1; // 0x10000321c
    int64_t v2 = 0x100000000 * v1;
    int64_t v3 = 424 * (v2 >> 32); // 0x100003230
    int64_t v4 = 0x100000000 * v1;
    int64_t * v5 = (int64_t *)((v4 >> 29) + (int64_t)&g3 + v3); // 0x10000324c
    int64_t result = *v5; // 0x10000324c
    if (result != 0) {
        int64_t * v6 = (int64_t *)(result + 16); // 0x10000326c
        *v5 = *v6;
        *v6 = 0;
        int32_t * v7 = (int32_t *)((v4 >> 30) + (int64_t)&g3 + 320 + v3); // 0x100003294
        *v7 = *v7 - 1;
        int32_t * v8 = (int32_t *)(v3 + (int64_t)&g3 + 212); // 0x1000032a4
        *v8 = *v8 - 1;
        int64_t v9 = 424 * (v4 >> 32); // 0x1000032b8
        int32_t * v10 = (int32_t *)(v9 + (int64_t)&g3 + 216 + (v2 >> 30)); // 0x1000032dc
        *v10 = *v10 - 1;
        int32_t * v11 = (int32_t *)(v9 + (int64_t)&g3 + 208); // 0x1000032ec
        *v11 = *v11 - 1;
    }
    // 0x1000032fc
    return result;
}

// Address range: 0x100003308 - 0x10000367c
int64_t function_100003308(void) {
    struct _IO_FILE * v1 = _fopen("poke646", "rt"); // 0x100003324
    if (v1 == NULL) {
        // 0x100003340
        _abort();
    }
    // 0x100003344
    _fseek(v1, 0, 2);
    int32_t v2 = _ftell(v1); // 0x10000335c
    int64_t * v3 = _malloc(v2 + 1); // 0x100003378
    int64_t v4 = (int64_t)v3; // 0x100003378
    _fseek(v1, 0, 0);
    _fread(v3, 1, v2, v1);
    _fclose(v1);
    *(char *)(v4 + (int64_t)v2) = 0;
    g1 = 0;
    int32_t v5 = -v2; // 0x1000033d8
    int32_t v6 = 0; // 0x1000033e0
    if (v5 < 0 != (v2 & v5) < 0) {
        char * v7 = (char *)((int64_t)v6 + v4); // 0x1000033f0
        if (_isspace((int32_t)*v7) != 0) {
            // 0x100003408
            *v7 = 0;
            g1++;
        }
        // 0x100003434
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x1000033e8
            v7 = (char *)((int64_t)v6 + v4);
            if (_isspace((int32_t)*v7) != 0) {
                // 0x100003408
                *v7 = 0;
                g1++;
            }
            // 0x100003434
            v6++;
        }
    }
    // 0x100003444
    if (*(char *)(v4 + (int64_t)(v2 - 1)) != 0) {
        // 0x100003468
        g1++;
    }
    // 0x100003480
    _bzero(&g3, 0x2b10);
    g4 = (int64_t)_calloc(g1, 8);
    int64_t * v8 = _malloc(24 * g1); // 0x1000034c4
    g2 = (int64_t)v8;
    int32_t v9 = -g1; // 0x1000034f4
    if (v9 < 0 == (g1 & v9) < 0) {
        // 0x10000364c
        return _printf("read %d names\n", 8);
    }
    char * v10 = (char *)v8; // 0x100003308
    int32_t v11 = 0; // 0x100003634
    int32_t v12 = v2; // 0x100003308
    int64_t v13; // 0x100003308
    int32_t v14; // 0x100003308
    int32_t v15; // 0x100003568
    while (true) {
      lab_0x100003504:
        // 0x100003504
        v14 = v11;
        char * v16 = v10;
        int64_t * v17; // 0x100003308
        int64_t v18; // 0x100003308
        if (v14 == 0) {
            int64_t v19 = (int64_t)v16;
            int64_t * v20 = (int64_t *)(v19 + 8);
            *v20 = v4;
            v18 = v4;
            v17 = v20;
            v13 = v19;
        } else {
            int64_t v21 = *(int64_t *)(24 * (int64_t)(v14 - 1) + 8 + g2); // 0x100003534
            int64_t v22 = (int64_t)v12 + 1 + v21; // 0x100003540
            int64_t v23 = (int64_t)v16;
            int64_t * v24 = (int64_t *)(v23 + 8);
            *v24 = v22;
            v18 = v22;
            v17 = v24;
            v13 = v23;
        }
        // 0x100003560
        v15 = _strlen((char *)v18);
        *v16 = *(char *)*v17 - 97;
        char v25 = *(char *)(*v17 + (int64_t)(v15 - 1)) - 97; // 0x1000035a0
        *(char *)(v13 + 1) = v25;
        char v26 = *v16; // 0x1000035b0
        if (v26 < 0) {
            // 0x10000360c
            _printf("bad name %s: first/last char must be letter\n", (char *)8);
            _abort();
            goto lab_0x100003630;
        } else {
            int32_t v27 = v26; // 0x1000035c8
            if (v25 < 0 || v26 < 26 == (25 - v27 & v27) < 0) {
                // 0x10000360c
                _printf("bad name %s: first/last char must be letter\n", (char *)8);
                _abort();
                goto lab_0x100003630;
            } else {
                int32_t v28 = v25; // 0x1000035f8
                if (v25 < 26 == (25 - v28 & v28) < 0) {
                    // 0x10000360c
                    _printf("bad name %s: first/last char must be letter\n", (char *)8);
                    _abort();
                    goto lab_0x100003630;
                } else {
                    goto lab_0x100003630;
                }
            }
        }
    }
    // 0x10000364c
    return _printf("read %d names\n", 8);
  lab_0x100003630:
    // 0x100003630
    v11 = v14 + 1;
    int32_t v29 = v11 - g1; // 0x1000034f4
    v10 = (char *)(v13 + 24);
    v12 = v15;
    if (v29 < 0 == ((v29 ^ v11) & (g1 ^ v11)) < 0) {
        return _printf("read %d names\n", 8);
    }
    goto lab_0x100003504;
}

// Address range: 0x10000367c - 0x100003738
int64_t function_10000367c(void) {
    // 0x10000367c
    int64_t v1; // 0x10000367c
    int64_t v2 = _printf("%d:", v1); // 0x1000036b8
    int32_t result; // 0x1000036dc
    while (true) {
        // 0x1000036bc
        if (v2 == 0) {
            // 0x1000036f0
            result = _putchar(10);
            if (result != 0) {
                // break -> 0x10000372c
                break;
            }
        }
        // 0x1000036fc
        _printf(" %s", (char *)v1);
        v2 += 16;
    }
    // 0x10000372c
    return result;
}

// Address range: 0x100003738 - 0x100003914
int64_t function_100003738(void) {
    // 0x100003738
    int64_t result; // 0x100003738
    int64_t v1 = 0x100000000 * result;
    int64_t v2 = 424 * (v1 >> 32) + (int64_t)&g3 + 320; // 0x100003760
    int64_t v3 = v1 >> 30; // 0x100003764
    if (*(int32_t *)(v2 + v3) != 0) {
        // 0x100003908
        return result;
    }
    int32_t v4 = -1;
    int32_t v5 = -1;
    int64_t v6 = 0;
    int32_t v7; // 0x100003738
    int32_t v8; // 0x100003738
    int32_t v9; // 0x1000038a0
    int32_t v10; // 0x1000038a8
    bool v11; // 0x1000038ac
    int32_t v12; // 0x10000380c
    int32_t v13; // 0x100003814
    bool v14; // 0x100003818
    int64_t v15; // 0x10000385c
    if ((int32_t)result == 0) {
        // 0x100003854
        v15 = 424 * v6;
        v7 = v4;
        v8 = v5;
        if (*(int32_t *)(v3 + (int64_t)&g3 + 320 + v15) != 0) {
            // 0x100003888
            v9 = *(int32_t *)(v15 + (int64_t)&g3 + 208);
            v10 = v9 - v4;
            v11 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v4)) < 0;
            v7 = v11 ? v4 : v9;
            v8 = v11 ? v5 : (int32_t)v6;
        }
    } else {
        // 0x1000037c0
        v7 = v4;
        v8 = v5;
        if (*(int32_t *)(4 * v6 + v2) != 0) {
            // 0x1000037f4
            v12 = *(int32_t *)(424 * v6 + (int64_t)&g3 + 212);
            v13 = v12 - v4;
            v14 = v13 == 0 | v13 < 0 != ((v13 ^ v12) & (v12 ^ v4)) < 0;
            v7 = v14 ? v4 : v12;
            v8 = v14 ? v5 : (int32_t)v6;
        }
    }
    int32_t result2 = v8;
    int64_t v16 = v6 + 1;
    while (v16 != 26) {
        // 0x1000037ac
        v4 = v7;
        v5 = result2;
        v6 = v16;
        if ((int32_t)result == 0) {
            // 0x100003854
            v15 = 424 * v6;
            v7 = v4;
            v8 = v5;
            if (*(int32_t *)(v3 + (int64_t)&g3 + 320 + v15) != 0) {
                // 0x100003888
                v9 = *(int32_t *)(v15 + (int64_t)&g3 + 208);
                v10 = v9 - v4;
                v11 = v10 == 0 | v10 < 0 != ((v10 ^ v9) & (v9 ^ v4)) < 0;
                v7 = v11 ? v4 : v9;
                v8 = v11 ? v5 : (int32_t)v6;
            }
        } else {
            // 0x1000037c0
            v7 = v4;
            v8 = v5;
            if (*(int32_t *)(4 * v6 + v2) != 0) {
                // 0x1000037f4
                v12 = *(int32_t *)(424 * v6 + (int64_t)&g3 + 212);
                v13 = v12 - v4;
                v14 = v13 == 0 | v13 < 0 != ((v13 ^ v12) & (v12 ^ v4)) < 0;
                v7 = v14 ? v4 : v12;
                v8 = v14 ? v5 : (int32_t)v6;
            }
        }
        // 0x1000038ec
        result2 = v8;
        v16 = v6 + 1;
    }
    // 0x100003908
    return result2;
}

// Address range: 0x100003914 - 0x10000397c
int64_t function_100003914(void) {
    // 0x100003958
    int64_t result; // 0x100003914
    int32_t * v1 = (int32_t *)(result + 16); // 0x100003968
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x10000397c - 0x1000039e8
int64_t function_10000397c(void) {
    // 0x10000397c
    int64_t result; // 0x10000397c
    if (*(int64_t *)(result + 8) == 0) {
        // branch -> 0x1000039c4
    }
    int32_t * v1 = (int32_t *)(result + 16); // 0x1000039d4
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x1000039e8 - 0x100003a5c
int64_t function_1000039e8(void) {
    // 0x1000039e8
    int64_t result; // 0x1000039e8
    if (result == 0) {
        // 0x100003a50
        return result;
    }
    int64_t v1 = result + 16; // 0x100003a14
    *(int64_t *)result = *(int64_t *)v1;
    int32_t * v2 = (int32_t *)v1; // 0x100003a24
    int32_t v3 = *v2 - 1; // 0x100003a28
    *v2 = v3;
    if (v3 == 0) {
        // 0x100003a40
        *(int64_t *)(result + 8) = 0;
    }
    // 0x100003a50
    return result;
}

// Address range: 0x100003a5c - 0x100003d5c
int64_t function_100003a5c(void) {
    int64_t * v1 = _calloc(1, 128); // 0x100003a74
    if ((int32_t)function_100003738() >= 0) {
        function_10000321c();
        function_100003914();
        while ((int32_t)function_100003738() >= 0) {
            // 0x100003aa8
            function_10000321c();
            function_100003914();
        }
    }
    // 0x100003ae4
    if ((int32_t)function_100003738() >= 0) {
        function_10000321c();
        function_10000397c();
        while ((int32_t)function_100003738() >= 0) {
            // 0x100003b04
            function_10000321c();
            function_10000397c();
        }
    }
    int64_t result = (int64_t)v1; // 0x100003a74
    int32_t v2 = 0;
    char * v3 = (char *)*v1; // 0x100003b44
    int32_t v4 = -v2;
    int32_t v5 = 0; // 0x100003b60
    char * v6 = v3; // 0x100003b60
    int64_t v7; // 0x100003b6c
    int32_t v8; // 0x100003b58
    if (v4 < 0 != (v2 & v4) < 0) {
        v7 = *(int64_t *)((int64_t)v6 + 16);
        while (v7 != 0) {
            // 0x100003b50
            v5++;
            v8 = v5 - v2;
            if (v8 < 0 == ((v8 ^ v5) & (v5 ^ v2)) < 0) {
                // break -> 0x100003ba0
                break;
            }
            v7 = *(int64_t *)((int64_t)(char *)v7 + 16);
        }
        return result;
    }
    while (v3 != NULL) {
        int32_t v9 = v4; // 0x100003bf0
        int32_t v10 = 0; // 0x100003bf0
        if ((int32_t)function_100003738() >= 0) {
            int32_t v11 = 0;
            int64_t v12 = function_10000321c(); // 0x100003c00
            int32_t v13 = v11; // 0x100003c14
            while (v12 != 0) {
                int32_t v14 = v11 + 1; // 0x100003c38
                *(int64_t *)(g4 + 8 * (int64_t)v11) = v12;
                int32_t v15 = v14; // 0x100003bf0
                v13 = v14;
                if ((int32_t)function_100003738() < 0) {
                    // break -> 0x100003c54
                    break;
                }
                v11 = v15;
                v12 = function_10000321c();
                v13 = v11;
            }
            // 0x100003c54
            v10 = v13;
            v9 = v10 - v2;
        }
        int32_t v16 = v10;
        int32_t v17 = v9;
        int32_t v18; // 0x100003a5c
        if (v17 == 0 || v17 < 0 != ((v17 ^ v16) & (v16 ^ v2)) < 0) {
            int32_t v19 = v16 - 1; // 0x100003d10
            int32_t v20 = v19; // 0x100003d20
            v18 = v2;
            if (v19 >= 0) {
                function_10000312c();
                int32_t v21 = v20 - 1; // 0x100003d10
                v20 = v21;
                v18 = v2;
                while (v21 >= 0) {
                    // 0x100003d28
                    function_10000312c();
                    v21 = v20 - 1;
                    v20 = v21;
                    v18 = v2;
                }
            }
        } else {
            // 0x100003c74
            if (v4 < 0 != (v2 & v4) < 0) {
                function_1000039e8();
                function_10000312c();
                int32_t v22 = 1; // 0x100003ca0
                int32_t v23 = v22 - v2; // 0x100003c7c
                int32_t v24 = v22; // 0x100003c84
                while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v2)) < 0) {
                    // 0x100003c8c
                    function_1000039e8();
                    function_10000312c();
                    v22 = v24 + 1;
                    v23 = v22 - v2;
                    v24 = v22;
                }
            }
            int32_t v25 = -v16; // 0x100003cbc
            v18 = -1;
            if (v25 < 0 != (v16 & v25) < 0) {
                function_100003914();
                int32_t v26 = 1; // 0x100003cf0
                int32_t v27 = v26 - v16; // 0x100003cbc
                int32_t v28 = v26; // 0x100003cc4
                v18 = -1;
                while (v27 < 0 != ((v27 ^ v26) & (v26 ^ v16)) < 0) {
                    // 0x100003ccc
                    function_100003914();
                    v26 = v28 + 1;
                    v27 = v26 - v16;
                    v28 = v26;
                    v18 = -1;
                }
            }
        }
        // 0x100003d4c
        v2 = v18 + 1;
        v3 = (char *)*v1;
        v4 = -v2;
        int32_t v29 = 0; // 0x100003b60
        v6 = v3;
        if (v4 < 0 != (v2 & v4) < 0) {
            v7 = *(int64_t *)((int64_t)v6 + 16);
            while (v7 != 0) {
                // 0x100003b50
                v5 = v29 + 1;
                v8 = v5 - v2;
                v29 = v5;
                if (v8 < 0 == ((v8 ^ v5) & (v5 ^ v2)) < 0) {
                    // break -> 0x100003ba0
                    break;
                }
                v7 = *(int64_t *)((int64_t)(char *)v7 + 16);
            }
            return result;
        }
    }
    // 0x100003bb4
    return result;
}

// Address range: 0x100003d5c - 0x100003e84
int64_t entry_point(void) {
    // 0x100003d5c
    function_100003308();
    int32_t v1 = 0; // 0x100003e30
    for (int32_t i = 0; i < 26; i++) {
        int32_t v2 = v1;
        _bzero(&g3, 0x2b10);
        int32_t v3 = -g1; // 0x100003db8
        if (v3 < 0 != (g1 & v3) < 0) {
            function_10000312c();
            int32_t v4 = 1; // 0x100003df0
            int32_t v5 = v4 - g1; // 0x100003db8
            int32_t v6 = v4; // 0x100003dc0
            while (v5 < 0 != ((v5 ^ v4) & (g1 ^ v4)) < 0) {
                // 0x100003dc8
                function_10000312c();
                v4 = v6 + 1;
                v5 = v4 - g1;
                v6 = v4;
            }
        }
        int64_t v7 = function_100003a5c(); // 0x100003e00
        int32_t * v8 = (int32_t *)(v7 + 16); // 0x100003e0c
        int32_t v9 = *v8; // 0x100003e0c
        int32_t v10 = v9 - v2; // 0x100003e14
        v1 = v2;
        if (v10 != 0 && v10 < 0 == ((v10 ^ v9) & (v9 ^ v2)) < 0) {
            // 0x100003e24
            function_10000367c();
            v1 = *v8;
        }
        // 0x100003e3c
        _free((int64_t *)v7);
    }
    // 0x100003e58
    _printf("longest found: %d\n", 0x2b10);
    return 0;
}

// Address range: 0x100003e84 - 0x100003e90
void function_100003e84(void) {
    // 0x100003e84
    _abort();
}

// Address range: 0x100003e90 - 0x100003e9c
void function_100003e90(int64_t * s, int32_t n) {
    // 0x100003e90
    _bzero(s, n);
}

// Address range: 0x100003e9c - 0x100003ea8
int64_t * function_100003e9c(int32_t nmemb, int32_t size) {
    // 0x100003e9c
    return _calloc(nmemb, size);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(struct _IO_FILE * stream) {
    // 0x100003ea8
    return _fclose(stream);
}

// Address range: 0x100003eb4 - 0x100003ec0
struct _IO_FILE * function_100003eb4(char * filename, char * modes) {
    // 0x100003eb4
    return _fopen(filename, modes);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ec0
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003ecc - 0x100003ed8
void function_100003ecc(int64_t * ptr) {
    // 0x100003ecc
    _free(ptr);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003ed8
    return _fseek(stream, off, whence);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(struct _IO_FILE * stream) {
    // 0x100003ee4
    return _ftell(stream);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(int32_t c) {
    // 0x100003ef0
    return _isspace(c);
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int32_t size) {
    // 0x100003efc
    return _malloc(size);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(int32_t c) {
    // 0x100003f14
    return _putchar(c);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * s) {
    // 0x100003f20
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 24

`
`#include <stdio.h>

#define N 32
#define K 3
#define MAX N * K

typedef struct { int x; int y; } point;

void rot(int n, point *p, int rx, int ry) {
    int t;
    if (!ry) {
        if (rx == 1) {
            p->x = n - 1 - p->x;
            p->y = n - 1 - p->y;
        }
        t = p->x;
        p->x = p->y;
        p->y = t;
    }
}

void d2pt(int n, int d, point *p) {
    int s = 1, t = d, rx, ry;
    p->x = 0;
    p->y = 0;
    while (s < n) {
        rx = 1 & (t / 2);
        ry = 1 & (t ^ rx);
        rot(s, p, rx, ry);
        p->x += s * rx;
        p->y += s * ry;
        t /= 4;
        s *= 2;
    }
}

int main() {
    int d, x, y, cx, cy, px, py;
    char pts[MAX][MAX];
    point curr, prev;
    for (x = 0; x < MAX; ++x)
        for (y = 0; y < MAX; ++y) pts[x][y] = ' ';
    prev.x = prev.y = 0;
    pts[0][0] = '.';
    for (d = 1; d < N * N; ++d) {
        d2pt(N, d, &curr);
        cx = curr.x * K;
        cy = curr.y * K;
        px = prev.x * K;
        py = prev.y * K;
        pts[cx][cy] = '.';
        if (cx == px ) {
            if (py < cy)
                for (y = py + 1; y < cy; ++y) pts[cx][y] = '|';
            else
                for (y = cy + 1; y < py; ++y) pts[cx][y] = '|';
        }
        else {
            if (px < cx)
                for (x = px + 1; x < cx; ++x) pts[x][cy] = '_';
            else
                for (x = cx + 1; x < px; ++x) pts[x][cy] = '_';
        }
        prev = curr;
    }
    for (x = 0; x < MAX; ++x) {
        for (y = 0; y < MAX; ++y) printf("%c", pts[y][x]);
        printf("\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039a8(void);
int64_t function_100003a54(void);
int64_t function_100003b68(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f78(void);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039a8 - 0x100003a54
int64_t function_1000039a8(void) {
    // 0x1000039a8
    int64_t result; // 0x1000039a8
    if ((int32_t)result != 0) {
        // 0x100003a4c
        return result;
    }
    int32_t * v1 = (int32_t *)result; // 0x1000039b0
    int32_t v2 = result;
    int32_t * v3; // 0x1000039a8
    int32_t v4; // 0x1000039a8
    int32_t v5; // 0x1000039a8
    if ((int32_t)result == 1) {
        int32_t v6 = result; // 0x1000039ac
        *v1 = v6 + -1 - v2;
        int32_t * v7 = (int32_t *)(result + 4);
        int32_t v8 = -1 - *v7 + v6; // 0x100003a10
        *v7 = v8;
        v4 = v8;
        v3 = v7;
        int64_t v9; // 0x1000039a8
        v5 = *(int32_t *)&v9;
    } else {
        int32_t * v10 = (int32_t *)(result + 4); // 0x100003a30
        v4 = *v10;
        v3 = v10;
        v5 = v2;
    }
    // 0x100003a20
    *v1 = v4;
    *v3 = v5;
    // 0x100003a4c
    return result;
}

// Address range: 0x100003a54 - 0x100003b4c
int64_t function_100003a54(void) {
    // 0x100003a54
    int64_t v1; // 0x100003a54
    int32_t v2 = v1; // 0x100003a60
    int32_t * v3 = (int32_t *)v1; // 0x100003a68
    *v3 = 0;
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x100003a88
    *v4 = 0;
    int32_t v5 = 1 - v2; // 0x100003a98
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003b40
        int64_t result; // 0x100003a54
        return result;
    }
    int32_t v6 = v1; // 0x100003a54
    int32_t v7 = 1; // 0x100003b34
    int32_t v8 = v6 / 2; // 0x100003ab0
    int64_t result2 = function_1000039a8(); // 0x100003ae4
    int64_t v9; // 0x100003a54
    *v3 = *(int32_t *)&v9 + v8 % 2 * v7;
    *v4 = *v4 + (v8 ^ v6) % 2 * v7;
    v7 *= 2;
    int32_t v10 = v7 - v2; // 0x100003a98
    v6 /= 4;
    while (v10 < 0 != ((v10 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003aa8
        v8 = v6 / 2;
        result2 = function_1000039a8();
        *v3 = *(int32_t *)&v9 + v8 % 2 * v7;
        *v4 = *v4 + (v8 ^ v6) % 2 * v7;
        v7 *= 2;
        v10 = v7 - v2;
        v6 /= 4;
    }
    // 0x100003b40
    return result2;
}

// Address range: 0x100003b4c - 0x100003b68
int64_t entry_point(void) {
    // 0x100003b4c
    return ___chkstk_darwin();
}

// Address range: 0x100003b68 - 0x100003f78
int64_t function_100003b68(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003b68
    int64_t v1; // 0x100003b68
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003b7c
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int64_t v3; // bp-9224, 0x100003b68
    int64_t v4 = &v3;
    for (int64_t i = 0; i < 96; i++) {
        for (int64_t j = 0; j < 96; j++) {
            // 0x100003bbc
            *(char *)(96 * i + v4 + j) = 32;
        }
    }
    // 0x100003c08
    v3 = 46;
    int32_t v5; // 0x100003b68
    int32_t v6 = 3 * v5;
    int32_t v7 = 3 * v5;
    int64_t v8 = 96 * (int64_t)v6 + v4;
    int64_t v9 = v7;
    int64_t v10 = v4 + v9;
    int32_t v11 = v6 + 1;
    int32_t v12 = -v7;
    int32_t v13 = 1 - v7;
    int32_t v14 = v7 + 1;
    char v15 = 1;
    function_100003a54();
    int32_t v16 = 0; // 0x100003c68
    *(char *)(v8 + v9) = 46;
    int32_t v17; // 0x100003b68
    int32_t v18; // 0x100003b68
    int32_t v19; // 0x100003b68
    int32_t v20; // 0x100003b68
    int32_t v21; // 0x100003b68
    int32_t v22; // 0x100003b68
    int32_t v23; // 0x100003b68
    int32_t v24; // 0x100003b68
    int32_t v25; // 0x100003b68
    int32_t v26; // 0x100003da4
    int32_t v27; // 0x100003e30
    int32_t v28; // 0x100003dcc
    int32_t v29; // 0x100003ce8
    int32_t v30; // 0x100003e30
    int32_t v31; // 0x100003dcc
    if (v16 == v6) {
        if (v12 < 0 == (v7 & v12) < 0) {
            // 0x100003d44
            if (v14 < 0) {
                *(char *)(v8 + (int64_t)v14) = 124;
                v19 = v14 + 1;
                v20 = v19;
                while (v19 < 0) {
                    // 0x100003d5c
                    *(char *)(v8 + (int64_t)v20) = 124;
                    v19 = v20 + 1;
                    v20 = v19;
                }
            }
        } else {
            // 0x100003ce0
            v18 = 1;
            if (v13 < 0 != (v13 & v7) < 0) {
                *(char *)(v8 + (int64_t)v18) = 124;
                v17 = v18 + 1;
                v29 = v17 - v7;
                v18 = v17;
                while (v29 < 0 != ((v29 ^ v17) & (v17 ^ v7)) < 0) {
                    // 0x100003cf8
                    *(char *)(v8 + (int64_t)v18) = 124;
                    v17 = v18 + 1;
                    v29 = v17 - v7;
                    v18 = v17;
                }
            }
        }
    } else {
        // 0x100003d9c
        v26 = v16 - v6;
        if (v26 < 0 == ((v26 ^ v16) & (v16 ^ v6)) < 0) {
            // 0x100003e28
            v27 = v11 - v16;
            if (v27 < 0 != ((v27 ^ v11) & (v16 ^ v11)) < 0) {
                *(char *)(96 * (int64_t)v11 + v10) = 95;
                v24 = v11 + 1;
                v30 = v24 - v16;
                v25 = v24;
                while (v30 < 0 != ((v30 ^ v24) & (v24 ^ v16)) < 0) {
                    // 0x100003e40
                    *(char *)(96 * (int64_t)v25 + v10) = 95;
                    v24 = v25 + 1;
                    v30 = v24 - v16;
                    v25 = v24;
                }
            }
        } else {
            // 0x100003dc4
            v22 = v16 + 1;
            v28 = v22 - v6;
            v23 = v22;
            if (v28 < 0 != ((v28 ^ v22) & (v22 ^ v6)) < 0) {
                *(char *)(96 * (int64_t)v23 + v10) = 95;
                v21 = v23 + 1;
                v31 = v21 - v6;
                v23 = v21;
                while (v31 < 0 != ((v31 ^ v21) & (v21 ^ v6)) < 0) {
                    // 0x100003ddc
                    *(char *)(96 * (int64_t)v23 + v10) = 95;
                    v21 = v23 + 1;
                    v31 = v21 - v6;
                    v23 = v21;
                }
            }
        }
    }
    char v32 = v15 + 1; // 0x100003e90
    int32_t v33 = v32; // 0x100003c24
    int32_t v34 = 0; // 0x100003c30
    while ((1023 - v33 & v33) >= 0) {
        // 0x100003c38
        v15 = v32;
        function_100003a54();
        v16 = 0;
        *(char *)(v8 + v9) = 46;
        if (v16 == v6) {
            if (v12 < 0 == (v7 & v12) < 0) {
                // 0x100003d44
                if (v14 < 0) {
                    *(char *)(v8 + (int64_t)v14) = 124;
                    v19 = v14 + 1;
                    v20 = v19;
                    while (v19 < 0) {
                        // 0x100003d5c
                        *(char *)(v8 + (int64_t)v20) = 124;
                        v19 = v20 + 1;
                        v20 = v19;
                    }
                }
            } else {
                // 0x100003ce0
                v18 = 1;
                if (v13 < 0 != (v13 & v7) < 0) {
                    *(char *)(v8 + (int64_t)v18) = 124;
                    v17 = v18 + 1;
                    v29 = v17 - v7;
                    v18 = v17;
                    while (v29 < 0 != ((v29 ^ v17) & (v17 ^ v7)) < 0) {
                        // 0x100003cf8
                        *(char *)(v8 + (int64_t)v18) = 124;
                        v17 = v18 + 1;
                        v29 = v17 - v7;
                        v18 = v17;
                    }
                }
            }
        } else {
            // 0x100003d9c
            v26 = v16 - v6;
            if (v26 < 0 == ((v26 ^ v16) & (v16 ^ v6)) < 0) {
                // 0x100003e28
                v27 = v11 - v16;
                if (v27 < 0 != ((v27 ^ v11) & (v16 ^ v11)) < 0) {
                    *(char *)(96 * (int64_t)v11 + v10) = 95;
                    v24 = v11 + 1;
                    v30 = v24 - v16;
                    v25 = v24;
                    while (v30 < 0 != ((v30 ^ v24) & (v24 ^ v16)) < 0) {
                        // 0x100003e40
                        *(char *)(96 * (int64_t)v25 + v10) = 95;
                        v24 = v25 + 1;
                        v30 = v24 - v16;
                        v25 = v24;
                    }
                }
            } else {
                // 0x100003dc4
                v22 = v16 + 1;
                v28 = v22 - v6;
                v23 = v22;
                if (v28 < 0 != ((v28 ^ v22) & (v22 ^ v6)) < 0) {
                    *(char *)(96 * (int64_t)v23 + v10) = 95;
                    v21 = v23 + 1;
                    v31 = v21 - v6;
                    v23 = v21;
                    while (v31 < 0 != ((v31 ^ v21) & (v21 ^ v6)) < 0) {
                        // 0x100003ddc
                        *(char *)(96 * (int64_t)v23 + v10) = 95;
                        v21 = v23 + 1;
                        v31 = v21 - v6;
                        v23 = v21;
                    }
                }
            }
        }
        // 0x100003e80
        v32 = v15 + 1;
        v33 = v32;
        v34 = 0;
    }
    for (int32_t i = 0; i < 96; i++) {
        // 0x100003ed4
        _printf("%c", v15);
    }
    // 0x100003f1c
    _printf((char *)0x100003f93);
    while (v34 != 95) {
        // continue -> 0x100003ec0
        continue;
    }
    // 0x100003f3c
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003f5c
        ___stack_chk_fail();
    }
    // 0x100003f60
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t function_100003f78(void) {
    // 0x100003f78
    return ___stack_chk_fail();
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include<stdio.h>

int main()
{
	FILE* fp = fopen("TAPE.FILE","w");
	
	fprintf(fp,"This code should be able to write a file to magnetic tape.\n");
	fprintf(fp,"The Wikipedia page on Magnetic tape data storage shows that magnetic tapes are still in use.\n");
	fprintf(fp,"In fact, the latest format, at the time of writing this code is TS1155 released in 2017.\n");
	fprintf(fp,"And since C is already 44, maybe 45, years old in 2017, I am sure someone somewhere did use a C compiler on magnetic tapes.\n");
	fprintf(fp,"If you happen to have one, please try to compile and execute me on that system.\n");
	fprintf(fp,"My creator tested me on an i5 machine with SSD and RAM that couldn't have even been dreamt of by Denis Ritchie.\n");
	fprintf(fp,"Who knows ? Maybe he did foresee today, after all he created something which is still young after 44-45 years and counting...\n");
	fprintf(fp,"EOF");
	
	fclose(fp);
	
	return 0;
}
`,`#include "create-a-file-on-magnetic-tape.h"



undefined4 entry(void)

{
  FILE *pFVar1;
  
  pFVar1 = _fopen("TAPE.FILE","w");
  _fprintf(pFVar1,"This code should be able to write a file to magnetic tape.\n");
  _fprintf(pFVar1,
           "The Wikipedia page on Magnetic tape data storage shows that magnetic tapes are still in use.\n"
          );
  _fprintf(pFVar1,
           "In fact, the latest format, at the time of writing this code is TS1155 released in 2017.\n"
          );
  _fprintf(pFVar1,
           "And since C is already 44, maybe 45, years old in 2017, I am sure someone somewhere did use a C compiler on magnetic tapes.\n"
          );
  _fprintf(pFVar1,
           "If you happen to have one, please try to compile and execute me on that system.\n");
  _fprintf(pFVar1,
           "My creator tested me on an i5 machine with SSD and RAM that couldn\'t have even been dreamt of by Denis Ritchie.\n"
          );
  _fprintf(pFVar1,
           "Who knows ? Maybe he did foresee today, after all he created something which is still young after 44-45 years and counting...\n"
          );
  _fprintf(pFVar1,"EOF");
  _fclose(pFVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003cc8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003cd4. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004008)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ce0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#define PRIME_COUNT 100000
int64_t PRIMES[PRIME_COUNT];
size_t primeSize = 0;

bool isPrime(int n) {
    size_t i = 0;

    for (i = 0; i < primeSize; i++) {
        int64_t p = PRIMES[i];
        if (n == p) {
            return true;
        }
        if (n % p == 0) {
            return false;
        }
        if (p * p > n) {
            break;
        }
    }

    return true;
}

void initialize() {
    int i;

    PRIMES[primeSize++] = 2;
    PRIMES[primeSize++] = 3;
    PRIMES[primeSize++] = 5;
    PRIMES[primeSize++] = 7;
    PRIMES[primeSize++] = 11;
    PRIMES[primeSize++] = 13;
    PRIMES[primeSize++] = 17;
    PRIMES[primeSize++] = 19;

    for (i = 21; primeSize < PRIME_COUNT;) {
        if (isPrime(i)) {
            PRIMES[primeSize++] = i;
        }
        i += 2;

        if (primeSize < PRIME_COUNT && isPrime(i)) {
            PRIMES[primeSize++] = i;
        }
        i += 2;
    }
}

void diff1(size_t diff) {
    int64_t pm0, pm1;
    int64_t fg1 = 0, fg2 = 0, lg1 = 0, lg2 = 0;
    size_t pos, count = 0;

    if (diff == 0) {
        return;
    }

    pm0 = PRIMES[0];
    for (pos = 1; pos < PRIME_COUNT; pos++) {
        pm1 = pm0;
        pm0 = PRIMES[pos];
        if (pm0 > 1000000) {
            break;
        }
        if (pm0 - pm1 == diff) {
            count++;
            if (fg1 == 0) {
                fg1 = pm1;
                fg2 = pm0;
            }
            lg1 = pm1;
            lg2 = pm0;
        }
    }

    printf("%ld|%d|%lld %lld|%lld %lld|\n", diff, count, fg1, fg2, lg1, lg2);
}

void diff2(size_t d0, size_t d1) {
    int64_t pm0, pm1, pm2;
    int64_t fg1 = 0, fg2, fg3, lg1, lg2, lg3;
    size_t pos, count = 0;

    if (d0 == 0 || d1 == 0) {
        return;
    }

    pm1 = PRIMES[0];
    pm0 = PRIMES[1];
    for (pos = 2; pos < PRIME_COUNT; pos++) {
        pm2 = pm1;
        pm1 = pm0;
        pm0 = PRIMES[pos];
        if (pm0 > 1000000) {
            break;
        }
        if (pm1 - pm2 == d0 && pm0 - pm1 == d1) {
            count++;
            if (fg1 == 0) {
                fg1 = pm2;
                fg2 = pm1;
                fg3 = pm0;
            }
            lg1 = pm2;
            lg2 = pm1;
            lg3 = pm0;
        }
    }

    printf("%d %d|%d|%lld %lld %lld|%lld %lld %lld|\n", d0, d1, count, fg1, fg2, fg3, lg1, lg2, lg3);
}

void diff3(size_t d0, size_t d1, size_t d2) {
    int64_t pm0, pm1, pm2, pm3;
    int64_t fg1 = 0, fg2, fg3, fg4, lg1, lg2, lg3, lg4;
    size_t pos, count = 0;

    if (d0 == 0 || d1 == 0 || d2 == 0) {
        return;
    }

    pm2 = PRIMES[0];
    pm1 = PRIMES[1];
    pm0 = PRIMES[2];
    for (pos = 3; pos < PRIME_COUNT; pos++) {
        pm3 = pm2;
        pm2 = pm1;
        pm1 = pm0;
        pm0 = PRIMES[pos];
        if (pm0 > 1000000) {
            break;
        }
        if (pm2 - pm3 == d0 && pm1 - pm2 == d1 && pm0 - pm1 == d2) {
            count++;
            if (fg1 == 0) {
                fg1 = pm3;
                fg2 = pm2;
                fg3 = pm1;
                fg4 = pm0;
            }
            lg1 = pm3;
            lg2 = pm2;
            lg3 = pm1;
            lg4 = pm0;
        }
    }

    printf("%d %d %d|%d|%lld %lld %lld %lld|%lld %lld %lld %lld|\n", d0, d1, d2, count, fg1, fg2, fg3, fg4, lg1, lg2, lg3, lg4);
}

int main() {
    initialize();

    printf("differences|count|first group|last group\n");

    diff1(2);
    diff1(1);

    diff2(2, 2);
    diff2(2, 4);
    diff2(4, 2);

    diff3(6, 4, 2);

    return 0;
}
`,`#include "successive-prime-differences.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined _isPrime(int param_1)

{
  long lVar1;
  long lVar2;
  ulong local_10;
  
  local_10 = 0;
  while( true ) {
    if (__primeSize <= local_10) {
      return 1;
    }
    lVar2 = *(long *)(&_PRIMES + local_10 * 8);
    if (param_1 == lVar2) break;
    lVar1 = 0;
    if (lVar2 != 0) {
      lVar1 = (long)param_1 / lVar2;
    }
    if ((long)param_1 == lVar1 * lVar2) {
      return 0;
    }
    if (lVar2 * lVar2 - (long)param_1 != 0 && (long)param_1 <= lVar2 * lVar2) {
      return 1;
    }
    local_10 = local_10 + 1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _initialize(void)

{
  long lVar1;
  ulong uVar2;
  int local_14;
  
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 2;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 3;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 5;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 7;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 0xb;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 0xd;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 0x11;
  lVar1 = __primeSize * 8;
  __primeSize = __primeSize + 1;
  *(undefined8 *)(&_PRIMES + lVar1) = 0x13;
  local_14 = 0x15;
  while (__primeSize < 100000) {
    uVar2 = _isPrime(local_14);
    if ((uVar2 & 1) != 0) {
      lVar1 = __primeSize * 8;
      __primeSize = __primeSize + 1;
      *(long *)(&_PRIMES + lVar1) = (long)local_14;
    }
    if ((__primeSize < 100000) && (uVar2 = _isPrime(local_14 + 2), (uVar2 & 1) != 0)) {
      lVar1 = __primeSize * 8;
      __primeSize = __primeSize + 1;
      *(long *)(&_PRIMES + lVar1) = (long)(local_14 + 2);
    }
    local_14 = local_14 + 4;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _diff1(long param_1)

{
  int iVar1;
  long lVar2;
  ulong local_50;
  long local_30;
  long local_20;
  
  local_30 = 0;
  if (param_1 == 0) {
    iVar1 = 0;
  }
  else {
    local_20 = __PRIMES;
    for (local_50 = 1;
        (local_50 < 100000 && (lVar2 = *(long *)(&_PRIMES + local_50 * 8), lVar2 < 0xf4241));
        local_50 = local_50 + 1) {
      if ((lVar2 - local_20 == param_1) && (local_30 == 0)) {
        local_30 = local_20;
      }
      local_20 = lVar2;
    }
    iVar1 = _printf("%ld|%d|%lld %lld|%lld %lld|\n");
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong _diff2(ulong param_1,long param_2)

{
  long lVar1;
  uint uVar2;
  long lVar3;
  ulong local_d0;
  long local_c8;
  long local_c0;
  long local_b8;
  long local_b0;
  long local_a8;
  long local_a0;
  long local_98;
  long local_90;
  undefined *local_80;
  long local_78;
  ulong local_70;
  long local_68;
  long local_60;
  long local_58;
  long local_50;
  long local_48;
  long local_40;
  long local_38;
  long local_30;
  long local_28;
  long local_20;
  ulong local_18;
  
  local_80 = (undefined *)&local_d0;
  local_40 = 0;
  local_78 = 0;
  if ((param_1 != 0) && (param_2 != 0)) {
    local_30 = __PRIMES;
    local_28 = _DAT_100008010;
    for (local_70 = 2; lVar1 = local_30, lVar3 = local_28, local_70 < 100000;
        local_70 = local_70 + 1) {
      local_38 = local_30;
      local_30 = local_28;
      lVar3 = *(long *)(&_PRIMES + local_70 * 8);
      if (1000000 < lVar3) break;
      if ((local_28 - lVar1 == param_1) && (lVar3 - local_28 == param_2)) {
        local_78 = local_78 + 1;
        if (local_40 == 0) {
          local_40 = lVar1;
          local_48 = local_28;
          local_50 = lVar3;
        }
        local_58 = lVar1;
        local_60 = local_28;
        local_68 = lVar3;
      }
      local_28 = lVar3;
    }
    local_28 = lVar3;
    local_c0 = local_78;
    local_b8 = local_40;
    local_b0 = local_48;
    local_a8 = local_50;
    local_a0 = local_58;
    local_98 = local_60;
    local_90 = local_68;
    local_d0 = param_1;
    local_c8 = param_2;
    local_20 = param_2;
    local_18 = param_1;
    uVar2 = _printf("%d %d|%d|%lld %lld %lld|%lld %lld %lld|\n");
    param_1 = (ulong)uVar2;
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong _diff3(ulong param_1,long param_2,long param_3)

{
  long lVar1;
  long lVar2;
  uint uVar3;
  long lVar4;
  ulong local_110;
  long local_108;
  long local_100;
  long local_f8;
  long local_f0;
  long local_e8;
  long local_e0;
  long local_d8;
  long local_d0;
  long local_c8;
  long local_c0;
  long local_b8;
  undefined *local_b0;
  long local_a8;
  ulong local_a0;
  long local_98;
  long local_90;
  long local_88;
  long local_80;
  long local_78;
  long local_70;
  long local_68;
  long local_60;
  long local_58;
  long local_50;
  long local_48;
  long local_40;
  long local_38;
  long local_30;
  ulong local_28;
  
  local_b0 = (undefined *)&local_110;
  local_60 = 0;
  local_a8 = 0;
  if (((param_1 != 0) && (param_2 != 0)) && (param_3 != 0)) {
    local_50 = __PRIMES;
    local_48 = _DAT_100008010;
    local_40 = _DAT_100008018;
    for (local_a0 = 3; lVar2 = local_48, lVar1 = local_50, lVar4 = local_40, local_a0 < 100000;
        local_a0 = local_a0 + 1) {
      local_58 = local_50;
      local_50 = local_48;
      local_48 = local_40;
      lVar4 = *(long *)(&_PRIMES + local_a0 * 8);
      if (1000000 < lVar4) break;
      if (((lVar2 - lVar1 == param_1) && (local_40 - lVar2 == param_2)) &&
         (lVar4 - local_40 == param_3)) {
        local_a8 = local_a8 + 1;
        if (local_60 == 0) {
          local_60 = lVar1;
          local_68 = lVar2;
          local_70 = local_40;
          local_78 = lVar4;
        }
        local_80 = lVar1;
        local_88 = lVar2;
        local_90 = local_40;
        local_98 = lVar4;
      }
      local_40 = lVar4;
    }
    local_40 = lVar4;
    local_f8 = local_a8;
    local_f0 = local_60;
    local_e8 = local_68;
    local_e0 = local_70;
    local_d8 = local_78;
    local_d0 = local_80;
    local_c8 = local_88;
    local_c0 = local_90;
    local_b8 = local_98;
    local_110 = param_1;
    local_108 = param_2;
    local_100 = param_3;
    local_38 = param_3;
    local_30 = param_2;
    local_28 = param_1;
    uVar3 = _printf("%d %d %d|%d|%lld %lld %lld %lld|%lld %lld %lld %lld|\n");
    param_1 = (ulong)uVar3;
  }
  return param_1;
}



undefined4 entry(void)

{
  _initialize();
  _printf("differences|count|first group|last group\n");
  _diff1();
  _diff1(1);
  _diff2(2);
  _diff2(2);
  _diff2(4,2);
  _diff3(6,4,2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
        unsigned int i = 0;
        do { printf("%o\n", i++); } while(i);
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f30 - 0x100003f98
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003f44
    v1++;
    int64_t v2; // 0x100003f30
    _printf("%o\n", (int32_t)v2);
    while (v1 != 0) {
        // 0x100003f48
        v1++;
        _printf("%o\n", (int32_t)v2);
    }
    // 0x100003f88
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <regex.h>
#include <string.h>

int main()
{
   regex_t preg;
   regmatch_t substmatch[1];
   const char *tp = "string$";
   const char *t1 = "this is a matching string";
   const char *t2 = "this is not a matching string!";
   const char *ss = "istyfied";

   regcomp(&preg, "string$", REG_EXTENDED);
   printf("'%s' %smatched with '%s'\n", t1,
                                        (regexec(&preg, t1, 0, NULL, 0)==0) ? "" : "did not ", tp);
   printf("'%s' %smatched with '%s'\n", t2,
                                        (regexec(&preg, t2, 0, NULL, 0)==0) ? "" : "did not ", tp);
   regfree(&preg);
   /* change "a[a-z]+" into "istifyed"?*/
   regcomp(&preg, "a[a-z]+", REG_EXTENDED);
   if ( regexec(&preg, t1, 1, substmatch, 0) == 0 )
   {
      //fprintf(stderr, "%d, %d\n", substmatch[0].rm_so, substmatch[0].rm_eo);
      char *ns = malloc(substmatch[0].rm_so + 1 + strlen(ss) +
                        (strlen(t1) - substmatch[0].rm_eo) + 2);
      memcpy(ns, t1, substmatch[0].rm_so+1);
      memcpy(&ns[substmatch[0].rm_so], ss, strlen(ss));
      memcpy(&ns[substmatch[0].rm_so+strlen(ss)], &t1[substmatch[0].rm_eo],
                strlen(&t1[substmatch[0].rm_eo]));
      ns[ substmatch[0].rm_so + strlen(ss) +
          strlen(&t1[substmatch[0].rm_eo]) ] = 0;
      printf("mod string: '%s'\n", ns);
      free(ns);
   } else {
      printf("the string '%s' is the same: no matching!\n", t1);
   }
   regfree(&preg);

   return 0;
}
`,`#include "regular-expressions-1.h"



undefined8 entry(void)

{
  long lVar1;
  char *pcVar2;
  int iVar3;
  size_t sVar4;
  size_t sVar5;
  void *pvVar6;
  undefined auStack_60 [36];
  undefined4 local_3c;
  long local_38;
  long local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_3c = 0;
  _regcomp();
  _regexec(auStack_60,"this is a matching string",0,0,0);
  _printf("\'%s\' %smatched with \'%s\'\n");
  _regexec(auStack_60,"this is not a matching string!",0,0,0);
  _printf("\'%s\' %smatched with \'%s\'\n");
  _regfree(auStack_60);
  _regcomp(auStack_60,"a[a-z]+",1);
  iVar3 = _regexec(auStack_60,"this is a matching string",1,&local_38,0);
  lVar1 = local_38;
  if (iVar3 == 0) {
    sVar4 = _strlen("istyfied");
    sVar5 = _strlen("this is a matching string");
    pvVar6 = _malloc(lVar1 + sVar4 + (sVar5 - local_30) + 3);
    ___memcpy_chk(pvVar6,"this is a matching string",local_38 + 1);
    lVar1 = (long)pvVar6 + local_38;
    sVar4 = _strlen("istyfied");
    ___memcpy_chk(lVar1,"istyfied",sVar4,0xffffffffffffffff);
    lVar1 = local_38;
    sVar4 = _strlen("istyfied");
    pcVar2 = "this is a matching string" + local_30;
    sVar5 = _strlen("this is a matching string" + local_30);
    ___memcpy_chk((long)pvVar6 + lVar1 + sVar4,pcVar2,sVar5,0xffffffffffffffff);
    sVar4 = _strlen("istyfied");
    sVar5 = _strlen("this is a matching string" + local_30);
    *(undefined *)((long)pvVar6 + local_38 + sVar4 + sVar5) = 0;
    _printf("mod string: \'%s\'\n");
    _free(pvVar6);
  }
  else {
    _printf("the string \'%s\' is the same: no matching!\n");
  }
  _regfree(auStack_60);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



void _regcomp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__regcomp_100004030)();
  return;
}



void _regexec(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__regexec_100004038)();
  return;
}



void _regfree(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__regfree_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004048)();
  return sVar1;
}


`
`// return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
static unsigned multiplication_modulo(unsigned a, unsigned b, const unsigned mod) {
	unsigned res = 0, tmp;
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (tmp = b) >= mod - b ? tmp -= mod : 0, b += tmp);
	return res % mod;
}

// return (n ^ exp) % mod
static unsigned mod_pow(unsigned n, unsigned exp, const unsigned mod) {
	unsigned res = 1;
	for (n %= mod; exp; exp & 1 ? res = multiplication_modulo(res, n, mod) : 0, n = multiplication_modulo(n, n, mod), exp >>= 1);
	return res;
}

static unsigned tonelli_shanks_1(const unsigned n, const unsigned mod) {
	// return root such that (root * root) % mod congruent to n % mod.
	// return 0 if no solution to the congruence exists.
	// mod is assumed odd prime.
	const unsigned a = n % mod;
	unsigned res, b, c, d, e, f, g, h;
	if (mod_pow(a, (mod - 1) >> 1, mod) != 1)
		res = 0;
	else
		switch (mod & 7) {
			case 3 : case 7 :
				res = mod_pow(a, (mod + 1) >> 2, mod);
				break;
			case 5 :
				res = mod_pow(a, (mod + 3) >> 3, mod);
				if (multiplication_modulo(res, res, mod) != a){
					b = mod_pow(2, (mod - 1) >> 2, mod);
					res = multiplication_modulo(res, b, mod);
				}
				break;
			default :
				if (a == 1)
					res = 1;
				else {
					for (c = mod - 1, d = 2; d < mod && mod_pow(d, c >> 1, mod) != c; ++d);
					for (e = 0; !(c & 1); ++e, c >>= 1);
					f = mod_pow(a, c, mod);
					b = mod_pow(d, c, mod);
					for (h = 0, g = 0; h < e; h++) {
						d = mod_pow(b, g, mod);
						d = multiplication_modulo(d, f, mod);
						d = mod_pow(d, 1 << (e - 1 - h), mod);
						if (d == mod - 1)
							g += 1 << h;
					}
					f = mod_pow(a, (c + 1) >> 1, mod);
					b = mod_pow(b, g >> 1, mod);
					res = multiplication_modulo(f, b, mod);
				}
		}
	return res;
}

// return root such that (root * root) % mod congruent to n % mod.
// return 0 (the default value of a) if no solution to the congruence exists.
static unsigned tonelli_shanks_2(unsigned n, const unsigned mod) {
	unsigned a = 0, b = mod - 1, c, d = b, e = 0, f = 2, g;
	if (mod_pow(n, b >> 1, mod) == 1) {
		for (; !(d & 1); ++e, d >>= 1);
		if (e == 1)
			a = mod_pow(n, (mod + 1) >> 2, mod);
		else {
			for (; b != mod_pow(f, b >> 1, mod); ++f);
			for (b = mod_pow(f, d, mod), a = mod_pow(n, (d + 1) >> 1, mod), c = mod_pow(n, d, mod), g = e; c != 1; g = d) {
				for (d = 0, e = c, --g; e != 1 && d < g; ++d)
					e = multiplication_modulo(e, e, mod);
				for (f = b, n = g - d; n--;)
					f = multiplication_modulo(f, f, mod);
				a = multiplication_modulo(a, f, mod);
				b = multiplication_modulo(f, f, mod);
				c = multiplication_modulo(c, b, mod);
			}
		}
	}
	return a;
}

#include <assert.h>
int main() {
	unsigned n, mod, root ; /* root_2 = mod - root */

	n = 27875, mod = 26371, root = tonelli_shanks_1(n, mod);
	assert(root == 14320); // 14320 * 14320  mod  26371 = 1504     and   1504 =    27875 mod 26371

	n = 1111111111, mod = 1111111121, root = tonelli_shanks_1(n, mod);
	assert(root == 88664850);

	n = 5258, mod = 3851, root = tonelli_shanks_1(n, mod);
	assert(root == 0); // no solution to the congruence exists.
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a0c(void);
int64_t function_100003d6c(void);
int64_t function_100003e24(void);
int64_t function_100003f48(char * a1, char * a2, int64_t a3, char * a4);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);

// ------------------------ Functions -------------------------

// Address range: 0x1000038ac - 0x100003a0c
int64_t entry_point(void) {
    // 0x1000038ac
    if ((int32_t)function_100003a0c() != 0x37f0) {
        // 0x100003900
        ___assert_rtn("main", "tonelli-shanks-algorithm-2.c", 87, "root == 14320");
    }
    // 0x100003924
    if ((int32_t)function_100003a0c() != 0x548eb12) {
        // 0x100003974
        ___assert_rtn("main", "tonelli-shanks-algorithm-2.c", 90, "root == 88664850");
    }
    // 0x100003998
    if ((int32_t)function_100003a0c() != 0) {
        // 0x1000039d8
        ___assert_rtn("main", "tonelli-shanks-algorithm-2.c", 93, "root == 0");
    }
    // 0x1000039fc
    return 0;
}

// Address range: 0x100003a0c - 0x100003d6c
int64_t function_100003a0c(void) {
    // 0x100003a0c
    if ((int32_t)function_100003d6c() != 1) {
        // 0x100003d5c
        return 0;
    }
    // 0x100003a68
    int64_t v1; // 0x100003a0c
    uint32_t v2 = (int32_t)v1; // 0x100003a1c
    uint32_t v3 = (int32_t)v1 % v2;
    switch (v2 % 8) {
        case 3: {
        }
        case 7: {
            // 0x100003d5c
            return function_100003d6c() & 0xffffffff;
        }
        case 5: {
            int64_t v4 = function_100003d6c(); // 0x100003b04
            if (v3 != (int32_t)function_100003e24()) {
                // 0x100003b0c
                function_100003d6c();
                v4 = function_100003e24();
            }
            // 0x100003d5c
            return v4 & 0xffffffff;
        }
    }
    // 0x100003b44
    if (v3 == 1) {
        // 0x100003d5c
        return 1;
    }
    int32_t v5 = v2 - 1; // 0x100003b68
    int32_t v6 = 2; // 0x100003b78
    while (v6 < v2) {
        // 0x100003bc4
        v6++;
        if (v5 == (int32_t)function_100003d6c()) {
            // break -> 0x100003bec
            break;
        }
    }
    int32_t v7 = 0; // 0x100003bf8
    int32_t v8 = 0; // 0x100003bf8
    if (v5 % 2 == 0) {
        uint32_t v9 = v5;
        v7++;
        int32_t v10 = v9 / 2; // 0x100003bf8
        v8 = v7;
        while ((v9 & 2) == 0) {
            // 0x100003c04
            v9 = v10;
            v7++;
            v10 = v9 / 2;
            v8 = v7;
        }
    }
    // 0x100003c20
    function_100003d6c();
    function_100003d6c();
    function_100003d6c();
    int32_t v11 = 0; // 0x100003c64
    if (v8 != 0) {
        function_100003e24();
        function_100003d6c();
        v11++;
        function_100003d6c();
        while (v11 != v8) {
            // 0x100003c6c
            function_100003e24();
            function_100003d6c();
            v11++;
            function_100003d6c();
        }
    }
    // 0x100003d08
    function_100003d6c();
    // 0x100003d5c
    return function_100003e24() & 0xffffffff;
}

// Address range: 0x100003d6c - 0x100003e24
int64_t function_100003d6c(void) {
    // 0x100003d6c
    int64_t v1; // 0x100003d6c
    int32_t v2 = v1; // 0x100003d7c
    if (v2 == 0) {
        // 0x100003e14
        return 1;
    }
    uint32_t v3 = v2;
    int32_t v4 = 1; // 0x100003dcc
    if (v3 % 2 != 0) {
        // 0x100003dd4
        v4 = function_100003e24();
    }
    int32_t result = v4;
    function_100003e24();
    int32_t v5 = v3 / 2; // 0x100003db4
    while (v3 >= 2) {
        // 0x100003dc0
        v3 = v5;
        v4 = result;
        if (v3 % 2 != 0) {
            // 0x100003dd4
            v4 = function_100003e24();
        }
        // 0x100003df0
        result = v4;
        function_100003e24();
        v5 = v3 / 2;
    }
    // 0x100003e14
    return result;
}

// Address range: 0x100003e24 - 0x100003f48
int64_t function_100003e24(void) {
    // 0x100003e24
    int64_t v1; // 0x100003e24
    int32_t v2 = v1; // 0x100003e28
    uint32_t v3 = (int32_t)v1; // 0x100003e30
    if (v2 == 0) {
        // 0x100003f2c
        return 0;
    }
    int32_t v4 = -v3;
    int32_t v5 = 0;
    uint32_t v6 = v2;
    uint32_t v7 = (int32_t)v1 % v3;
    int32_t v8 = v5; // 0x100003e78
    int32_t v9; // 0x100003e24
    if (v6 % 2 != 0) {
        // 0x100003e80
        v9 = v7 < v3 - v5 ? 0 : v4;
        v8 = v5 + v7 + v9;
    }
    int32_t v10 = v8;
    int32_t v11 = (v7 < v3 - v7 ? 0 : v4) + 2 * v7; // 0x100003e60
    int32_t v12 = v6 / 2; // 0x100003e60
    while (v6 >= 2) {
        // 0x100003e6c
        v5 = v10;
        v6 = v12;
        v7 = v11;
        v8 = v5;
        if (v6 % 2 != 0) {
            // 0x100003e80
            v9 = v7 < v3 - v5 ? 0 : v4;
            v8 = v5 + v7 + v9;
        }
        // 0x100003ed0
        v10 = v8;
        v11 = (v7 < v3 - v7 ? 0 : v4) + 2 * v7;
        v12 = v6 / 2;
    }
    // 0x100003f2c
    return v10 % v3;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003f48
    return ___assert_rtn(a1, a2, a3, a4);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include<stdio.h>
#define de 0
#define pe 1
#define ab 2

int main(){
	int sum = 0, i, j;
	int try_max = 0;
	//1 is deficient by default and can add it deficient list
	int   count_list[3] = {1,0,0};
	for(i=2; i <= 20000; i++){
		//Set maximum to check for proper division
		try_max = i/2;
		//1 is in all proper division number
		sum = 1;
		for(j=2; j<try_max; j++){
			//Check for proper division
			if (i % j)
				continue; //Pass if not proper division
			//Set new maximum for divisibility check
			try_max = i/j;
			//Add j to sum
			sum += j;
			if (j != try_max)
				sum += try_max;
		}
		//Categorize summation
		if (sum < i){
			count_list[de]++;
			continue;
		}
		if (sum > i){
			count_list[ab]++;
			continue;
		}
		count_list[pe]++;
	}
	printf("\nThere are %d deficient," ,count_list[de]);
	printf(" %d perfect," ,count_list[pe]);
	printf(" %d abundant numbers between 1 and 20000.\n" ,count_list[ab]);
return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f30(int64_t a1);
int32_t function_100003f3c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d14 - 0x100003f30
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d28
    int32_t v2 = 2;
    int32_t v3 = v2 / 2; // 0x100003d80
    int32_t v4 = 2 - v3; // 0x100003da0
    int32_t v5 = v3; // 0x100003da8
    int32_t v6; // 0x100003d14
    int32_t v7; // 0x100003d14
    int32_t v8; // 0x100003e2c
    int32_t v9; // 0x100003da0
    if (v4 < 0 != (v4 & v3) < 0) {
        v7 = 2;
        v6 = v5;
        if (v2 % v7 == 0) {
            // 0x100003dd8
            v6 = v2 / v7;
        }
        // 0x100003e28
        v8 = v7 + 1;
        v9 = v8 - v6;
        v5 = v6;
        while (v9 < 0 != ((v9 ^ v8) & (v6 ^ v8)) < 0) {
            // 0x100003db0
            v7 = v8;
            v6 = v5;
            if (v2 % v7 == 0) {
                // 0x100003dd8
                v6 = v2 / v7;
            }
            // 0x100003e28
            v8 = v7 + 1;
            v9 = v8 - v6;
            v5 = v6;
        }
    }
    int32_t v10 = v2 + 1; // 0x100003e9c
    while (v2 == 0x4e1f || v2 < 0x4e1f != (0x4e1e - v2 & v10) < 0) {
        // 0x100003d78
        v2 = v10;
        v3 = v2 / 2;
        v4 = 2 - v3;
        v5 = v3;
        if (v4 < 0 != (v4 & v3) < 0) {
            v7 = 2;
            v6 = v5;
            if (v2 % v7 == 0) {
                // 0x100003dd8
                v6 = v2 / v7;
            }
            // 0x100003e28
            v8 = v7 + 1;
            v9 = v8 - v6;
            v5 = v6;
            while (v9 < 0 != ((v9 ^ v8) & (v6 ^ v8)) < 0) {
                // 0x100003db0
                v7 = v8;
                v6 = v5;
                if (v2 % v7 == 0) {
                    // 0x100003dd8
                    v6 = v2 / v7;
                }
                // 0x100003e28
                v8 = v7 + 1;
                v9 = v8 - v6;
                v5 = v6;
            }
        }
        // 0x100003e98
        v10 = v2 + 1;
    }
    // 0x100003ea8
    int64_t v11; // 0x100003d14
    _printf("\nThere are %d deficient,", v11);
    _printf(" %d perfect,", v11);
    int32_t v12 = _printf(" %d abundant numbers between 1 and 20000.\n", v11); // 0x100003ef8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f1c
        ___stack_chk_fail((int64_t)v12);
    }
    // 0x100003f20
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(int64_t a1) {
    // 0x100003f30
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <math.h>

static void
using_float ()                  /* C2x does not require "void". */
{
  int count = 0;
  float phi0 = 1.0f;
  float phi1;
  float difference;
  do
    {
      phi1 = 1.0f + (1.0f / phi0);
      difference = fabsf (phi1 - phi0);
      phi0 = phi1;
      count += 1;
    }
  while (1.0e-5f < difference);

  printf ("Using type float --\n");
  printf ("Result: %f after %d iterations\n", phi1, count);
  printf ("The error is approximately %f\n",
          phi1 - (0.5f * (1.0f + sqrtf (5.0f))));
}

static void
using_double ()                 /* C2x does not require "void". */
{
  int count = 0;
  double phi0 = 1.0;
  double phi1;
  double difference;
  do
    {
      phi1 = 1.0 + (1.0 / phi0);
      difference = fabs (phi1 - phi0);
      phi0 = phi1;
      count += 1;
    }
  while (1.0e-5 < difference);

  printf ("Using type double --\n");
  printf ("Result: %f after %d iterations\n", phi1, count);
  printf ("The error is approximately %f\n",
          phi1 - (0.5 * (1.0 + sqrt (5.0))));
}

int
main ()                         /* C2x does not require "void". */
{
  using_float ();
  printf ("\n");
  using_double ();
}
`,`#include "golden-ratio-convergence.h"



undefined8 entry(void)

{
  int iVar1;
  
  FUN_100003d58();
  iVar1 = _printf("\n");
  FUN_100003e44(iVar1);
  return 0;
}



int FUN_100003d58(void)

{
  float fVar1;
  int iVar2;
  float fVar3;
  float local_18;
  
  local_18 = 1.0;
  do {
    fVar3 = 1.0 / local_18 + 1.0;
    fVar1 = fVar3 - local_18;
    local_18 = fVar3;
  } while (1e-05 < ABS(fVar1));
  _printf("Using type float --\n");
  _printf("Result: %f after %d iterations\n");
  NEON_fmadd(0xbf000000,0x404f1bbd,fVar3);
  iVar2 = _printf("The error is approximately %f\n");
  return iVar2;
}



int FUN_100003e44(void)

{
  double dVar1;
  int iVar2;
  double dVar3;
  double local_20;
  
  local_20 = 1.0;
  do {
    dVar3 = 1.0 / local_20 + 1.0;
    dVar1 = dVar3 - local_20;
    local_20 = dVar3;
  } while (1e-05 < ABS(dVar1));
  _printf("Using type double --\n");
  _printf("Result: %f after %d iterations\n");
  NEON_fmadd(0xbfe0000000000000,0x4009e3779b97f4a8,dVar3);
  iVar2 = _printf("The error is approximately %f\n");
  return iVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

enum { S_NONE, S_LIST, S_STRING, S_SYMBOL };

typedef struct {
	int type;
	size_t len;
	void *buf;
} s_expr, *expr;

void whine(const char *s)
{
	fprintf(stderr, "parse error before ==>%.10s\n", s);
}

expr parse_string(const char *s, char **e)
{
	expr ex = calloc(sizeof(s_expr), 1);
	char buf[256] = {0};
	int i = 0;

	while (*s) {
		if (i >= 256) {
			fprintf(stderr, "string too long:\n");
			whine(s);
			goto fail;
		}
		switch (*s) {
		case '\\':
			switch (*++s) {
			case '\\':
			case '"':	buf[i++] = *s++;
					continue;

			default:	whine(s);
					goto fail;
			}
		case '"':	goto success;
		default:	buf[i++] = *s++;
		}
	}
fail:
	free(ex);
	return 0;

success:
	*(const char **)e = s + 1;
	ex->type = S_STRING;
	ex->buf = strdup(buf);
	ex->len = strlen(buf);
	return ex;
}

expr parse_symbol(const char *s, char **e)
{
	expr ex = calloc(sizeof(s_expr), 1);
	char buf[256] = {0};
	int i = 0;

	while (*s) {
		if (i >= 256) {
			fprintf(stderr, "symbol too long:\n");
			whine(s);
			goto fail;
		}
		if (isspace(*s)) goto success;
		if (*s == ')' || *s == '(') {
			s--;
			goto success;
		}

		switch (*s) {
		case '\\':
			switch (*++s) {
			case '\\': case '"': case '(': case ')':
					buf[i++] = *s++;
					continue;
			default:	whine(s);
					goto fail;
			}
		case '"':	whine(s);
				goto success;
		default:	buf[i++] = *s++;
		}
	}
fail:
	free(ex);
	return 0;

success:
	*(const char **)e = s + 1;
	ex->type = S_SYMBOL;
	ex->buf = strdup(buf);
	ex->len = strlen(buf);
	return ex;
}

void append(expr list, expr ele)
{
	list->buf = realloc(list->buf, sizeof(expr) * ++list->len);
	((expr*)(list->buf))[list->len - 1] = ele;
}

expr parse_list(const char *s, char **e)
{
	expr ex = calloc(sizeof(s_expr), 1), chld;
	char *next;

	ex->len = 0;

	while (*s) {
		if (isspace(*s)) {
			s++;
			continue;
		}

		switch (*s) {
		case '"':
			chld = parse_string(s+1, &next);
			if (!chld) goto fail;
			append(ex, chld);
			s = next;
			continue;
		case '(':
			chld = parse_list(s+1, &next);
			if (!chld) goto fail;
			append(ex, chld);
			s = next;
			continue;
		case ')':
			goto success;

		default:
			chld = parse_symbol(s, &next);
			if (!chld) goto fail;
			append(ex, chld);
			s = next;
			continue;
		}
	}

fail:
	whine(s);
	free(ex);
	return 0;

success:
	*(const char **)e = s+1;
	ex->type = S_LIST;
	return ex;
}

expr parse_term(const char *s, char **e)
{
	while (*s) {
		if (isspace(*s)) {
			s++;
			continue;
		}
		switch(*s) {
		case '(':
			return parse_list(s+1, e);
		case '"':
			return parse_string(s+1, e);
		default:
			return parse_symbol(s+1, e);
		}
	}
	return 0;
}

void print_expr(expr e, int depth)
{
#define sep() for(i = 0; i < depth; i++) printf("    ")
	int i;
	if (!e) return;


	switch(e->type) {
	case S_LIST:
		sep();
		puts("(");
		for (i = 0; i < e->len; i++)
			print_expr(((expr*)e->buf)[i], depth + 1);
		sep();
		puts(")");
		return;
	case S_SYMBOL:
	case S_STRING:
		sep();
		if (e->type == S_STRING) putchar('"');
		for (i = 0; i < e->len; i++) {
			switch(((char*)e->buf)[i]) {
			case '"':
			case '\\':
				putchar('\\');
				break;
			case ')': case '(':
				if (e->type == S_SYMBOL)
					putchar('\\');
			}

			putchar(((char*)e->buf)[i]);
		}
		if (e->type == S_STRING) putchar('"');
		putchar('\n');
		return;
	}
}

int main()
{
	char *next;
	const char *in = "((data da\\(\\)ta \"quot\\\\ed data\" 123 4.5)\n"
			" (\"data\" (!@# (4.5) \"(mo\\\"re\" \"data)\")))";

	expr x = parse_term(in, &next);

	printf("input is:\n%s\n", in);
	printf("parsed as:\n");
	print_expr(x, 0);
	return 0;
}
`,`#include "s-expressions-1.h"



int _whine(void)

{
  int iVar1;
  
  iVar1 = _fprintf(*(FILE **)PTR____stderrp_100004010,"parse error before ==>%.10s\n");
  return iVar1;
}



undefined4 * _parse_string(char *param_1,long *param_2)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  int local_14c;
  char *local_138;
  undefined4 *local_130;
  char acStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_130 = (undefined4 *)_calloc(0x18,1);
  _memset(acStack_128,0,0x100);
  local_14c = 0;
  local_138 = param_1;
  do {
    if (*local_138 == '\0') {
LAB_1000034b8:
      _free(local_130);
      local_130 = (undefined4 *)0x0;
LAB_100003518:
      if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
        return local_130;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    if (0xff < local_14c) {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"string too long:\n");
      _whine(local_138);
      goto LAB_1000034b8;
    }
    if (*local_138 == '\"') {
      *param_2 = (long)(local_138 + 1);
      *local_130 = 2;
      pcVar1 = _strdup(acStack_128);
      *(char **)(local_130 + 4) = pcVar1;
      sVar2 = _strlen(acStack_128);
      *(size_t *)(local_130 + 2) = sVar2;
      goto LAB_100003518;
    }
    if (*local_138 == '\\') {
      if ((local_138[1] != '\"') && (local_138[1] != '\\')) {
        _whine(local_138 + 1);
        goto LAB_1000034b8;
      }
      lVar3 = (long)local_14c;
      local_14c = local_14c + 1;
      acStack_128[lVar3] = local_138[1];
      local_138 = local_138 + 2;
    }
    else {
      lVar3 = (long)local_14c;
      local_14c = local_14c + 1;
      acStack_128[lVar3] = *local_138;
      local_138 = local_138 + 1;
    }
  } while( true );
}



undefined4 * _parse_symbol(char *param_1,long *param_2)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  long lVar4;
  int local_14c;
  char *local_138;
  undefined4 *local_130;
  char acStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_130 = (undefined4 *)_calloc(0x18,1);
  _memset(acStack_128,0,0x100);
  local_14c = 0;
  local_138 = param_1;
  do {
    if (*local_138 == '\0') {
LAB_100003758:
      _free(local_130);
      local_130 = (undefined4 *)0x0;
LAB_1000037b8:
      if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
        return local_130;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    if (0xff < local_14c) {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"symbol too long:\n");
      _whine(local_138);
      goto LAB_100003758;
    }
    iVar1 = _isspace((int)*local_138);
    if (iVar1 != 0) {
LAB_100003768:
      *param_2 = (long)(local_138 + 1);
      *local_130 = 3;
      pcVar2 = _strdup(acStack_128);
      *(char **)(local_130 + 4) = pcVar2;
      sVar3 = _strlen(acStack_128);
      *(size_t *)(local_130 + 2) = sVar3;
      goto LAB_1000037b8;
    }
    if ((*local_138 == ')') || (*local_138 == '(')) {
      local_138 = local_138 + -1;
      goto LAB_100003768;
    }
    if (*local_138 == '\"') {
      _whine(local_138);
      goto LAB_100003768;
    }
    if (*local_138 == '\\') {
      iVar1 = (int)local_138[1];
      if (((iVar1 != 0x22) && (1 < iVar1 - 0x28U)) && (iVar1 != 0x5c)) {
        _whine(local_138 + 1);
        goto LAB_100003758;
      }
      lVar4 = (long)local_14c;
      local_14c = local_14c + 1;
      acStack_128[lVar4] = local_138[1];
      local_138 = local_138 + 2;
    }
    else {
      lVar4 = (long)local_14c;
      local_14c = local_14c + 1;
      acStack_128[lVar4] = *local_138;
      local_138 = local_138 + 1;
    }
  } while( true );
}



void _append(long param_1,undefined8 param_2)

{
  long lVar1;
  void *pvVar2;
  
  lVar1 = *(long *)(param_1 + 8) + 1;
  *(long *)(param_1 + 8) = lVar1;
  pvVar2 = _realloc(*(void **)(param_1 + 0x10),lVar1 * 8);
  *(void **)(param_1 + 0x10) = pvVar2;
  *(undefined8 *)(*(long *)(param_1 + 0x10) + (*(long *)(param_1 + 8) + -1) * 8) = param_2;
  return;
}



undefined4 * _parse_list(char *param_1,long *param_2)

{
  char cVar1;
  int iVar2;
  char *local_40;
  long local_38;
  undefined4 *local_30;
  long *local_28;
  char *local_20;
  
  local_28 = param_2;
  local_20 = param_1;
  local_30 = (undefined4 *)_calloc(0x18,1);
  *(undefined8 *)(local_30 + 2) = 0;
  while (*local_20 != '\0') {
    iVar2 = _isspace((int)*local_20);
    if (iVar2 == 0) {
      cVar1 = *local_20;
      if (cVar1 == '\"') {
        local_38 = _parse_string(local_20 + 1,&local_40);
        if (local_38 == 0) break;
        _append(local_30,local_38);
        local_20 = local_40;
      }
      else if (cVar1 == '(') {
        local_38 = _parse_list(local_20 + 1,&local_40);
        if (local_38 == 0) break;
        _append(local_30,local_38);
        local_20 = local_40;
      }
      else {
        if (cVar1 == ')') {
          *local_28 = (long)(local_20 + 1);
          *local_30 = 1;
          return local_30;
        }
        local_38 = _parse_symbol(local_20,&local_40);
        if (local_38 == 0) break;
        _append(local_30,local_38);
        local_20 = local_40;
      }
    }
    else {
      local_20 = local_20 + 1;
    }
  }
  _whine(local_20);
  _free(local_30);
  return (undefined4 *)0x0;
}



undefined8 _parse_term(char *param_1,undefined8 param_2)

{
  int iVar1;
  undefined8 uVar2;
  char *local_20;
  
  local_20 = param_1;
  while( true ) {
    if (*local_20 == '\0') {
      return 0;
    }
    iVar1 = _isspace((int)*local_20);
    if (iVar1 == 0) break;
    local_20 = local_20 + 1;
  }
  if (*local_20 != '\"') {
    if (*local_20 == '(') {
      uVar2 = _parse_list(local_20 + 1,param_2);
      return uVar2;
    }
    uVar2 = _parse_symbol(local_20 + 1,param_2);
    return uVar2;
  }
  uVar2 = _parse_string(local_20 + 1,param_2);
  return uVar2;
}



int * _print_expr(int *param_1,int param_2)

{
  uint uVar1;
  int iVar2;
  int local_20;
  
  if (param_1 != (int *)0x0) {
    if (*param_1 == 1) {
      for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
        _printf("    ");
      }
      _puts("(");
      for (local_20 = 0; (ulong)(long)local_20 < *(ulong *)(param_1 + 2); local_20 = local_20 + 1) {
        _print_expr(*(undefined8 *)(*(long *)(param_1 + 4) + (long)local_20 * 8),param_2 + 1);
      }
      for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
        _printf("    ");
      }
      uVar1 = _puts(")");
      param_1 = (int *)(ulong)uVar1;
    }
    else if (*param_1 - 2U < 2) {
      for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
        _printf("    ");
      }
      if (*param_1 == 2) {
        _putchar(0x22);
      }
      for (local_20 = 0; (ulong)(long)local_20 < *(ulong *)(param_1 + 2); local_20 = local_20 + 1) {
        iVar2 = (int)*(char *)(*(long *)(param_1 + 4) + (long)local_20);
        if (iVar2 == 0x22) {
LAB_100003d4c:
          _putchar(0x5c);
        }
        else if (iVar2 - 0x28U < 2) {
          if (*param_1 == 3) {
            _putchar(0x5c);
          }
        }
        else if (iVar2 == 0x5c) goto LAB_100003d4c;
        _putchar((int)*(char *)(*(long *)(param_1 + 4) + (long)local_20));
      }
      if (*param_1 == 2) {
        _putchar(0x22);
      }
      uVar1 = _putchar(10);
      param_1 = (int *)(ulong)uVar1;
    }
  }
  return param_1;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined auStack_20 [12];
  undefined4 local_14;
  
  local_14 = 0;
  uVar1 = _parse_term("((data da\\(\\)ta \"quot\\\\ed data\" 123 4.5)\n (\"data\" (!@# (4.5) \"(mo\\\"re\" \"data)\")))"
                      ,auStack_20);
  _printf("input is:\n%s\n");
  _printf("parsed as:\n");
  _print_expr(uVar1,0);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isspace(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isspace_100004030)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004038)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004048)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004058)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004060)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004068)();
  return sVar1;
}


`
`/*Almost every C program has the below line,
the #include preprocessor directive is used to
instruct the compiler which files to load before compiling the program.

All preprocessor commands begin with #
*/
#include<stdio.h>

/*The #define preprocessor directive is often used to create abbreviations for code segments*/
#define Hi printf("Hi There.");

/*It can be used, or misused, for rather innovative uses*/

#define start int main(){
#define end return 0;}

start

Hi

/*And here's the nice part, want your compiler to talk to you ?
Just use the #warning pragma if you are using a C99 compliant compiler
like GCC*/
#warning "Don't you have anything better to do ?"

#ifdef __unix__
#warning "What are you doing still working on Unix ?"
printf("\nThis is an Unix system.");
#elif _WIN32
#warning "You couldn't afford a 64 bit ?"
printf("\nThis is a 32 bit Windows system.");
#elif _WIN64
#warning "You couldn't afford an Apple ?"
printf("\nThis is a 64 bit Windows system.");
#endif

end

/*Enlightened ?*/
`,`#include "pragmatic-directives.h"



undefined4 entry(void)

{
  _printf("Hi There.");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdio.h>

int isPrime(unsigned int n)
{
	unsigned int num;
	
	if ( n < 2||!(n & 1))
		return n == 2;

	for (num = 3; num <= n/num; num += 2)
		if (!(n % num))
			return 0;
	return 1;
}

int main()
{
	unsigned int l,u,i,sum=0;
	
	printf("Enter lower and upper bounds: ");
	scanf("%ld%ld",&l,&u);
	
	for(i=l;i<=u;i++){
		if(isPrime(i)==1)
			{
				printf("\n%ld",i);
				sum++;
			}
	}
	
	printf("\n\nPrime numbers found in [%ld,%ld] : %ld",l,u,sum);
	
	return 0;
}
`,`#include "sequence-of-primes-by-trial-division.h"



bool _isPrime(uint param_1)

{
  uint uVar1;
  bool bVar2;
  uint local_c;
  
  if ((param_1 < 2) || ((param_1 & 1) == 0)) {
    bVar2 = param_1 == 2;
  }
  else {
    local_c = 3;
    while( true ) {
      uVar1 = 0;
      if (local_c != 0) {
        uVar1 = param_1 / local_c;
      }
      if (uVar1 < local_c) {
        return true;
      }
      uVar1 = 0;
      if (local_c != 0) {
        uVar1 = param_1 / local_c;
      }
      if (param_1 == uVar1 * local_c) break;
      local_c = local_c + 2;
    }
    bVar2 = false;
  }
  return bVar2;
}



undefined8 entry(void)

{
  int iVar1;
  uint local_20;
  uint local_1c;
  uint local_18;
  
  _printf("Enter lower and upper bounds: ");
  _scanf("%ld%ld");
  for (local_20 = local_18; local_20 <= local_1c; local_20 = local_20 + 1) {
    iVar1 = _isPrime(local_20);
    if (iVar1 == 1) {
      _printf("\n%ld");
    }
  }
  _printf("\n\nPrime numbers found in [%ld,%ld] : %ld");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

char * base;
void get_diff()
{
	char x;
	if (base - &x < 200)
		printf("%p %d\n", &x, base - &x);
}

void recur()
{
	get_diff();
	recur();
}

int main()
{
	char v = 32;
	printf("pos of v: %p\n", base = &v);
	recur();
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ea0(void);
int64_t function_100003f10(int64_t a1);
int32_t function_100003f84(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ea0 - 0x100003f10
int64_t function_100003ea0(void) {
    // 0x100003ea0
    int64_t v1; // bp-17, 0x100003ea0
    int64_t v2 = g1 - (int64_t)&v1; // 0x100003ebc
    int64_t result; // 0x100003ea0
    if (v2 < 200 != (199 - v2 & v2) < 0) {
        // 0x100003ed0
        int64_t v3; // 0x100003ea0
        result = _printf("%p %d\n", (int64_t *)v3, v3);
    }
    // 0x100003f04
    return result;
}

// Address range: 0x100003f10 - 0x100003f28
int64_t function_100003f10(int64_t a1) {
    // 0x100003f10
    function_100003ea0();
    return function_100003f10((int64_t)&g2);
}

// Address range: 0x100003f28 - 0x100003f84
int64_t entry_point(void) {
    int64_t v1 = 32; // bp-21, 0x100003f48
    g1 = &v1;
    int64_t v2; // 0x100003f28
    _printf("pos of v: %p\n", (int64_t *)v2);
    function_100003f10((int64_t)&g2);
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>

void set_mode(int want_key)
{
	static struct termios old, new;
	if (!want_key) {
		tcsetattr(STDIN_FILENO, TCSANOW, &old);
		return;
	}

	tcgetattr(STDIN_FILENO, &old);
	new = old;
	new.c_lflag &= ~(ICANON);
	tcsetattr(STDIN_FILENO, TCSANOW, &new);
}

int get_key()
{
	int c = 0;
	fd_set fs;

	FD_ZERO(&fs);
	FD_SET(STDIN_FILENO, &fs);
	select(STDIN_FILENO + 1, &fs, 0, 0, 0);

	if (FD_ISSET(STDIN_FILENO, &fs)) {
		c = getchar();
		set_mode(0);
	}
	return c;
}

int main()
{
	int c = 0;
	while (c != 'n') {
		set_mode(1);

		/* flush pending input so we won't format the hardrive
		   because user accidentally typed 'y' before we even prompted */
		tcflush(STDIN_FILENO, TCIFLUSH);

		printf("Show this prompt again [Yes/No/Ignore you]? ");
		fflush(stdout);

		switch(c = tolower(get_key())) {
		case 'y':	putchar('\n');
				break;

		case 'n':	printf("\nDone\n");
				break;

		case 'i':	puts("\nI'll ignore keys for 5 seconds");
				sleep(5);
				putchar('\n');
				break;
		default:
				puts("\nAssume that was the cat.");
		}
	}

	return 0;
}
`,`#include "keyboard-input-flush-the-keyboard-buffer-2.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _set_mode(int param_1)

{
  int iVar1;
  
  if (param_1 == 0) {
    iVar1 = _tcsetattr(0,0,(termios *)0x100008000);
  }
  else {
    _tcgetattr(0,(termios *)0x100008000);
    _memcpy((void *)0x100008048,(void *)0x100008000,0x48);
    _DAT_100008060 = _DAT_100008060 & 0xfffffffffffffeff;
    iVar1 = _tcsetattr(0,0,(termios *)0x100008048);
  }
  return iVar1;
}



int _get_key(void)

{
  bool bVar1;
  fd_set afStack_d4 [32];
  int local_54;
  fd_set *local_50;
  int local_44;
  fd_set *local_40;
  int local_38;
  uint local_34;
  fd_set *local_30;
  undefined4 local_28;
  int local_24;
  fd_set *local_20;
  undefined4 local_18;
  int local_14;
  
  bVar1 = PTR____darwin_check_fd_set_overflow_100004000 == (undefined *)0x0;
  local_54 = 0;
  _memset(afStack_d4,0,0x80);
  local_44 = 0;
  local_18 = 0;
  local_50 = afStack_d4;
  local_20 = afStack_d4;
  if (bVar1) {
    local_14 = 1;
  }
  else {
    local_14 = ___darwin_check_fd_set_overflow(0,afStack_d4,0);
  }
  if (local_14 != 0) {
    *(uint *)(local_50 + (ulong)(long)local_44 / 0x20) =
         *(uint *)(local_50 + (ulong)(long)local_44 / 0x20) |
         (uint)(1L << (ulong)(long)local_44 % 0x20);
  }
  _select(1,afStack_d4,(fd_set *)0x0,(fd_set *)0x0,(timeval *)0x0);
  local_38 = 0;
  local_28 = 0;
  local_40 = afStack_d4;
  local_30 = afStack_d4;
  if (bVar1) {
    local_24 = 1;
  }
  else {
    local_24 = ___darwin_check_fd_set_overflow(0,afStack_d4,0);
  }
  if (local_24 == 0) {
    local_34 = 0;
  }
  else {
    local_34 = *(uint *)(local_40 + (ulong)(long)local_38 / 0x20) &
               (uint)(1L << (ulong)(long)local_38 % 0x20);
  }
  if (local_34 != 0) {
    local_54 = _getchar();
    _set_mode(0);
  }
  return local_54;
}



undefined8 entry(void)

{
  int iVar1;
  int local_18;
  
  local_18 = 0;
  while (local_18 != 0x6e) {
    _set_mode();
    _tcflush(0,1);
    _printf("Show this prompt again [Yes/No/Ignore you]? ");
    iVar1 = _fflush(*(FILE **)PTR____stdoutp_100004008);
    iVar1 = _get_key(iVar1);
    local_18 = _tolower(iVar1);
    if (local_18 == 0x69) {
      _puts("\nI\'ll ignore keys for 5 seconds");
      _sleep(5);
      _putchar(10);
    }
    else if (local_18 == 0x6e) {
      _printf("\nDone\n");
    }
    else if (local_18 == 0x79) {
      _putchar(10);
    }
    else {
      _puts("\nAssume that was the cat.");
    }
  }
  return 0;
}



void ___darwin_check_fd_set_overflow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____darwin_check_fd_set_overflow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004028)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004038)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _select(int param_1,fd_set *param_2,fd_set *param_3,fd_set *param_4,timeval *param_5)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__select_100004048)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint _sleep(uint param_1)

{
  uint uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__sleep_100004050)(param_1);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcflush(int param_1,int param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcflush_100004058)(param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcgetattr(int param_1,termios *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcgetattr_100004060)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcsetattr(int param_1,int param_2,termios *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcsetattr_100004068)(param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tolower(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tolower_100004070)(_c);
  return iVar1;
}


`
`#include<stdio.h>
#include<string.h>

int main()
{
    char str[24]="Good Morning";
    char *cstr=" to all";
    char *cstr2=" !!!";
    int x=0;
    //failure when space allocated to str is insufficient.

    if(sizeof(str)>strlen(str)+strlen(cstr)+strlen(cstr2))
            {
                /* 1st method*/
                strcat(str,cstr);

                /*2nd method*/
                x=strlen(str);
                sprintf(&str[x],"%s",cstr2);

                printf("%s\n",str);

            }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f40(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003f4c(int64_t a1);
int64_t function_100003f58(int64_t * a1, int64_t a2, int64_t a3);
int32_t function_100003f64(char * format, ...);
int32_t function_100003f70(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcat_chk(int64_t * a1, int64_t a2, int64_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e04 - 0x100003f40
int64_t entry_point(void) {
    int64_t v1 = (float64_t)*(float128_t *)"Good Morning"; // bp-48, 0x100003e34
    int32_t v2 = _strlen((char *)&v1); // 0x100003e5c
    int32_t v3 = _strlen(" to all"); // 0x100003e68
    int64_t v4 = _strlen(" !!!"); // 0x100003e80
    uint64_t v5 = (int64_t)v3 + (int64_t)v2 + v4; // 0x100003e88
    int64_t v6 = v4; // 0x100003e98
    if (v5 != 24 && v5 <= 24) {
        // 0x100003ea0
        ___strcat_chk(&v1, (int64_t)" to all", 24);
        int32_t v7 = _strlen((char *)&v1); // 0x100003eb8
        ___sprintf_chk((int64_t)v7 + (int64_t)&v1, 0, -1, "%s");
        v6 = _printf("%s\n", NULL);
    }
    int64_t v8 = *(int64_t *)0x100004010; // 0x100003f14
    if (*(int64_t *)v8 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003f2c
        ___stack_chk_fail(v6);
    }
    // 0x100003f30
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(int64_t a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003f40
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f4c - 0x100003f58
int64_t function_100003f4c(int64_t a1) {
    // 0x100003f4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003f58
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * s) {
    // 0x100003f70
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdbool.h>

#define N_COLS 15
#define N_ROWS 15

// Probability granularity 0.0, 0.1, ... 1.0
#define N_STEPS 11

// Simulation tries
#define N_TRIES 100

typedef unsigned char Cell;
enum { EMPTY_CELL   = ' ',
       FILLED_CELL  = '#',
       VISITED_CELL = '.' };
typedef Cell Grid[N_ROWS][N_COLS];

void initialize(Grid grid, const double probability) {
    for (size_t r = 0; r < N_ROWS; r++)
        for (size_t c = 0; c < N_COLS; c++) {
            const double rnd = rand() / (double)RAND_MAX;
            grid[r][c] = (rnd < probability) ? EMPTY_CELL : FILLED_CELL;
        }
}

void show(Grid grid) {
    char line[N_COLS + 3];
    memset(&line[0], '-', N_COLS + 2);
    line[0] = '+';
    line[N_COLS + 1] = '+';
    line[N_COLS + 2] = '\0';

    printf("%s\n", line);
    for (size_t r = 0; r < N_ROWS; r++) {
        putchar('|');
        for (size_t c = 0; c < N_COLS; c++)
            putchar(grid[r][c]);
        puts("|");
    }
    printf("%s\n", line);
}

bool walk(Grid grid, const size_t r, const size_t c) {
    const size_t bottom = N_ROWS - 1;
    grid[r][c] = VISITED_CELL;

    if (r < bottom && grid[r + 1][c] == EMPTY_CELL) { // Down.
        if (walk(grid, r + 1, c))
            return true;
    } else if (r == bottom)
        return true;

    if (c && grid[r][c - 1] == EMPTY_CELL) // Left.
        if (walk(grid, r, c - 1))
            return true;

    if (c < N_COLS - 1 && grid[r][c + 1] == EMPTY_CELL) // Right.
        if (walk(grid, r, c + 1))
            return true;

    if (r && grid[r - 1][c] == EMPTY_CELL) // Up.
        if (walk(grid, r - 1, c))
            return true;

    return false;
}

bool percolate(Grid grid) {
    const size_t startR = 0;
    for (size_t c = 0; c < N_COLS; c++)
        if (grid[startR][c] == EMPTY_CELL)
            if (walk(grid, startR, c))
                return true;
    return false;
}

typedef struct {
    double prob;
    size_t count;
} Counter;

int main() {
    const double probability_step = 1.0 / (N_STEPS - 1);
    Counter counters[N_STEPS];
    for (size_t i = 0; i < N_STEPS; i++)
        counters[i] = (Counter){ i * probability_step, 0 };

    bool sample_shown = false;
    static Grid grid;
    srand(time(NULL));

    for (size_t i = 0; i < N_STEPS; i++) {
        for (size_t t = 0; t < N_TRIES; t++) {
            initialize(grid, counters[i].prob);
            if (percolate(grid)) {
                counters[i].count++;
                if (!sample_shown) {
                    printf("Percolating sample (%dx%d,"
                           " probability =%5.2f):\n",
                           N_COLS, N_ROWS, counters[i].prob);
                    show(grid);
                    sample_shown = true;
                }
            }
        }
    }

    printf("\nFraction of %d tries that percolate through:\n", N_TRIES);
    for (size_t i = 0; i < N_STEPS; i++)
        printf("%1.1f %1.3f\n", counters[i].prob,
               counters[i].count / (double)N_TRIES);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003710(void);
int64_t function_1000037e8(void);
int64_t function_10000392c(void);
int64_t function_100003ba4(void);
int64_t function_100003ebc(int64_t a1);
int32_t function_100003ec8(char * format, ...);
int32_t function_100003ed4(int32_t c);
int32_t function_100003ee0(char * s);
int32_t function_100003eec(void);
void function_100003ef8(int32_t seed);
int32_t function_100003f04(int32_t * timer);

// --------------------- Global Variables ---------------------

float64_t g1 = 2147483647.0; // 0x100003f10
float64_t g2 = 0.1; // 0x100003f18

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003710 - 0x1000037e8
int64_t function_100003710(void) {
    int32_t result; // 0x10000375c
    for (int64_t i = 0; i < 15; i++) {
        for (int64_t j = 0; j < 15; j++) {
            // 0x10000375c
            result = _rand();
            float64_t v1; // bp-32, 0x100003710
            char v2 = (float64_t)result / g1 <= v1 ? 35 : 32; // 0x1000037b0
            int64_t v3; // 0x100003710
            *(char *)(15 * i + v3 + j) = v2;
        }
    }
    // 0x1000037dc
    return result;
}

// Address range: 0x1000037e8 - 0x10000392c
int64_t function_1000037e8(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000037fc
    int64_t v2; // 0x1000037e8
    char * v3 = (char *)v2; // 0x10000384c
    _printf("%s\n", v3);
    for (int64_t i = 0; i < 15; i++) {
        // 0x10000386c
        _putchar(124);
        for (int64_t j = 0; j < 15; j++) {
            // 0x100003890
            _putchar((int32_t)*(char *)(15 * i + v2 + j));
        }
        // 0x1000038c4
        _puts("|");
    }
    int64_t v4 = _printf("%s\n", v3); // 0x1000038f8
    int64_t result = v4; // 0x100003914
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x10000391c
        result = ___stack_chk_fail(v4);
    }
    // 0x100003920
    return result;
}

// Address range: 0x10000392c - 0x100003ba4
int64_t function_10000392c(void) {
    // 0x10000392c
    int64_t v1; // 0x10000392c
    uint64_t v2 = v1;
    int64_t v3 = v1 + 15 * v1 + v2;
    *(char *)v3 = 46;
    if (v1 < 14) {
        // 0x100003984
        if (*(char *)(v3 + 15) == 32) {
            // 0x1000039b4
            if (function_10000392c() % 2 != 0) {
                // 0x100003b90
                return 1;
            }
        }
    } else {
        // 0x1000039e8
        if (v1 == 14) {
            // 0x100003b90
            return 1;
        }
    }
    if (v2 == 0) {
        goto lab_0x100003aa0;
    } else {
        // 0x100003a28
        if (*(char *)(v3 - 1) == 32) {
            // 0x100003a58
            if (function_10000392c() % 2 != 0) {
                // 0x100003b90
                return 1;
            }
        }
        if (v2 < 14) {
            goto lab_0x100003aa0;
        } else {
            goto lab_0x100003b04;
        }
    }
  lab_0x100003aa0:
    // 0x100003aa0
    if (*(char *)(v3 + 1) == 32) {
        // 0x100003ad0
        if (function_10000392c() % 2 != 0) {
            // 0x100003b90
            return 1;
        }
    }
    goto lab_0x100003b04;
  lab_0x100003b04:
    if (v1 == 0 || *(char *)(v3 - 15) != 32) {
        // 0x100003b90
        return 0;
    }
    // 0x100003b48
    if (function_10000392c() % 2 != 0) {
        // 0x100003b90
        return 1;
    }
    // 0x100003b90
    return 0;
}

// Address range: 0x100003ba4 - 0x100003c5c
int64_t function_100003ba4(void) {
    int64_t v1 = 0; // 0x100003c28
    int64_t v2; // 0x100003ba4
    if (*(char *)(v1 + v2) == 32) {
        // 0x100003bf0
        if (function_10000392c() % 2 != 0) {
            // break -> 0x100003c48
            break;
        }
    }
    // 0x100003c24
    v1++;
    int64_t result = 0; // 0x100003bcc
    while (v1 < 15) {
        // 0x100003bd4
        if (*(char *)(v1 + v2) == 32) {
            // 0x100003bf0
            result = 1;
            if (function_10000392c() % 2 != 0) {
                // break -> 0x100003c48
                break;
            }
        }
        // 0x100003c24
        v1++;
        result = 0;
    }
    // 0x100003c48
    return result;
}

// Address range: 0x100003c5c - 0x100003ebc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c74
    int64_t v2; // bp-216, 0x100003c5c
    int64_t v3 = &v2;
    int64_t v4 = 0;
    *(float128_t *)(16 * v4 + v3) = (float128_t)(g2 * (float64_t)v4);
    int64_t v5 = v4 + 1; // 0x100003cdc
    while (v5 != 11) {
        // 0x100003ca8
        v4 = v5;
        *(float128_t *)(16 * v4 + v3) = (float128_t)(g2 * (float64_t)v4);
        v5 = v4 + 1;
    }
    // 0x100003ce8
    _srand(_time(NULL));
    int32_t v6 = 0; // 0x100003c5c
    int64_t v7; // 0x100003c5c
    int128_t v8; // 0x100003c5c
    for (int64_t i = 0; i < 11; i++) {
        int64_t * v9 = (int64_t *)(v3 + 8 + 16 * i);
        for (int64_t j = 0; j < 100; j++) {
            int32_t v10 = v6;
            function_100003710();
            v6 = v10;
            if (function_100003ba4() % 2 != 0) {
                // 0x100003d60
                *v9 = *v9 + 1;
                v6 = v10;
                if (v10 % 2 == 0) {
                    // 0x100003d84
                    _printf("Percolating sample (%dx%d, probability =%5.2f):\n", v7, v7, (float64_t)(int64_t)v8);
                    function_1000037e8();
                    v6 = 1;
                }
            }
        }
    }
    // 0x100003df8
    _printf("\nFraction of %d tries that percolate through:\n", v7);
    int32_t v11; // 0x100003e6c
    for (int64_t i = 0; i < 11; i++) {
        // 0x100003e2c
        v11 = _printf("%1.1f %1.3f\n", (float64_t)(int64_t)v8, (float64_t)(int64_t)v8);
    }
    // 0x100003e84
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ea4
        ___stack_chk_fail((int64_t)v11);
    }
    // 0x100003ea8
    return 0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(int64_t a1) {
    // 0x100003ebc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(char * format, ...) {
    // 0x100003ec8
    return _printf(format);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(int32_t c) {
    // 0x100003ed4
    return _putchar(c);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(char * s) {
    // 0x100003ee0
    return _puts(s);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(void) {
    // 0x100003eec
    return _rand();
}

// Address range: 0x100003ef8 - 0x100003f04
void function_100003ef8(int32_t seed) {
    // 0x100003ef8
    _srand(seed);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(int32_t * timer) {
    // 0x100003f04
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>

int main() {
  printf("%d\n", 'a'); /* prints "97" */
  printf("%c\n", 97); /* prints "a"; we don't have to cast because printf is type agnostic */
  return 0;
}
`,`#include "character-codes.h"



undefined4 entry(void)

{
  _printf("%d\n");
  _printf("%c\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include "stdio.h"

typedef struct Range {
    int start, end, sum;
} Range;

Range maxSubseq(const int sequence[], const int len) {
    int maxSum = 0, thisSum = 0, i = 0;
    int start = 0, end = -1, j;

    for (j = 0; j < len; j++) {
        thisSum += sequence[j];
        if (thisSum < 0) {
            i = j + 1;
            thisSum = 0;
        } else if (thisSum > maxSum) {
            maxSum = thisSum;
            start = i;
            end   = j;
        }
    }

    Range r;
    if (start <= end && start >= 0 && end >= 0) {
        r.start = start;
        r.end = end + 1;
        r.sum = maxSum;
    } else {
        r.start = 0;
        r.end = 0;
        r.sum = 0;
    }
    return r;
}

int main(int argc, char **argv) {
    int a[] = {-1 , -2 , 3 , 5 , 6 , -2 , -1 , 4 , -4 , 2 , -1};
    int alength = sizeof(a)/sizeof(a[0]);

    Range r = maxSubseq(a, alength);
    printf("Max sum = %d\n", r.sum);
    int i;
    for (i = r.start; i < r.end; i++)
        printf("%d ", a[i]);
    printf("\n");

    return 0;
}
`,`#include "greatest-subsequential-sum.h"



undefined  [16] _maxSubseq(long param_1,int param_2)

{
  undefined auVar1 [16];
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_34;
  int iStack_30;
  int local_2c;
  undefined4 uStack_1c;
  
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  local_54 = 0;
  local_58 = -1;
  for (local_5c = 0; local_5c < param_2; local_5c = local_5c + 1) {
    local_4c = local_4c + *(int *)(param_1 + (long)local_5c * 4);
    if (local_4c < 0) {
      local_50 = local_5c + 1;
      local_4c = 0;
    }
    else if (local_48 < local_4c) {
      local_54 = local_50;
      local_58 = local_5c;
      local_48 = local_4c;
    }
  }
  if (((local_58 < local_54) || (local_54 < 0)) || (local_58 < 0)) {
    local_34 = 0;
    iStack_30 = 0;
    local_2c = 0;
  }
  else {
    local_34 = local_54;
    iStack_30 = local_58 + 1;
    local_2c = local_48;
  }
  auVar1._4_4_ = iStack_30;
  auVar1._0_4_ = local_34;
  auVar1._12_4_ = uStack_1c;
  auVar1._8_4_ = local_2c;
  if (*(long *)PTR____stack_chk_guard_100004008 == *(long *)PTR____stack_chk_guard_100004008) {
    return auVar1;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 uVar2;
  int local_7c;
  int local_78;
  int iStack_74;
  undefined auStack_44 [44];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_44,&DAT_100003f68,0x2c);
  uVar2 = _maxSubseq(auStack_44,0xb);
  _printf("Max sum = %d\n");
  local_78 = (int)uVar2;
  for (local_7c = local_78; iStack_74 = (int)((ulong)uVar2 >> 0x20), local_7c < iStack_74;
      local_7c = local_7c + 1) {
    _printf("%d ");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include<math.h>
#include<stdio.h>

double
meanAngle (double *angles, int size)
{
  double y_part = 0, x_part = 0;
  int i;

  for (i = 0; i < size; i++)
    {
      x_part += cos (angles[i] * M_PI / 180);
      y_part += sin (angles[i] * M_PI / 180);
    }

  return atan2 (y_part / size, x_part / size) * 180 / M_PI;
}

int
main ()
{
  double angleSet1[] = { 350, 10 };
  double angleSet2[] = { 90, 180, 270, 360};
  double angleSet3[] = { 10, 20, 30};

  printf ("\nMean Angle for 1st set : %lf degrees", meanAngle (angleSet1, 2));
  printf ("\nMean Angle for 2nd set : %lf degrees", meanAngle (angleSet2, 4));
  printf ("\nMean Angle for 3rd set : %lf degrees\n", meanAngle (angleSet3, 3));
  return 0;
}
`,`#include "averages-mean-angle.h"



undefined  [16] _meanAngle(long param_1,int param_2)

{
  double dVar1;
  undefined auVar2 [16];
  undefined4 local_34;
  undefined8 local_30;
  undefined8 local_28;
  
  local_28 = 0.0;
  local_30 = 0.0;
  for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
    dVar1 = (double)_cos((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_30 = local_30 + dVar1;
    dVar1 = (double)_sin((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_28 = local_28 + dVar1;
  }
  dVar1 = (double)_atan2(local_28 / (double)(long)param_2,local_30 / (double)(long)param_2);
  auVar2._0_8_ = (dVar1 * 180.0) / 3.141592653589793;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_70;
  undefined8 uStack_68;
  undefined8 local_60;
  undefined8 local_50;
  undefined8 uStack_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 0x4024000000000000;
  local_30 = 0x4075e00000000000;
  uStack_48 = 0x4066800000000000;
  local_50 = 0x4056800000000000;
  uStack_38 = 0x4076800000000000;
  local_40 = 0x4070e00000000000;
  uStack_68 = 0x4034000000000000;
  local_70 = 0x4024000000000000;
  local_60 = 0x403e000000000000;
  _meanAngle(&local_30,2);
  _printf("\nMean Angle for 1st set : %lf degrees");
  _meanAngle(&local_50,4);
  _printf("\nMean Angle for 2nd set : %lf degrees");
  _meanAngle(&local_70,3);
  iVar1 = _printf("\nMean Angle for 3rd set : %lf degrees\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004010)();
  return;
}



void _cos(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cos_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004028)();
  return;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

const char *encoded =
    "MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH"
    "VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD"
    "ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS"
    "FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG"
    "ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ"
    "ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS"
    "JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT"
    "LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST"
    "MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH"
    "QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV"
    "RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW"
    "TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO"
    "SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR"
    "ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX"
    "BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB"
    "BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA"
    "FWAML ZZRXJ EKAHV FASMU LVVUT TGK";

const double freq[] = {
    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,
    0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,
    0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,
    0.00978, 0.02360, 0.00150, 0.01974, 0.00074
};

int best_match(const double *a, const double *b) {
    double sum = 0, fit, d, best_fit = 1e100;
    int i, rotate, best_rotate = 0;
    for (i = 0; i < 26; i++)
        sum += a[i];
    for (rotate = 0; rotate < 26; rotate++) {
        fit = 0;
        for (i = 0; i < 26; i++) {
            d = a[(i + rotate) % 26] / sum - b[i];
            fit += d * d / b[i];
        }

        if (fit < best_fit) {
            best_fit = fit;
            best_rotate = rotate;
        }
    }

    return best_rotate;
}

double freq_every_nth(const int *msg, int len, int interval, char *key) {
    double sum, d, ret;
    double out[26], accu[26] = {0};
    int i, j, rot;

    for (j = 0; j < interval; j++) {
        for (i = 0; i < 26; i++)
            out[i] = 0;
        for (i = j; i < len; i += interval)
            out[msg[i]]++;
        key[j] = rot = best_match(out, freq);
        key[j] += 'A';
        for (i = 0; i < 26; i++)
            accu[i] += out[(i + rot) % 26];
    }

    for (i = 0, sum = 0; i < 26; i++)
        sum += accu[i];

    for (i = 0, ret = 0; i < 26; i++) {
        d = accu[i] / sum - freq[i];
        ret += d * d / freq[i];
    }

    key[interval] = '\0';
    return ret;
}

int main() {
    int txt[strlen(encoded)];
    int len = 0, j;
    char key[100];
    double fit, best_fit = 1e100;

    for (j = 0; encoded[j] != '\0'; j++)
        if (isupper(encoded[j]))
            txt[len++] = encoded[j] - 'A';

    for (j = 1; j < 30; j++) {
        fit = freq_every_nth(txt, len, j, key);
        printf("%f, key length: %2d, %s", fit, j, key);
        if (fit < best_fit) {
            best_fit = fit;
            printf(" <--- best so far");
        }
        printf("\n");
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003420(void);
int64_t function_100003594(void);
int64_t function_1000038c4(void);
int64_t function_100003a84(void);
int32_t function_100003a90(int32_t c);
int64_t * function_100003a9c(int64_t * s, int32_t c, int32_t n);
int32_t function_100003aa8(char * format, ...);
int32_t function_100003ab4(char * s);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0e+100; // 0x100003ac0
char * g2 = "\x98;"; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(int64_t a1);
int64_t ___stack_chk_fail(void);
int32_t _isupper(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003420 - 0x100003594
int64_t function_100003420(void) {
    float64_t v1 = 0.0; // 0x100003470
    int64_t v2; // 0x100003420
    for (int64_t i = 0; i < 26; i++) {
        // 0x100003460
        v1 += *(float64_t *)(8 * i + v2);
    }
    float64_t v3 = g1;
    int32_t result = 0;
    for (int64_t i = 0; i < 26; i++) {
        float64_t v4 = v3; // 0x10000354c
        int64_t v5 = 0;
        float64_t v6 = *(float64_t *)(v2 + (int64_t)(8 * ((int32_t)(v5 + i) % 26))); // 0x1000034ec
        float64_t v7 = *(float64_t *)(8 * v5 + v2); // 0x100003500
        float64_t v8 = v6 / v1 - v7; // 0x100003504
        float64_t v9 = v8 * v8 / v7; // 0x10000352c
        v5++;
        float64_t v10 = v9; // 0x1000034c4
        while (v5 != 26) {
            // 0x1000034cc
            v6 = *(float64_t *)(v2 + (int64_t)(8 * ((int32_t)(v5 + i) % 26)));
            v7 = *(float64_t *)(8 * v5 + v2);
            v8 = v6 / v1 - v7;
            v9 = v10 + v8 * v8 / v7;
            v5++;
            v10 = v9;
        }
        // 0x100003548
        v3 = v9 > v4 ? v9 : v4;
        result = v9 > v4 ? (int32_t)i : result;
    }
    // 0x100003588
    return result;
}

// Address range: 0x100003594 - 0x100003874
int64_t function_100003594(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000035ac
    int64_t v2; // 0x100003594
    int32_t v3 = v2; // 0x1000035bc
    int64_t v4; // bp-448, 0x100003594
    int64_t * v5 = _memset(&v4, 0, 208); // 0x1000035d0
    int32_t v6 = -v3; // 0x1000035e4
    int64_t v7 = (int64_t)v5; // 0x1000035ec
    if (v6 < 0 != (v6 & v3) < 0) {
        int32_t v8 = v2; // 0x1000035b8
        int64_t v9; // bp-240, 0x100003594
        int64_t v10 = &v9;
        int32_t v11 = 0;
        for (int64_t i = 0; i < 26; i++) {
            // 0x100003610
            *(float64_t *)(8 * i + v10) = 0.0;
        }
        int32_t v12 = v11 - v8; // 0x100003648
        int32_t v13 = v11; // 0x100003650
        int32_t v14; // 0x100003660
        float64_t * v15; // 0x10000366c
        int32_t v16; // 0x100003688
        int32_t v17; // 0x100003648
        if (v12 < 0 != ((v12 ^ v11) & (v11 ^ v8)) < 0) {
            v14 = *(int32_t *)(4 * (int64_t)v13 + v2);
            v15 = (float64_t *)(8 * (int64_t)v14 + v10);
            *v15 = *v15 + 1.0;
            v16 = v13 + v3;
            v17 = v16 - v8;
            v13 = v16;
            while (v17 < 0 != ((v17 ^ v16) & (v16 ^ v8)) < 0) {
                // 0x100003658
                v14 = *(int32_t *)(4 * (int64_t)v13 + v2);
                v15 = (float64_t *)(8 * (int64_t)v14 + v10);
                *v15 = *v15 + 1.0;
                v16 = v13 + v3;
                v17 = v16 - v8;
                v13 = v16;
            }
        }
        int64_t v18 = function_100003420(); // 0x1000036a0
        *(char *)(v2 + (int64_t)v11) = (char)v18 + 65;
        float64_t v19; // 0x100003708
        float64_t * v20; // 0x100003718
        for (int64_t i = 0; i < 26; i++) {
            // 0x1000036e8
            v19 = *(float64_t *)((int64_t)(8 * (((int32_t)i + (int32_t)v18) % 26)) + v10);
            v20 = (float64_t *)(8 * i + (int64_t)&v4);
            *v20 = v19 + *v20;
        }
        int32_t v21 = v11 + 1; // 0x100003740
        int32_t v22 = v21 - v3; // 0x1000035e4
        v7 = v18;
        while (v22 < 0 != ((v22 ^ v21) & (v21 ^ v3)) < 0) {
            // 0x1000035fc
            v11 = v21;
            for (int64_t i = 0; i < 26; i++) {
                // 0x100003610
                *(float64_t *)(8 * i + v10) = 0.0;
            }
            // 0x100003640
            v12 = v11 - v8;
            v13 = v11;
            if (v12 < 0 != ((v12 ^ v11) & (v11 ^ v8)) < 0) {
                v14 = *(int32_t *)(4 * (int64_t)v13 + v2);
                v15 = (float64_t *)(8 * (int64_t)v14 + v10);
                *v15 = *v15 + 1.0;
                v16 = v13 + v3;
                v17 = v16 - v8;
                v13 = v16;
                while (v17 < 0 != ((v17 ^ v16) & (v16 ^ v8)) < 0) {
                    // 0x100003658
                    v14 = *(int32_t *)(4 * (int64_t)v13 + v2);
                    v15 = (float64_t *)(8 * (int64_t)v14 + v10);
                    *v15 = *v15 + 1.0;
                    v16 = v13 + v3;
                    v17 = v16 - v8;
                    v13 = v16;
                }
            }
            // 0x100003694
            v18 = function_100003420();
            *(char *)(v2 + (int64_t)v11) = (char)v18 + 65;
            for (int64_t i = 0; i < 26; i++) {
                // 0x1000036e8
                v19 = *(float64_t *)((int64_t)(8 * (((int32_t)i + (int32_t)v18) % 26)) + v10);
                v20 = (float64_t *)(8 * i + (int64_t)&v4);
                *v20 = v19 + *v20;
            }
            // 0x10000373c
            v21 = v11 + 1;
            v22 = v21 - v3;
            v7 = v18;
        }
    }
    // 0x10000375c
    *(char *)((0x100000000 * v2 >> 32) + v2) = 0;
    int64_t result = v7; // 0x100003854
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x10000385c
        result = ___stack_chk_fail();
    }
    // 0x100003860
    return result;
}

// Address range: 0x100003874 - 0x1000038c4
int64_t entry_point(void) {
    // 0x100003874
    return ___chkstk_darwin((int64_t)_strlen(g2));
}

// Address range: 0x1000038c4 - 0x100003a84
int64_t function_1000038c4(void) {
    // 0x1000038c4
    int64_t v1; // 0x1000038c4
    int64_t v2; // 0x1000038c4
    int64_t v3 = (int64_t)&v1 - *(int64_t *)(v2 - 168); // 0x1000038cc
    int64_t * v4 = (int64_t *)(v2 - 160); // 0x1000038d4
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 - 132); // 0x1000038dc
    *v5 = 0;
    int64_t v6 = v2 - 152; // 0x1000038e8
    int64_t * v7 = (int64_t *)v6;
    *v7 = (int64_t)g1;
    int32_t * v8 = (int32_t *)(v2 - 136); // 0x1000038ec
    *v8 = 0;
    char v9 = *g2; // 0x100003900
    if (v9 != 0) {
        char v10; // 0x100003948
        int32_t v11; // 0x100003950
        if (_isupper((int32_t)v9) != 0) {
            // 0x100003938
            v10 = *(char *)((int64_t)*v8 + (int64_t)g2);
            v11 = *v5;
            *v5 = v11 + 1;
            *(int32_t *)(4 * (int64_t)v11 + *v4) = (int32_t)v10 - 65;
        }
        int32_t v12 = *v8 + 1; // 0x100003970
        *v8 = v12;
        char v13 = *(char *)((int64_t)g2 + (int64_t)v12); // 0x100003900
        while (v13 != 0) {
            // 0x100003914
            if (_isupper((int32_t)v13) != 0) {
                // 0x100003938
                v10 = *(char *)((int64_t)*v8 + (int64_t)g2);
                v11 = *v5;
                *v5 = v11 + 1;
                *(int32_t *)(4 * (int64_t)v11 + *v4) = (int32_t)v10 - 65;
            }
            // 0x10000396c
            v12 = *v8 + 1;
            *v8 = v12;
            v13 = *(char *)((int64_t)g2 + (int64_t)v12);
        }
    }
    // 0x100003988
    *v8 = 1;
    int64_t * v14 = (int64_t *)(v2 - 176); // 0x1000039ac
    int64_t v15 = v2 - 144;
    int64_t * v16 = (int64_t *)v15;
    uint32_t v17 = *v5; // 0x1000039a0
    *v14 = v2 - 108;
    function_100003594();
    *v16 = (int64_t)g1;
    *(int64_t *)(v3 - 32) = (int64_t)g1;
    *(int64_t *)(v3 - 24) = (int64_t)*v8;
    *(int64_t *)(v3 - 16) = *v14;
    int128_t v18; // 0x1000038c4
    _printf("%f, key length: %2d, %s", (float64_t)(int64_t)v18, (int64_t)v17, (char *)(int64_t)1);
    float64_t v19 = *(float64_t *)v15; // 0x1000039ec
    float64_t v20 = v19; // 0x1000039ec
    int64_t v21; // 0x1000038c4
    if (v19 > *(float64_t *)v6) {
        // 0x100003a04
        v21 = *v16;
        v20 = v21;
        *v7 = v21;
        _printf(" <--- best so far");
    }
    // 0x100003a1c
    _printf((char *)0x100003f94);
    int32_t v22 = *v8; // 0x100003a2c
    int32_t v23 = v22 + 1; // 0x100003a30
    *v8 = v23;
    while (v22 < 29 != (28 - v22 & v23) < 0) {
        // 0x10000399c
        v17 = *v5;
        *v14 = v2 - 108;
        function_100003594();
        *v16 = (int64_t)v20;
        *(int64_t *)(v3 - 32) = (int64_t)v20;
        *(int64_t *)(v3 - 24) = (int64_t)*v8;
        *(int64_t *)(v3 - 16) = *v14;
        _printf("%f, key length: %2d, %s", (float64_t)(int64_t)v18, (int64_t)v17, (char *)(int64_t)v23);
        v19 = *(float64_t *)v15;
        v20 = v19;
        if (v19 > *(float64_t *)v6) {
            // 0x100003a04
            v21 = *v16;
            v20 = v21;
            *v7 = v21;
            _printf(" <--- best so far");
        }
        // 0x100003a1c
        _printf((char *)0x100003f94);
        v22 = *v8;
        v23 = v22 + 1;
        *v8 = v23;
    }
    // 0x100003a3c
    *(int32_t *)(v2 - 112) = 0;
    int32_t * v24 = (int32_t *)(v2 - 180); // 0x100003a4c
    *v24 = 0;
    int64_t result = 0; // 0x100003a68
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003a70
        ___stack_chk_fail();
        result = (int64_t)*v24;
    }
    // 0x100003a74
    return result;
}

// Address range: 0x100003a84 - 0x100003a90
int64_t function_100003a84(void) {
    // 0x100003a84
    return ___stack_chk_fail();
}

// Address range: 0x100003a90 - 0x100003a9c
int32_t function_100003a90(int32_t c) {
    // 0x100003a90
    return _isupper(c);
}

// Address range: 0x100003a9c - 0x100003aa8
int64_t * function_100003a9c(int64_t * s, int32_t c, int32_t n) {
    // 0x100003a9c
    return _memset(s, c, n);
}

// Address range: 0x100003aa8 - 0x100003ab4
int32_t function_100003aa8(char * format, ...) {
    // 0x100003aa8
    return _printf(format);
}

// Address range: 0x100003ab4 - 0x100003ac0
int32_t function_100003ab4(char * s) {
    // 0x100003ab4
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

int main(int argc, char **argv) {

   int user1 = 0, user2 = 0;
   printf("Enter two integers.  Space delimited, please:  ");
   scanf("%d %d",&user1, &user2);
   int array[user1][user2];
   array[user1/2][user2/2] = user1 + user2;
   printf("array[%d][%d] is %d\n",user1/2,user2/2,array[user1/2][user2/2]);

   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e38(void);
int64_t function_100003f38(int64_t a1);
int32_t function_100003f44(char * format, ...);
int32_t function_100003f50(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(int64_t a1);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003e38
int64_t entry_point(void) {
    // 0x100003d8c
    _printf("Enter two integers.  Space delimited, please:  ");
    int64_t v1; // 0x100003d8c
    return ___chkstk_darwin((int64_t)_scanf("%d %d", (int64_t *)v1, (int64_t *)v1));
}

// Address range: 0x100003e38 - 0x100003f38
int64_t function_100003e38(void) {
    // 0x100003e38
    int64_t v1; // 0x100003e38
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)(v2 - 72); // 0x100003e40
    int64_t v4; // 0x100003e38
    int64_t v5 = (int64_t)&v4 - *(int64_t *)(v2 - 88); // 0x100003e48
    *(int64_t *)(v2 - 48) = *(int64_t *)(v2 - 80);
    *(int64_t *)(v2 - 56) = v3;
    int32_t * v6 = (int32_t *)(v2 - 28); // 0x100003e58
    int32_t v7 = *v6; // 0x100003e58
    int32_t * v8 = (int32_t *)(v2 - 32); // 0x100003e5c
    int32_t v9 = *v8; // 0x100003e5c
    int64_t v10 = 4 * v3;
    *(int32_t *)(v10 * (int64_t)(v7 / 2) + v5 + (int64_t)(4 * v9 / 2)) = v9 + v7;
    int32_t v11 = *v6 / 2; // 0x100003e90
    int32_t v12 = *v8 / 2; // 0x100003e98
    uint32_t v13 = *(int32_t *)(v10 * (int64_t)v11 + v5 + (int64_t)(4 * v12)); // 0x100003ebc
    *(int64_t *)(v5 - 32) = (int64_t)v11;
    *(int64_t *)(v5 - 24) = (int64_t)v12;
    *(int64_t *)(v5 - 16) = (int64_t)v13;
    int32_t v14 = _printf("array[%d][%d] is %d\n", v1, v1, v1); // 0x100003ee8
    *(int32_t *)(v2 - 12) = 0;
    int32_t * v15 = (int32_t *)(v2 - 60); // 0x100003f00
    *v15 = 0;
    int64_t result = 0; // 0x100003f1c
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003f24
        ___stack_chk_fail((int64_t)v14);
        result = (int64_t)*v15;
    }
    // 0x100003f28
    return result;
}

// Address range: 0x100003f38 - 0x100003f44
int64_t function_100003f38(int64_t a1) {
    // 0x100003f38
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include<unistd.h>
#include<stdio.h>
#include<time.h>

#define SHORTLAG 1000
#define LONGLAG  2000

int main(){
	int i,times,hour,min,sec,min1,min2;
	
	time_t t;
	struct tm* currentTime;
	
	while(1){
		time(&t);
		currentTime = localtime(&t);
		
		hour = currentTime->tm_hour;
		min = currentTime->tm_min;
		sec = currentTime->tm_sec;
		
		hour = 12;
		min = 0;
		sec = 0;
		
		if((min==0 || min==30) && sec==0)
			times = ((hour*60 + min)%240)%8;
		if(times==0){
			times = 8;
		}	

		if(min==0){
			min1 = 0;
			min2 = 0;
		}
		
		else{
			min1 = 3;
			min2 = 0;
		}
		
		if((min==0 || min==30) && sec==0){
			printf("\nIt is now %d:%d%d %s. Sounding the bell %d times.",hour,min1,min2,(hour>11)?"PM":"AM",times);
		
			for(i=1;i<=times;i++){
				printf("\a");
				
				(i%2==0)?sleep(LONGLAG):sleep(SHORTLAG);
			}
		}
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
struct tm * function_100003f3c(int32_t * timer);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(int32_t seconds);
int32_t function_100003f60(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

struct tm * _localtime(int32_t * a1);
int32_t _printf(char * a1, ...);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cdc - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003cdc
    while (true) {
      lab_0x100003cf0:;
        // 0x100003cf0
        int64_t v1; // bp-56, 0x100003cdc
        _time((int32_t *)&v1);
        _localtime((int32_t *)&v1);
        int64_t v2; // 0x100003cdc
        _printf("\nIt is now %d:%d%d %s. Sounding the bell %d times.", v2, v2, v2, (char *)v2, v2);
        int32_t v3 = 1; // 0x100003f28
        while (true) {
          lab_0x100003ed8:;
            int32_t v4 = v3;
            _printf((char *)0x100003fa5);
            if (v4 == 2 * v4 / 2) {
                // 0x100003f08
                _sleep(2000);
            } else {
                // 0x100003f14
                _sleep(1000);
            }
            // 0x100003f24
            v3 = v4 + 1;
            int32_t v5 = v4 - 7; // 0x100003ec8
            if (v5 == 0 || v5 < 0 != (v4 + 0x7ffffff9 & v3) < 0) {
                goto lab_0x100003ed8;
            } else {
                goto lab_0x100003cf0;
            }
        }
    }
}

// Address range: 0x100003f3c - 0x100003f48
struct tm * function_100003f3c(int32_t * timer) {
    // 0x100003f3c
    return _localtime(timer);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t seconds) {
    // 0x100003f54
    return _sleep(seconds);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t * timer) {
    // 0x100003f60
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <time.h>

int identity(int x) { return x; }

int sum(int s)
{
  int i;
  for(i=0; i < 1000000; i++) s += i;
  return s;
}

#ifdef CLOCK_PROCESS_CPUTIME_ID
/* cpu time in the current process */
#define CLOCKTYPE  CLOCK_PROCESS_CPUTIME_ID
#else
/* this one should be appropriate to avoid errors on multiprocessors systems */
#define CLOCKTYPE  CLOCK_MONOTONIC
#endif

double time_it(int (*action)(int), int arg)
{
  struct timespec tsi, tsf;

  clock_gettime(CLOCKTYPE, &tsi);
  action(arg);
  clock_gettime(CLOCKTYPE, &tsf);

  double elaps_s = difftime(tsf.tv_sec, tsi.tv_sec);
  long elaps_ns = tsf.tv_nsec - tsi.tv_nsec;
  return elaps_s + ((double)elaps_ns) / 1.0e9;
}

int main()
{
  printf("identity (4) takes %lf s\n", time_it(identity, 4));
  printf("sum      (4) takes %lf s\n", time_it(sum, 4));
  return 0;
}
`,`#include "time-a-function.h"



undefined4 _identity(undefined4 param_1)

{
  return param_1;
}



int _sum(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_4 = param_1;
  for (local_8 = 0; local_8 < 1000000; local_8 = local_8 + 1) {
    local_4 = local_4 + local_8;
  }
  return local_4;
}



undefined  [16] _time_it(code *param_1,undefined4 param_2)

{
  double dVar1;
  undefined auVar2 [16];
  time_t local_40;
  long local_38;
  time_t local_30;
  long local_28;
  undefined4 local_1c;
  code *local_18;
  
  local_1c = param_2;
  local_18 = param_1;
  _clock_gettime(0xc,&local_30);
  (*local_18)(local_1c);
  _clock_gettime(0xc,&local_40);
  dVar1 = _difftime(local_40,local_30);
  auVar2._0_8_ = dVar1 + (double)(local_38 - local_28) / 1000000000.0;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined4 entry(void)

{
  _time_it(_identity);
  _printf("identity (4) takes %lf s\n");
  _time_it(_sum,4);
  _printf("sum      (4) takes %lf s\n");
  return 0;
}



void _clock_gettime(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__clock_gettime_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _difftime(time_t param_1,time_t param_2)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__difftime_100004008)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
   int user1 = 0;
   int space_needed;
   int *a1, **array;
   int row, col, offset;

   printf("Enter size of array:  ");
   scanf("%d",&user1);

   space_needed = (user1+1)*user1/2;
   a1 = malloc(space_needed * sizeof(*a1));
   array = malloc(user1 * sizeof(*array));
   for (row=0,offset=0; row<user1; offset+=(user1-row), row++) {
      array[row]=a1+offset-row;
      for (col=row; col<user1; col++)
          array[row][col] = 1+col-row;
   }
   for (row=0; row<user1; row++)
      printf("%d ", array[row][user1-1]);
   printf("\n");

   free(array);
   free(a1);
   return 0;
}
`,`#include "create-a-two-dimensional-array-at-runtime-4.h"



undefined8 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  int local_44;
  int local_40;
  int local_3c;
  
  _printf("Enter size of array:  ");
  _scanf("%d");
  pvVar1 = _malloc(0);
  pvVar2 = _malloc(0);
  local_44 = 0;
  for (local_3c = 0; local_3c < 0; local_3c = local_3c + 1) {
    *(long *)((long)pvVar2 + (long)local_3c * 8) =
         (long)pvVar1 + (long)local_3c * -4 + (long)local_44 * 4;
    for (local_40 = local_3c; local_40 < 0; local_40 = local_40 + 1) {
      *(int *)(*(long *)((long)pvVar2 + (long)local_3c * 8) + (long)local_40 * 4) =
           (local_40 + 1) - local_3c;
    }
    local_44 = local_44 - local_3c;
  }
  for (local_3c = 0; local_3c < 0; local_3c = local_3c + 1) {
    _printf("%d ");
  }
  _printf("\n");
  _free(pvVar2);
  _free(pvVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>
#include <string.h>

#define N 2200

int main(int argc, char **argv){
   int a,b,c,d;
   int r[N+1];
   memset(r,0,sizeof(r));	// zero solution array
   for(a=1; a<=N; a++){
      for(b=a; b<=N; b++){
	 int aabb;
	 if(a&1 && b&1) continue;  // for positive odd a and b, no solution.
	 aabb=a*a + b*b;
	 for(c=b; c<=N; c++){
	    int aabbcc=aabb + c*c;
	    d=(int)sqrt((float)aabbcc);
	    if(aabbcc == d*d && d<=N) r[d]=1;	// solution
	 }
      }
   }
   for(a=1; a<=N; a++)
      if(!r[a]) printf("%d ",a);	// print non solution
   printf("\n");
}
`,`#include "pythagorean-quadruples-1.h"



undefined4 entry(void)

{
  int iVar1;
  int iVar2;
  uint local_22ac;
  uint local_22a8;
  uint local_22a4;
  int aiStack_228c [2201];
  long local_28;
  
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _bzero(aiStack_228c,0x2264);
  for (local_22a4 = 1; (int)local_22a4 < 0x899; local_22a4 = local_22a4 + 1) {
    for (local_22a8 = local_22a4; (int)local_22a8 < 0x899; local_22a8 = local_22a8 + 1) {
      if (((local_22a4 & 1) == 0) || ((local_22a8 & 1) == 0)) {
        for (local_22ac = local_22a8; (int)local_22ac < 0x899; local_22ac = local_22ac + 1) {
          iVar1 = local_22a4 * local_22a4 + local_22a8 * local_22a8 + local_22ac * local_22ac;
          iVar2 = (int)SQRT((float)iVar1);
          if ((iVar1 == iVar2 * iVar2) && (iVar2 < 0x899)) {
            aiStack_228c[iVar2] = 1;
          }
        }
      }
    }
  }
  for (local_22a4 = 1; (int)local_22a4 < 0x899; local_22a4 = local_22a4 + 1) {
    if (aiStack_228c[(int)local_22a4] == 0) {
      _printf("%d ");
    }
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`typedef unsigned long long int ulong; // define a type that represent the limit (64-bit)

ulong mod_mul(ulong a, ulong b, const ulong mod) {
	ulong res = 0, c; // return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (c = b) >= mod - b ? c -= mod : 0, b += c);
	return res % mod;
}

ulong mod_pow(ulong n, ulong exp, const ulong mod) {
	ulong res = 1; // return (n ^ exp) % mod
	for (n %= mod; exp; exp & 1 ? res = mod_mul(res, n, mod) : 0, n = mod_mul(n, n, mod), exp >>= 1);
	return res;
}

ulong square_root(const ulong N) {
	ulong res = 0, rem = N, c, d;
	for (c = 1 << 62; c; c >>= 2) {
		d = res + c;
		res >>= 1;
		if (rem >= d)
			rem -= d, res += c;
	} // returns the square root of N.
	return res;
}

int is_prime(const ulong N) {
	ulong i = 1; // return a truthy value about the primality of N.
	if (N > 1) for (; i < 64 && mod_pow(i, N - 1, N) <= 1; ++i);
	return i == 64;
}

ulong pollard_rho(const ulong N) {
	// Require : N is a composite number, not a square.
	// Ensure : res is a non-trivial factor of N.
	// Option : change the timeout, change the rand function.
	static const int timeout = 18;
	static unsigned long long rand_val = 2994439072U;
	rand_val = (rand_val * 1025416097U + 286824428U) % 4294967291LLU;
	ulong res = 1, a, b, c, i = 0, j = 1, x = 1, y = 1 + rand_val % (N - 1);
	for (; res == 1; ++i) {
		if (i == j) {
			if (j >> timeout)
				break;
			j <<= 1;
			x = y;
		}
		a = y, b = y; // performs y = (y * y) % N
		for (y = 0; a; a & 1 ? b >= N - y ? y -= N : 0, y += b : 0, a >>= 1, (c = b) >= N - b ? c -= N : 0, b += c);
		y = (1 + y) % N;
		for (a = y > x ? y - x : x - y, b = N; (a %= b) && (b %= a);); // compute the gcd(abs(y - x), N);
		res = a | b;
	}
	return res;
}

void factor(const ulong N, ulong *array) {
	// very basic manager that fill the given array (the size of the result is the first array element)	
	// it does not perform initial trial divisions, which is generally highly recommended.
	if (N < 4 || is_prime(N)) {
		if (N > 1 || !*array) array[++*array] = N;
		return;
	}
	ulong x = square_root(N);
	if (x * x != N) x = pollard_rho(N);
	factor(x, array);
	factor(N / x, array);
}

#include <stdio.h>

int main(void) {
	// simple test.
	unsigned long long n = 18446744073709551615U;
	ulong fac[65] = {0};
	factor(n, fac);
	for (ulong i = 1; i <= *fac; ++i)
		printf("* %llu\n", fac[i]);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003778(void);
int64_t function_10000389c(void);
int64_t function_100003954(void);
int64_t function_1000039fc(void);
int64_t function_100003aac(void);
int64_t function_100003d7c(void);
int64_t function_100003f58(int64_t a1);
void function_100003f64(int64_t * s, int32_t n);
int32_t function_100003f70(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0xb27b83a0; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003778 - 0x10000389c
int64_t function_100003778(void) {
    // 0x100003778
    int64_t v1; // 0x100003778
    uint64_t v2 = v1;
    if (v1 == 0) {
        // 0x100003880
        return 0;
    }
    int64_t v3 = -v2;
    int64_t v4 = 0;
    int64_t v5; // 0x100003778
    uint64_t v6 = v5;
    uint64_t v7 = v1 % v2;
    int64_t v8 = v4; // 0x1000037cc
    int64_t v9; // 0x100003778
    if (v6 % 2 != 0) {
        // 0x1000037d4
        v9 = v7 < v2 - v4 ? 0 : v3;
        v8 = v4 + v7 + v9;
    }
    int64_t v10 = v8;
    int64_t v11 = (v7 < v2 - v7 ? 0 : v3) + 2 * v7; // 0x1000037b4
    v5 = v6 / 2;
    while (v6 >= 2) {
        // 0x1000037c0
        v4 = v10;
        v6 = v5;
        v7 = v11;
        v8 = v4;
        if (v6 % 2 != 0) {
            // 0x1000037d4
            v9 = v7 < v2 - v4 ? 0 : v3;
            v8 = v4 + v7 + v9;
        }
        // 0x100003824
        v10 = v8;
        v11 = (v7 < v2 - v7 ? 0 : v3) + 2 * v7;
        v5 = v6 / 2;
    }
    // 0x100003880
    return v10 % v2;
}

// Address range: 0x10000389c - 0x100003954
int64_t function_10000389c(void) {
    // 0x10000389c
    int64_t v1; // 0x10000389c
    if (v1 == 0) {
        // 0x100003944
        return 1;
    }
    // 0x10000389c
    int64_t v2; // 0x10000389c
    uint64_t v3 = v2;
    int64_t v4 = 1; // 0x1000038fc
    if (v3 % 2 != 0) {
        // 0x100003904
        v4 = function_100003778();
    }
    int64_t result = v4;
    function_100003778();
    v2 = v3 / 2;
    while (v3 >= 2) {
        // 0x1000038f0
        v3 = v2;
        v4 = result;
        if (v3 % 2 != 0) {
            // 0x100003904
            v4 = function_100003778();
        }
        // 0x100003920
        result = v4;
        function_100003778();
        v2 = v3 / 2;
    }
    // 0x100003944
    return result;
}

// Address range: 0x100003954 - 0x1000039fc
int64_t function_100003954(void) {
    // 0x100003954
    int64_t v1; // 0x100003954
    if (v1 == 0) {
        // 0x1000039f0
        return 0;
    }
    int64_t result = 0; // 0x10000397c
    int64_t v2; // 0x100003954
    uint64_t v3 = v2;
    int64_t v4; // 0x100003954
    uint64_t v5 = v4;
    uint64_t v6 = result + v5; // 0x10000398c
    result = (v3 < v6 ? 0 : v5) + result / 2;
    v4 = v5 / 4;
    v2 = v3 - (v3 < v6 ? 0 : v6);
    while (v5 >= 4) {
        // 0x100003984
        v3 = v2;
        v5 = v4;
        v6 = result + v5;
        result = (v3 < v6 ? 0 : v5) + result / 2;
        v4 = v5 / 4;
        v2 = v3 - (v3 < v6 ? 0 : v6);
    }
    // 0x1000039f0
    return result;
}

// Address range: 0x1000039fc - 0x100003aac
int64_t function_1000039fc(void) {
    // 0x1000039fc
    int64_t v1; // 0x1000039fc
    int64_t v2 = v1;
    if (v2 == 1 || v2 == 0) {
        // 0x100003a90
        return false;
    }
    int64_t v3 = 1; // 0x100003a20
    int64_t v4 = function_10000389c(); // 0x100003a58
    int64_t v5 = v3; // 0x100003a70
    while (v4 == 1 || v4 == 0) {
        // 0x100003a7c
        v3++;
        v5 = 64;
        if (v3 >= 64) {
            // break -> 0x100003a90
            break;
        }
        v4 = function_10000389c();
        v5 = v3;
    }
    // 0x100003a90
    return v5 == 64;
}

// Address range: 0x100003aac - 0x100003d7c
int64_t function_100003aac(void) {
    // 0x100003aac
    int64_t v1; // 0x100003aac
    uint64_t v2 = v1;
    g1 = (0x3d1e9ba1 * g1 + 0x111897ec) % 0xfffffffb;
    int64_t v3 = -v2;
    int64_t v4 = 0; // 0x100003aac
    int64_t v5 = 1;
    int64_t v6 = v5; // 0x100003b48
    int64_t v7 = 1; // 0x100003b48
    if (v4 == v5) {
        // 0x100003b50
        if (v5 >= 0x40000) {
            // break -> 0x100003d70
            break;
        }
        // 0x100003b6c
        v6 = 2 * v5;
    }
    int64_t v8 = v7;
    int64_t v9 = v7; // 0x100003ba8
    int64_t v10 = v7; // 0x100003ba8
    int64_t v11 = 0; // 0x100003ba8
    int64_t v12; // 0x100003aac
    int64_t v13; // 0x100003aac
    uint64_t v14; // 0x100003aac
    uint64_t v15; // 0x100003aac
    int64_t v16; // 0x100003aac
    int64_t v17; // 0x100003aac
    if (v7 != 0) {
        v16 = 0;
        v14 = v10;
        v15 = v9;
        v17 = v16;
        if (v14 % 2 != 0) {
            // 0x100003bc8
            v12 = v15 < v2 - v16 ? 0 : v3;
            v17 = v16 + v15 + v12;
        }
        // 0x100003c18
        v13 = v15 < v2 - v15 ? 0 : v3;
        v9 = v13 + 2 * v15;
        v10 = v14 / 2;
        v11 = v17;
        while (v14 >= 2) {
            // 0x100003bb4
            v16 = v17;
            v14 = v10;
            v15 = v9;
            v17 = v16;
            if (v14 % 2 != 0) {
                // 0x100003bc8
                v12 = v15 < v2 - v16 ? 0 : v3;
                v17 = v16 + v15 + v12;
            }
            // 0x100003c18
            v13 = v15 < v2 - v15 ? 0 : v3;
            v9 = v13 + 2 * v15;
            v10 = v14 / 2;
            v11 = v17;
        }
    }
    uint64_t v18 = (v11 + 1) % v2;
    int64_t v19 = v18 == v8 | v18 < v8 ? v8 - v18 : v18 - v8;
    int64_t v20; // 0x100003aac
    uint64_t v21 = v19 % v20;
    int64_t v22 = v20; // 0x100003d0c
    int64_t v23; // 0x100003aac
    int64_t v24; // 0x100003aac
    while (v21 != 0) {
        // 0x100003d3c
        v24 = v20 % v21;
        v23 = v21;
        v20 = v24;
        v22 = 0;
        if (v24 == 0) {
            // break -> 0x100003d4c
            break;
        }
        v21 = v23 % v20;
        v22 = v20;
    }
    int64_t v25 = v22 | v21; // 0x100003d54
    v4++;
    int64_t result = v25; // 0x100003b30
    while (v25 == 1) {
        // 0x100003b38
        v5 = v6;
        v7 = v18;
        v6 = v5;
        int64_t v26 = v8; // 0x100003b48
        if (v4 == v5) {
            // 0x100003b50
            result = 1;
            if (v5 >= 0x40000) {
                // break -> 0x100003d70
                break;
            }
            // 0x100003b6c
            v6 = 2 * v5;
            v26 = v7;
        }
        // 0x100003b84
        v8 = v26;
        v9 = v7;
        v10 = v7;
        v11 = 0;
        if (v7 != 0) {
            v16 = 0;
            v14 = v10;
            v15 = v9;
            v17 = v16;
            if (v14 % 2 != 0) {
                // 0x100003bc8
                v12 = v15 < v2 - v16 ? 0 : v3;
                v17 = v16 + v15 + v12;
            }
            // 0x100003c18
            v13 = v15 < v2 - v15 ? 0 : v3;
            v9 = v13 + 2 * v15;
            v10 = v14 / 2;
            v11 = v17;
            while (v14 >= 2) {
                // 0x100003bb4
                v16 = v17;
                v14 = v10;
                v15 = v9;
                v17 = v16;
                if (v14 % 2 != 0) {
                    // 0x100003bc8
                    v12 = v15 < v2 - v16 ? 0 : v3;
                    v17 = v16 + v15 + v12;
                }
                // 0x100003c18
                v13 = v15 < v2 - v15 ? 0 : v3;
                v9 = v13 + 2 * v15;
                v10 = v14 / 2;
                v11 = v17;
            }
        }
        // 0x100003c74
        v18 = (v11 + 1) % v2;
        v19 = v18 == v8 | v18 < v8 ? v8 - v18 : v18 - v8;
        v21 = v19 % v20;
        v22 = v20;
        while (v21 != 0) {
            // 0x100003d3c
            v24 = v20 % v21;
            v23 = v21;
            v20 = v24;
            v22 = 0;
            if (v24 == 0) {
                // break -> 0x100003d4c
                break;
            }
            v21 = v23 % v20;
            v22 = v20;
        }
        // 0x100003d4c
        v25 = v22 | v21;
        v4++;
        result = v25;
    }
    // 0x100003d70
    return result;
}

// Address range: 0x100003d7c - 0x100003e78
int64_t function_100003d7c(void) {
    // 0x100003d7c
    int64_t v1; // 0x100003d7c
    int64_t v2 = v1;
    uint64_t v3 = v1;
    int64_t result; // 0x100003d7c
    if (v3 >= 4) {
        int64_t v4 = function_1000039fc(); // 0x100003da8
        result = v4;
        if ((int32_t)v4 == 0) {
            int64_t v5 = function_100003954(); // 0x100003e10
            if (v5 * v5 != v3) {
                // 0x100003e38
                function_100003aac();
            }
            // 0x100003e48
            function_100003d7c();
            // 0x100003e6c
            return function_100003d7c();
        }
    }
    // 0x100003dbc
    if (v2 == 0 || v3 != 0 == (v3 != 1)) {
        // 0x100003de8
        *(int64_t *)v2 = v2 + 1;
    }
    // 0x100003e6c
    return result;
}

// Address range: 0x100003e78 - 0x100003f58
int64_t entry_point(void) {
    // 0x100003e78
    int64_t v1; // bp-552, 0x100003e78
    _bzero(&v1, 520);
    uint64_t v2 = v1; // 0x100003ed0
    int64_t v3 = 1; // 0x100003edc
    int64_t v4 = function_100003d7c(); // 0x100003edc
    if (v2 <= 1 != v2 != 1) {
        int32_t v5 = _printf("* %llu\n", (int64_t)&v1); // 0x100003f00
        v3++;
        while (v3 >= v1 != v3 != v1) {
            // 0x100003ee4
            v5 = _printf("* %llu\n", (int64_t)&v1);
            v3++;
        }
        // 0x100003ecc
        v4 = v5;
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f2c
    if (v6 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f40
        ___stack_chk_fail(v4);
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t a1) {
    // 0x100003f58
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(int64_t * s, int32_t n) {
    // 0x100003f64
    _bzero(s, n);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>

#define S 10
typedef struct { double v; int fixed; } node;

#define each(i, x) for(i = 0; i < x; i++)
node **alloc2(int w, int h)
{
	int i;
	node **a = calloc(1, sizeof(node*)*h + sizeof(node)*w*h);
	each(i, h) a[i] = i ? a[i-1] + w : (node*)(a + h);
	return a;
}

void set_boundary(node **m)
{
	m[1][1].fixed =  1; m[1][1].v =  1;
	m[6][7].fixed = -1; m[6][7].v = -1;
}

double calc_diff(node **m, node **d, int w, int h)
{
	int i, j, n;
	double v, total = 0;
	each(i, h) each(j, w) {
		v = 0; n = 0;
		if (i) v += m[i-1][j].v, n++;
		if (j) v += m[i][j-1].v, n++;
		if (i+1 < h) v += m[i+1][j].v, n++;
		if (j+1 < w) v += m[i][j+1].v, n++;

		d[i][j].v = v = m[i][j].v - v / n;
		if (!m[i][j].fixed) total += v * v;
	}
	return total;
}

double iter(node **m, int w, int h)
{
	node **d = alloc2(w, h);
	int i, j;
	double diff = 1e10;
	double cur[] = {0, 0, 0};

	while (diff > 1e-24) {
		set_boundary(m);
		diff = calc_diff(m, d, w, h);
		each(i,h) each(j, w) m[i][j].v -= d[i][j].v;
	}

	each(i, h) each(j, w)
		cur[ m[i][j].fixed + 1 ] += d[i][j].v *
				(!!i + !!j + (i < h-1) + (j < w -1));

	free(d);
	return (cur[2] - cur[0])/2;
}

int main()
{
	node **mesh = alloc2(S, S);
	printf("R = %g\n", 2 / iter(mesh, S, S));
	return 0;
}
`,`#include "resistor-mesh.h"



void * _alloc2(int param_1,int param_2)

{
  void *pvVar1;
  undefined8 local_30;
  undefined4 local_1c;
  
  pvVar1 = _calloc(1,(long)param_2 * 8 + (long)param_1 * 0x10 * (long)param_2);
  for (local_1c = 0; local_1c < param_2; local_1c = local_1c + 1) {
    if (local_1c == 0) {
      local_30 = (void *)((long)pvVar1 + (long)param_2 * 8);
    }
    else {
      local_30 = (void *)(*(long *)((long)pvVar1 + (long)(local_1c + -1) * 8) + (long)param_1 * 0x10
                         );
    }
    *(void **)((long)pvVar1 + (long)local_1c * 8) = local_30;
  }
  return pvVar1;
}



void _set_boundary(long param_1)

{
  *(undefined4 *)(*(long *)(param_1 + 8) + 0x18) = 1;
  *(undefined8 *)(*(long *)(param_1 + 8) + 0x10) = 0x3ff0000000000000;
  *(undefined4 *)(*(long *)(param_1 + 0x30) + 0x78) = 0xffffffff;
  *(undefined8 *)(*(long *)(param_1 + 0x30) + 0x70) = 0xbff0000000000000;
  return;
}



undefined  [16] _calc_diff(long param_1,long param_2,int param_3,int param_4)

{
  byte bVar1;
  double dVar2;
  undefined auVar3 [16];
  undefined8 local_38;
  undefined8 local_30;
  undefined4 local_20;
  undefined4 local_1c;
  
  local_38 = 0;
  for (local_1c = 0; local_1c < param_4; local_1c = local_1c + 1) {
    for (local_20 = 0; local_20 < param_3; local_20 = local_20 + 1) {
      local_30 = 0.0;
      bVar1 = local_1c != 0;
      if ((bool)bVar1) {
        local_30 = *(double *)
                    (*(long *)(param_1 + (long)(local_1c + -1) * 8) + (long)local_20 * 0x10) + 0.0;
      }
      if (local_20 != 0) {
        local_30 = local_30 +
                   *(double *)
                    (*(long *)(param_1 + (long)local_1c * 8) + (long)(local_20 + -1) * 0x10);
        bVar1 = bVar1 + 1;
      }
      if (local_1c + 1 < param_4) {
        local_30 = local_30 +
                   *(double *)
                    (*(long *)(param_1 + (long)(local_1c + 1) * 8) + (long)local_20 * 0x10);
        bVar1 = bVar1 + 1;
      }
      if (local_20 + 1 < param_3) {
        local_30 = local_30 +
                   *(double *)
                    (*(long *)(param_1 + (long)local_1c * 8) + (long)(local_20 + 1) * 0x10);
        bVar1 = bVar1 + 1;
      }
      dVar2 = *(double *)(*(long *)(param_1 + (long)local_1c * 8) + (long)local_20 * 0x10) -
              local_30 / (double)bVar1;
      *(double *)(*(long *)(param_2 + (long)local_1c * 8) + (long)local_20 * 0x10) = dVar2;
      if (*(int *)(*(long *)(param_1 + (long)local_1c * 8) + (long)local_20 * 0x10 + 8) == 0) {
        local_38 = NEON_fmadd(dVar2,dVar2,local_38);
      }
    }
  }
  auVar3._8_8_ = 0;
  auVar3._0_8_ = local_38;
  return auVar3;
}



undefined  [16] _iter(long param_1,int param_2,int param_3)

{
  double *pdVar1;
  void *pvVar2;
  double dVar3;
  undefined auVar4 [16];
  double local_58;
  int local_50;
  int local_4c;
  double local_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = (void *)_alloc2(param_2,param_3);
  local_58 = 10000000000.0;
  local_30[0] = 0.0;
  local_30[1] = 0.0;
  local_30[2] = 0.0;
  while (1e-24 < local_58) {
    _set_boundary(param_1);
    local_58 = (double)_calc_diff(param_1,pvVar2,param_2,param_3);
    for (local_4c = 0; local_4c < param_3; local_4c = local_4c + 1) {
      for (local_50 = 0; local_50 < param_2; local_50 = local_50 + 1) {
        pdVar1 = (double *)(*(long *)(param_1 + (long)local_4c * 8) + (long)local_50 * 0x10);
        *pdVar1 = *pdVar1 - *(double *)
                             (*(long *)((long)pvVar2 + (long)local_4c * 8) + (long)local_50 * 0x10);
      }
    }
  }
  for (local_4c = 0; local_4c < param_3; local_4c = local_4c + 1) {
    for (local_50 = 0; local_50 < param_2; local_50 = local_50 + 1) {
      dVar3 = (double)NEON_fmadd(*(undefined8 *)
                                  (*(long *)((long)pvVar2 + (long)local_4c * 8) +
                                  (long)local_50 * 0x10),
                                 (double)(byte)((local_4c != 0) + (local_50 != 0) +
                                                (local_4c < param_3 + -1) +
                                               (local_50 < param_2 + -1)),
                                 local_30[*(int *)(*(long *)(param_1 + (long)local_4c * 8) +
                                                   (long)local_50 * 0x10 + 8) + 1]);
      local_30[*(int *)(*(long *)(param_1 + (long)local_4c * 8) + (long)local_50 * 0x10 + 8) + 1] =
           dVar3;
    }
  }
  _free(pvVar2);
  auVar4._0_8_ = (local_30[2] - local_30[0]) / 2.0;
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    auVar4._8_8_ = 0;
    return auVar4;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined4 entry(void)

{
  undefined8 uVar1;
  
  uVar1 = _alloc2(10);
  _iter(uVar1,10);
  _printf("R = %g\n");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdio.h>

#define nelems(x) (sizeof(x) / sizeof((x)[0]))

const unsigned long multiplier[] = {1, 3, 5, 7, 11, 3*5, 3*7, 3*11, 5*7, 5*11, 7*11, 3*5*7, 3*5*11, 3*7*11, 5*7*11, 3*5*7*11};

unsigned long long gcd(unsigned long long a, unsigned long long b)
{
    while (b != 0)
    {
        a %= b;
        a ^= b;
        b ^= a;
        a ^= b;
    }

    return a;
}

unsigned long long SQUFOF( unsigned long long N )
{
    unsigned long long D, Po, P, Pprev, Q, Qprev, q, b, r, s;
    unsigned long L, B, i;
    s = (unsigned long long)(sqrtl(N)+0.5);
    if (s*s == N) return s;
    for (int k = 0; k < nelems(multiplier) && N <= 0xffffffffffffffff/multiplier[k]; k++) {
        D = multiplier[k]*N;
        Po = Pprev = P = sqrtl(D);
        Qprev = 1;
        Q = D - Po*Po;
        L = 2 * sqrtl( 2*s );
        B = 3 * L;
        for (i = 2 ; i < B ; i++) {
            b = (unsigned long long)((Po + P)/Q);
            P = b*Q - P;
            q = Q;
            Q = Qprev + b*(Pprev - P);
            r = (unsigned long long)(sqrtl(Q)+0.5);
            if (!(i & 1) && r*r == Q) break;
            Qprev = q;
            Pprev = P;
        };
        if (i >= B) continue;
        b = (unsigned long long)((Po - P)/r);
        Pprev = P = b*r + P;
        Qprev = r;
        Q = (D - Pprev*Pprev)/Qprev;
        i = 0;
        do {
            b = (unsigned long long)((Po + P)/Q);
            Pprev = P;
            P = b*Q - P;
            q = Q;
            Q = Qprev + b*(Pprev - P);
            Qprev = q;
            i++;
        } while (P != Pprev);
        r = gcd(N, Qprev);
        if (r != 1 && r != N) return r;
    }
    return 0;
}

int main(int argc, char *argv[]) {
    int i;
    const unsigned long long data[] = {
        2501,
        12851,
        13289,
        75301,
        120787,
        967009,
        997417,
        7091569,
        13290059,
        42854447,
        223553581,
        2027651281,
        11111111111,
        100895598169,
        1002742628021,
        60012462237239,
        287129523414791,
        9007199254740931,
        11111111111111111,
        314159265358979323,
        384307168202281507,
        419244183493398773,
        658812288346769681,
        922337203685477563,
        1000000000000000127,
        1152921505680588799,
        1537228672809128917,
        4611686018427387877};

    for(int i = 0; i < nelems(data); i++) {
        unsigned long long example, factor, quotient;
        example = data[i];
        factor = SQUFOF(example);
        if(factor == 0) {
            printf("%llu was not factored.\n", example);
        }
        else {
            quotient = example / factor;
            printf("Integer %llu has factors %llu and %llu\n",
               example, factor, quotient);
        }
    }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000386c(void);
int64_t function_1000038e8(void);
int64_t function_100003dd4(int64_t a1);
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003dec(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 1; // 0x100003df8
int64_t g2 = 2501; // 0x100003e78

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000386c - 0x1000038e8
int64_t function_10000386c(void) {
    // 0x10000386c
    int64_t v1; // 0x10000386c
    if (v1 == 0) {
        // 0x1000038dc
        int64_t result; // 0x10000386c
        return result;
    }
    int64_t v2; // 0x10000386c
    int64_t result2 = v2;
    int64_t v3; // 0x10000386c
    int64_t v4 = v3 % result2;
    v3 = result2;
    while (v4 != 0) {
        // 0x100003890
        result2 = v4;
        v4 = v3 % result2;
        v3 = result2;
    }
    // 0x1000038dc
    return result2;
}

// Address range: 0x1000038e8 - 0x100003c9c
int64_t function_1000038e8(void) {
    // 0x1000038e8
    int64_t v1; // 0x1000038e8
    uint64_t v2 = v1;
    int64_t result = sqrt((float64_t)v2) + 0.5; // 0x10000390c
    if (result * result == v2) {
        // 0x100003c8c
        return result;
    }
    uint64_t v3 = 3 * (int64_t)(2.0 * sqrt((float64_t)(2 * result)));
    int64_t v4 = 0;
    int64_t result2; // 0x1000038e8
    while (true) {
        uint64_t v5 = *(int64_t *)(8 * v4 + (int64_t)&g1); // 0x100003974
        uint64_t v6 = 0xffffffffffffffff / v5; // 0x10000397c
        result2 = 0;
        if (v2 != v6 && v2 >= v6) {
            // break -> 0x100003c8c
            break;
        }
        if (v3 > 2) {
            int64_t v7 = v5 * v2; // 0x1000039b0
            int64_t v8 = sqrt((float64_t)v7); // 0x1000039c4
            int64_t v9 = v7 - v8 * v8;
            uint64_t v10 = 2;
            uint64_t v11 = 2 * v8 / v9; // 0x100003a58
            int64_t v12 = v11 * v9 - v8; // 0x100003a70
            int64_t v13 = (v8 - v12) * v11 + 1; // 0x100003a98
            uint64_t v14 = (int64_t)(sqrt((float64_t)v13) + 0.5); // 0x100003ab4
            while (v10 % 2 == 0 != (v14 * v14 == v13)) {
                int64_t v15 = v10 + 1; // 0x100003b0c
                int64_t v16 = v12; // 0x100003a40
                if (v15 >= v3) {
                    goto lab_0x100003c74;
                }
                int64_t v17 = v9;
                v9 = v13;
                v10 = v15;
                v11 = (v16 + v8) / v9;
                v12 = v11 * v9 - v16;
                v13 = (v16 - v12) * v11 + v17;
                v14 = (int64_t)(sqrt((float64_t)v13) + 0.5);
            }
            uint64_t v18 = v8 - v12; // 0x100003b3c
            int64_t v19 = v18 - v18 % v14 + v12; // 0x100003b5c
            int64_t v20 = (v7 - v19 * v19) / v14; // 0x100003b94
            int64_t v21 = v19;
            uint64_t v22 = (v21 + v8) / v20; // 0x100003ba8
            int64_t v23 = v22 * v20 - v21; // 0x100003bc8
            int64_t v24 = v20; // 0x100003c20
            v20 = (v21 - v23) * v22 + v14;
            while (v21 != v23) {
                int64_t v25 = v24;
                v21 = v23;
                v22 = (v21 + v8) / v20;
                v23 = v22 * v20 - v21;
                v24 = v20;
                v20 = (v21 - v23) * v22 + v25;
            }
            int64_t v26 = function_10000386c(); // 0x100003c30
            result2 = v26;
            if (v26 != 1 && v26 != v2) {
                // break -> 0x100003c8c
                break;
            }
        }
      lab_0x100003c74:
        // 0x100003c74
        v4++;
        result2 = 0;
        if (v4 >= 16) {
            // break -> 0x100003c8c
            break;
        }
    }
    // 0x100003c8c
    return result2;
}

// Address range: 0x100003c9c - 0x100003dd4
int64_t entry_point(void) {
    // 0x100003c9c
    int64_t v1; // bp-264, 0x100003c9c
    _memcpy(&v1, &g2, 224);
    int32_t v2; // 0x100003c9c
    for (int32_t i = 0; i < 28; i++) {
        // 0x100003cf8
        if (function_1000038e8() == 0) {
            // 0x100003d28
            v2 = _printf("%llu was not factored.\n", (int64_t)&g2);
        } else {
            // 0x100003d44
            int64_t v3; // 0x100003c9c
            int32_t v4 = _printf("Integer %llu has factors %llu and %llu\n", (int64_t)&g2, 224, v3); // 0x100003d78
            v2 = v4;
        }
    }
    int64_t v5 = *(int64_t *)0x100004008; // 0x100003da4
    if (*(int64_t *)v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003dbc
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003dc0
    return 0;
}

// Address range: 0x100003dd4 - 0x100003de0
int64_t function_100003dd4(int64_t a1) {
    // 0x100003dd4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003de0 - 0x100003dec
int64_t * function_100003de0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003de0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dec - 0x100003df8
int32_t function_100003dec(char * format, ...) {
    // 0x100003dec
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include<stdio.h>

void generateGaps(unsigned long long int start,int count){

    int counter = 0;
    unsigned long long int i = start;
    char str[100];

    printf("\nFirst %d Gapful numbers >= %llu :\n",count,start);

    while(counter<count){
        sprintf(str,"%llu",i);
        if((i%(10*(str[0]-'0') + i%10))==0L){
            printf("\n%3d : %llu",counter+1,i);
            counter++;
        }
        i++;
    }
}

int main()
{
    unsigned long long int i = 100;
    int count = 0;
    char str[21];

    generateGaps(100,30);
    printf("\n");
    generateGaps(1000000,15);
    printf("\n");
    generateGaps(1000000000,15);
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d4c(void);
int64_t function_100003f4c(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003f58(int64_t a1);
int32_t function_100003f64(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d4c - 0x100003ea0
int64_t function_100003d4c(void) {
    // 0x100003d4c
    int64_t v1; // 0x100003d4c
    int32_t v2 = v1; // 0x100003d6c
    int32_t v3 = -v2; // 0x100003dac
    int64_t v4 = _printf("\nFirst %d Gapful numbers >= %llu :\n", v1, v1); // 0x100003db4
    if (v3 < 0 != (v3 & v2) < 0) {
        int32_t v5 = 0;
        int64_t v6; // 0x100003d4c
        uint64_t v7 = v6;
        int64_t v8; // bp-124, 0x100003d4c
        int64_t v9 = ___sprintf_chk(&v8, 0, 100, "%llu"); // 0x100003ddc
        int32_t v10 = v5; // 0x100003e20
        int64_t v11 = v9; // 0x100003e20
        if (v7 % (v7 % 10 + (int64_t)(10 * (0x1000000 * (int32_t)v8 >> 24) - 480)) == 0) {
            // 0x100003e28
            v10 = v5 + 1;
            v11 = _printf("\n%3d : %llu", 0, 100);
        }
        int32_t v12 = v10;
        int32_t v13 = v12 - v2; // 0x100003dac
        v6 = v7 + 1;
        v4 = v11;
        while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v2)) < 0) {
            // 0x100003dbc
            v5 = v12;
            v7 = v6;
            v9 = ___sprintf_chk(&v8, 0, 100, "%llu");
            v10 = v5;
            v11 = v9;
            if (v7 % (v7 % 10 + (int64_t)(10 * (0x1000000 * (int32_t)v8 >> 24) - 480)) == 0) {
                // 0x100003e28
                v10 = v5 + 1;
                v11 = _printf("\n%3d : %llu", 0, 100);
            }
            // 0x100003e60
            v12 = v10;
            v13 = v12 - v2;
            v6 = v7 + 1;
            v4 = v11;
        }
    }
    int64_t v14 = *(int64_t *)0x100004010; // 0x100003e78
    int64_t result = v4; // 0x100003e88
    if (*(int64_t *)v14 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003e90
        result = ___stack_chk_fail(v4);
    }
    // 0x100003e94
    return result;
}

// Address range: 0x100003ea0 - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003ea0
    function_100003d4c();
    _printf((char *)0x100003fa5);
    function_100003d4c();
    _printf("\n");
    function_100003d4c();
    int32_t v1 = _printf("\n"); // 0x100003f14
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003f24
    if (v2 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003f38
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f3c
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int64_t function_100003f4c(int64_t * a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003f4c
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t a1) {
    // 0x100003f58
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

int main()
{
  int door, square, increment;
  for (door = 1, square = 1, increment = 1; door <= 100; door++ == square && (square += increment += 2))
    printf("door #%d is %s.\n", door, (door == square? "open" : "closed"));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ea4 - 0x100003f7c
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003ea4
    _printf("door #%d is %s.\n", v2, (char *)v2);
    int32_t v3 = v1 + 1; // 0x100003f30
    while (v1 == 99 || v1 < 99 != (98 - v1 & v3) < 0) {
        // 0x100003edc
        v1 = v3;
        _printf("door #%d is %s.\n", v2, (char *)v2);
        v3 = v1 + 1;
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <math.h>

int main() {
    int n = 1, count = 0, sq, cr;
    for ( ; count < 30; ++n) {
        sq = n * n;
        cr = (int)cbrt((double)sq);
        if (cr * cr * cr != sq) {
            count++;
            printf("%d\n", sq);
        }
        else {
            printf("%d is square and cube\n", sq);
        }
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f74(float64_t a1);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

float64_t _cbrt(float64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e7c - 0x100003f74
int64_t entry_point(void) {
    // 0x100003e7c
    float64_t v1; // 0x100003e7c
    int32_t v2 = v1;
    int32_t v3 = 0;
    int32_t v4 = 1;
    _cbrt((float64_t)(int64_t)__asm_sshll(0.0f, 0));
    int32_t v5; // 0x100003e7c
    int64_t v6; // 0x100003e7c
    if (v2 * v2 * v2 == v4 * v4) {
        // 0x100003f30
        _printf("%d is square and cube\n", v6);
        v5 = v3;
    } else {
        // 0x100003f04
        _printf("%d\n", v6);
        v5 = v3 + 1;
    }
    int32_t v7 = v4 + 1; // 0x100003ea8
    while (v5 < 30 != (29 - v5 & v5) < 0) {
        // 0x100003eb0
        v3 = v5;
        v4 = v7;
        _cbrt((float64_t)(int64_t)__asm_sshll(0.0f, 0));
        if (v2 * v2 * v2 == v4 * v4) {
            // 0x100003f30
            _printf("%d is square and cube\n", v6);
            v5 = v3;
        } else {
            // 0x100003f04
            _printf("%d\n", v6);
            v5 = v3 + 1;
        }
        // 0x100003f54
        v7 = v4 + 1;
    }
    // 0x100003f64
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
float64_t function_100003f74(float64_t a1) {
    // 0x100003f74
    return _cbrt(a1);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>

int icmp(const void *a, const void *b)
{
	return *(const int*)a < *(const int*)b ? -1 : *(const int*)a > *(const int*)b;
}

void leaf_plot(int *x, int len)
{
	int i, j, d;

	qsort(x, len, sizeof(int), icmp);

	i = x[0] / 10 - 1;
	for (j = 0; j < len; j++) {
		d = x[j] / 10;
		while (d > i) printf("%s%3d |", j ? "\n" : "", ++i);
		printf(" %d", x[j] % 10);
	}
}

int main()
{
	int data[] = {
	  12, 127,  28,  42,  39, 113,  42,  18,  44, 118,  44,  37, 113, 124,
	  37,  48, 127,  36,  29,  31, 125, 139, 131, 115, 105, 132, 104, 123,
	  35, 113, 122,  42, 117, 119,  58, 109,  23, 105,  63,  27,  44, 105,
	  99,  41, 128, 121, 116, 125,  32,  61,  37, 127,  29, 113, 121,  58,
	 114, 126,  53, 114,  96,  25, 109,   7,  31, 141,  46,  13,  27,  43,
	 117, 116,  27,   7,  68,  40,  31, 115, 124,  42, 128,  52,  71, 118,
	 117,  38,  27, 106,  33, 117, 116, 111,  40, 119,  47, 105,  57, 122,
	 109, 124, 115,  43, 120,  43,  27,  27,  18,  28,  48, 125, 107, 114,
	  34, 133,  45, 120,  30, 127,  31, 116, 146 };

	leaf_plot(data, sizeof(data)/sizeof(data[0]));

	return 0;
}
`,`#include "stem-and-leaf-plot-1.h"



uint _icmp(int *param_1,int *param_2)

{
  undefined4 local_14;
  
  if (*param_1 < *param_2) {
    local_14 = 0xffffffff;
  }
  else {
    local_14 = (uint)(*param_2 < *param_1);
  }
  return local_14;
}



void _leaf_plot(int *param_1,int param_2)

{
  int iVar1;
  int local_24;
  int local_20;
  
  _qsort(param_1,(long)param_2,4,(int *)_icmp);
  local_20 = *param_1 / 10 + -1;
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    iVar1 = param_1[local_24];
    while (local_20 < iVar1 / 10) {
      local_20 = local_20 + 1;
      _printf("%s%3d |");
    }
    _printf(" %d");
  }
  return;
}



undefined8 entry(void)

{
  undefined auStack_20c [484];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_20c,&DAT_100003db4,0x1e4);
  _leaf_plot(auStack_20c,0x79);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003da0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004020)();
  return;
}


`
`#include <stdio.h>

int next_perm(int size, int * nums)
{
        int *l, *k, tmp;

        for (k = nums + size - 2; k >= nums && k[0] >= k[1]; k--) {};
        if (k < nums) return 0;

        for (l = nums + size - 1; *l <= *k; l--) {};
        tmp = *k; *k = *l; *l = tmp;

        for (l = nums + size - 1, k++; k < l; k++, l--) {
                tmp = *k; *k = *l; *l = tmp;
        }

        return 1;
}

void make_part(int n, int * sizes)
{
        int x[1024], i, j, *ptr, len = 0;

        for (ptr = x, i = 0; i < n; i++)
                for (j = 0, len += sizes[i]; j < sizes[i]; j++, *(ptr++) = i);

        do {
                for (i = 0; i < n; i++) {
                        printf(" { ");
                        for (j = 0; j < len; j++)
                                if (x[j] == i) printf("%d ", j);

                        printf("}");
                }
                printf("\n");
        } while (next_perm(len, x));
}

int main()
{
        int s1[] = {2, 0, 2};
        int s2[] = {1, 2, 3, 4};

        printf("Part 2 0 2:\n");
        make_part(3, s1);

        printf("\nPart 1 2 3 4:\n");
        make_part(4, s2);

        return 1;
}
`,`#include "ordered-partitions-1.h"



undefined4 _next_perm(int param_1,int *param_2)

{
  bool bVar1;
  int iVar2;
  int *local_20;
  int *local_18;
  undefined4 local_4;
  
  local_20 = param_2 + (long)param_1 + -2;
  while( true ) {
    bVar1 = false;
    if (param_2 <= local_20) {
      bVar1 = local_20[1] <= *local_20;
    }
    if (!bVar1) break;
    local_20 = local_20 + -1;
  }
  if (local_20 < param_2) {
    local_4 = 0;
  }
  else {
    local_18 = param_2 + param_1;
    do {
      local_18 = local_18 + -1;
    } while (*local_18 <= *local_20);
    iVar2 = *local_20;
    *local_20 = *local_18;
    *local_18 = iVar2;
    local_18 = param_2 + param_1;
    while( true ) {
      local_18 = local_18 + -1;
      local_20 = local_20 + 1;
      if (local_18 <= local_20) break;
      iVar2 = *local_20;
      *local_20 = *local_18;
      *local_18 = iVar2;
    }
    local_4 = 1;
  }
  return local_4;
}



void _make_part(void)

{
  int iVar1;
  int iVar2;
  long extraout_x1;
  int local_104c;
  int *local_1048;
  int local_1040;
  int local_103c;
  int local_1028 [1024];
  long local_28;
  
  iVar1 = (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_104c = 0;
  local_1048 = local_1028;
  for (local_103c = 0; local_103c < iVar1; local_103c = local_103c + 1) {
    local_1040 = 0;
    local_104c = local_104c + *(int *)(extraout_x1 + (long)local_103c * 4);
    while (local_1040 < *(int *)(extraout_x1 + (long)local_103c * 4)) {
      local_1040 = local_1040 + 1;
      *local_1048 = local_103c;
      local_1048 = local_1048 + 1;
    }
  }
  do {
    for (local_103c = 0; local_103c < iVar1; local_103c = local_103c + 1) {
      _printf(" { ");
      for (local_1040 = 0; local_1040 < local_104c; local_1040 = local_1040 + 1) {
        if (local_1028[local_1040] == local_103c) {
          _printf("%d ");
        }
      }
      _printf("}");
    }
    _printf("\n");
    iVar2 = _next_perm(local_104c,local_1028);
  } while (iVar2 != 0);
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_28;
  undefined4 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_28 = 2;
  local_20 = 2;
  uStack_38 = 0x400000003;
  local_40 = 0x200000001;
  _printf("Part 2 0 2:\n");
  _make_part(3,&local_28);
  _printf("\nPart 1 2 3 4:\n");
  _make_part(4,&local_40);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 1;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void vc(int n, int base, int *num, int *denom)
{
        int p = 0, q = 1;

        while (n) {
                p = p * base + (n % base);
                q *= base;
                n /= base;
        }

        *num = p;
        *denom = q;

        while (p) { n = p; p = q % p; q = n; }
        *num /= q;
        *denom /= q;
}

int main()
{
        int d, n, i, b;
        for (b = 2; b < 6; b++) {
                printf("base %d:", b);
                for (i = 0; i < 10; i++) {
                        vc(i, b, &n, &d);
                        if (n) printf("  %d/%d", n, d);
                        else   printf("  0");
                }
                printf("\n");
        }

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d5c(void);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d5c - 0x100003e6c
int64_t function_100003d5c(void) {
    // 0x100003d5c
    int64_t result; // 0x100003d5c
    int32_t v1 = result; // 0x100003d60
    int32_t v2 = result; // 0x100003d64
    int32_t * v3 = (int32_t *)result; // 0x100003d68
    int32_t * v4 = (int32_t *)result; // 0x100003d6c
    int32_t v5 = 1; // 0x100003d8c
    int32_t v6 = v1; // 0x100003d8c
    int32_t v7 = 0; // 0x100003d8c
    int32_t v8; // 0x100003d5c
    if (v1 == 0) {
        // 0x100003de0
        *v3 = 0;
        *v4 = 1;
        v8 = 1;
    } else {
        v7 = v6 % v2 + v7 * v2;
        v5 *= v2;
        v6 /= v2;
        while (v6 != 0) {
            // 0x100003d94
            v7 = v6 % v2 + v7 * v2;
            v5 *= v2;
            v6 /= v2;
        }
        // 0x100003de0
        *v3 = v7;
        *v4 = v5;
        v8 = v5;
        if (v7 != 0) {
            int32_t v9 = v5 % v7;
            int32_t v10 = v7; // 0x100003e08
            v8 = v7;
            while (v9 != 0) {
                int32_t v11 = v9;
                v9 = v10 % v11;
                v10 = v11;
                v8 = v11;
            }
        }
    }
    // 0x100003e3c
    int64_t v12; // 0x100003d5c
    *v3 = *(int32_t *)&v12 / v8;
    int64_t v13; // 0x100003d5c
    *v4 = *(int32_t *)&v13 / v8;
    return result;
}

// Address range: 0x100003e6c - 0x100003f7c
int64_t entry_point(void) {
    int64_t v1 = 2;
    int64_t v2; // 0x100003e6c
    _printf("base %d:", v2);
    int32_t v3; // bp-28, 0x100003e6c
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003ed4
        function_100003d5c();
        if (v3 == 0) {
            // 0x100003f28
            _printf("  0");
        } else {
            // 0x100003efc
            _printf("  %d/%d", v1, (int64_t)&v3);
        }
    }
    // 0x100003f4c
    _printf((char *)0x100003f9d);
    int64_t v4 = v1 + 1;
    v2 = v1;
    while (v4 != 6) {
        // 0x100003e9c
        v1 = v4;
        _printf("base %d:", v2);
        for (int32_t i = 0; i < 10; i++) {
            // 0x100003ed4
            function_100003d5c();
            if (v3 == 0) {
                // 0x100003f28
                _printf("  0");
            } else {
                // 0x100003efc
                _printf("  %d/%d", v1, (int64_t)&v3);
            }
        }
        // 0x100003f4c
        _printf((char *)0x100003f9d);
        v4 = v1 + 1;
        v2 = v1;
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

int is_leap_year(unsigned year)
{
    return !(year & (year % 100 ? 3 : 15));
}

int main(void)
{
    const unsigned test_case[] = {
        1900, 1994, 1996, 1997, 2000, 2024, 2025, 2026, 2100
    };
    const unsigned n = sizeof test_case / sizeof test_case[0];

    for (unsigned i = 0; i != n; ++i) {
        unsigned year = test_case[i];
        printf("%u is %sa leap year.\n", year, is_leap_year(year) ? "" : "not ");
    }
    return 0;
}
`,`#include "leap-year.h"



bool _is_leap_year(uint param_1)

{
  uint uVar1;
  
  uVar1 = 3;
  if (param_1 % 100 == 0) {
    uVar1 = 0xf;
  }
  return (param_1 & uVar1) == 0;
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  uint local_48;
  undefined4 auStack_3c [9];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memcpy(auStack_3c,&DAT_100003f60,0x24);
  for (local_48 = 0; local_48 != 9; local_48 = local_48 + 1) {
    _is_leap_year(auStack_3c[local_48]);
    uVar1 = _printf("%u is %sa leap year.\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

void pascal_low(int **mat, int n) {
    int i, j;

    for (i = 0; i < n; ++i)
        for (j = 0; j < n; ++j)
            if (i < j)
                mat[i][j] = 0;
            else if (i == j || j == 0)
                mat[i][j] = 1;
            else
                mat[i][j] = mat[i - 1][j - 1] + mat[i - 1][j];
}

void pascal_upp(int **mat, int n) {
    int i, j;

    for (i = 0; i < n; ++i)
        for (j = 0; j < n; ++j)
            if (i > j)
                mat[i][j] = 0;
            else if (i == j || i == 0)
                mat[i][j] = 1;
            else
                mat[i][j] = mat[i - 1][j - 1] + mat[i][j - 1];
}

void pascal_sym(int **mat, int n) {
    int i, j;

    for (i = 0; i < n; ++i)
        for (j = 0; j < n; ++j)
            if (i == 0 || j == 0)
                mat[i][j] = 1;
            else
                mat[i][j] = mat[i - 1][j] + mat[i][j - 1];
}

int main(int argc, char * argv[]) {
    int **mat;
    int i, j, n;

    /* Input size of the matrix */
    n = 5;

    /* Matrix allocation */
    mat = calloc(n, sizeof(int *));
    for (i = 0; i < n; ++i)
        mat[i] = calloc(n, sizeof(int));

    /* Matrix computation */
    printf("=== Pascal upper matrix ===\n");
    pascal_upp(mat, n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            printf("%4d%c", mat[i][j], j < n - 1 ? ' ' : '\n');

    printf("=== Pascal lower matrix ===\n");
    pascal_low(mat, n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            printf("%4d%c", mat[i][j], j < n - 1 ? ' ' : '\n');

    printf("=== Pascal symmetric matrix ===\n");
    pascal_sym(mat, n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            printf("%4d%c", mat[i][j], j < n - 1 ? ' ' : '\n');

    return 0;
}
`,`#include "pascal-matrix-generation.h"



void _pascal_low(long param_1,int param_2)

{
  int local_14;
  int local_10;
  
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
      if (local_10 < local_14) {
        *(undefined4 *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) = 0;
      }
      else if ((local_10 == local_14) || (local_14 == 0)) {
        *(undefined4 *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) = 1;
      }
      else {
        *(int *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) =
             *(int *)(*(long *)(param_1 + (long)(local_10 + -1) * 8) + (long)(local_14 + -1) * 4) +
             *(int *)(*(long *)(param_1 + (long)(local_10 + -1) * 8) + (long)local_14 * 4);
      }
    }
  }
  return;
}



void _pascal_upp(long param_1,int param_2)

{
  int local_14;
  int local_10;
  
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
      if (local_14 < local_10) {
        *(undefined4 *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) = 0;
      }
      else if ((local_10 == local_14) || (local_10 == 0)) {
        *(undefined4 *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) = 1;
      }
      else {
        *(int *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) =
             *(int *)(*(long *)(param_1 + (long)(local_10 + -1) * 8) + (long)(local_14 + -1) * 4) +
             *(int *)(*(long *)(param_1 + (long)local_10 * 8) + (long)(local_14 + -1) * 4);
      }
    }
  }
  return;
}



void _pascal_sym(long param_1,int param_2)

{
  int local_14;
  int local_10;
  
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
      if ((local_10 == 0) || (local_14 == 0)) {
        *(undefined4 *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) = 1;
      }
      else {
        *(int *)(*(long *)(param_1 + (long)local_10 * 8) + (long)local_14 * 4) =
             *(int *)(*(long *)(param_1 + (long)(local_10 + -1) * 8) + (long)local_14 * 4) +
             *(int *)(*(long *)(param_1 + (long)local_10 * 8) + (long)(local_14 + -1) * 4);
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  int local_30;
  int local_2c;
  
  pvVar1 = _calloc(5,8);
  for (local_2c = 0; local_2c < 5; local_2c = local_2c + 1) {
    pvVar2 = _calloc(5,4);
    *(void **)((long)pvVar1 + (long)local_2c * 8) = pvVar2;
  }
  _printf("=== Pascal upper matrix ===\n");
  _pascal_upp(pvVar1,5);
  for (local_2c = 0; local_2c < 5; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < 5; local_30 = local_30 + 1) {
      _printf("%4d%c");
    }
  }
  _printf("=== Pascal lower matrix ===\n");
  _pascal_low(pvVar1,5);
  for (local_2c = 0; local_2c < 5; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < 5; local_30 = local_30 + 1) {
      _printf("%4d%c");
    }
  }
  _printf("=== Pascal symmetric matrix ===\n");
  _pascal_sym(pvVar1,5);
  for (local_2c = 0; local_2c < 5; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < 5; local_30 = local_30 + 1) {
      _printf("%4d%c");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int spiral(int w, int h, int x, int y)
{
	return y ? w + spiral(h - 1, w, y - 1, w - x - 1) : x;
}

int main(int argc, char **argv)
{
	int w = atoi(argv[1]), h = atoi(argv[2]), i, j;
	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++)
			printf("%4d", spiral(w, h, j, i));
		putchar('\n');
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e10(void);
int32_t function_100003f80(char * nptr);
int32_t function_100003f8c(char * format, ...);
int32_t function_100003f98(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e10 - 0x100003e9c
int64_t function_100003e10(void) {
    // 0x100003e10
    int64_t v1; // 0x100003e10
    int64_t v2; // 0x100003e10
    if ((int32_t)v2 != 0) {
        // 0x100003e40
        v1 = function_100003e10() + v2;
    }
    // 0x100003e8c
    return v1 & 0xffffffff;
}

// Address range: 0x100003e9c - 0x100003f80
int64_t entry_point(void) {
    // 0x100003e9c
    int64_t v1; // 0x100003e9c
    int32_t v2 = _atoi((char *)*(int64_t *)(v1 + 8)); // 0x100003ebc
    uint32_t v3 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003ecc
    int32_t v4 = -v3; // 0x100003ee4
    if (v4 < 0 == (v3 & v4) < 0) {
        // 0x100003f70
        return 0;
    }
    int32_t v5 = -v2; // 0x100003f04
    int32_t v6 = 0; // 0x100003f64
    int32_t v7; // 0x100003e9c
    int32_t v8; // 0x100003f48
    int32_t v9; // 0x100003f04
    if (v5 < 0 != (v2 & v5) < 0) {
        function_100003e10();
        _printf("%4d", (int64_t)v3);
        v8 = 1;
        v9 = v8 - v2;
        v7 = v8;
        while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003f14
            function_100003e10();
            _printf("%4d", (int64_t)v3);
            v8 = v7 + 1;
            v9 = v8 - v2;
            v7 = v8;
        }
    }
    // 0x100003f54
    _putchar(10);
    v6++;
    while (v6 - v3 < 0 != ((v6 - v3 ^ v6) & (v6 ^ v3)) < 0) {
        // 0x100003efc
        if (v5 < 0 != (v2 & v5) < 0) {
            function_100003e10();
            _printf("%4d", (int64_t)v3);
            v8 = 1;
            v9 = v8 - v2;
            v7 = v8;
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v2)) < 0) {
                // 0x100003f14
                function_100003e10();
                _printf("%4d", (int64_t)v3);
                v8 = v7 + 1;
                v9 = v8 - v2;
                v7 = v8;
            }
        }
        // 0x100003f54
        _putchar(10);
        v6++;
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * nptr) {
    // 0x100003f80
    return _atoi(nptr);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(int32_t c) {
    // 0x100003f98
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`/*
 * File extension is in extensions list (dots allowed).
 *
 * This problem is trivial because the so-called extension is simply the end
 * part of the name.
 */

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <locale.h>
#include <string.h>

#ifdef _Bool
#include <stdbool.h>
#else
#define bool int
#define true  1
#define false 0
#endif

/*
 * The implemented algorithm is not the most efficient one: for N extensions
 * of length M it has the cost O(N * M).
 */
int checkFileExtension(char* fileName, char* fileExtensions)
{
    char* fileExtension = fileExtensions;

    if ( *fileName )
    {
        while ( *fileExtension )
        {
            int fileNameLength = strlen(fileName);
            int extensionLength = strlen(fileExtension);
            if ( fileNameLength >= extensionLength )
            {
                char* a = fileName + fileNameLength - extensionLength;
                char* b = fileExtension;
                while ( *a && toupper(*a++) == toupper(*b++) )
                    ;
                if ( !*a )
                    return true;
            }
            fileExtension += extensionLength + 1;
        }
    }
    return false;
}

void printExtensions(char* extensions)
{
    while( *extensions )
    {
        printf("%s\n", extensions);
        extensions += strlen(extensions) + 1;
    }
}

bool test(char* fileName, char* extension, bool expectedResult)
{
    bool result = checkFileExtension(fileName,extension);
    bool returnValue = result == expectedResult;
    printf("%20s  result: %-5s  expected: %-5s  test %s\n",
        fileName,
        result         ? "true"   : "false",
        expectedResult ? "true"   : "false",
        returnValue    ? "passed" : "failed" );
    return returnValue;
}

int main(void)
{
    static char extensions[] = ".zip\0.rar\0.7z\0.gz\0.archive\0.A##\0.tar.bz2\0";

    setlocale(LC_ALL,"");

    printExtensions(extensions);
    printf("\n");

    if ( test("MyData.a##",         extensions,true )
    &&   test("MyData.tar.Gz",      extensions,true )
    &&   test("MyData.gzip",        extensions,false)
    &&   test("MyData.7z.backup",   extensions,false)
    &&   test("MyData...",          extensions,false)
    &&   test("MyData",             extensions,false)
    &&   test("MyData_v1.0.tar.bz2",extensions,true )
    &&   test("MyData_v1.0.bz2",    extensions,false)
    &&   test("filename",           extensions,false)
    )
        printf("\n%s\n", "All tests passed.");
    else
        printf("\n%s\n", "Last test failed.");

    printf("\n%s\n", "press enter");
    getchar();
    return 0;
}
`,`#include "file-extension-is-in-extensions-list-1.h"



undefined4 _checkFileExtension(char *param_1,char *param_2)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  size_t sVar4;
  size_t sVar5;
  int iVar6;
  char *local_48;
  char *local_40;
  char *local_30;
  
  local_30 = param_2;
  if (*param_1 != '\0') {
    for (; *local_30 != '\0'; local_30 = local_30 + (iVar6 + 1)) {
      sVar4 = _strlen(param_1);
      sVar5 = _strlen(local_30);
      iVar6 = (int)sVar5;
      if (iVar6 <= (int)sVar4) {
        local_40 = param_1 + ((long)(int)sVar4 - (long)iVar6);
        local_48 = local_30;
        do {
          bVar1 = false;
          if (*local_40 != '\0') {
            iVar2 = _toupper((int)*local_40);
            iVar3 = _toupper((int)*local_48);
            bVar1 = iVar2 == iVar3;
            local_48 = local_48 + 1;
            local_40 = local_40 + 1;
          }
        } while (bVar1);
        if (*local_40 == '\0') {
          return 1;
        }
      }
    }
  }
  return 0;
}



void _printExtensions(char *param_1)

{
  size_t sVar1;
  char *local_18;
  
  for (local_18 = param_1; *local_18 != '\0'; local_18 = local_18 + sVar1 + 1) {
    _printf("%s\n");
    sVar1 = _strlen(local_18);
  }
  return;
}



bool _test(undefined8 param_1,undefined8 param_2,int param_3)

{
  int iVar1;
  
  iVar1 = _checkFileExtension(param_1,param_2);
  _printf("%20s  result: %-5s  expected: %-5s  test %s\n");
  return iVar1 == param_3;
}



undefined8 entry(void)

{
  int iVar1;
  
  _setlocale(0,"");
  _printExtensions();
  _printf("\n");
  iVar1 = _test("MyData.a##",&DAT_100008000,1);
  if (iVar1 != 0) {
    iVar1 = _test("MyData.tar.Gz",&DAT_100008000,1);
    if (iVar1 != 0) {
      iVar1 = _test("MyData.gzip",&DAT_100008000,0);
      if (iVar1 != 0) {
        iVar1 = _test("MyData.7z.backup",&DAT_100008000,0);
        if (iVar1 != 0) {
          iVar1 = _test("MyData...",&DAT_100008000,0);
          if (iVar1 != 0) {
            iVar1 = _test("MyData",&DAT_100008000,0);
            if (iVar1 != 0) {
              iVar1 = _test("MyData_v1.0.tar.bz2",&DAT_100008000,1);
              if (iVar1 != 0) {
                iVar1 = _test("MyData_v1.0.bz2",&DAT_100008000,0);
                if ((iVar1 != 0) && (iVar1 = _test("filename",&DAT_100008000,0), iVar1 != 0)) {
                  _printf("\n%s\n");
                  goto LAB_100003e44;
                }
              }
            }
          }
        }
      }
    }
  }
  _printf("\n%s\n");
LAB_100003e44:
  _printf("\n%s\n");
  _getchar();
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004000)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004018)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _toupper(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__toupper_100004020)(_c);
  return iVar1;
}


`
`#include <stdio.h>

const char DIGITS[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
const int DIGITS_LEN = 64;

void encodeNegativeBase(long n, long base, char *out) {
    char *ptr = out;

    if (base > -1 || base < -62) {
        /* Bounds check*/
        out = "";
        return;
    }
    if (n == 0) {
        /* Trivial case */
        out = "0";
        return;
    }

    /* Convert the number into a string (in reverse) */
    while (n != 0) {
        long rem = n % base;
        n = n / base;
        if (rem < 0) {
            n++;
            rem = rem - base;
        }
        *ptr = DIGITS[rem];
        ptr++;
    }
    *ptr = 0;

    /* Reverse the current string to get the final result */
    ptr--;
    while (out < ptr) {
        char t = *out;
        *out = *ptr;
        *ptr = t;
        out++;
        ptr--;
    }
    return;
}

long decodeNegativeBase(const char* ns, long base) {
    long value, bb;
    int i;
    const char *ptr;

    if (base < -62 || base > -1) {
        /* Bounds check */
        return 0;
    }
    if (ns[0] == 0 || (ns[0] == '0' && ns[1] == 0)) {
        /* Trivial case */
        return 0;
    }

    /* Find the end of the string */
    ptr = ns;
    while (*ptr != 0) {
        ptr++;
    }

    /* Convert */
    value = 0;
    bb = 1;
    ptr--;
    while (ptr >= ns) {
        for (i = 0; i < DIGITS_LEN; i++) {
            if (*ptr == DIGITS[i]) {
                value = value + i * bb;
                bb = bb * base;
                break;
            }
        }
        ptr--;
    }

    return value;
}

void driver(long n, long b) {
    char buf[64];
    long value;

    encodeNegativeBase(n, b, buf);
    printf("%12d encoded in base %3d = %12s\n", n, b, buf);

    value = decodeNegativeBase(buf, b);
    printf("%12s decoded in base %3d = %12d\n", buf, b, value);

    printf("\n");
}

int main() {
    driver(10, -2);
    driver(146, -3);
    driver(15, -10);
    driver(12, -62);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a94(void);
int64_t function_100003c28(void);
int64_t function_100003dc8(void);
int64_t function_100003ef4(int64_t a1);
int32_t function_100003f00(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a94 - 0x100003c28
int64_t function_100003a94(void) {
    // 0x100003a94
    int64_t result; // 0x100003a94
    if (result >= 0) {
        // 0x100003c20
        return result;
    }
    int64_t v1 = result + 62; // 0x100003ac4
    if (result == 0 || v1 < 0 != (v1 & (result ^ -0x8000000000000000)) < 0) {
        // 0x100003c20
        return result;
    }
    char * v2 = (char *)result; // 0x100003aa0
    char * v3 = v2;
    int64_t v4; // 0x100003a94
    int64_t v5 = v4 % result;
    int64_t v6 = v5 < 0 ? -result : 0;
    int64_t v7 = v4 / result + (int64_t)(v5 < 0);
    char v8 = *(char *)(v5 + (int64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" + v6); // 0x100003b8c
    *v3 = v8;
    char * v9 = (char *)((int64_t)v3 + 1);
    while (v7 != 0) {
        // 0x100003b20
        v3 = v9;
        v5 = v7 % result;
        v6 = v5 < 0 ? -result : 0;
        v7 = v7 / result + (int64_t)(v5 < 0);
        v8 = *(char *)(v5 + (int64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" + v6);
        *v3 = v8;
        v9 = (char *)((int64_t)v3 + 1);
    }
    // 0x100003ba8
    *v9 = 0;
    char * v10 = v3; // 0x100003bd0
    if (v3 <= v2) {
        // 0x100003c20
        return result;
    }
    char * v11 = v2; // 0x100003bd0
    *v11 = *v10;
    *v10 = *v11;
    v11 = (char *)((int64_t)v11 + 1);
    v10 = (char *)((int64_t)v10 - 1);
    while (v11 < v10) {
        // 0x100003bd8
        *v11 = *v10;
        *v10 = *v11;
        v11 = (char *)((int64_t)v11 + 1);
        v10 = (char *)((int64_t)v10 - 1);
    }
    // 0x100003c20
    return result;
}

// Address range: 0x100003c28 - 0x100003dc8
int64_t function_100003c28(void) {
    // 0x100003c28
    int64_t v1; // 0x100003c28
    int64_t v2 = v1;
    int64_t v3 = v2 + 62; // 0x100003c38
    if (v2 < 0 != (v3 < 0 == (v3 & (v2 ^ -0x8000000000000000)) < 0)) {
        // 0x100003dbc
        return 0;
    }
    // 0x100003c64
    uint64_t v4; // 0x100003c28
    switch ((char)v4) {
        case 0: {
            // 0x100003dbc
            return 0;
        }
        case 48: {
            // 0x100003c94
            if (*(char *)(v1 + 1) == 0) {
                // 0x100003dbc
                return 0;
            }
            // break -> 0x100003cb4
            break;
        }
    }
    int64_t v5; // 0x100003c28
    int64_t v6 = v5;
    v5 = v6 + 1;
    while (*(char *)v6 != 0) {
        // 0x100003cc0
        v6 = v5;
        v5 = v6 + 1;
    }
    int64_t v7 = v6 - 1;
    int64_t v8 = v7; // 0x100003d14
    int64_t v9 = 1; // 0x100003d14
    if (v1 > v7) {
        // 0x100003dbc
        return 0;
    }
    int64_t v10 = 0; // 0x100003d14
    int64_t result; // 0x100003c28
    while (true) {
        int64_t v11 = v10;
        int64_t v12 = v9;
        int32_t v13 = 0;
        int64_t v14 = v13; // 0x100003d40
        char v15 = *(char *)(v14 + (int64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"); // 0x100003d4c
        int64_t v16; // 0x100003c28
        while (*(char *)v8 != v15) {
            int32_t v17 = v13 + 1; // 0x100003d94
            v16 = v11;
            v9 = v12;
            if (v13 < 63 == (62 - v13 & v17) < 0) {
                goto lab_0x100003da0;
            }
            v13 = v17;
            v14 = v13;
            v15 = *(char *)(v14 + (int64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
        }
        // 0x100003d60
        v16 = v12 * v14 + v11;
        v9 = v12 * v2;
      lab_0x100003da0:
        // 0x100003da0
        v10 = v16;
        v8--;
        result = v10;
        if (v1 > v8) {
            // break -> 0x100003dbc
            break;
        }
    }
    // 0x100003dbc
    return result;
}

// Address range: 0x100003dc8 - 0x100003e9c
int64_t function_100003dc8(void) {
    // 0x100003dc8
    int64_t v1; // bp-88, 0x100003dc8
    int64_t v2 = &v1; // 0x100003df4
    function_100003a94();
    int64_t v3; // 0x100003dc8
    _printf("%12d encoded in base %3d = %12s\n", v3, v2, (char *)v3);
    function_100003c28();
    _printf("%12s decoded in base %3d = %12d\n", (char *)v3, v2, v3);
    int64_t v4 = _printf((char *)0x100003f95); // 0x100003e68
    int64_t v5 = *(int64_t *)0x100004008; // 0x100003e74
    int64_t result = v4; // 0x100003e84
    if (*(int64_t *)v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e8c
        result = ___stack_chk_fail(v4);
    }
    // 0x100003e90
    return result;
}

// Address range: 0x100003e9c - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003e9c
    function_100003dc8();
    function_100003dc8();
    function_100003dc8();
    function_100003dc8();
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1) {
    // 0x100003ef4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * format, ...) {
    // 0x100003f00
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

void feigenbaum() {
    int i, j, k, max_it = 13, max_it_j = 10;
    double a, x, y, d, a1 = 1.0, a2 = 0.0, d1 = 3.2;
    printf(" i       d\n");
    for (i = 2; i <= max_it; ++i) {
        a = a1 + (a1 - a2) / d1;
        for (j = 1; j <= max_it_j; ++j) {
            x = 0.0;
            y = 0.0;
            for (k = 1; k <= 1 << i; ++k) {
                 y = 1.0 - 2.0 * y * x;
                 x = a - x * x;
            }
            a -= x / y;
        }
        d = (a1 - a2) / (a - a1);
        printf("%2d    %.8f\n", i, d);
        d1 = d;
        a2 = a1;
        a1 = a;
    }
}

int main() {
    feigenbaum();
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d78(void);
int32_t function_100003f74(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d78 - 0x100003f48
int64_t function_100003d78(void) {
    // 0x100003d78
    _printf(" i       d\n");
    uint32_t v1 = 2;
    int32_t v2 = 1 << v1; // 0x100003e48
    int32_t v3 = 1 - v2; // 0x100003e4c
    int32_t v4 = 1;
    int32_t v5; // 0x100003d78
    int32_t v6; // 0x100003e94
    int32_t v7; // 0x100003e4c
    if (v3 == 0 || v3 < 0 != (v3 & v2) < 0) {
        v6 = 2;
        v7 = v6 - v2;
        v5 = v6;
        while (v7 == 0 || v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x100003e5c
            v6 = v5 + 1;
            v7 = v6 - v2;
            v5 = v6;
        }
    }
    int32_t v8 = v4 + 1; // 0x100003ec0
    while (v4 == 9 || v4 < 9 != (8 - v4 & v8) < 0) {
        // 0x100003e3c
        v4 = v8;
        if (v3 == 0 || v3 < 0 != (v3 & v2) < 0) {
            v6 = 2;
            v7 = v6 - v2;
            v5 = v6;
            while (v7 == 0 || v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0) {
                // 0x100003e5c
                v6 = v5 + 1;
                v7 = v6 - v2;
                v5 = v6;
            }
        }
        // 0x100003ea0
        v8 = v4 + 1;
    }
    // 0x100003ecc
    int64_t v9; // 0x100003d78
    int128_t v10; // 0x100003d78
    int32_t result = _printf("%2d    %.8f\n", v9, (float64_t)(int64_t)v10); // 0x100003f0c
    int32_t v11 = v1 + 1; // 0x100003f30
    while (v1 == 12 || v1 < 12 != (11 - v1 & v11) < 0) {
        // 0x100003de0
        v1 = v11;
        v2 = 1 << v1;
        v3 = 1 - v2;
        v4 = 1;
        if (v3 == 0 || v3 < 0 != (v3 & v2) < 0) {
            v6 = 2;
            v7 = v6 - v2;
            v5 = v6;
            while (v7 == 0 || v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0) {
                // 0x100003e5c
                v6 = v5 + 1;
                v7 = v6 - v2;
                v5 = v6;
            }
        }
        // 0x100003ea0
        v8 = v4 + 1;
        while (v4 == 9 || v4 < 9 != (8 - v4 & v8) < 0) {
            // 0x100003e3c
            v4 = v8;
            if (v3 == 0 || v3 < 0 != (v3 & v2) < 0) {
                v6 = 2;
                v7 = v6 - v2;
                v5 = v6;
                while (v7 == 0 || v7 < 0 != ((v7 ^ v6) & (v6 ^ v2)) < 0) {
                    // 0x100003e5c
                    v6 = v5 + 1;
                    v7 = v6 - v2;
                    v5 = v6;
                }
            }
            // 0x100003ea0
            v8 = v4 + 1;
        }
        // 0x100003ecc
        result = _printf("%2d    %.8f\n", v9, (float64_t)(int64_t)v10);
        v11 = v1 + 1;
    }
    // 0x100003f3c
    return result;
}

// Address range: 0x100003f48 - 0x100003f74
int64_t entry_point(void) {
    // 0x100003f48
    function_100003d78();
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

int verbose = 0;
enum {
	clown = -1,
	abe, bob, col, dan, ed, fred, gav, hal, ian, jon,
	abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan,
};
const char *name[] = {
	"Abe", "Bob", "Col",  "Dan", "Ed",  "Fred", "Gav", "Hal",  "Ian", "Jon",
	"Abi", "Bea", "Cath", "Dee", "Eve", "Fay",  "Gay", "Hope", "Ivy", "Jan"
};
int pref[jan + 1][jon + 1] = {
	{ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay },
	{ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay },
	{ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan },
	{ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi },
	{ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay },
	{ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay },
	{ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay },
	{ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee },
	{ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve },
	{ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope },

	{ bob, fred, jon, gav, ian, abe, dan, ed, col, hal   },
	{ bob, abe, col, fred, gav, dan, ian, ed, jon, hal   },
	{ fred, bob, ed, gav, hal, col, ian, abe, dan, jon   },
	{ fred, jon, col, abe, ian, hal, gav, dan, bob, ed   },
	{ jon, hal, fred, dan, abe, gav, col, ed, ian, bob   },
	{ bob, abe, ed, ian, jon, dan, fred, gav, col, hal   },
	{ jon, gav, hal, fred, bob, abe, col, ed, dan, ian   },
	{ gav, jon, bob, abe, ian, dan, hal, ed, col, fred   },
	{ ian, col, hal, gav, fred, bob, abe, ed, jon, dan   },
	{ ed, hal, gav, abe, bob, jon, col, ian, fred, dan   },
};
int pairs[jan + 1], proposed[jan + 1];

void engage(int man, int woman)
{
	pairs[man] = woman;
	pairs[woman] = man;
	if (verbose) printf("%4s is engaged to %4s\n", name[man], name[woman]);
}

void dump(int woman, int man)
{
	pairs[man] = pairs[woman] = clown;
	if (verbose) printf("%4s dumps %4s\n", name[woman], name[man]);
}

/* how high this person ranks that: lower is more preferred */
int rank(int this, int that)
{
	int i;
	for (i = abe; i <= jon && pref[this][i] != that; i++);
	return i;
}

void propose(int man, int woman)
{
	int fiance = pairs[woman];
	if (verbose) printf("%4s proposes to %4s\n", name[man], name[woman]);

	if (fiance == clown) {
		engage(man, woman);
	} else if (rank(woman, man) < rank(woman, fiance)) {
		dump(woman, fiance);
		engage(man, woman);
	}
}

int covet(int man1, int wife2)
{
	if (rank(man1, wife2) < rank(man1, pairs[man1]) &&
			rank(wife2, man1) < rank(wife2, pairs[wife2])) {
		printf( "    %4s (w/ %4s) and %4s (w/ %4s) prefer each other"
			" over current pairing.\n",
			name[man1], name[pairs[man1]], name[wife2], name[pairs[wife2]]
		);
		return 1;
	}
	return 0;
}

int thy_neighbors_wife(int man1, int man2)
{	/* +: force checking all pairs; "||" would shortcircuit */
	return covet(man1, pairs[man2]) + covet(man2, pairs[man1]);
}

int unstable()
{
	int i, j, bad = 0;
	for (i = abe; i < jon; i++) {
		for (j = i + 1; j <= jon; j++)
			if (thy_neighbors_wife(i, j)) bad = 1;
	}
	return bad;
}

int main()
{
	int i, unengaged;
	/* init: everyone marries the clown */
	for (i = abe; i <= jan; i++)
		pairs[i] = proposed[i] = clown;

	/* rounds */
	do {
		unengaged = 0;
		for (i = abe; i <= jon; i++) {
		//for (i = abi; i <= jan; i++) { /* could let women propose */
			if (pairs[i] != clown) continue;
			unengaged = 1;
			propose(i, pref[i][++proposed[i]]);
		}
	} while (unengaged);

	printf("Pairing:\n");
	for (i = abe; i <= jon; i++)
		printf("  %4s - %s\n", name[i],
			pairs[i] == clown ? "clown" : name[pairs[i]]);

	printf(unstable()
		? "Marriages not stable\n" /* draw sad face here */
		: "Stable matchup\n");

	printf("\nBut if Bob and Fred were to swap:\n");
	i = pairs[bob];
	engage(bob, pairs[fred]);
	engage(fred, i);
	printf(unstable() ? "Marriages not stable\n" : "Stable matchup\n");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003708(void);
int64_t function_100003794(void);
int64_t function_10000381c(void);
int64_t function_1000038ac(void);
int64_t function_1000039a4(void);
int64_t function_100003ab4(void);
int64_t function_100003b14(void);
int32_t function_100003e54(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0xe0000000a; // 0x1000080a0
int32_t g2 = -0x1120531; // 0x1000083c0
int32_t * g3 = (int32_t *)0x100000c; // 0x1000083c4
int32_t * g4 = NULL; // 0x100008414

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003708 - 0x100003794
int64_t function_100003708(void) {
    // 0x100003708
    int64_t v1; // 0x100003708
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = (int32_t)v1;
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = (int32_t)v1;
    int64_t result; // 0x100003708
    if (g2 != 0) {
        // 0x100003754
        result = _printf("%4s is engaged to %4s\n", (char *)v1, (char *)v1);
    }
    // 0x100003788
    return result;
}

// Address range: 0x100003794 - 0x10000381c
int64_t function_100003794(void) {
    // 0x100003794
    int64_t v1; // 0x100003794
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = -1;
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = -1;
    int64_t result; // 0x100003794
    if (g2 != 0) {
        // 0x1000037dc
        result = _printf("%4s dumps %4s\n", (char *)v1, (char *)v1);
    }
    // 0x100003810
    return result;
}

// Address range: 0x10000381c - 0x1000038ac
int64_t function_10000381c(void) {
    // 0x10000381c
    int64_t v1; // 0x10000381c
    int64_t v2 = 40 * (0x100000000 * v1 >> 32) + (int64_t)&g1;
    int32_t v3 = 0;
    int32_t result = v3; // 0x100003884
    while (*(int32_t *)(v2 + 4 * (int64_t)v3) != (int32_t)v1) {
        int32_t v4 = v3 + 1; // 0x100003894
        int32_t v5 = v3 - 8; // 0x100003834
        result = v4;
        if (v5 != 0 && v5 < 0 == (7 - v3 & v4) < 0) {
            // break -> 0x1000038a0
            break;
        }
        v3 = v4;
        result = v3;
    }
    // 0x1000038a0
    return result;
}

// Address range: 0x1000038ac - 0x1000039a4
int64_t function_1000038ac(void) {
    // 0x1000038ac
    int64_t v1; // 0x1000038ac
    if (g2 != 0) {
        // 0x1000038ec
        _printf("%4s proposes to %4s\n", (char *)v1, (char *)v1);
    }
    if (*(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) == -1) {
        // 0x100003998
        return function_100003708();
    }
    int64_t v2 = function_10000381c(); // 0x10000394c
    int64_t v3 = function_10000381c(); // 0x10000395c
    int32_t v4 = v2; // 0x100003968
    int32_t v5 = v4 - (int32_t)v3; // 0x100003968
    int64_t result = v2 & 0xffffffff; // 0x100003970
    if (v5 < 0 != ((v5 ^ v4) & (int32_t)(v3 ^ v2)) < 0) {
        // 0x100003978
        function_100003794();
        result = function_100003708();
    }
    // 0x100003998
    return result;
}

// Address range: 0x1000039a4 - 0x100003ab4
int64_t function_1000039a4(void) {
    int64_t v1 = function_10000381c(); // 0x1000039c0
    int32_t v2 = v1; // 0x1000039c4
    int64_t v3 = function_10000381c(); // 0x1000039dc
    int32_t v4 = v2 - (int32_t)v3; // 0x1000039e8
    if (v4 < 0 == ((v4 ^ v2) & (int32_t)(v3 ^ v1)) < 0) {
        // 0x100003aa4
        return 0;
    }
    int64_t v5 = function_10000381c(); // 0x100003a00
    int32_t v6 = v5; // 0x100003a04
    int64_t v7; // 0x1000039a4
    uint32_t v8 = *(int32_t *)((0x100000000 * v7 >> 30) + (int64_t)&g3); // 0x100003a18
    int64_t v9 = function_10000381c(); // 0x100003a1c
    int32_t v10 = v6 - (int32_t)v9; // 0x100003a28
    int64_t result = 0; // 0x100003a30
    if (v10 < 0 != ((v10 ^ v6) & (int32_t)(v9 ^ v5)) < 0) {
        // 0x100003a38
        _printf("    %4s (w/ %4s) and %4s (w/ %4s) prefer each other over current pairing.\n", (char *)(int64_t)v8, (char *)v7, (char *)v7, (char *)v7);
        result = 1;
    }
    // 0x100003aa4
    return result;
}

// Address range: 0x100003ab4 - 0x100003b14
int64_t function_100003ab4(void) {
    int64_t v1 = function_1000039a4(); // 0x100003ae0
    return function_1000039a4() + v1 & 0xffffffff;
}

// Address range: 0x100003b14 - 0x100003bc4
int64_t function_100003b14(void) {
    int32_t v1 = 0;
    v1++;
    int32_t v2 = v1;
    int32_t result = (int32_t)function_100003ab4() == 0 ? 0 : 1;
    int32_t v3 = v2 + 1;
    int32_t v4 = v2 - 8; // 0x100003b54
    int32_t v5 = result; // 0x100003b5c
    while (v4 == 0 || v4 < 0 != (v3 & 7 - v2) < 0) {
        // 0x100003b64
        v2 = v3;
        result = (int32_t)function_100003ab4() == 0 ? v5 : 1;
        v3 = v2 + 1;
        v4 = v2 - 8;
        v5 = result;
    }
    while (v1 != 9) {
        // 0x100003b64
        v1++;
        v2 = v1;
        result = (int32_t)function_100003ab4() == 0 ? result : 1;
        v3 = v2 + 1;
        v4 = v2 - 8;
        v5 = result;
        while (v4 == 0 || v4 < 0 != (v3 & 7 - v2) < 0) {
            // 0x100003b64
            v2 = v3;
            result = (int32_t)function_100003ab4() == 0 ? v5 : 1;
            v3 = v2 + 1;
            v4 = v2 - 8;
            v5 = result;
        }
    }
    // 0x100003bb4
    return result;
}

// Address range: 0x100003bc4 - 0x100003e54
int64_t entry_point(void) {
    int32_t v1 = 0;
    int64_t v2 = 4 * (int64_t)v1; // 0x100003c00
    *(int32_t *)(v2 + (int64_t)&g4) = -1;
    *(int32_t *)(v2 + (int64_t)&g3) = -1;
    int32_t v3 = v1 + 1; // 0x100003c1c
    while (v1 == 18 || v1 < 18 != (17 - v1 & v3) < 0) {
        // 0x100003bf0
        v1 = v3;
        v2 = 4 * (int64_t)v1;
        *(int32_t *)(v2 + (int64_t)&g4) = -1;
        *(int32_t *)(v2 + (int64_t)&g3) = -1;
        v3 = v1 + 1;
    }
    int32_t v4 = 0;
    int64_t v5 = v4; // 0x100003c4c
    int64_t v6 = 4 * v5; // 0x100003c58
    int32_t v7 = 0; // 0x100003c64
    int64_t v8; // 0x100003bc4
    int64_t v9 = v8; // 0x100003c64
    int32_t v10; // 0x100003ca8
    uint32_t v11; // 0x100003cb0
    int32_t * v12; // 0x100003ca4
    if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
        // 0x100003c70
        v12 = (int32_t *)(v6 + (int64_t)&g4);
        v10 = *v12 + 1;
        *v12 = v10;
        v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
        function_1000038ac();
        v7 = 1;
        v9 = v11;
    }
    int64_t v13 = v9;
    int32_t v14 = v7;
    int32_t v15 = v4 + 1; // 0x100003cc0
    int32_t v16 = v4 - 8; // 0x100003c3c
    while (v16 == 0 || v16 < 0 != (7 - v4 & v15) < 0) {
        // 0x100003c4c
        v4 = v15;
        v5 = v4;
        v6 = 4 * v5;
        v7 = v14;
        v9 = v13;
        if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
            // 0x100003c70
            v12 = (int32_t *)(v6 + (int64_t)&g4);
            v10 = *v12 + 1;
            *v12 = v10;
            v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
            function_1000038ac();
            v7 = 1;
            v9 = v11;
        }
        // 0x100003cbc
        v13 = v9;
        v14 = v7;
        v15 = v4 + 1;
        v16 = v4 - 8;
    }
    // 0x100003cd0
    while (v14 != 0) {
        // 0x100003c2c
        v4 = 0;
        v5 = v4;
        v6 = 4 * v5;
        v7 = 0;
        v9 = v13;
        if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
            // 0x100003c70
            v12 = (int32_t *)(v6 + (int64_t)&g4);
            v10 = *v12 + 1;
            *v12 = v10;
            v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
            function_1000038ac();
            v7 = 1;
            v9 = v11;
        }
        // 0x100003cbc
        v13 = v9;
        v14 = v7;
        v15 = v4 + 1;
        v16 = v4 - 8;
        while (v16 == 0 || v16 < 0 != (7 - v4 & v15) < 0) {
            // 0x100003c4c
            v4 = v15;
            v5 = v4;
            v6 = 4 * v5;
            v7 = v14;
            v9 = v13;
            if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
                // 0x100003c70
                v12 = (int32_t *)(v6 + (int64_t)&g4);
                v10 = *v12 + 1;
                *v12 = v10;
                v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
                function_1000038ac();
                v7 = 1;
                v9 = v11;
            }
            // 0x100003cbc
            v13 = v9;
            v14 = v7;
            v15 = v4 + 1;
            v16 = v4 - 8;
        }
    }
    // 0x100003ce4
    _printf("Pairing:\n");
    int32_t v17 = 0;
    int64_t v18; // 0x100003bc4
    _printf("  %4s - %s\n", (char *)v13, (char *)v18);
    int32_t v19 = v17 + 1; // 0x100003d9c
    while (v17 == 8 || v17 < 8 != (7 - v17 & v19) < 0) {
        // 0x100003d0c
        v17 = v19;
        _printf("  %4s - %s\n", (char *)v13, (char *)v18);
        v19 = v17 + 1;
    }
    // 0x100003da8
    _printf((int32_t)function_100003b14() == 0 ? "Stable matchup\n" : "Marriages not stable\n");
    _printf("\nBut if Bob and Fred were to swap:\n");
    function_100003708();
    function_100003708();
    _printf((int32_t)function_100003b14() == 0 ? "Stable matchup\n" : "Marriages not stable\n");
    return 0;
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(char * format, ...) {
    // 0x100003e54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
` #include <stdio.h>

/**
 * description : Counts the number of bits set to 1
 *        input: the number to have its bit counted
 *       output: the number of bits set to 1
 */
unsigned count_bits(unsigned v) {
    unsigned c = 0;
    while (v) {
        c += v & 1;
        v >>= 1;
    }

    return c;
}

int main(void) {
    /*          i: loop iterator
     *     length: the length of the sequence to be printed
     * ascii_base: the lower char for use when printing
     */
    unsigned i, length = 0;
    int ascii_base;


    /* scan in sequence length */
    printf("Sequence length: ");
    do {
        scanf("%u", &length);
    } while (length == 0);


    /* scan in sequence mode */
    printf("(a)lpha or (b)inary: ");
    do {
        ascii_base = getchar();
    } while ((ascii_base != 'a') && (ascii_base != 'b'));
    ascii_base = ascii_base == 'b' ? '0' : 'A';


    /* print the Thue-Morse sequence */
    for (i = 0; i < length; ++i) {
        putchar(ascii_base + count_bits(i) % 2);
    }
    putchar('\n');

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003da8(void);
int32_t function_100003f44(void);
int32_t function_100003f50(char * format, ...);
int32_t function_100003f5c(int32_t c);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003da8 - 0x100003dfc
int64_t function_100003da8(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    int32_t v2 = v1; // 0x100003dac
    uint32_t v3 = v2; // 0x100003dc4
    if (v2 == 0) {
        // 0x100003df0
        return 0;
    }
    int32_t result = 0; // 0x100003dc4
    result += v3 % 2;
    while (v3 >= 2) {
        // 0x100003dcc
        v3 /= 2;
        result += v3 % 2;
    }
    // 0x100003df0
    return result;
}

// Address range: 0x100003dfc - 0x100003f44
int64_t entry_point(void) {
    // 0x100003dfc
    _printf("Sequence length: ");
    while (true) {
        // 0x100003e20
        int64_t v1; // 0x100003dfc
        _scanf("%u", (int32_t *)v1);
    }
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(void) {
    // 0x100003f44
    return _getchar();
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _printf(format);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(int32_t c) {
    // 0x100003f5c
    return _putchar(c);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

unsigned chowla(const unsigned n) {
  unsigned sum = 0;
  for (unsigned i = 2, j; i * i <= n; i ++) if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);
  return sum;
}

int main(int argc, char const *argv[]) {
  unsigned a;
  for (unsigned n = 1; n < 38; n ++) printf("chowla(%u) = %u\n", n, chowla(n));

  unsigned n, count = 0, power = 100;
  for (n = 2; n < 10000001; n ++) {
    if (chowla(n) == 0) count ++;
    if (n % power == 0) printf("There is %u primes < %u\n", count, power), power *= 10;
  }

  count = 0;
  unsigned limit = 350000000;
  unsigned k = 2, kk = 3, p;
  for ( ; ; ) {
    if ((p = k * kk) > limit) break;
    if (chowla(p) == p - 1) {
      printf("%d is a perfect number\n", p);
      count ++;
    }
    k = kk + 1; kk += k;
  }
  printf("There are %u perfect numbers < %u\n", count, limit);
  return 0;
}
`,`#include "chowla-numbers.h"



int _chowla(uint param_1)

{
  uint uVar1;
  uint local_18;
  uint local_c;
  int local_8;
  
  local_8 = 0;
  for (local_c = 2; local_c * local_c <= param_1; local_c = local_c + 1) {
    uVar1 = 0;
    if (local_c != 0) {
      uVar1 = param_1 / local_c;
    }
    if (param_1 == uVar1 * local_c) {
      local_18 = 0;
      if (local_c != 0) {
        local_18 = param_1 / local_c;
      }
      if (local_c == local_18) {
        local_18 = 0;
      }
      local_8 = local_8 + local_c + local_18;
    }
  }
  return local_8;
}



undefined8 entry(void)

{
  uint uVar1;
  int iVar2;
  int local_40;
  int local_3c;
  uint local_34;
  uint local_2c;
  uint local_28;
  
  for (local_28 = 1; local_28 < 0x26; local_28 = local_28 + 1) {
    _chowla(local_28);
    _printf("chowla(%u) = %u\n");
  }
  local_34 = 100;
  for (local_2c = 2; local_2c < 0x989681; local_2c = local_2c + 1) {
    _chowla(local_2c);
    uVar1 = 0;
    if (local_34 != 0) {
      uVar1 = local_2c / local_34;
    }
    if (local_2c == uVar1 * local_34) {
      _printf("There is %u primes < %u\n");
      local_34 = local_34 * 10;
    }
  }
  local_3c = 2;
  for (local_40 = 3; uVar1 = local_3c * local_40, uVar1 < 0x14dc9381; local_40 = local_40 + local_3c
      ) {
    iVar2 = _chowla(uVar1);
    if (iVar2 == uVar1 - 1) {
      _printf("%d is a perfect number\n");
    }
    local_3c = local_40 + 1;
  }
  _printf("There are %u perfect numbers < %u\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>

int main(){
   int a;
   /* ...input or change a here */
   assert(a == 42); /* aborts program when a is not 42, unless the NDEBUG macro was defined */

   return 0;
}
`,`#include "assertions-1.h"



undefined8 entry(void)

{
  int local_18;
  
  if (local_18 != 0x2a) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","assertions-1.c",6,"a == 42");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}


`
`#include <stdio.h>

int main() {
    int i, gprev = 0;
    int s[7] = {1, 2, 2, 3, 4, 4, 5};

    /* There is no output as 'prev' is created anew each time
       around the loop and set explicitly to zero. */
    for (i = 0; i < 7; ++i) {
//  for (int i = 0, prev; i < 7; ++i) { // as below, see note
        int curr = s[i];
        int prev = 0;
//      int prev; // produces same output as second loop
        if (i > 0 && curr == prev) printf("%d\n", i);
        prev = curr;
    }

    /*  Now 'gprev' is used and reassigned
        each time around the loop producing the desired output. */
    for (i = 0; i < 7; ++i) {
        int curr = s[i];
        if (i > 0 && curr == gprev) printf("%d\n", i);
        gprev = curr;
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f70(void);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.24399158242461027606401097390298646e-314L; // 0x100003f88

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dd0 - 0x100003f70
int64_t entry_point(void) {
    int64_t v1 = (float64_t)g1; // bp-64, 0x100003e04
    int64_t v2 = &v1;
    int64_t v3 = 0;
    int64_t v4; // 0x100003dd0
    if (v3 != 0) {
        // 0x100003e54
        if (*(int32_t *)(4 * v3 + v2) == 0) {
            // 0x100003e6c
            _printf("%d\n", v4);
        }
    }
    int64_t v5 = v3 + 1;
    int64_t v6 = 0; // 0x100003e24
    while (v5 != 7) {
        // 0x100003e2c
        v3 = v5;
        if (v3 != 0) {
            // 0x100003e54
            if (*(int32_t *)(4 * v3 + v2) == 0) {
                // 0x100003e6c
                _printf("%d\n", v4);
            }
        }
        // 0x100003e98
        v5 = v3 + 1;
        v6 = 0;
    }
    int32_t v7 = *(int32_t *)(4 * v6 + v2); // 0x100003ecc
    if (v6 != 0 == v7 == 0) {
        // 0x100003f00
        _printf("%d\n", v4);
    }
    int64_t v8 = v6 + 1;
    v6 = v8;
    int32_t v9 = v7; // 0x100003ebc
    while (v8 != 7) {
        // 0x100003ec4
        v7 = *(int32_t *)(4 * v6 + v2);
        if (v6 != 0 == v7 == v9) {
            // 0x100003f00
            _printf("%d\n", v4);
        }
        // 0x100003f20
        v8 = v6 + 1;
        v6 = v8;
        v9 = v7;
    }
    int64_t v10 = *(int64_t *)0x100004008; // 0x100003f44
    if (*(int64_t *)v10 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f5c
        ___stack_chk_fail();
    }
    // 0x100003f60
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t function_100003f70(void) {
    // 0x100003f70
    return ___stack_chk_fail();
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`/* Include statements and constant definitions */
#include <stdio.h>
#define HIGHEST_DEGREE 5
#define LARGEST_NUMBER 10

/* Recursive implementation of multifactorial function */
int multifact(int n, int deg){
   return n <= deg ? n : n * multifact(n - deg, deg);
}

/* Iterative implementation of multifactorial function */
int multifact_i(int n, int deg){
   int result = n;
   while (n >= deg + 1){
      result *= (n - deg);
      n -= deg;
   }
   return result;
}

/* Test function to print out multifactorials */
int main(void){
   int i, j;
   for (i = 1; i <= HIGHEST_DEGREE; i++){
      printf("\nDegree %d: ", i);
      for (j = 1; j <= LARGEST_NUMBER; j++){
         printf("%d ", multifact(j, i));
      }
   }
}
`,`#include "multifactorial.h"



int _multifact(int param_1,int param_2)

{
  undefined4 local_1c;
  
  local_1c = param_1;
  if (param_2 < param_1) {
    local_1c = _multifact(param_1 - param_2,param_2);
    local_1c = param_1 * local_1c;
  }
  return local_1c;
}



int _multifact_i(int param_1,int param_2)

{
  undefined4 local_c;
  undefined4 local_4;
  
  local_c = param_1;
  for (local_4 = param_1; param_2 + 1 <= local_4; local_4 = local_4 - param_2) {
    local_c = local_c * (local_4 - param_2);
  }
  return local_c;
}



undefined4 entry(void)

{
  int local_1c;
  int local_18;
  
  for (local_18 = 1; local_18 < 6; local_18 = local_18 + 1) {
    _printf("\nDegree %d: ");
    for (local_1c = 1; local_1c < 0xb; local_1c = local_1c + 1) {
      _multifact(local_1c,local_18);
      _printf("%d ");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdarg.h>
#include<stdio.h>

long int factorial(int n){
	if(n>1)
		return n*factorial(n-1);
	return 1;
}

long int sumOfFactorials(int num,...){
	va_list vaList;
	long int sum = 0;
	
	va_start(vaList,num);
	
	while(num--)
		sum += factorial(va_arg(vaList,int));
	
	va_end(vaList);
	
	return sum;
}

int main()
{
	printf("\nSum of factorials of [1,5] : %ld",sumOfFactorials(5,1,2,3,4,5));
	printf("\nSum of factorials of [3,5] : %ld",sumOfFactorials(3,3,4,5));
	printf("\nSum of factorials of [1,3] : %ld",sumOfFactorials(3,1,2,3));
	
	return 0;
}
`,`#include "currying.h"



long _factorial(int param_1)

{
  undefined8 local_18;
  
  if (param_1 < 2) {
    local_18 = 1;
  }
  else {
    local_18 = _factorial(param_1 + -1);
    local_18 = param_1 * local_18;
  }
  return local_18;
}



long _sumOfFactorials(int param_1)

{
  undefined4 uVar1;
  long lVar2;
  long local_28;
  int local_14;
  
  local_28 = 0;
  local_14 = param_1;
  while (local_14 != 0) {
    uVar1 = *(undefined4 *)register0x00000008;
    register0x00000008 = (BADSPACEBASE *)((long)register0x00000008 + 8);
    lVar2 = _factorial(uVar1);
    local_28 = local_28 + lVar2;
    local_14 = local_14 + -1;
  }
  return local_28;
}



undefined4 entry(void)

{
  _sumOfFactorials(5);
  _printf("\nSum of factorials of [1,5] : %ld");
  _sumOfFactorials(3);
  _printf("\nSum of factorials of [3,5] : %ld");
  _sumOfFactorials(3);
  _printf("\nSum of factorials of [1,3] : %ld");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int semiprime(int n)
{
	int p, f = 0;
	for (p = 2; f < 2 && p*p <= n; p++)
		while (0 == n % p)
			n /= p, f++;

	return f + (n > 1) == 2;
}

int main(void)
{
	int i;
	for (i = 2; i < 100; i++)
		if (semiprime(i)) printf(" %d", i);
	putchar('\n');

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e04(void);
int32_t function_100003f84(char * format, ...);
int32_t function_100003f90(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e04 - 0x100003ef0
int64_t function_100003e04(void) {
    int32_t v1 = 0;
    int64_t v2; // 0x100003e04
    int32_t v3 = v2;
    int32_t v4 = 2;
    int32_t v5 = v4 * v4; // 0x100003e40
    while (v5 - v3 == 0 || v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v3 ^ v5)) < 0) {
        int32_t v6 = v1; // 0x100003e88
        int32_t v7 = v3; // 0x100003e88
        int32_t v8 = v3; // 0x100003e88
        int32_t v9 = v1; // 0x100003e88
        if (v3 % v4 == 0) {
            int32_t v10 = v7 / v4; // 0x100003e98
            int32_t v11 = v6 + 1; // 0x100003ea4
            v6 = v11;
            v7 = v10;
            v8 = v10;
            v9 = v11;
            while (v10 % v4 == 0) {
                // 0x100003e90
                v10 = v7 / v4;
                v11 = v6 + 1;
                v6 = v11;
                v7 = v10;
                v8 = v10;
                v9 = v11;
            }
        }
        // 0x100003eb4
        v1 = v9;
        v3 = v8;
        if (v1 < 2 == (1 - v1 & v1) < 0) {
            // break -> 0x100003ec4
            break;
        }
        v4++;
        v5 = v4 * v4;
    }
    int32_t v12 = v3;
    int32_t v13 = v12 - 1; // 0x100003ecc
    return v1 + (int32_t)!((v13 == 0 | v13 < 0 != (v12 & -v12) < 0)) == 2;
}

// Address range: 0x100003ef0 - 0x100003f84
int64_t entry_point(void) {
    for (int32_t i = 2; i < 100; i++) {
        // 0x100003f20
        if ((int32_t)function_100003e04() != 0) {
            // 0x100003f38
            int64_t v1; // 0x100003ef0
            _printf(" %d", v1);
        }
    }
    // 0x100003f6c
    _putchar(10);
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(int32_t c) {
    // 0x100003f90
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned char byte;
int w = 0, h = 0, verbose = 0;
unsigned long count = 0;

byte **hor, **ver, **vis;
byte **c = 0;

enum { U = 1, D = 2, L = 4, R = 8 };

byte ** alloc2(int w, int h)
{
	int i;
	byte **x = calloc(1, sizeof(byte*) * h + h * w);
	x[0] = (byte *)&x[h];
	for (i = 1; i < h; i++)
		x[i] = x[i - 1] + w;
	return x;
}

void show()
{
	int i, j, v, last_v;
	printf("%ld\n", count);
#if 0
	for (i = 0; i <= h; i++) {
		for (j = 0; j <= w; j++)
			printf("%d ", hor[i][j]);
		puts("");
	}
	puts("");

	for (i = 0; i <= h; i++) {
		for (j = 0; j <= w; j++)
			printf("%d ", ver[i][j]);
		puts("");
	}
	puts("");
#endif
	for (i = 0; i < h; i++) {
		if (!i) v = last_v = 0;
		else last_v = v = hor[i][0] ? !last_v : last_v;

		for (j = 0; j < w; v = ver[i][++j] ? !v : v)
			printf(v ? "\033[31m[]" : "\033[33m{}");
		puts("\033[m");
	}
	putchar('\n');
}

void walk(int y, int x)
{
	if (x < 0 || y < 0 || x > w || y > h) return;

	if (!x || !y || x == w || y == h) {
		++count;
		if (verbose) show();
		return;
	}

	if (vis[y][x]) return;
	vis[y][x]++; vis[h - y][w - x]++;

	if (x && !hor[y][x - 1]) {
		hor[y][x - 1] = hor[h - y][w - x] = 1;
		walk(y, x - 1);
		hor[y][x - 1] = hor[h - y][w - x] = 0;
	}
	if (x < w && !hor[y][x]) {
		hor[y][x] = hor[h - y][w - x - 1] = 1;
		walk(y, x + 1);
		hor[y][x] = hor[h - y][w - x - 1] = 0;
	}

	if (y && !ver[y - 1][x]) {
		ver[y - 1][x] = ver[h - y][w - x] = 1;
		walk(y - 1, x);
		ver[y - 1][x] = ver[h - y][w - x] = 0;
	}

	if (y < h && !ver[y][x]) {
		ver[y][x] = ver[h - y - 1][w - x] = 1;
		walk(y + 1, x);
		ver[y][x] = ver[h - y - 1][w - x] = 0;
	}

	vis[y][x]--; vis[h - y][w - x]--;
}

void cut(void)
{
	if (1 & (h * w)) return;

	hor = alloc2(w + 1, h + 1);
	ver = alloc2(w + 1, h + 1);
	vis = alloc2(w + 1, h + 1);

	if (h & 1) {
		ver[h/2][w/2] = 1;
		walk(h / 2, w / 2);
	} else if (w & 1) {
		hor[h/2][w/2] = 1;
		walk(h / 2, w / 2);
	} else {
		vis[h/2][w/2] = 1;

		hor[h/2][w/2-1] = hor[h/2][w/2] = 1;
		walk(h / 2, w / 2 - 1);
		hor[h/2][w/2-1] = hor[h/2][w/2] = 0;

		ver[h/2 - 1][w/2] = ver[h/2][w/2] = 1;
		walk(h / 2 - 1, w/2);
	}
}

void cwalk(int y, int x, int d)
{
	if (!y || y == h || !x || x == w) {
		++count;
		return;
	}
	vis[y][x] = vis[h-y][w-x] = 1;

	if (x && !vis[y][x-1])
		cwalk(y, x - 1, d|1);
	if ((d&1) && x < w && !vis[y][x+1])
		cwalk(y, x + 1, d|1);
	if (y && !vis[y-1][x])
		cwalk(y - 1, x, d|2);
	if ((d&2) && y < h && !vis[y + 1][x])
		cwalk(y + 1, x, d|2);

	vis[y][x] = vis[h-y][w-x] = 0;
}

void count_only(void)
{
	int t;
	long res;
	if (h * w & 1) return;
	if (h & 1) t = h, h = w, w = t;

	vis = alloc2(w + 1, h + 1);
	vis[h/2][w/2] = 1;

	if (w & 1) vis[h/2][w/2 + 1] = 1;
	if (w > 1) {
		cwalk(h/2, w/2 - 1, 1);
		res = 2 * count - 1;
		count = 0;
		if (w != h)
			cwalk(h/2+1, w/2, (w & 1) ? 3 : 2);

		res += 2 * count - !(w & 1);
	} else {
		res = 1;
	}
	if (w == h) res = 2 * res + 2;
	count = res;
}

int main(int c, char **v)
{
	int i;

	for (i = 1; i < c; i++) {
		if (v[i][0] == '-' && v[i][1] == 'v' && !v[i][2]) {
			verbose = 1;
		} else if (!w) {
			w = atoi(v[i]);
			if (w <= 0) goto bail;
		} else if (!h) {
			h = atoi(v[i]);
			if (h <= 0) goto bail;
		} else
			goto bail;
	}
	if (!w) goto bail;
	if (!h) h = w;

	if (verbose) cut();
	else count_only();

	printf("Total: %ld\n", count);
	return 0;

bail:	fprintf(stderr, "bad args\n");
	return 1;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002ba0(void);
int64_t function_100002c5c(void);
int64_t function_100002e10(void);
int64_t function_10000346c(void);
int64_t function_100003774(void);
int64_t function_100003a7c(void);
int32_t function_100003f30(char * nptr);
int64_t * function_100003f3c(int32_t nmemb, int32_t size);
int32_t function_100003f48(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f54(char * format, ...);
int32_t function_100003f60(int32_t c);
int32_t function_100003f6c(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x5d5b6d31335b1b; // 0x100003f7d
char * g2 = "\x1b[33m{}"; // 0x100003f85
char * g3 = "\x1b[m"; // 0x100003f8d
int32_t * g4 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int32_t g5 = 0x100000c; // 0x100008004
int32_t g6 = 0; // 0x100008008
int64_t g7 = 0x4b800000012; // 0x100008010
int64_t g8 = 0x4800000019; // 0x100008020
char g9[11] = "__PAGEZERO"; // 0x100008028
char g10[3] = "RO"; // 0x100008030

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002ba0 - 0x100002c5c
int64_t function_100002ba0(void) {
    // 0x100002ba0
    int64_t v1; // 0x100002ba0
    int32_t v2 = v1; // 0x100002bb0
    int64_t * v3 = _calloc(1, (int32_t)((v1 + 8) * v1)); // 0x100002bd4
    int64_t result = (int64_t)v3; // 0x100002bd4
    *v3 = (0x100000000 * v1 >> 29) + result;
    int32_t v4 = 1 - v2; // 0x100002c04
    if (v4 < 0 == (v4 & v2) < 0) {
        // 0x100002c4c
        return result;
    }
    int32_t v5 = 1; // 0x100002c40
    int64_t v6 = *(int64_t *)((int64_t)(8 * v5 - 8) + result); // 0x100002c20
    *(int64_t *)(8 * (int64_t)v5 + result) = v6 + (0x100000000 * v1 >> 32);
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100002c14
        v6 = *(int64_t *)((int64_t)(8 * v5 - 8) + result);
        *(int64_t *)(8 * (int64_t)v5 + result) = v6 + (0x100000000 * v1 >> 32);
        v5++;
    }
    // 0x100002c4c
    return result;
}

// Address range: 0x100002c5c - 0x100002e10
int64_t function_100002c5c(void) {
    // 0x100002c5c
    int64_t v1; // 0x100002c5c
    _printf("%ld\n", (int32_t)v1);
    int32_t v2 = -g5; // 0x100002c98
    if (v2 < 0 == (g5 & v2) < 0) {
        // 0x100002dfc
        return _putchar(10);
    }
    int32_t v3 = 0;
    int32_t v4 = 0; // 0x100002cb4
    int32_t v5; // 0x100002c5c
    char v6; // 0x100002cdc
    int64_t v7; // 0x100002cd8
    if (v3 != 0) {
        // 0x100002cc8
        int32_t v8; // 0x100002c5c
        v5 = v8;
        v7 = *(int64_t *)(g8 + 8 * (int64_t)v3);
        v6 = *(char *)v7;
        v4 = v6 == 0 ? v5 : (int32_t)(v5 == 0);
    }
    int32_t v9 = v4;
    int32_t v10 = *(int32_t *)&g4; // 0x100002d34
    int32_t v11 = -v10; // 0x100002d38
    int32_t v12; // 0x100002c5c
    int32_t v13; // 0x100002c5c
    char * v14; // 0x100002d70
    int64_t v15; // 0x100002d80
    int64_t v16; // 0x100002d88
    int32_t v17; // 0x100002d90
    char v18; // 0x100002d98
    int32_t v19; // 0x100002d34
    if (v11 < 0 != (v10 & v11) < 0) {
        // 0x100002d48
        v17 = 0;
        v12 = v9;
        v14 = v12 == 0 ? (char *)&g2 : (char *)&g1;
        _printf(v14);
        v15 = *(int64_t *)&g9;
        v16 = *(int64_t *)(v15 + 8 * (int64_t)v3);
        v17++;
        v18 = *(char *)(v16 + (int64_t)v17);
        v13 = v18 == 0 ? v12 : (int32_t)(v12 == 0);
        v19 = *(int32_t *)&g4;
        while (v17 - v19 < 0 != ((v17 - v19 ^ v17) & (v19 ^ v17)) < 0) {
            // 0x100002d48
            v12 = v13;
            v14 = v12 == 0 ? (char *)&g2 : (char *)&g1;
            _printf(v14);
            v15 = *(int64_t *)&g9;
            v16 = *(int64_t *)(v15 + 8 * (int64_t)v3);
            v17++;
            v18 = *(char *)(v16 + (int64_t)v17);
            v13 = v18 == 0 ? v12 : (int32_t)(v12 == 0);
            v19 = *(int32_t *)&g4;
        }
    }
    // 0x100002ddc
    _puts((char *)&g3);
    int32_t v20 = v3 + 1; // 0x100002df0
    int32_t v21 = v20 - g5; // 0x100002c98
    while (v21 < 0 != ((v21 ^ v20) & (g5 ^ v20)) < 0) {
        // 0x100002ca8
        v3 = v20;
        v4 = 0;
        if (v3 != 0) {
            // 0x100002cc8
            v5 = v9;
            v7 = *(int64_t *)(g8 + 8 * (int64_t)v3);
            v6 = *(char *)v7;
            v4 = v6 == 0 ? v5 : (int32_t)(v5 == 0);
        }
        // 0x100002d24
        v9 = v4;
        v10 = *(int32_t *)&g4;
        v11 = -v10;
        if (v11 < 0 != (v10 & v11) < 0) {
            // 0x100002d48
            v17 = 0;
            v12 = v9;
            v14 = v12 == 0 ? (char *)&g2 : (char *)&g1;
            _printf(v14);
            v15 = *(int64_t *)&g9;
            v16 = *(int64_t *)(v15 + 8 * (int64_t)v3);
            v17++;
            v18 = *(char *)(v16 + (int64_t)v17);
            v13 = v18 == 0 ? v12 : (int32_t)(v12 == 0);
            v19 = *(int32_t *)&g4;
            while (v17 - v19 < 0 != ((v17 - v19 ^ v17) & (v19 ^ v17)) < 0) {
                // 0x100002d48
                v12 = v13;
                v14 = v12 == 0 ? (char *)&g2 : (char *)&g1;
                _printf(v14);
                v15 = *(int64_t *)&g9;
                v16 = *(int64_t *)(v15 + 8 * (int64_t)v3);
                v17++;
                v18 = *(char *)(v16 + (int64_t)v17);
                v13 = v18 == 0 ? v12 : (int32_t)(v12 == 0);
                v19 = *(int32_t *)&g4;
            }
        }
        // 0x100002ddc
        _puts((char *)&g3);
        v20 = v3 + 1;
        v21 = v20 - g5;
    }
    // 0x100002dfc
    return _putchar(10);
}

// Address range: 0x100002e10 - 0x10000346c
int64_t function_100002e10(void) {
    // 0x100002e10
    int64_t v1; // 0x100002e10
    int32_t v2 = v1; // 0x100002e1c
    int32_t v3 = v1; // 0x100002e20
    int64_t result; // 0x100002e10
    if (v3 < 0 || v2 < 0) {
        // 0x100003460
        return result;
    }
    int32_t v4 = *(int32_t *)&g4; // 0x100002e54
    int32_t v5 = v3 - v4; // 0x100002e58
    if (v5 != 0 && v5 < 0 == ((v5 ^ v3) & (v4 ^ v3)) < 0) {
        // 0x100003460
        return result;
    }
    int32_t v6 = v2 - g5; // 0x100002e74
    if (v6 != 0 && v6 < 0 == ((v6 ^ v2) & (g5 ^ v2)) < 0) {
        // 0x100003460
        return result;
    }
    if (v3 == 0 | v2 == 0 || v4 == v3 || g5 == v2) {
        // 0x100002ee8
        g7++;
        if (g6 != 0) {
            // 0x100002f10
            result = function_100002c5c();
        }
        // 0x100003460
        return result;
    }
    int64_t v7 = 0x100000000 * v1 >> 29; // 0x100002f2c
    int64_t v8 = *(int64_t *)(*(int64_t *)&g10 + v7); // 0x100002f2c
    int64_t v9 = 0x100000000 * v1;
    int64_t v10 = v9 >> 32; // 0x100002f30
    char * v11 = (char *)(v8 + v10); // 0x100002f38
    if (*v11 != 0) {
        // 0x100003460
        return result;
    }
    // 0x100002fc4
    *v11 = 1;
    int64_t v12 = *(int64_t *)&g10; // 0x100002f78
    int64_t v13 = *(int64_t *)(v12 + (int64_t)(8 * (g5 - v2))); // 0x100002f8c
    char * v14 = (char *)(v13 + (int64_t)(*(int32_t *)&g4 - v3)); // 0x100002fa4
    *v14 = *v14 + 1;
    int64_t v15 = v9 - 0x100000000 >> 32; // 0x100002fe0
    int64_t v16; // 0x100002e10
    if (*(char *)(*(int64_t *)(g8 + v7) + v15) == 0) {
        int64_t v17 = *(int64_t *)(g8 + (int64_t)(8 * (g5 - v2))); // 0x10000301c
        *(char *)(v17 + (int64_t)(*(int32_t *)&g4 - v3)) = 1;
        *(char *)(*(int64_t *)(g8 + v7) + v15) = 1;
        int64_t v18 = function_100002e10(); // 0x100003068
        int64_t v19 = *(int64_t *)(g8 + (int64_t)(8 * (g5 - v2))); // 0x100003088
        *(char *)(v19 + (int64_t)(*(int32_t *)&g4 - v3)) = 0;
        *(char *)(*(int64_t *)(g8 + v7) + v15) = 0;
        v16 = v18;
    }
    int32_t v20 = *(int32_t *)&g4; // 0x1000030c8
    int32_t v21 = v3 - v20; // 0x1000030cc
    int64_t v22 = v16; // 0x1000030d4
    if (v21 < 0 != ((v21 ^ v3) & (v20 ^ v3)) < 0) {
        // 0x1000030dc
        v22 = v16;
        if (*(char *)(*(int64_t *)(g8 + v7) + v10) == 0) {
            int64_t v23 = *(int64_t *)(g8 + (int64_t)(8 * (g5 - v2))); // 0x100003130
            int32_t v24 = -1 - v3;
            *(char *)(v23 + (int64_t)(v20 + v24)) = 1;
            *(char *)(*(int64_t *)(g8 + v7) + v10) = 1;
            int64_t v25 = function_100002e10(); // 0x10000317c
            int64_t v26 = *(int64_t *)(g8 + (int64_t)(8 * (g5 - v2))); // 0x10000319c
            *(char *)(v26 + (int64_t)(*(int32_t *)&g4 + v24)) = 0;
            *(char *)(*(int64_t *)(g8 + v7) + v10) = 0;
            v22 = v25;
        }
    }
    int64_t v27 = *(int64_t *)&g9; // 0x1000031f0
    int64_t v28 = 8 * v1 + 0xfffffff8 & 0xfffffff8; // 0x1000031fc
    int64_t v29 = v22; // 0x100003214
    if (*(char *)(*(int64_t *)(v27 + v28) + v10) == 0) {
        int64_t v30 = *(int64_t *)(v27 + (int64_t)(8 * (g5 - v2))); // 0x100003240
        *(char *)(v30 + (int64_t)(*(int32_t *)&g4 - v3)) = 1;
        *(char *)(*(int64_t *)(*(int64_t *)&g9 + v28) + v10) = 1;
        v29 = function_100002e10();
        int64_t v31 = *(int64_t *)&g9; // 0x10000329c
        int64_t v32 = *(int64_t *)(v31 + (int64_t)(8 * (g5 - v2))); // 0x1000032ac
        *(char *)(v32 + (int64_t)(*(int32_t *)&g4 - v3)) = 0;
        *(char *)(*(int64_t *)(*(int64_t *)&g9 + v28) + v10) = 0;
    }
    int32_t v33 = v2 - g5; // 0x1000032f0
    int64_t result2 = v29; // 0x1000032f8
    if (v33 < 0 != ((v33 ^ v2) & (g5 ^ v2)) < 0) {
        int64_t v34 = *(int64_t *)&g9; // 0x100003308
        result2 = v29;
        if (*(char *)(*(int64_t *)(v34 + v7) + v10) == 0) {
            int32_t v35 = v2 ^ 0x1fffffff;
            int64_t v36 = *(int64_t *)(v34 + (int64_t)(8 * (g5 + v35))); // 0x100003358
            *(char *)(v36 + (int64_t)(*(int32_t *)&g4 - v3)) = 1;
            *(char *)(*(int64_t *)(*(int64_t *)&g9 + v7) + v10) = 1;
            int64_t v37 = function_100002e10(); // 0x1000033a0
            int64_t v38 = *(int64_t *)&g9; // 0x1000033b0
            int64_t v39 = *(int64_t *)(v38 + (int64_t)(8 * (g5 + v35))); // 0x1000033c4
            *(char *)(v39 + (int64_t)(*(int32_t *)&g4 - v3)) = 0;
            *(char *)(*(int64_t *)(*(int64_t *)&g9 + v7) + v10) = 0;
            result2 = v37;
        }
    }
    int64_t v40 = *(int64_t *)(*(int64_t *)&g10 + v7); // 0x100003408
    char * v41 = (char *)(v40 + v10); // 0x100003414
    *v41 = *v41 - 1;
    int64_t v42 = *(int64_t *)&g10; // 0x100003424
    int64_t v43 = *(int64_t *)(v42 + (int64_t)(8 * (g5 - v2))); // 0x100003438
    char * v44 = (char *)(v43 + (int64_t)(*(int32_t *)&g4 - v3)); // 0x100003450
    *v44 = *v44 - 1;
    // 0x100003460
    return result2;
}

// Address range: 0x10000346c - 0x100003774
int64_t function_10000346c(void) {
    // 0x10000346c
    int64_t result; // 0x10000346c
    if (*(int32_t *)&g4 * g5 % 2 != 0) {
        // 0x100003768
        return result;
    }
    // 0x1000034a4
    g8 = function_100002ba0();
    int64_t v1 = function_100002ba0(); // 0x1000034ec
    *(int64_t *)&g9 = v1;
    int64_t v2 = function_100002ba0(); // 0x100003514
    *(int64_t *)&g10 = v2;
    if (g5 % 2 != 0) {
        int64_t v3 = *(int64_t *)(*(int64_t *)&g9 + (int64_t)(8 * g5 / 2)); // 0x100003558
        *(char *)(v3 + (int64_t)(*(int32_t *)&g4 / 2)) = 1;
        // 0x100003768
        return function_100002e10();
    }
    int32_t v4 = *(int32_t *)&g4; // 0x100003590
    if (v4 % 2 == 0) {
        int64_t v5 = *(int64_t *)(v2 + (int64_t)(8 * g5 / 2)); // 0x100003618
        *(char *)(v5 + (int64_t)(v4 / 2)) = 1;
        int64_t v6 = *(int64_t *)(g8 + (int64_t)(8 * g5 / 2)); // 0x100003654
        *(char *)(v6 + (int64_t)(*(int32_t *)&g4 / 2)) = 1;
        int64_t v7 = *(int64_t *)(g8 + (int64_t)(8 * g5 / 2)); // 0x100003674
        *(char *)(v7 + (int64_t)(*(int32_t *)&g4 / 2 - 1)) = 1;
        function_100002e10();
        int64_t v8 = *(int64_t *)(g8 + (int64_t)(8 * g5 / 2)); // 0x1000036c4
        *(char *)(v8 + (int64_t)(*(int32_t *)&g4 / 2)) = 0;
        int64_t v9 = *(int64_t *)(g8 + (int64_t)(8 * g5 / 2)); // 0x1000036e4
        *(char *)(v9 + (int64_t)(*(int32_t *)&g4 / 2 - 1)) = 0;
        int64_t v10 = *(int64_t *)(*(int64_t *)&g9 + (int64_t)(8 * g5 / 2)); // 0x100003710
        *(char *)(v10 + (int64_t)(*(int32_t *)&g4 / 2)) = 1;
        int64_t v11 = *(int64_t *)&g9; // 0x100003724
        int64_t v12 = *(int64_t *)(v11 + (int64_t)(8 * g5 / 2 - 8)); // 0x100003734
        *(char *)(v12 + (int64_t)(*(int32_t *)&g4 / 2)) = 1;
        result = function_100002e10();
    } else {
        int64_t v13 = *(int64_t *)(g8 + (int64_t)(8 * g5 / 2)); // 0x1000035c0
        *(char *)(v13 + (int64_t)(v4 / 2)) = 1;
        result = function_100002e10();
    }
    // 0x100003768
    return result;
}

// Address range: 0x100003774 - 0x100003a7c
int64_t function_100003774(void) {
    // 0x100003774
    int64_t v1; // 0x100003774
    int32_t v2 = v1; // 0x100003780
    int64_t result; // 0x100003774
    if (v2 == 0) {
        // 0x1000037ec
        g7++;
        // 0x100003a70
        return result;
    }
    int32_t v3 = v1; // 0x100003784
    if (v3 == 0 || g5 == v2) {
        // 0x1000037ec
        g7++;
        // 0x100003a70
        return result;
    }
    int32_t v4 = *(int32_t *)&g4; // 0x1000037d8
    if (v4 == v3) {
        // 0x1000037ec
        g7++;
        // 0x100003a70
        return result;
    }
    int64_t v5 = *(int64_t *)&g10; // 0x100003808
    int64_t v6 = *(int64_t *)(v5 + (int64_t)(8 * (g5 - v2))); // 0x10000381c
    *(char *)(v6 + (int64_t)(v4 - v3)) = 1;
    int64_t v7 = 0x100000000 * v1 >> 29; // 0x100003844
    int64_t v8 = 0x100000000 * v1;
    int64_t v9 = v8 >> 32; // 0x100003848
    *(char *)(*(int64_t *)(*(int64_t *)&g10 + v7) + v9) = 1;
    int64_t v10 = *(int64_t *)(*(int64_t *)&g10 + v7); // 0x100003878
    int64_t v11; // 0x100003774
    if (*(char *)(v10 + (v8 - 0x100000000 >> 32)) == 0) {
        // 0x10000389c
        v11 = function_100003774();
    }
    uint32_t v12 = (int32_t)v1; // 0x100003788
    int64_t v13 = v11; // 0x1000038c4
    if (v12 % 2 != 0) {
        int32_t v14 = *(int32_t *)&g4; // 0x1000038d4
        int32_t v15 = v3 - v14; // 0x1000038d8
        v13 = v11;
        if (v15 < 0 != ((v15 ^ v3) & (v14 ^ v3)) < 0) {
            int64_t v16 = *(int64_t *)(*(int64_t *)&g10 + v7); // 0x1000038f8
            v13 = v11;
            if (*(char *)(v16 + (v8 + 0x100000000 >> 32)) == 0) {
                // 0x10000391c
                v13 = function_100003774();
            }
        }
    }
    int64_t v17 = 8 * v1;
    int64_t v18 = *(int64_t *)(*(int64_t *)&g10 + (v17 + 0xfffffff8 & 0xfffffff8)); // 0x100003960
    int64_t v19 = v13; // 0x100003978
    if (*(char *)(v18 + v9) == 0) {
        // 0x100003980
        v19 = function_100003774();
    }
    int64_t result2 = v19; // 0x1000039a8
    if ((v12 & 2) != 0) {
        int32_t v20 = v2 - g5; // 0x1000039bc
        result2 = v19;
        if (v20 < 0 != ((v20 ^ v2) & (g5 ^ v2)) < 0) {
            int64_t v21 = *(int64_t *)(*(int64_t *)&g10 + (v17 + 8 & 0xfffffff8)); // 0x1000039e0
            result2 = v19;
            if (*(char *)(v21 + v9) == 0) {
                // 0x100003a00
                result2 = function_100003774();
            }
        }
    }
    int64_t v22 = *(int64_t *)&g10; // 0x100003a24
    int64_t v23 = *(int64_t *)(v22 + (int64_t)(8 * (g5 - v2))); // 0x100003a38
    *(char *)(v23 + (int64_t)(*(int32_t *)&g4 - v3)) = 0;
    *(char *)(*(int64_t *)(*(int64_t *)&g10 + v7) + v9) = 0;
    // 0x100003a70
    return result2;
}

// Address range: 0x100003a7c - 0x100003d04
int64_t function_100003a7c(void) {
    uint32_t v1 = g5; // 0x100003a8c
    int32_t v2 = *(int32_t *)&g4; // 0x100003a94
    if (v2 * v1 % 2 != 0) {
        // 0x100003cf8
        int64_t result; // 0x100003a7c
        return result;
    }
    if (v1 % 2 != 0) {
        // 0x100003ac8
        g5 = v2;
        *(int32_t *)&g4 = v1;
    }
    int64_t v3 = function_100002ba0(); // 0x100003b0c
    *(int64_t *)&g10 = v3;
    int64_t v4 = *(int64_t *)(v3 + (int64_t)(8 * g5 / 2)); // 0x100003b34
    *(char *)(v4 + (int64_t)(*(int32_t *)&g4 / 2)) = 1;
    int32_t v5 = *(int32_t *)&g4; // 0x100003b4c
    int32_t v6 = v5; // 0x100003b58
    if (v5 % 2 != 0) {
        int64_t v7 = *(int64_t *)&g10; // 0x100003b68
        int64_t v8 = *(int64_t *)(v7 + (int64_t)(8 * g5 / 2)); // 0x100003b7c
        *(char *)(v8 + (int64_t)(v5 / 2 + 1)) = 1;
        v6 = *(int32_t *)&g4;
    }
    int32_t v9 = v6; // 0x100003ba4
    int32_t v10 = v9 - 1; // 0x100003ba8
    int32_t v11 = v9; // 0x100003bb0
    int64_t result2 = v3; // 0x100003bb0
    int64_t v12 = 1; // 0x100003bb0
    if (v10 != 0 && v10 < 0 == (v9 & -v9) < 0) {
        int64_t v13 = function_100003774(); // 0x100003be4
        int64_t v14 = g7; // 0x100003bf4
        g7 = 0;
        int32_t v15 = *(int32_t *)&g4; // 0x100003c0c
        int32_t v16 = v15; // 0x100003c1c
        int64_t v17 = 0; // 0x100003c1c
        result2 = v13;
        if (v15 != g5) {
            // 0x100003c24
            result2 = function_100003774();
            v16 = *(int32_t *)&g4;
            v17 = 2 * g7;
        }
        // 0x100003c68
        v11 = v16;
        v12 = 2 * v14 - 1 + v17 + (int64_t)(v11 % 2 == 0);
    }
    int64_t v18 = v12;
    g7 = v11 == g5 ? 2 * v18 + 2 : v18;
    // 0x100003cf8
    return result2;
}

// Address range: 0x100003d04 - 0x100003f30
int64_t entry_point(void) {
    // 0x100003d04
    int64_t v1; // 0x100003d04
    int32_t v2 = v1; // 0x100003d14
    int32_t v3 = 1 - v2; // 0x100003d30
    int32_t v4 = 1; // 0x100003d38
    char * v5; // 0x100003d04
    if (v3 < 0 == (v3 & v2) < 0) {
      lab_0x100003e68:;
        int32_t v6 = *(int32_t *)&g4; // 0x100003e6c
        if (v6 != 0) {
            // 0x100003e84
            if (g5 == 0) {
                // 0x100003e9c
                g5 = v6;
            }
            // 0x100003eb0
            if (g6 == 0) {
                // 0x100003ed0
                function_100003a7c();
            } else {
                // 0x100003ec8
                function_10000346c();
            }
            // 0x100003ed8
            _printf("Total: %ld\n", (int32_t)v1);
            // 0x100003f20
            return 0;
        }
    } else {
        while (true) {
          lab_0x100003d40:;
            int64_t v7 = *(int64_t *)(8 * (int64_t)v4 + v1); // 0x100003d48
            v5 = (char *)v7;
            if (*v5 == 45) {
                // 0x100003d60
                if (*(char *)(v7 + 1) == 118) {
                    // 0x100003d80
                    if (*(char *)(v7 + 2) == 0) {
                        // 0x100003da0
                        g6 = 1;
                        goto lab_0x100003e58;
                    } else {
                        goto lab_0x100003db0;
                    }
                } else {
                    goto lab_0x100003db0;
                }
            } else {
                goto lab_0x100003db0;
            }
        }
    }
  lab_0x100003efc_3:
    // 0x100003efc
    _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "bad args\n");
    // 0x100003f20
    return 1;
  lab_0x100003db0:
    // 0x100003db0
    if (*(int32_t *)&g4 == 0) {
        int32_t v8 = _atoi(v5); // 0x100003dd4
        *(int32_t *)&g4 = v8;
        if (v8 < 1) {
            // break -> 0x100003efc
            goto lab_0x100003efc_3;
        }
    } else {
        // 0x100003dfc
        if (g5 != 0) {
            // break -> 0x100003efc
            goto lab_0x100003efc_3;
        }
        int32_t v9 = _atoi(v5); // 0x100003e20
        g5 = v9;
        if (v9 < 1) {
            // break -> 0x100003efc
            goto lab_0x100003efc_3;
        }
    }
    goto lab_0x100003e58;
  lab_0x100003e58:
    // 0x100003e58
    v4++;
    int32_t v10 = v4 - v2; // 0x100003d30
    if (v10 < 0 == ((v10 ^ v4) & (v4 ^ v2)) < 0) {
        goto lab_0x100003e68;
    }
    goto lab_0x100003d40;
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * nptr) {
    // 0x100003f30
    return _atoi(nptr);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int32_t nmemb, int32_t size) {
    // 0x100003f3c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f48
    return _fprintf(stream, format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t c) {
    // 0x100003f60
    return _putchar(c);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * s) {
    // 0x100003f6c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>

// just generate 0s and 1s without storing them
double run_test(double p, int len, int runs)
{
	int r, x, y, i, cnt = 0, thresh = p * RAND_MAX;

	for (r = 0; r < runs; r++)
		for (x = 0, i = len; i--; x = y)
			cnt += x < (y = rand() < thresh);

	return (double)cnt / runs / len;
}

int main(void)
{
	double p, p1p, K;
	int ip, n;

	puts(	"running 1000 tests each:\n"
		" p\t   n\tK\tp(1-p)\t     diff\n"
		"-----------------------------------------------");
	for (ip = 1; ip < 10; ip += 2) {
		p = ip / 10., p1p = p * (1 - p);

		for (n = 100; n <= 100000; n *= 10) {
			K = run_test(p, n, 1000);
			printf("%.1f\t%6d\t%.4f\t%.4f\t%+.4f (%+.2f%%)\n",
				p, n, K, p1p, K - p1p, (K - p1p) / p1p * 100);
		}
		putchar('\n');
	}

	return 0;
}
`,`#include "percolation-mean-run-density.h"



undefined  [16] _run_test(double param_1,int param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  undefined auVar4 [16];
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_24;
  
  local_34 = 0;
  for (local_24 = 0; local_24 < param_3; local_24 = local_24 + 1) {
    local_30 = param_2;
    bVar2 = false;
    while (local_30 != 0) {
      iVar3 = _rand();
      bVar1 = iVar3 < (int)(param_1 * 2147483647.0);
      local_34 = local_34 + (uint)(bVar2 < bVar1);
      local_30 = local_30 + -1;
      bVar2 = bVar1;
    }
  }
  auVar4._0_8_ = ((double)(long)local_34 / (double)(long)param_3) / (double)(long)param_2;
  auVar4._8_8_ = 0;
  return auVar4;
}



undefined8 entry(void)

{
  int local_38;
  int local_34;
  
  _puts(
       "running 1000 tests each:\n p\t   n\tK\tp(1-p)\t     diff\n-----------------------------------------------"
       );
  for (local_34 = 1; local_34 < 10; local_34 = local_34 + 2) {
    for (local_38 = 100; local_38 < 0x186a1; local_38 = local_38 * 10) {
      _run_test((double)(long)local_34 / 10.0,local_38,1000);
      _printf("%.1f\t%6d\t%.4f\t%.4f\t%+.4f (%+.2f%%)\n");
    }
    _putchar(10);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}


`
